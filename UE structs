#pragma once

/*
* SDK generated by Dumper-69
*
* https://github.com/Encryqed/Dumper-69
*/

// Package: HLL

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PhysXVehicles_structs.hpp"
#include "PhysXVehicles_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "HLL_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SlateCore_structs.hpp"
#include "SlateCore_classes.hpp"
#include "ReplicationGraph_structs.hpp"
#include "ReplicationGraph_classes.hpp"
#include "OnlineSubsystem_structs.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Class HLL.CinematicTigerStub
// 0x0758 (0x0978 - 0x0220)
class ACinematicTigerStub final : public AActor
{
public:
	class USkeletalMeshComponent*                 TankMesh;                                          // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           AllLeftTrackTiles;                                 // 0x0228(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           AllRightTrackTiles;                                // 0x0238(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_000;                                // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_001;                                // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_002;                                // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_003;                                // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_004;                                // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_005;                                // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_006;                                // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_007;                                // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_008;                                // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_009;                                // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_010;                                // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_011;                                // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_012;                                // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_013;                                // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_014;                                // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_015;                                // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_016;                                // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_017;                                // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_018;                                // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_019;                                // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_020;                                // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_021;                                // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_022;                                // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_023;                                // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_024;                                // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_025;                                // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_026;                                // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_027;                                // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_028;                                // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_029;                                // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_030;                                // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_031;                                // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_032;                                // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_033;                                // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_034;                                // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_035;                                // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_036;                                // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_037;                                // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_038;                                // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_039;                                // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_040;                                // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_041;                                // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_042;                                // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_043;                                // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_044;                                // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_045;                                // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_046;                                // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_047;                                // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_048;                                // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_049;                                // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_050;                                // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_051;                                // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_052;                                // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_053;                                // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_054;                                // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_055;                                // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_056;                                // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_057;                                // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_058;                                // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_059;                                // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_060;                                // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_061;                                // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_062;                                // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_063;                                // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_064;                                // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_065;                                // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_066;                                // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_067;                                // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_068;                                // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_069;                                // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_070;                                // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_071;                                // 0x0480(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_072;                                // 0x0488(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_073;                                // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_074;                                // 0x0498(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_075;                                // 0x04A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_076;                                // 0x04A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_077;                                // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_078;                                // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_079;                                // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_080;                                // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_081;                                // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_082;                                // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_083;                                // 0x04E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_084;                                // 0x04E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_085;                                // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_086;                                // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_087;                                // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_088;                                // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_089;                                // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_090;                                // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_091;                                // 0x0520(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_092;                                // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_093;                                // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_094;                                // 0x0538(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_095;                                // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_096;                                // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_097;                                // 0x0550(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_098;                                // 0x0558(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_099;                                // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_100;                                // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_101;                                // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_102;                                // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_103;                                // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_104;                                // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_105;                                // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_106;                                // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_107;                                // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_108;                                // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_109;                                // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_110;                                // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_111;                                // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_112;                                // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_113;                                // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_114;                                // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_000;                                 // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_001;                                 // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_002;                                 // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_003;                                 // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_004;                                 // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_005;                                 // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_006;                                 // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_007;                                 // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_008;                                 // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_009;                                 // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_010;                                 // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_011;                                 // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_012;                                 // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_013;                                 // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_014;                                 // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_015;                                 // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_016;                                 // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_017;                                 // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_018;                                 // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_019;                                 // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_020;                                 // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_021;                                 // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_022;                                 // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_023;                                 // 0x0698(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_024;                                 // 0x06A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_025;                                 // 0x06A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_026;                                 // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_027;                                 // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_028;                                 // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_029;                                 // 0x06C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_030;                                 // 0x06D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_031;                                 // 0x06D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_032;                                 // 0x06E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_033;                                 // 0x06E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_034;                                 // 0x06F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_035;                                 // 0x06F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_036;                                 // 0x0700(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_037;                                 // 0x0708(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_038;                                 // 0x0710(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_039;                                 // 0x0718(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_040;                                 // 0x0720(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_041;                                 // 0x0728(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_042;                                 // 0x0730(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_043;                                 // 0x0738(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_044;                                 // 0x0740(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_045;                                 // 0x0748(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_046;                                 // 0x0750(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_047;                                 // 0x0758(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_048;                                 // 0x0760(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_049;                                 // 0x0768(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_050;                                 // 0x0770(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_051;                                 // 0x0778(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_052;                                 // 0x0780(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_053;                                 // 0x0788(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_054;                                 // 0x0790(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_055;                                 // 0x0798(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_056;                                 // 0x07A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_057;                                 // 0x07A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_058;                                 // 0x07B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_059;                                 // 0x07B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_060;                                 // 0x07C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_061;                                 // 0x07C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_062;                                 // 0x07D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_063;                                 // 0x07D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_064;                                 // 0x07E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_065;                                 // 0x07E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_066;                                 // 0x07F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_067;                                 // 0x07F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_068;                                 // 0x0800(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_069;                                 // 0x0808(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_070;                                 // 0x0810(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_071;                                 // 0x0818(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_072;                                 // 0x0820(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_073;                                 // 0x0828(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_074;                                 // 0x0830(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_075;                                 // 0x0838(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_076;                                 // 0x0840(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_077;                                 // 0x0848(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_078;                                 // 0x0850(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_079;                                 // 0x0858(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_080;                                 // 0x0860(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_081;                                 // 0x0868(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_082;                                 // 0x0870(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_083;                                 // 0x0878(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_084;                                 // 0x0880(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_085;                                 // 0x0888(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_086;                                 // 0x0890(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_087;                                 // 0x0898(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_088;                                 // 0x08A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_089;                                 // 0x08A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_090;                                 // 0x08B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_091;                                 // 0x08B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_092;                                 // 0x08C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_093;                                 // 0x08C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_094;                                 // 0x08D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_095;                                 // 0x08D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_096;                                 // 0x08E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_097;                                 // 0x08E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_098;                                 // 0x08F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_099;                                 // 0x08F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_100;                                 // 0x0900(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_101;                                 // 0x0908(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_102;                                 // 0x0910(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_103;                                 // 0x0918(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_104;                                 // 0x0920(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_105;                                 // 0x0928(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_106;                                 // 0x0930(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_107;                                 // 0x0938(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_108;                                 // 0x0940(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_109;                                 // 0x0948(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_110;                                 // 0x0950(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_111;                                 // 0x0958(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_112;                                 // 0x0960(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_113;                                 // 0x0968(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_114;                                 // 0x0970(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicTigerStub">();
	}
	static class ACinematicTigerStub* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACinematicTigerStub>();
	}
};
static_assert(alignof(ACinematicTigerStub) == 0x000008, "Wrong alignment on ACinematicTigerStub");
static_assert(sizeof(ACinematicTigerStub) == 0x000978, "Wrong size on ACinematicTigerStub");
static_assert(offsetof(ACinematicTigerStub, TankMesh) == 0x000220, "Member 'ACinematicTigerStub::TankMesh' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, AllLeftTrackTiles) == 0x000228, "Member 'ACinematicTigerStub::AllLeftTrackTiles' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, AllRightTrackTiles) == 0x000238, "Member 'ACinematicTigerStub::AllRightTrackTiles' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_000) == 0x000248, "Member 'ACinematicTigerStub::RightTrackTile_000' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_001) == 0x000250, "Member 'ACinematicTigerStub::RightTrackTile_001' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_002) == 0x000258, "Member 'ACinematicTigerStub::RightTrackTile_002' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_003) == 0x000260, "Member 'ACinematicTigerStub::RightTrackTile_003' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_004) == 0x000268, "Member 'ACinematicTigerStub::RightTrackTile_004' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_005) == 0x000270, "Member 'ACinematicTigerStub::RightTrackTile_005' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_006) == 0x000278, "Member 'ACinematicTigerStub::RightTrackTile_006' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_007) == 0x000280, "Member 'ACinematicTigerStub::RightTrackTile_007' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_008) == 0x000288, "Member 'ACinematicTigerStub::RightTrackTile_008' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_009) == 0x000290, "Member 'ACinematicTigerStub::RightTrackTile_009' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_010) == 0x000298, "Member 'ACinematicTigerStub::RightTrackTile_010' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_011) == 0x0002A0, "Member 'ACinematicTigerStub::RightTrackTile_011' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_012) == 0x0002A8, "Member 'ACinematicTigerStub::RightTrackTile_012' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_013) == 0x0002B0, "Member 'ACinematicTigerStub::RightTrackTile_013' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_014) == 0x0002B8, "Member 'ACinematicTigerStub::RightTrackTile_014' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_015) == 0x0002C0, "Member 'ACinematicTigerStub::RightTrackTile_015' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_016) == 0x0002C8, "Member 'ACinematicTigerStub::RightTrackTile_016' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_017) == 0x0002D0, "Member 'ACinematicTigerStub::RightTrackTile_017' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_018) == 0x0002D8, "Member 'ACinematicTigerStub::RightTrackTile_018' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_019) == 0x0002E0, "Member 'ACinematicTigerStub::RightTrackTile_019' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_020) == 0x0002E8, "Member 'ACinematicTigerStub::RightTrackTile_020' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_021) == 0x0002F0, "Member 'ACinematicTigerStub::RightTrackTile_021' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_022) == 0x0002F8, "Member 'ACinematicTigerStub::RightTrackTile_022' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_023) == 0x000300, "Member 'ACinematicTigerStub::RightTrackTile_023' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_024) == 0x000308, "Member 'ACinematicTigerStub::RightTrackTile_024' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_025) == 0x000310, "Member 'ACinematicTigerStub::RightTrackTile_025' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_026) == 0x000318, "Member 'ACinematicTigerStub::RightTrackTile_026' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_027) == 0x000320, "Member 'ACinematicTigerStub::RightTrackTile_027' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_028) == 0x000328, "Member 'ACinematicTigerStub::RightTrackTile_028' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_029) == 0x000330, "Member 'ACinematicTigerStub::RightTrackTile_029' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_030) == 0x000338, "Member 'ACinematicTigerStub::RightTrackTile_030' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_031) == 0x000340, "Member 'ACinematicTigerStub::RightTrackTile_031' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_032) == 0x000348, "Member 'ACinematicTigerStub::RightTrackTile_032' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_033) == 0x000350, "Member 'ACinematicTigerStub::RightTrackTile_033' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_034) == 0x000358, "Member 'ACinematicTigerStub::RightTrackTile_034' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_035) == 0x000360, "Member 'ACinematicTigerStub::RightTrackTile_035' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_036) == 0x000368, "Member 'ACinematicTigerStub::RightTrackTile_036' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_037) == 0x000370, "Member 'ACinematicTigerStub::RightTrackTile_037' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_038) == 0x000378, "Member 'ACinematicTigerStub::RightTrackTile_038' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_039) == 0x000380, "Member 'ACinematicTigerStub::RightTrackTile_039' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_040) == 0x000388, "Member 'ACinematicTigerStub::RightTrackTile_040' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_041) == 0x000390, "Member 'ACinematicTigerStub::RightTrackTile_041' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_042) == 0x000398, "Member 'ACinematicTigerStub::RightTrackTile_042' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_043) == 0x0003A0, "Member 'ACinematicTigerStub::RightTrackTile_043' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_044) == 0x0003A8, "Member 'ACinematicTigerStub::RightTrackTile_044' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_045) == 0x0003B0, "Member 'ACinematicTigerStub::RightTrackTile_045' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_046) == 0x0003B8, "Member 'ACinematicTigerStub::RightTrackTile_046' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_047) == 0x0003C0, "Member 'ACinematicTigerStub::RightTrackTile_047' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_048) == 0x0003C8, "Member 'ACinematicTigerStub::RightTrackTile_048' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_049) == 0x0003D0, "Member 'ACinematicTigerStub::RightTrackTile_049' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_050) == 0x0003D8, "Member 'ACinematicTigerStub::RightTrackTile_050' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_051) == 0x0003E0, "Member 'ACinematicTigerStub::RightTrackTile_051' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_052) == 0x0003E8, "Member 'ACinematicTigerStub::RightTrackTile_052' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_053) == 0x0003F0, "Member 'ACinematicTigerStub::RightTrackTile_053' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_054) == 0x0003F8, "Member 'ACinematicTigerStub::RightTrackTile_054' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_055) == 0x000400, "Member 'ACinematicTigerStub::RightTrackTile_055' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_056) == 0x000408, "Member 'ACinematicTigerStub::RightTrackTile_056' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_057) == 0x000410, "Member 'ACinematicTigerStub::RightTrackTile_057' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_058) == 0x000418, "Member 'ACinematicTigerStub::RightTrackTile_058' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_059) == 0x000420, "Member 'ACinematicTigerStub::RightTrackTile_059' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_060) == 0x000428, "Member 'ACinematicTigerStub::RightTrackTile_060' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_061) == 0x000430, "Member 'ACinematicTigerStub::RightTrackTile_061' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_062) == 0x000438, "Member 'ACinematicTigerStub::RightTrackTile_062' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_063) == 0x000440, "Member 'ACinematicTigerStub::RightTrackTile_063' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_064) == 0x000448, "Member 'ACinematicTigerStub::RightTrackTile_064' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_065) == 0x000450, "Member 'ACinematicTigerStub::RightTrackTile_065' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_066) == 0x000458, "Member 'ACinematicTigerStub::RightTrackTile_066' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_067) == 0x000460, "Member 'ACinematicTigerStub::RightTrackTile_067' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_068) == 0x000468, "Member 'ACinematicTigerStub::RightTrackTile_068' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_069) == 0x000470, "Member 'ACinematicTigerStub::RightTrackTile_069' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_070) == 0x000478, "Member 'ACinematicTigerStub::RightTrackTile_070' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_071) == 0x000480, "Member 'ACinematicTigerStub::RightTrackTile_071' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_072) == 0x000488, "Member 'ACinematicTigerStub::RightTrackTile_072' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_073) == 0x000490, "Member 'ACinematicTigerStub::RightTrackTile_073' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_074) == 0x000498, "Member 'ACinematicTigerStub::RightTrackTile_074' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_075) == 0x0004A0, "Member 'ACinematicTigerStub::RightTrackTile_075' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_076) == 0x0004A8, "Member 'ACinematicTigerStub::RightTrackTile_076' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_077) == 0x0004B0, "Member 'ACinematicTigerStub::RightTrackTile_077' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_078) == 0x0004B8, "Member 'ACinematicTigerStub::RightTrackTile_078' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_079) == 0x0004C0, "Member 'ACinematicTigerStub::RightTrackTile_079' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_080) == 0x0004C8, "Member 'ACinematicTigerStub::RightTrackTile_080' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_081) == 0x0004D0, "Member 'ACinematicTigerStub::RightTrackTile_081' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_082) == 0x0004D8, "Member 'ACinematicTigerStub::RightTrackTile_082' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_083) == 0x0004E0, "Member 'ACinematicTigerStub::RightTrackTile_083' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_084) == 0x0004E8, "Member 'ACinematicTigerStub::RightTrackTile_084' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_085) == 0x0004F0, "Member 'ACinematicTigerStub::RightTrackTile_085' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_086) == 0x0004F8, "Member 'ACinematicTigerStub::RightTrackTile_086' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_087) == 0x000500, "Member 'ACinematicTigerStub::RightTrackTile_087' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_088) == 0x000508, "Member 'ACinematicTigerStub::RightTrackTile_088' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_089) == 0x000510, "Member 'ACinematicTigerStub::RightTrackTile_089' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_090) == 0x000518, "Member 'ACinematicTigerStub::RightTrackTile_090' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_091) == 0x000520, "Member 'ACinematicTigerStub::RightTrackTile_091' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_092) == 0x000528, "Member 'ACinematicTigerStub::RightTrackTile_092' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_093) == 0x000530, "Member 'ACinematicTigerStub::RightTrackTile_093' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_094) == 0x000538, "Member 'ACinematicTigerStub::RightTrackTile_094' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_095) == 0x000540, "Member 'ACinematicTigerStub::RightTrackTile_095' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_096) == 0x000548, "Member 'ACinematicTigerStub::RightTrackTile_096' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_097) == 0x000550, "Member 'ACinematicTigerStub::RightTrackTile_097' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_098) == 0x000558, "Member 'ACinematicTigerStub::RightTrackTile_098' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_099) == 0x000560, "Member 'ACinematicTigerStub::RightTrackTile_099' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_100) == 0x000568, "Member 'ACinematicTigerStub::RightTrackTile_100' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_101) == 0x000570, "Member 'ACinematicTigerStub::RightTrackTile_101' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_102) == 0x000578, "Member 'ACinematicTigerStub::RightTrackTile_102' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_103) == 0x000580, "Member 'ACinematicTigerStub::RightTrackTile_103' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_104) == 0x000588, "Member 'ACinematicTigerStub::RightTrackTile_104' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_105) == 0x000590, "Member 'ACinematicTigerStub::RightTrackTile_105' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_106) == 0x000598, "Member 'ACinematicTigerStub::RightTrackTile_106' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_107) == 0x0005A0, "Member 'ACinematicTigerStub::RightTrackTile_107' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_108) == 0x0005A8, "Member 'ACinematicTigerStub::RightTrackTile_108' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_109) == 0x0005B0, "Member 'ACinematicTigerStub::RightTrackTile_109' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_110) == 0x0005B8, "Member 'ACinematicTigerStub::RightTrackTile_110' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_111) == 0x0005C0, "Member 'ACinematicTigerStub::RightTrackTile_111' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_112) == 0x0005C8, "Member 'ACinematicTigerStub::RightTrackTile_112' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_113) == 0x0005D0, "Member 'ACinematicTigerStub::RightTrackTile_113' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, RightTrackTile_114) == 0x0005D8, "Member 'ACinematicTigerStub::RightTrackTile_114' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_000) == 0x0005E0, "Member 'ACinematicTigerStub::LeftTrackTile_000' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_001) == 0x0005E8, "Member 'ACinematicTigerStub::LeftTrackTile_001' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_002) == 0x0005F0, "Member 'ACinematicTigerStub::LeftTrackTile_002' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_003) == 0x0005F8, "Member 'ACinematicTigerStub::LeftTrackTile_003' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_004) == 0x000600, "Member 'ACinematicTigerStub::LeftTrackTile_004' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_005) == 0x000608, "Member 'ACinematicTigerStub::LeftTrackTile_005' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_006) == 0x000610, "Member 'ACinematicTigerStub::LeftTrackTile_006' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_007) == 0x000618, "Member 'ACinematicTigerStub::LeftTrackTile_007' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_008) == 0x000620, "Member 'ACinematicTigerStub::LeftTrackTile_008' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_009) == 0x000628, "Member 'ACinematicTigerStub::LeftTrackTile_009' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_010) == 0x000630, "Member 'ACinematicTigerStub::LeftTrackTile_010' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_011) == 0x000638, "Member 'ACinematicTigerStub::LeftTrackTile_011' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_012) == 0x000640, "Member 'ACinematicTigerStub::LeftTrackTile_012' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_013) == 0x000648, "Member 'ACinematicTigerStub::LeftTrackTile_013' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_014) == 0x000650, "Member 'ACinematicTigerStub::LeftTrackTile_014' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_015) == 0x000658, "Member 'ACinematicTigerStub::LeftTrackTile_015' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_016) == 0x000660, "Member 'ACinematicTigerStub::LeftTrackTile_016' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_017) == 0x000668, "Member 'ACinematicTigerStub::LeftTrackTile_017' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_018) == 0x000670, "Member 'ACinematicTigerStub::LeftTrackTile_018' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_019) == 0x000678, "Member 'ACinematicTigerStub::LeftTrackTile_019' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_020) == 0x000680, "Member 'ACinematicTigerStub::LeftTrackTile_020' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_021) == 0x000688, "Member 'ACinematicTigerStub::LeftTrackTile_021' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_022) == 0x000690, "Member 'ACinematicTigerStub::LeftTrackTile_022' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_023) == 0x000698, "Member 'ACinematicTigerStub::LeftTrackTile_023' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_024) == 0x0006A0, "Member 'ACinematicTigerStub::LeftTrackTile_024' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_025) == 0x0006A8, "Member 'ACinematicTigerStub::LeftTrackTile_025' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_026) == 0x0006B0, "Member 'ACinematicTigerStub::LeftTrackTile_026' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_027) == 0x0006B8, "Member 'ACinematicTigerStub::LeftTrackTile_027' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_028) == 0x0006C0, "Member 'ACinematicTigerStub::LeftTrackTile_028' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_029) == 0x0006C8, "Member 'ACinematicTigerStub::LeftTrackTile_029' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_030) == 0x0006D0, "Member 'ACinematicTigerStub::LeftTrackTile_030' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_031) == 0x0006D8, "Member 'ACinematicTigerStub::LeftTrackTile_031' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_032) == 0x0006E0, "Member 'ACinematicTigerStub::LeftTrackTile_032' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_033) == 0x0006E8, "Member 'ACinematicTigerStub::LeftTrackTile_033' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_034) == 0x0006F0, "Member 'ACinematicTigerStub::LeftTrackTile_034' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_035) == 0x0006F8, "Member 'ACinematicTigerStub::LeftTrackTile_035' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_036) == 0x000700, "Member 'ACinematicTigerStub::LeftTrackTile_036' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_037) == 0x000708, "Member 'ACinematicTigerStub::LeftTrackTile_037' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_038) == 0x000710, "Member 'ACinematicTigerStub::LeftTrackTile_038' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_039) == 0x000718, "Member 'ACinematicTigerStub::LeftTrackTile_039' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_040) == 0x000720, "Member 'ACinematicTigerStub::LeftTrackTile_040' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_041) == 0x000728, "Member 'ACinematicTigerStub::LeftTrackTile_041' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_042) == 0x000730, "Member 'ACinematicTigerStub::LeftTrackTile_042' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_043) == 0x000738, "Member 'ACinematicTigerStub::LeftTrackTile_043' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_044) == 0x000740, "Member 'ACinematicTigerStub::LeftTrackTile_044' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_045) == 0x000748, "Member 'ACinematicTigerStub::LeftTrackTile_045' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_046) == 0x000750, "Member 'ACinematicTigerStub::LeftTrackTile_046' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_047) == 0x000758, "Member 'ACinematicTigerStub::LeftTrackTile_047' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_048) == 0x000760, "Member 'ACinematicTigerStub::LeftTrackTile_048' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_049) == 0x000768, "Member 'ACinematicTigerStub::LeftTrackTile_049' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_050) == 0x000770, "Member 'ACinematicTigerStub::LeftTrackTile_050' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_051) == 0x000778, "Member 'ACinematicTigerStub::LeftTrackTile_051' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_052) == 0x000780, "Member 'ACinematicTigerStub::LeftTrackTile_052' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_053) == 0x000788, "Member 'ACinematicTigerStub::LeftTrackTile_053' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_054) == 0x000790, "Member 'ACinematicTigerStub::LeftTrackTile_054' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_055) == 0x000798, "Member 'ACinematicTigerStub::LeftTrackTile_055' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_056) == 0x0007A0, "Member 'ACinematicTigerStub::LeftTrackTile_056' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_057) == 0x0007A8, "Member 'ACinematicTigerStub::LeftTrackTile_057' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_058) == 0x0007B0, "Member 'ACinematicTigerStub::LeftTrackTile_058' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_059) == 0x0007B8, "Member 'ACinematicTigerStub::LeftTrackTile_059' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_060) == 0x0007C0, "Member 'ACinematicTigerStub::LeftTrackTile_060' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_061) == 0x0007C8, "Member 'ACinematicTigerStub::LeftTrackTile_061' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_062) == 0x0007D0, "Member 'ACinematicTigerStub::LeftTrackTile_062' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_063) == 0x0007D8, "Member 'ACinematicTigerStub::LeftTrackTile_063' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_064) == 0x0007E0, "Member 'ACinematicTigerStub::LeftTrackTile_064' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_065) == 0x0007E8, "Member 'ACinematicTigerStub::LeftTrackTile_065' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_066) == 0x0007F0, "Member 'ACinematicTigerStub::LeftTrackTile_066' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_067) == 0x0007F8, "Member 'ACinematicTigerStub::LeftTrackTile_067' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_068) == 0x000800, "Member 'ACinematicTigerStub::LeftTrackTile_068' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_069) == 0x000808, "Member 'ACinematicTigerStub::LeftTrackTile_069' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_070) == 0x000810, "Member 'ACinematicTigerStub::LeftTrackTile_070' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_071) == 0x000818, "Member 'ACinematicTigerStub::LeftTrackTile_071' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_072) == 0x000820, "Member 'ACinematicTigerStub::LeftTrackTile_072' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_073) == 0x000828, "Member 'ACinematicTigerStub::LeftTrackTile_073' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_074) == 0x000830, "Member 'ACinematicTigerStub::LeftTrackTile_074' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_075) == 0x000838, "Member 'ACinematicTigerStub::LeftTrackTile_075' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_076) == 0x000840, "Member 'ACinematicTigerStub::LeftTrackTile_076' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_077) == 0x000848, "Member 'ACinematicTigerStub::LeftTrackTile_077' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_078) == 0x000850, "Member 'ACinematicTigerStub::LeftTrackTile_078' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_079) == 0x000858, "Member 'ACinematicTigerStub::LeftTrackTile_079' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_080) == 0x000860, "Member 'ACinematicTigerStub::LeftTrackTile_080' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_081) == 0x000868, "Member 'ACinematicTigerStub::LeftTrackTile_081' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_082) == 0x000870, "Member 'ACinematicTigerStub::LeftTrackTile_082' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_083) == 0x000878, "Member 'ACinematicTigerStub::LeftTrackTile_083' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_084) == 0x000880, "Member 'ACinematicTigerStub::LeftTrackTile_084' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_085) == 0x000888, "Member 'ACinematicTigerStub::LeftTrackTile_085' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_086) == 0x000890, "Member 'ACinematicTigerStub::LeftTrackTile_086' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_087) == 0x000898, "Member 'ACinematicTigerStub::LeftTrackTile_087' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_088) == 0x0008A0, "Member 'ACinematicTigerStub::LeftTrackTile_088' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_089) == 0x0008A8, "Member 'ACinematicTigerStub::LeftTrackTile_089' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_090) == 0x0008B0, "Member 'ACinematicTigerStub::LeftTrackTile_090' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_091) == 0x0008B8, "Member 'ACinematicTigerStub::LeftTrackTile_091' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_092) == 0x0008C0, "Member 'ACinematicTigerStub::LeftTrackTile_092' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_093) == 0x0008C8, "Member 'ACinematicTigerStub::LeftTrackTile_093' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_094) == 0x0008D0, "Member 'ACinematicTigerStub::LeftTrackTile_094' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_095) == 0x0008D8, "Member 'ACinematicTigerStub::LeftTrackTile_095' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_096) == 0x0008E0, "Member 'ACinematicTigerStub::LeftTrackTile_096' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_097) == 0x0008E8, "Member 'ACinematicTigerStub::LeftTrackTile_097' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_098) == 0x0008F0, "Member 'ACinematicTigerStub::LeftTrackTile_098' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_099) == 0x0008F8, "Member 'ACinematicTigerStub::LeftTrackTile_099' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_100) == 0x000900, "Member 'ACinematicTigerStub::LeftTrackTile_100' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_101) == 0x000908, "Member 'ACinematicTigerStub::LeftTrackTile_101' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_102) == 0x000910, "Member 'ACinematicTigerStub::LeftTrackTile_102' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_103) == 0x000918, "Member 'ACinematicTigerStub::LeftTrackTile_103' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_104) == 0x000920, "Member 'ACinematicTigerStub::LeftTrackTile_104' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_105) == 0x000928, "Member 'ACinematicTigerStub::LeftTrackTile_105' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_106) == 0x000930, "Member 'ACinematicTigerStub::LeftTrackTile_106' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_107) == 0x000938, "Member 'ACinematicTigerStub::LeftTrackTile_107' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_108) == 0x000940, "Member 'ACinematicTigerStub::LeftTrackTile_108' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_109) == 0x000948, "Member 'ACinematicTigerStub::LeftTrackTile_109' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_110) == 0x000950, "Member 'ACinematicTigerStub::LeftTrackTile_110' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_111) == 0x000958, "Member 'ACinematicTigerStub::LeftTrackTile_111' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_112) == 0x000960, "Member 'ACinematicTigerStub::LeftTrackTile_112' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_113) == 0x000968, "Member 'ACinematicTigerStub::LeftTrackTile_113' has a wrong offset!");
static_assert(offsetof(ACinematicTigerStub, LeftTrackTile_114) == 0x000970, "Member 'ACinematicTigerStub::LeftTrackTile_114' has a wrong offset!");

// Class HLL.HLLPlayerStats
// 0x00E8 (0x0198 - 0x00B0)
class UHLLPlayerStats final : public UActorComponent
{
public:
	uint8                                         Pad_FD3[0xE8];                                     // 0x00B0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Client_IncrementStat(const EHLLPlayerStat InStat);
	void Client_InitializeStats(const struct FPersistentPersonalStats& InitialStats);
	void Client_NotifyShotHit();
	void Client_SetStat(const EHLLPlayerStat InStat, const int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPlayerStats">();
	}
	static class UHLLPlayerStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPlayerStats>();
	}
};
static_assert(alignof(UHLLPlayerStats) == 0x000008, "Wrong alignment on UHLLPlayerStats");
static_assert(sizeof(UHLLPlayerStats) == 0x000198, "Wrong size on UHLLPlayerStats");

// Class HLL.AchievementDataSubSystem
// 0x0010 (0x0040 - 0x0030)
class UAchievementDataSubSystem final : public UGameInstanceSubsystem
{
public:
	class UDataTable*                             AchievementStatTable;                              // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             AchievementTable;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementDataSubSystem">();
	}
	static class UAchievementDataSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementDataSubSystem>();
	}
};
static_assert(alignof(UAchievementDataSubSystem) == 0x000008, "Wrong alignment on UAchievementDataSubSystem");
static_assert(sizeof(UAchievementDataSubSystem) == 0x000040, "Wrong size on UAchievementDataSubSystem");
static_assert(offsetof(UAchievementDataSubSystem, AchievementStatTable) == 0x000030, "Member 'UAchievementDataSubSystem::AchievementStatTable' has a wrong offset!");
static_assert(offsetof(UAchievementDataSubSystem, AchievementTable) == 0x000038, "Member 'UAchievementDataSubSystem::AchievementTable' has a wrong offset!");

// Class HLL.HLLMapIconBase
// 0x0138 (0x0368 - 0x0230)
class UHLLMapIconBase : public UUserWidget
{
public:
	class UScaleBox*                              MapIconScaleBox;                                   // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLMapDataBase*                        AssignedData;                                      // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              IconAlignment;                                     // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IconPriority;                                      // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD5[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRuntimeFloatCurve                     ZoomIconScale;                                     // 0x0250(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EMapIconFilter                                FilterType;                                        // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHighlightOnHover : 1;                             // 0x02D9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowHighlightLock : 1;                           // 0x02D9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_40 : 6;                                     // 0x00D9(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-69 ])
	uint8                                         Pad_FD6[0x42];                                     // 0x02DA(0x0042)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bAllowMapInteraction : 1;                          // 0x031C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FD7[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLTooltipBase>            TooltipClass;                                      // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TooltipZOrder;                                     // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD8[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLTooltipBase*                        ActiveTooltip;                                     // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapIconButton*                         HoverButton;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD9[0x10];                                     // 0x0348(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLOverviewMap*                        OwningMapWidget;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FDA[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClicked();
	void OnHovered();
	void OnSelectedStateChanged(const bool bNewIsSelected);
	void OnUnhovered();
	void SetZPriority(const int32 InPriority);

	EMapIconFilter GetFilterType() const;
	bool IsInDeploymentMap() const;
	bool IsSelected() const;
	struct FVector2D ScaleWorldToIcon(const struct FVector2D& InSize, const float CurrentZoom) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIconBase">();
	}
	static class UHLLMapIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIconBase>();
	}
};
static_assert(alignof(UHLLMapIconBase) == 0x000008, "Wrong alignment on UHLLMapIconBase");
static_assert(sizeof(UHLLMapIconBase) == 0x000368, "Wrong size on UHLLMapIconBase");
static_assert(offsetof(UHLLMapIconBase, MapIconScaleBox) == 0x000230, "Member 'UHLLMapIconBase::MapIconScaleBox' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, AssignedData) == 0x000238, "Member 'UHLLMapIconBase::AssignedData' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, IconAlignment) == 0x000240, "Member 'UHLLMapIconBase::IconAlignment' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, IconPriority) == 0x000248, "Member 'UHLLMapIconBase::IconPriority' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, ZoomIconScale) == 0x000250, "Member 'UHLLMapIconBase::ZoomIconScale' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, FilterType) == 0x0002D8, "Member 'UHLLMapIconBase::FilterType' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, TooltipClass) == 0x000320, "Member 'UHLLMapIconBase::TooltipClass' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, TooltipZOrder) == 0x000328, "Member 'UHLLMapIconBase::TooltipZOrder' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, ActiveTooltip) == 0x000330, "Member 'UHLLMapIconBase::ActiveTooltip' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, HoverButton) == 0x000338, "Member 'UHLLMapIconBase::HoverButton' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, IconImage) == 0x000340, "Member 'UHLLMapIconBase::IconImage' has a wrong offset!");
static_assert(offsetof(UHLLMapIconBase, OwningMapWidget) == 0x000358, "Member 'UHLLMapIconBase::OwningMapWidget' has a wrong offset!");

// Class HLL.HLLMapIcon_SeatBase
// 0x0008 (0x0370 - 0x0368)
class UHLLMapIcon_SeatBase : public UHLLMapIconBase
{
public:
	uint8                                         bColouriseButton : 1;                              // 0x0368(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bColouriseIcon : 1;                                // 0x0368(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FDB[0x7];                                      // 0x0369(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_SeatBase">();
	}
	static class UHLLMapIcon_SeatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_SeatBase>();
	}
};
static_assert(alignof(UHLLMapIcon_SeatBase) == 0x000008, "Wrong alignment on UHLLMapIcon_SeatBase");
static_assert(sizeof(UHLLMapIcon_SeatBase) == 0x000370, "Wrong size on UHLLMapIcon_SeatBase");

// Class HLL.ShooterTeamStart
// 0x0008 (0x0258 - 0x0250)
class AShooterTeamStart final : public APlayerStart
{
public:
	int32                                         SpawnTeam;                                         // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNotForPlayers : 1;                                // 0x0254(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotForBots : 1;                                   // 0x0254(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FDC[0x3];                                      // 0x0255(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterTeamStart">();
	}
	static class AShooterTeamStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterTeamStart>();
	}
};
static_assert(alignof(AShooterTeamStart) == 0x000008, "Wrong alignment on AShooterTeamStart");
static_assert(sizeof(AShooterTeamStart) == 0x000258, "Wrong size on AShooterTeamStart");
static_assert(offsetof(AShooterTeamStart, SpawnTeam) == 0x000250, "Member 'AShooterTeamStart::SpawnTeam' has a wrong offset!");

// Class HLL.HLLWeatherLightningActor
// 0x0038 (0x0258 - 0x0220)
class AHLLWeatherLightningActor final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             StrikeLightningEvent;                              // 0x0220(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UHLLWeatherManagerData*                 WeatherManagerData;                                // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHLLWeatherManagerActor*                WeatherManagerActor;                               // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FDD[0x18];                                     // 0x0240(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AttempLightning(EWeatherType WeatherType, EWeatherIntensity Intensity);
	void OnLightningCooldownFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherLightningActor">();
	}
	static class AHLLWeatherLightningActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLWeatherLightningActor>();
	}
};
static_assert(alignof(AHLLWeatherLightningActor) == 0x000008, "Wrong alignment on AHLLWeatherLightningActor");
static_assert(sizeof(AHLLWeatherLightningActor) == 0x000258, "Wrong size on AHLLWeatherLightningActor");
static_assert(offsetof(AHLLWeatherLightningActor, StrikeLightningEvent) == 0x000220, "Member 'AHLLWeatherLightningActor::StrikeLightningEvent' has a wrong offset!");
static_assert(offsetof(AHLLWeatherLightningActor, WeatherManagerData) == 0x000230, "Member 'AHLLWeatherLightningActor::WeatherManagerData' has a wrong offset!");
static_assert(offsetof(AHLLWeatherLightningActor, WeatherManagerActor) == 0x000238, "Member 'AHLLWeatherLightningActor::WeatherManagerActor' has a wrong offset!");

// Class HLL.HLLRadialMenu_ChildBase
// 0x0008 (0x0238 - 0x0230)
class UHLLRadialMenu_ChildBase : public UUserWidget
{
public:
	TWeakObjectPtr<class UHLLRadialMenu_Base>     OwningRadialMenu;                                  // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_UpdateRenderAngle(const float InAngle, const float InCorrectionAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_ChildBase">();
	}
	static class UHLLRadialMenu_ChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_ChildBase>();
	}
};
static_assert(alignof(UHLLRadialMenu_ChildBase) == 0x000008, "Wrong alignment on UHLLRadialMenu_ChildBase");
static_assert(sizeof(UHLLRadialMenu_ChildBase) == 0x000238, "Wrong size on UHLLRadialMenu_ChildBase");
static_assert(offsetof(UHLLRadialMenu_ChildBase, OwningRadialMenu) == 0x000230, "Member 'UHLLRadialMenu_ChildBase::OwningRadialMenu' has a wrong offset!");

// Class HLL.HLLRadialMenu_Segment
// 0x0040 (0x0278 - 0x0238)
class UHLLRadialMenu_Segment : public UHLLRadialMenu_ChildBase
{
public:
	struct FSlateSound                            HoveredSound;                                      // 0x0238(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            UnhoveredSound;                                    // 0x0250(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsSelected : 1;                                   // 0x0268(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FDE[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 SegmentProgress;                                   // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_OnSelectionChanged(const bool bSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_Segment">();
	}
	static class UHLLRadialMenu_Segment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_Segment>();
	}
};
static_assert(alignof(UHLLRadialMenu_Segment) == 0x000008, "Wrong alignment on UHLLRadialMenu_Segment");
static_assert(sizeof(UHLLRadialMenu_Segment) == 0x000278, "Wrong size on UHLLRadialMenu_Segment");
static_assert(offsetof(UHLLRadialMenu_Segment, HoveredSound) == 0x000238, "Member 'UHLLRadialMenu_Segment::HoveredSound' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Segment, UnhoveredSound) == 0x000250, "Member 'UHLLRadialMenu_Segment::UnhoveredSound' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Segment, SegmentProgress) == 0x000270, "Member 'UHLLRadialMenu_Segment::SegmentProgress' has a wrong offset!");

// Class HLL.HLLRadialMenu_MarkersSegment
// 0x0010 (0x0288 - 0x0278)
class UHLLRadialMenu_MarkersSegment : public UHLLRadialMenu_Segment
{
public:
	EHLLMarker                                    MarkerType;                                        // 0x0278(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FDF[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 MarkerIcon;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_InitMarkerSegment(const struct FMarkerMetaData& MarkerMeta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_MarkersSegment">();
	}
	static class UHLLRadialMenu_MarkersSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_MarkersSegment>();
	}
};
static_assert(alignof(UHLLRadialMenu_MarkersSegment) == 0x000008, "Wrong alignment on UHLLRadialMenu_MarkersSegment");
static_assert(sizeof(UHLLRadialMenu_MarkersSegment) == 0x000288, "Wrong size on UHLLRadialMenu_MarkersSegment");
static_assert(offsetof(UHLLRadialMenu_MarkersSegment, MarkerType) == 0x000278, "Member 'UHLLRadialMenu_MarkersSegment::MarkerType' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_MarkersSegment, MarkerIcon) == 0x000280, "Member 'UHLLRadialMenu_MarkersSegment::MarkerIcon' has a wrong offset!");

// Class HLL.HLLSeat
// 0x07A0 (0x09C0 - 0x0220)
class AHLLSeat : public AActor
{
public:
	uint8                                         bUsePostProcess : 1;                               // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FE0[0xF];                                      // 0x0221(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	struct FPostProcessSettings                   PostSettings;                                      // 0x0230(0x0540)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE1[0x8];                                      // 0x0770(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FHLLSeatZoomLevel>              ZoomFOVList;                                       // 0x0778(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ZoomInSound;                                       // 0x0788(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ZoomOutSound;                                      // 0x0790(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlendZoom;                                        // 0x0798(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE2[0x3];                                      // 0x0799(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ZoomBlendSpeed;                                    // 0x079C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanZoomDuringReload;                              // 0x07A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictedToOfficers;                             // 0x07A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE3[0x6];                                      // 0x07A2(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterCharacter*                      CurrentOccupant;                                   // 0x07A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLSeatOccupancyUpdate                OccupancyUpdate;                                   // 0x07B0(0x0010)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHLLSeatOccupancyUpdate                PendingOccupancyUpdateRep;                         // 0x07C0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bHasPendingOccupancyUpdate;                        // 0x07D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bHideFirstPerson : 1;                              // 0x07D1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideThirdPerson : 1;                              // 0x07D1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFirstPersonIsThirdPerson : 1;                     // 0x07D1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideThirdPersonHeadInFirstPerson : 1;             // 0x07D1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSameTeamOnly : 1;                            // 0x07D1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowEntryDuringMatchWarmup : 1;                  // 0x07D1(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAttachOccupant : 1;                               // 0x07D1(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESeatAttachmentMode                           AttachmentMode;                                    // 0x07D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bProtectOccupant : 1;                              // 0x07D3(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnequipWeaponOnSeating : 1;                       // 0x07D3(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSeatViewpoint : 1;                             // 0x07D3(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableLaserTagging : 1;                           // 0x07D3(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_41 : 4;                                     // 0x00D3(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-69 ])
	uint8                                         bDisablePingMarkers : 1;                           // 0x07D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FE4[0x3];                                      // 0x07D5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   AttachSocketName;                                  // 0x07D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EyepointSocketName;                                // 0x07E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              OccupantAnim_1P;                                   // 0x07E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              OccupantAnim_3P;                                   // 0x07F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ServerReferenceMesh;                               // 0x07F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHLLSeatWidgetBase>         SeatUI;                                            // 0x0800(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            SeatIcon;                                          // 0x0808(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SeatDisplayName;                                   // 0x0890(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<EHint>                                   HintsToDisplay;                                    // 0x08A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bClearEnterOrExitHintOnEnter : 1;                  // 0x08F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EHint                                         CanEnterHint;                                      // 0x08F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHint                                         CantEnterHint;                                     // 0x08FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPassengerCollisionMode : 1;                       // 0x08FB(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReceiveSharedKillCredit : 1;                      // 0x08FB(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSendSeatCapsuleOffsets : 1;                       // 0x08FB(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ESeatOccupantDeathAction                      OccupantDeathAction;                               // 0x08FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE5[0x3];                                      // 0x08FD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundMix*                              SoundMix;                                          // 0x0900(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsExterior : 1;                                   // 0x0908(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FE6[0x7];                                      // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             ExitSound;                                         // 0x0910(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             EnterSound;                                        // 0x0918(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasPushedSoundMix : 1;                            // 0x0920(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_FE7[0x7];                                      // 0x0921(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UInputComponent*                        SeatInput;                                         // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SeatOwner;                                         // 0x0930(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SeatIndex;                                         // 0x0938(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE8[0xC];                                      // 0x093C(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         EntryTime;                                         // 0x0948(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwitchTime;                                        // 0x094C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExitTime;                                          // 0x0950(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHidesPlayerNameHUDIndicator : 1;                  // 0x0954(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FE9[0x23];                                     // 0x0955(0x0023)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AHLLArmourWeapon*>               OwnedWeapons;                                      // 0x0978(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSupportCrouch;                                    // 0x0988(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FEA[0x3];                                      // 0x0989(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   CrouchEyepointName;                                // 0x098C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchBlendSpeed;                                  // 0x0994(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOccupantCrouched;                                 // 0x0998(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FEB[0x27];                                     // 0x0999(0x0027)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_OccupancyUpdate();
	void OnRep_OccupantCrouch();
	void Server_TryExit();
	void Server_TrySwitchSeat(const uint8 NewSeatIndex);
	void ServerSetCrouch(const bool bCrouched);

	bool AreWeaponsInitialized() const;
	int32 GetSeatIndex() const;
	class AActor* GetSeatOwner() const;
	int32 GetZoomLevel() const;
	bool IsZoomedIn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeat">();
	}
	static class AHLLSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSeat>();
	}
};
static_assert(alignof(AHLLSeat) == 0x000010, "Wrong alignment on AHLLSeat");
static_assert(sizeof(AHLLSeat) == 0x0009C0, "Wrong size on AHLLSeat");
static_assert(offsetof(AHLLSeat, PostSettings) == 0x000230, "Member 'AHLLSeat::PostSettings' has a wrong offset!");
static_assert(offsetof(AHLLSeat, ZoomFOVList) == 0x000778, "Member 'AHLLSeat::ZoomFOVList' has a wrong offset!");
static_assert(offsetof(AHLLSeat, ZoomInSound) == 0x000788, "Member 'AHLLSeat::ZoomInSound' has a wrong offset!");
static_assert(offsetof(AHLLSeat, ZoomOutSound) == 0x000790, "Member 'AHLLSeat::ZoomOutSound' has a wrong offset!");
static_assert(offsetof(AHLLSeat, bBlendZoom) == 0x000798, "Member 'AHLLSeat::bBlendZoom' has a wrong offset!");
static_assert(offsetof(AHLLSeat, ZoomBlendSpeed) == 0x00079C, "Member 'AHLLSeat::ZoomBlendSpeed' has a wrong offset!");
static_assert(offsetof(AHLLSeat, bCanZoomDuringReload) == 0x0007A0, "Member 'AHLLSeat::bCanZoomDuringReload' has a wrong offset!");
static_assert(offsetof(AHLLSeat, bRestrictedToOfficers) == 0x0007A1, "Member 'AHLLSeat::bRestrictedToOfficers' has a wrong offset!");
static_assert(offsetof(AHLLSeat, CurrentOccupant) == 0x0007A8, "Member 'AHLLSeat::CurrentOccupant' has a wrong offset!");
static_assert(offsetof(AHLLSeat, OccupancyUpdate) == 0x0007B0, "Member 'AHLLSeat::OccupancyUpdate' has a wrong offset!");
static_assert(offsetof(AHLLSeat, PendingOccupancyUpdateRep) == 0x0007C0, "Member 'AHLLSeat::PendingOccupancyUpdateRep' has a wrong offset!");
static_assert(offsetof(AHLLSeat, bHasPendingOccupancyUpdate) == 0x0007D0, "Member 'AHLLSeat::bHasPendingOccupancyUpdate' has a wrong offset!");
static_assert(offsetof(AHLLSeat, AttachmentMode) == 0x0007D2, "Member 'AHLLSeat::AttachmentMode' has a wrong offset!");
static_assert(offsetof(AHLLSeat, AttachSocketName) == 0x0007D8, "Member 'AHLLSeat::AttachSocketName' has a wrong offset!");
static_assert(offsetof(AHLLSeat, EyepointSocketName) == 0x0007E0, "Member 'AHLLSeat::EyepointSocketName' has a wrong offset!");
static_assert(offsetof(AHLLSeat, OccupantAnim_1P) == 0x0007E8, "Member 'AHLLSeat::OccupantAnim_1P' has a wrong offset!");
static_assert(offsetof(AHLLSeat, OccupantAnim_3P) == 0x0007F0, "Member 'AHLLSeat::OccupantAnim_3P' has a wrong offset!");
static_assert(offsetof(AHLLSeat, ServerReferenceMesh) == 0x0007F8, "Member 'AHLLSeat::ServerReferenceMesh' has a wrong offset!");
static_assert(offsetof(AHLLSeat, SeatUI) == 0x000800, "Member 'AHLLSeat::SeatUI' has a wrong offset!");
static_assert(offsetof(AHLLSeat, SeatIcon) == 0x000808, "Member 'AHLLSeat::SeatIcon' has a wrong offset!");
static_assert(offsetof(AHLLSeat, SeatDisplayName) == 0x000890, "Member 'AHLLSeat::SeatDisplayName' has a wrong offset!");
static_assert(offsetof(AHLLSeat, HintsToDisplay) == 0x0008A8, "Member 'AHLLSeat::HintsToDisplay' has a wrong offset!");
static_assert(offsetof(AHLLSeat, CanEnterHint) == 0x0008F9, "Member 'AHLLSeat::CanEnterHint' has a wrong offset!");
static_assert(offsetof(AHLLSeat, CantEnterHint) == 0x0008FA, "Member 'AHLLSeat::CantEnterHint' has a wrong offset!");
static_assert(offsetof(AHLLSeat, OccupantDeathAction) == 0x0008FC, "Member 'AHLLSeat::OccupantDeathAction' has a wrong offset!");
static_assert(offsetof(AHLLSeat, SoundMix) == 0x000900, "Member 'AHLLSeat::SoundMix' has a wrong offset!");
static_assert(offsetof(AHLLSeat, ExitSound) == 0x000910, "Member 'AHLLSeat::ExitSound' has a wrong offset!");
static_assert(offsetof(AHLLSeat, EnterSound) == 0x000918, "Member 'AHLLSeat::EnterSound' has a wrong offset!");
static_assert(offsetof(AHLLSeat, SeatInput) == 0x000928, "Member 'AHLLSeat::SeatInput' has a wrong offset!");
static_assert(offsetof(AHLLSeat, SeatOwner) == 0x000930, "Member 'AHLLSeat::SeatOwner' has a wrong offset!");
static_assert(offsetof(AHLLSeat, SeatIndex) == 0x000938, "Member 'AHLLSeat::SeatIndex' has a wrong offset!");
static_assert(offsetof(AHLLSeat, EntryTime) == 0x000948, "Member 'AHLLSeat::EntryTime' has a wrong offset!");
static_assert(offsetof(AHLLSeat, SwitchTime) == 0x00094C, "Member 'AHLLSeat::SwitchTime' has a wrong offset!");
static_assert(offsetof(AHLLSeat, ExitTime) == 0x000950, "Member 'AHLLSeat::ExitTime' has a wrong offset!");
static_assert(offsetof(AHLLSeat, OwnedWeapons) == 0x000978, "Member 'AHLLSeat::OwnedWeapons' has a wrong offset!");
static_assert(offsetof(AHLLSeat, bSupportCrouch) == 0x000988, "Member 'AHLLSeat::bSupportCrouch' has a wrong offset!");
static_assert(offsetof(AHLLSeat, CrouchEyepointName) == 0x00098C, "Member 'AHLLSeat::CrouchEyepointName' has a wrong offset!");
static_assert(offsetof(AHLLSeat, CrouchBlendSpeed) == 0x000994, "Member 'AHLLSeat::CrouchBlendSpeed' has a wrong offset!");
static_assert(offsetof(AHLLSeat, bOccupantCrouched) == 0x000998, "Member 'AHLLSeat::bOccupantCrouched' has a wrong offset!");

// Class HLL.VehicleSeatBase
// 0x0010 (0x09D0 - 0x09C0)
#pragma pack(push, 0x1)
class alignas(0x10) AVehicleSeatBase : public AHLLSeat
{
public:
	uint8                                         bOnlyAllowSameUnitMembers : 1;                     // 0x09C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FEC[0x7];                                      // 0x09C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSeatBase">();
	}
	static class AVehicleSeatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleSeatBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AVehicleSeatBase) == 0x000010, "Wrong alignment on AVehicleSeatBase");
static_assert(sizeof(AVehicleSeatBase) == 0x0009D0, "Wrong size on AVehicleSeatBase");

// Class HLL.ReconVehiclePassengerSeat
// 0x0010 (0x09E0 - 0x09D0)
class AReconVehiclePassengerSeat final : public AVehicleSeatBase
{
public:
	class USceneComponent*                        InteriorMeshAttachmentRoot;                        // 0x09C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   InteriorMesh;                                      // 0x09D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USeatCameraController*                  CameraController;                                  // 0x09D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReconVehiclePassengerSeat">();
	}
	static class AReconVehiclePassengerSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReconVehiclePassengerSeat>();
	}
};
static_assert(alignof(AReconVehiclePassengerSeat) == 0x000010, "Wrong alignment on AReconVehiclePassengerSeat");
static_assert(sizeof(AReconVehiclePassengerSeat) == 0x0009E0, "Wrong size on AReconVehiclePassengerSeat");
static_assert(offsetof(AReconVehiclePassengerSeat, InteriorMeshAttachmentRoot) == 0x0009C8, "Member 'AReconVehiclePassengerSeat::InteriorMeshAttachmentRoot' has a wrong offset!");
static_assert(offsetof(AReconVehiclePassengerSeat, InteriorMesh) == 0x0009D0, "Member 'AReconVehiclePassengerSeat::InteriorMesh' has a wrong offset!");
static_assert(offsetof(AReconVehiclePassengerSeat, CameraController) == 0x0009D8, "Member 'AReconVehiclePassengerSeat::CameraController' has a wrong offset!");

// Class HLL.ClientBotInputComponent
// 0x0010 (0x0148 - 0x0138)
class UClientBotInputComponent : public UInputComponent
{
public:
	TArray<class UClientBotProcessor*>            M_processors;                                      // 0x0138(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotInputComponent">();
	}
	static class UClientBotInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotInputComponent>();
	}
};
static_assert(alignof(UClientBotInputComponent) == 0x000008, "Wrong alignment on UClientBotInputComponent");
static_assert(sizeof(UClientBotInputComponent) == 0x000148, "Wrong size on UClientBotInputComponent");
static_assert(offsetof(UClientBotInputComponent, M_processors) == 0x000138, "Member 'UClientBotInputComponent::M_processors' has a wrong offset!");

// Class HLL.HLLMapIcon_Basic
// 0x0000 (0x0368 - 0x0368)
class UHLLMapIcon_Basic : public UHLLMapIconBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Basic">();
	}
	static class UHLLMapIcon_Basic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Basic>();
	}
};
static_assert(alignof(UHLLMapIcon_Basic) == 0x000008, "Wrong alignment on UHLLMapIcon_Basic");
static_assert(sizeof(UHLLMapIcon_Basic) == 0x000368, "Wrong size on UHLLMapIcon_Basic");

// Class HLL.HLLMapIcon_ResourceNode
// 0x0008 (0x0370 - 0x0368)
class UHLLMapIcon_ResourceNode : public UHLLMapIcon_Basic
{
public:
	class USizeBox*                               RadiusSBox;                                        // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_ResourceNode">();
	}
	static class UHLLMapIcon_ResourceNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_ResourceNode>();
	}
};
static_assert(alignof(UHLLMapIcon_ResourceNode) == 0x000008, "Wrong alignment on UHLLMapIcon_ResourceNode");
static_assert(sizeof(UHLLMapIcon_ResourceNode) == 0x000370, "Wrong size on UHLLMapIcon_ResourceNode");
static_assert(offsetof(UHLLMapIcon_ResourceNode, RadiusSBox) == 0x000368, "Member 'UHLLMapIcon_ResourceNode::RadiusSBox' has a wrong offset!");

// Class HLL.AnimationTests
// 0x0128 (0x0348 - 0x0220)
class AAnimationTests final : public AActor
{
public:
	TSubclassOf<class AShooterCharacterT1>        CharacterBP;                                       // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ADS;                                               // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Crouch;                                            // 0x0229(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GoProne;                                           // 0x022A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FED[0x5];                                      // 0x022B(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class ATargetPoint*                           ForwardPauseBackwardSpawn;                         // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           ForwardBackwardSpawn;                              // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           SprintForwardBackwardPauseSpawn;                   // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           SprintForwardBackwardNoPauseSpawn;                 // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           WalkingLeftRightNoPauseSpawn;                      // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           WalkingLeftRightPauseSpawn;                        // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           TurningSpawn;                                      // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           StandCrouchSpawn;                                  // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           CrouchProneSpawn;                                  // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           StandProneSpawn;                                   // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           StandADSSpawn;                                     // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           CrouchADSSpawn;                                    // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           ProneADSSpawn;                                     // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           BoltCycleStandSpawn;                               // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           BoltCycleCrouchSpawn;                              // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATargetPoint*                           BoltCycleProneSpawn;                               // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AShooterCharacterT1*                    ForwardPauseBackwardChar;                          // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    ForwardBackwardChar;                               // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    SprintForwardBackwardPauseChar;                    // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    SprintForwardBackwardNoPauseChar;                  // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    WalkingLeftRightNoPauseChar;                       // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    WalkingLeftRightPauseChar;                         // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    TurningChar;                                       // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    StandCrouchChar;                                   // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    CrouchProneChar;                                   // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    StandProneChar;                                    // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    StandADSChar;                                      // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    CrouchADSChar;                                     // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    ProneADSChar;                                      // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    BoltCycleStandChar;                                // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    BoltCycleCrouchChar;                               // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacterT1*                    BoltCycleProneChar;                                // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FEE[0x18];                                     // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationTests">();
	}
	static class AAnimationTests* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnimationTests>();
	}
};
static_assert(alignof(AAnimationTests) == 0x000008, "Wrong alignment on AAnimationTests");
static_assert(sizeof(AAnimationTests) == 0x000348, "Wrong size on AAnimationTests");
static_assert(offsetof(AAnimationTests, CharacterBP) == 0x000220, "Member 'AAnimationTests::CharacterBP' has a wrong offset!");
static_assert(offsetof(AAnimationTests, ADS) == 0x000228, "Member 'AAnimationTests::ADS' has a wrong offset!");
static_assert(offsetof(AAnimationTests, Crouch) == 0x000229, "Member 'AAnimationTests::Crouch' has a wrong offset!");
static_assert(offsetof(AAnimationTests, GoProne) == 0x00022A, "Member 'AAnimationTests::GoProne' has a wrong offset!");
static_assert(offsetof(AAnimationTests, ForwardPauseBackwardSpawn) == 0x000230, "Member 'AAnimationTests::ForwardPauseBackwardSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, ForwardBackwardSpawn) == 0x000238, "Member 'AAnimationTests::ForwardBackwardSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, SprintForwardBackwardPauseSpawn) == 0x000240, "Member 'AAnimationTests::SprintForwardBackwardPauseSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, SprintForwardBackwardNoPauseSpawn) == 0x000248, "Member 'AAnimationTests::SprintForwardBackwardNoPauseSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, WalkingLeftRightNoPauseSpawn) == 0x000250, "Member 'AAnimationTests::WalkingLeftRightNoPauseSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, WalkingLeftRightPauseSpawn) == 0x000258, "Member 'AAnimationTests::WalkingLeftRightPauseSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, TurningSpawn) == 0x000260, "Member 'AAnimationTests::TurningSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, StandCrouchSpawn) == 0x000268, "Member 'AAnimationTests::StandCrouchSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, CrouchProneSpawn) == 0x000270, "Member 'AAnimationTests::CrouchProneSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, StandProneSpawn) == 0x000278, "Member 'AAnimationTests::StandProneSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, StandADSSpawn) == 0x000280, "Member 'AAnimationTests::StandADSSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, CrouchADSSpawn) == 0x000288, "Member 'AAnimationTests::CrouchADSSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, ProneADSSpawn) == 0x000290, "Member 'AAnimationTests::ProneADSSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, BoltCycleStandSpawn) == 0x000298, "Member 'AAnimationTests::BoltCycleStandSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, BoltCycleCrouchSpawn) == 0x0002A0, "Member 'AAnimationTests::BoltCycleCrouchSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, BoltCycleProneSpawn) == 0x0002A8, "Member 'AAnimationTests::BoltCycleProneSpawn' has a wrong offset!");
static_assert(offsetof(AAnimationTests, ForwardPauseBackwardChar) == 0x0002B0, "Member 'AAnimationTests::ForwardPauseBackwardChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, ForwardBackwardChar) == 0x0002B8, "Member 'AAnimationTests::ForwardBackwardChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, SprintForwardBackwardPauseChar) == 0x0002C0, "Member 'AAnimationTests::SprintForwardBackwardPauseChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, SprintForwardBackwardNoPauseChar) == 0x0002C8, "Member 'AAnimationTests::SprintForwardBackwardNoPauseChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, WalkingLeftRightNoPauseChar) == 0x0002D0, "Member 'AAnimationTests::WalkingLeftRightNoPauseChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, WalkingLeftRightPauseChar) == 0x0002D8, "Member 'AAnimationTests::WalkingLeftRightPauseChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, TurningChar) == 0x0002E0, "Member 'AAnimationTests::TurningChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, StandCrouchChar) == 0x0002E8, "Member 'AAnimationTests::StandCrouchChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, CrouchProneChar) == 0x0002F0, "Member 'AAnimationTests::CrouchProneChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, StandProneChar) == 0x0002F8, "Member 'AAnimationTests::StandProneChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, StandADSChar) == 0x000300, "Member 'AAnimationTests::StandADSChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, CrouchADSChar) == 0x000308, "Member 'AAnimationTests::CrouchADSChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, ProneADSChar) == 0x000310, "Member 'AAnimationTests::ProneADSChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, BoltCycleStandChar) == 0x000318, "Member 'AAnimationTests::BoltCycleStandChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, BoltCycleCrouchChar) == 0x000320, "Member 'AAnimationTests::BoltCycleCrouchChar' has a wrong offset!");
static_assert(offsetof(AAnimationTests, BoltCycleProneChar) == 0x000328, "Member 'AAnimationTests::BoltCycleProneChar' has a wrong offset!");

// Class HLL.UIClassSelector
// 0x0098 (0x00C0 - 0x0028)
class UUIClassSelector final : public UObject
{
public:
	uint8                                         Pad_FEF[0x8];                                      // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUIClassCollection                     DefaultClasses;                                    // 0x0030(0x0090)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIClassSelector">();
	}
	static class UUIClassSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIClassSelector>();
	}
};
static_assert(alignof(UUIClassSelector) == 0x000008, "Wrong alignment on UUIClassSelector");
static_assert(sizeof(UUIClassSelector) == 0x0000C0, "Wrong size on UUIClassSelector");
static_assert(offsetof(UUIClassSelector, DefaultClasses) == 0x000030, "Member 'UUIClassSelector::DefaultClasses' has a wrong offset!");

// Class HLL.ClientBotProcessor
// 0x0008 (0x0030 - 0x0028)
class UClientBotProcessor : public UObject
{
public:
	uint8                                         Pad_FF0[0x8];                                      // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor">();
	}
	static class UClientBotProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor>();
	}
};
static_assert(alignof(UClientBotProcessor) == 0x000008, "Wrong alignment on UClientBotProcessor");
static_assert(sizeof(UClientBotProcessor) == 0x000030, "Wrong size on UClientBotProcessor");

// Class HLL.ClientBotProcessor_LetGo
// 0x0010 (0x0040 - 0x0030)
class UClientBotProcessor_LetGo final : public UClientBotProcessor
{
public:
	uint8                                         Pad_FF1[0x10];                                     // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor_LetGo">();
	}
	static class UClientBotProcessor_LetGo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor_LetGo>();
	}
};
static_assert(alignof(UClientBotProcessor_LetGo) == 0x000008, "Wrong alignment on UClientBotProcessor_LetGo");
static_assert(sizeof(UClientBotProcessor_LetGo) == 0x000040, "Wrong size on UClientBotProcessor_LetGo");

// Class HLL.BaseShooterGameMode
// 0x0008 (0x0310 - 0x0308)
class ABaseShooterGameMode : public AGameMode
{
public:
	EGameModeType                                 GameModeType;                                      // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsExplorer;                                        // 0x0309(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FF2[0x6];                                      // 0x030A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseShooterGameMode">();
	}
	static class ABaseShooterGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseShooterGameMode>();
	}
};
static_assert(alignof(ABaseShooterGameMode) == 0x000008, "Wrong alignment on ABaseShooterGameMode");
static_assert(sizeof(ABaseShooterGameMode) == 0x000310, "Wrong size on ABaseShooterGameMode");
static_assert(offsetof(ABaseShooterGameMode, GameModeType) == 0x000308, "Member 'ABaseShooterGameMode::GameModeType' has a wrong offset!");
static_assert(offsetof(ABaseShooterGameMode, IsExplorer) == 0x000309, "Member 'ABaseShooterGameMode::IsExplorer' has a wrong offset!");

// Class HLL.ShooterGameMode
// 0x0288 (0x0598 - 0x0310)
class AShooterGameMode : public ABaseShooterGameMode
{
public:
	TSubclassOf<class APawn>                      BotPawnClass;                                      // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APawn>                      AxisPlayerPawnClass;                               // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APawn>                      AlliesPlayerPawnClass;                             // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHLLAdminCamera>            AdminCameraClass;                                  // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF3[0x28];                                     // 0x0330(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         WarmupTime;                                        // 0x0358(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTime;                                         // 0x035C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPlayers;                                        // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSectors;                                    // 0x0364(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FF4[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         SectorCaptureTime;                                 // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SectorCaptureProtectionTime;                       // 0x036C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FF5[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         DeathScore;                                        // 0x0378(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxBots;                                           // 0x037C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AShooterAIController*>           BotControllers;                                    // 0x0380(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FF6[0x50];                                     // 0x0390(0x0050)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class FText>                           ServerMessageOverride;                             // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AController*>                      M_deployedPlayerControllers;                       // 0x03F0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UPendingPlayerDeployment*>       M_pendingDeployments;                              // 0x0440(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AShooterPickup*>                 LevelPickups;                                      // 0x0450(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RConChangingMapDelay;                              // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FF7[0x48];                                     // 0x0464(0x0048)(Fixing Size After Last Property [ Dumper-69 ])
	struct FScoreXPModifiers                      XP_ScoreModifiers;                                 // 0x04AC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MatchWinMultiplier;                                // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchLossMultiplier;                               // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         XPPerMatchMinute;                                  // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BonusMultiplierPerCommendation;                    // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinMatchTimeForXP;                                 // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ActionScoreTable;                                  // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GlobalScoreModifier;                               // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLRoleModifiers                      RoleModifiers[0xE];                                // 0x04DC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         FinaleTimer;                                       // 0x054C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMatchFinaleState                             FinaleState;                                       // 0x0550(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FF8[0x7];                                      // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDateTime                              TimeFinished;                                      // 0x0558(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FinaleTime_EndScreen;                              // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FinaleTime_Commendations;                          // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FinaleTime_ProgressionAndGroupPhoto;               // 0x0568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumPunishTime;                                 // 0x056C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePlayerPunishment;                           // 0x0570(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF9[0x7];                                      // 0x0571(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AHLLTurnBackVolume*>             TurnBackAreas;                                     // 0x0578(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FFA[0x8];                                      // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FGameModifiers                         GameModifiers;                                     // 0x0590(0x0008)(NoDestructor, NativeAccessSpecifierPublic)

public:
	void SetAllowBots(bool bInAllowBots, int32 InMaxBots);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameMode">();
	}
	static class AShooterGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGameMode>();
	}
};
static_assert(alignof(AShooterGameMode) == 0x000008, "Wrong alignment on AShooterGameMode");
static_assert(sizeof(AShooterGameMode) == 0x000598, "Wrong size on AShooterGameMode");
static_assert(offsetof(AShooterGameMode, BotPawnClass) == 0x000310, "Member 'AShooterGameMode::BotPawnClass' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, AxisPlayerPawnClass) == 0x000318, "Member 'AShooterGameMode::AxisPlayerPawnClass' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, AlliesPlayerPawnClass) == 0x000320, "Member 'AShooterGameMode::AlliesPlayerPawnClass' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, AdminCameraClass) == 0x000328, "Member 'AShooterGameMode::AdminCameraClass' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, WarmupTime) == 0x000358, "Member 'AShooterGameMode::WarmupTime' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, RoundTime) == 0x00035C, "Member 'AShooterGameMode::RoundTime' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, MaxPlayers) == 0x000360, "Member 'AShooterGameMode::MaxPlayers' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, bIgnoreSectors) == 0x000364, "Member 'AShooterGameMode::bIgnoreSectors' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, SectorCaptureTime) == 0x000368, "Member 'AShooterGameMode::SectorCaptureTime' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, SectorCaptureProtectionTime) == 0x00036C, "Member 'AShooterGameMode::SectorCaptureProtectionTime' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, DeathScore) == 0x000378, "Member 'AShooterGameMode::DeathScore' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, MaxBots) == 0x00037C, "Member 'AShooterGameMode::MaxBots' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, BotControllers) == 0x000380, "Member 'AShooterGameMode::BotControllers' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, ServerMessageOverride) == 0x0003E0, "Member 'AShooterGameMode::ServerMessageOverride' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, M_deployedPlayerControllers) == 0x0003F0, "Member 'AShooterGameMode::M_deployedPlayerControllers' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, M_pendingDeployments) == 0x000440, "Member 'AShooterGameMode::M_pendingDeployments' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, LevelPickups) == 0x000450, "Member 'AShooterGameMode::LevelPickups' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, RConChangingMapDelay) == 0x000460, "Member 'AShooterGameMode::RConChangingMapDelay' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, XP_ScoreModifiers) == 0x0004AC, "Member 'AShooterGameMode::XP_ScoreModifiers' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, MatchWinMultiplier) == 0x0004BC, "Member 'AShooterGameMode::MatchWinMultiplier' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, MatchLossMultiplier) == 0x0004C0, "Member 'AShooterGameMode::MatchLossMultiplier' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, XPPerMatchMinute) == 0x0004C4, "Member 'AShooterGameMode::XPPerMatchMinute' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, BonusMultiplierPerCommendation) == 0x0004C8, "Member 'AShooterGameMode::BonusMultiplierPerCommendation' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, MinMatchTimeForXP) == 0x0004CC, "Member 'AShooterGameMode::MinMatchTimeForXP' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, ActionScoreTable) == 0x0004D0, "Member 'AShooterGameMode::ActionScoreTable' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, GlobalScoreModifier) == 0x0004D8, "Member 'AShooterGameMode::GlobalScoreModifier' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, RoleModifiers) == 0x0004DC, "Member 'AShooterGameMode::RoleModifiers' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, FinaleTimer) == 0x00054C, "Member 'AShooterGameMode::FinaleTimer' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, FinaleState) == 0x000550, "Member 'AShooterGameMode::FinaleState' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, TimeFinished) == 0x000558, "Member 'AShooterGameMode::TimeFinished' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, FinaleTime_EndScreen) == 0x000560, "Member 'AShooterGameMode::FinaleTime_EndScreen' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, FinaleTime_Commendations) == 0x000564, "Member 'AShooterGameMode::FinaleTime_Commendations' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, FinaleTime_ProgressionAndGroupPhoto) == 0x000568, "Member 'AShooterGameMode::FinaleTime_ProgressionAndGroupPhoto' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, MaximumPunishTime) == 0x00056C, "Member 'AShooterGameMode::MaximumPunishTime' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, bEnablePlayerPunishment) == 0x000570, "Member 'AShooterGameMode::bEnablePlayerPunishment' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, TurnBackAreas) == 0x000578, "Member 'AShooterGameMode::TurnBackAreas' has a wrong offset!");
static_assert(offsetof(AShooterGameMode, GameModifiers) == 0x000590, "Member 'AShooterGameMode::GameModifiers' has a wrong offset!");

// Class HLL.ShooterPracticeGameMode
// 0x0000 (0x0598 - 0x0598)
class AShooterPracticeGameMode final : public AShooterGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPracticeGameMode">();
	}
	static class AShooterPracticeGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPracticeGameMode>();
	}
};
static_assert(alignof(AShooterPracticeGameMode) == 0x000008, "Wrong alignment on AShooterPracticeGameMode");
static_assert(sizeof(AShooterPracticeGameMode) == 0x000598, "Wrong size on AShooterPracticeGameMode");

// Class HLL.Army
// 0x0030 (0x0260 - 0x0230)
class UArmy : public UUserWidget
{
public:
	class UArmyCommanderRole*                     CommanderRole;                                     // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatoonList*                           Infantry;                                          // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatoonList*                           Armor;                                             // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatoonList*                           Recon;                                             // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CommanderText;                                     // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReadOnly : 1;                                     // 0x0258(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FFC[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OverrideCommanderTextFromPlayerState() const;
	void OverrideCommanderTextFromPlayerTeam(const ETeam PlayerTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Army">();
	}
	static class UArmy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmy>();
	}
};
static_assert(alignof(UArmy) == 0x000008, "Wrong alignment on UArmy");
static_assert(sizeof(UArmy) == 0x000260, "Wrong size on UArmy");
static_assert(offsetof(UArmy, CommanderRole) == 0x000230, "Member 'UArmy::CommanderRole' has a wrong offset!");
static_assert(offsetof(UArmy, Infantry) == 0x000238, "Member 'UArmy::Infantry' has a wrong offset!");
static_assert(offsetof(UArmy, Armor) == 0x000240, "Member 'UArmy::Armor' has a wrong offset!");
static_assert(offsetof(UArmy, Recon) == 0x000248, "Member 'UArmy::Recon' has a wrong offset!");
static_assert(offsetof(UArmy, CommanderText) == 0x000250, "Member 'UArmy::CommanderText' has a wrong offset!");

// Class HLL.ClientBotGrenadeInputComponent
// 0x0000 (0x0148 - 0x0148)
class UClientBotGrenadeInputComponent final : public UClientBotInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotGrenadeInputComponent">();
	}
	static class UClientBotGrenadeInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotGrenadeInputComponent>();
	}
};
static_assert(alignof(UClientBotGrenadeInputComponent) == 0x000008, "Wrong alignment on UClientBotGrenadeInputComponent");
static_assert(sizeof(UClientBotGrenadeInputComponent) == 0x000148, "Wrong size on UClientBotGrenadeInputComponent");

// Class HLL.TankSeatBase
// 0x0000 (0x09D0 - 0x09D0)
class ATankSeatBase : public AVehicleSeatBase
{
public:
	uint8                                         bOnlyAllowArmourUnitsIn : 1;                       // 0x09C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FFD[0x7];                                      // 0x09C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankSeatBase">();
	}
	static class ATankSeatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATankSeatBase>();
	}
};
static_assert(alignof(ATankSeatBase) == 0x000010, "Wrong alignment on ATankSeatBase");
static_assert(sizeof(ATankSeatBase) == 0x0009D0, "Wrong size on ATankSeatBase");

// Class HLL.TankGunnerSeat
// 0x0020 (0x09F0 - 0x09D0)
class ATankGunnerSeat final : public ATankSeatBase
{
public:
	uint8                                         Pad_FFE[0x9];                                      // 0x09D0(0x0009)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bCanPrecisionAim;                                  // 0x09D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FFF[0x2];                                      // 0x09DA(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SlowPitchMultiplier;                               // 0x09DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowYawMultiplier;                                 // 0x09E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1000[0xC];                                     // 0x09E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Server_UpdateTurretRotation(const struct FPitchYawControllerTargetRotationValues& TargetRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankGunnerSeat">();
	}
	static class ATankGunnerSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATankGunnerSeat>();
	}
};
static_assert(alignof(ATankGunnerSeat) == 0x000010, "Wrong alignment on ATankGunnerSeat");
static_assert(sizeof(ATankGunnerSeat) == 0x0009F0, "Wrong size on ATankGunnerSeat");
static_assert(offsetof(ATankGunnerSeat, bCanPrecisionAim) == 0x0009D9, "Member 'ATankGunnerSeat::bCanPrecisionAim' has a wrong offset!");
static_assert(offsetof(ATankGunnerSeat, SlowPitchMultiplier) == 0x0009DC, "Member 'ATankGunnerSeat::SlowPitchMultiplier' has a wrong offset!");
static_assert(offsetof(ATankGunnerSeat, SlowYawMultiplier) == 0x0009E0, "Member 'ATankGunnerSeat::SlowYawMultiplier' has a wrong offset!");

// Class HLL.AnimationTestSpawner
// 0x0008 (0x0228 - 0x0220)
class AAnimationTestSpawner final : public AActor
{
public:
	bool                                          bSpawnOnBegin;                                     // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMergeMeshes;                                      // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1001[0x6];                                     // 0x0222(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationTestSpawner">();
	}
	static class AAnimationTestSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnimationTestSpawner>();
	}
};
static_assert(alignof(AAnimationTestSpawner) == 0x000008, "Wrong alignment on AAnimationTestSpawner");
static_assert(sizeof(AAnimationTestSpawner) == 0x000228, "Wrong size on AAnimationTestSpawner");
static_assert(offsetof(AAnimationTestSpawner, bSpawnOnBegin) == 0x000220, "Member 'AAnimationTestSpawner::bSpawnOnBegin' has a wrong offset!");
static_assert(offsetof(AAnimationTestSpawner, bMergeMeshes) == 0x000221, "Member 'AAnimationTestSpawner::bMergeMeshes' has a wrong offset!");

// Class HLL.ClientBotPlayerInputComponent
// 0x0000 (0x0148 - 0x0148)
class UClientBotPlayerInputComponent final : public UClientBotInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotPlayerInputComponent">();
	}
	static class UClientBotPlayerInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotPlayerInputComponent>();
	}
};
static_assert(alignof(UClientBotPlayerInputComponent) == 0x000008, "Wrong alignment on UClientBotPlayerInputComponent");
static_assert(sizeof(UClientBotPlayerInputComponent) == 0x000148, "Wrong size on UClientBotPlayerInputComponent");

// Class HLL.HLLMapIcon_ControlPoint
// 0x01D0 (0x0538 - 0x0368)
class UHLLMapIcon_ControlPoint final : public UHLLMapIconBase
{
public:
	class UTextBlock*                             ObjectiveNameText;                                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBanner;                                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressFadeEnemy;                                 // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressFadeFriendly;                              // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BannerImage;                                       // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SoftCapturePointScaleBox;                          // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               HardCapturePointScaleBox;                          // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            OffensiveIcon;                                     // 0x03A0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DefensiveIcon;                                     // 0x0428(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ControlPointLockedIcon;                            // 0x04B0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_ControlPoint">();
	}
	static class UHLLMapIcon_ControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_ControlPoint>();
	}
};
static_assert(alignof(UHLLMapIcon_ControlPoint) == 0x000008, "Wrong alignment on UHLLMapIcon_ControlPoint");
static_assert(sizeof(UHLLMapIcon_ControlPoint) == 0x000538, "Wrong size on UHLLMapIcon_ControlPoint");
static_assert(offsetof(UHLLMapIcon_ControlPoint, ObjectiveNameText) == 0x000368, "Member 'UHLLMapIcon_ControlPoint::ObjectiveNameText' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, ProgressBanner) == 0x000370, "Member 'UHLLMapIcon_ControlPoint::ProgressBanner' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, ProgressFadeEnemy) == 0x000378, "Member 'UHLLMapIcon_ControlPoint::ProgressFadeEnemy' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, ProgressFadeFriendly) == 0x000380, "Member 'UHLLMapIcon_ControlPoint::ProgressFadeFriendly' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, BannerImage) == 0x000388, "Member 'UHLLMapIcon_ControlPoint::BannerImage' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, SoftCapturePointScaleBox) == 0x000390, "Member 'UHLLMapIcon_ControlPoint::SoftCapturePointScaleBox' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, HardCapturePointScaleBox) == 0x000398, "Member 'UHLLMapIcon_ControlPoint::HardCapturePointScaleBox' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, OffensiveIcon) == 0x0003A0, "Member 'UHLLMapIcon_ControlPoint::OffensiveIcon' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, DefensiveIcon) == 0x000428, "Member 'UHLLMapIcon_ControlPoint::DefensiveIcon' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ControlPoint, ControlPointLockedIcon) == 0x0004B0, "Member 'UHLLMapIcon_ControlPoint::ControlPointLockedIcon' has a wrong offset!");

// Class HLL.AnimInstance_Weapon_Revolver
// 0x0060 (0x02D0 - 0x0270)
class UAnimInstance_Weapon_Revolver final : public UAnimInstance
{
public:
	uint8                                         Pad_1002[0x28];                                    // 0x0270(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CylinderRotationSpeed;                             // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAngleStep;                                 // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultAmmoCount;                                  // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCylinderAngle;                              // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  CartridgeReloaded;                                 // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 CartridgeScale;                                    // 0x02B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCylinderAngle;                              // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1003[0x4];                                     // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void NativeOnCartridgeReload();
	void NativeOnFire();
	void NativeOnReloadStarted();
	void NativeOnReloadStopped();
	void NativeOnRotateBulletCase();
	void OnCartridgeReload();
	void OnFire();
	void OnReloadStarted();
	void OnReloadStopped();
	void OnRotateBulletCase();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstance_Weapon_Revolver">();
	}
	static class UAnimInstance_Weapon_Revolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstance_Weapon_Revolver>();
	}
};
static_assert(alignof(UAnimInstance_Weapon_Revolver) == 0x000010, "Wrong alignment on UAnimInstance_Weapon_Revolver");
static_assert(sizeof(UAnimInstance_Weapon_Revolver) == 0x0002D0, "Wrong size on UAnimInstance_Weapon_Revolver");
static_assert(offsetof(UAnimInstance_Weapon_Revolver, CylinderRotationSpeed) == 0x000298, "Member 'UAnimInstance_Weapon_Revolver::CylinderRotationSpeed' has a wrong offset!");
static_assert(offsetof(UAnimInstance_Weapon_Revolver, RotationAngleStep) == 0x00029C, "Member 'UAnimInstance_Weapon_Revolver::RotationAngleStep' has a wrong offset!");
static_assert(offsetof(UAnimInstance_Weapon_Revolver, DefaultAmmoCount) == 0x0002A0, "Member 'UAnimInstance_Weapon_Revolver::DefaultAmmoCount' has a wrong offset!");
static_assert(offsetof(UAnimInstance_Weapon_Revolver, DefaultCylinderAngle) == 0x0002A4, "Member 'UAnimInstance_Weapon_Revolver::DefaultCylinderAngle' has a wrong offset!");
static_assert(offsetof(UAnimInstance_Weapon_Revolver, CartridgeReloaded) == 0x0002A8, "Member 'UAnimInstance_Weapon_Revolver::CartridgeReloaded' has a wrong offset!");
static_assert(offsetof(UAnimInstance_Weapon_Revolver, CartridgeScale) == 0x0002B8, "Member 'UAnimInstance_Weapon_Revolver::CartridgeScale' has a wrong offset!");
static_assert(offsetof(UAnimInstance_Weapon_Revolver, CurrentCylinderAngle) == 0x0002C8, "Member 'UAnimInstance_Weapon_Revolver::CurrentCylinderAngle' has a wrong offset!");

// Class HLL.HLLDismemberData
// 0x0038 (0x0068 - 0x0030)
class UHLLDismemberData final : public UDataAsset
{
public:
	class USkeletalMesh*                          GoreMesh;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          GoreMeshPhysicsAsset;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   COMBoneName;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         COMImpulseScale;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1004[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundCue*                              TearSound;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHLLBreakableJointData>         BreakableJoints;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDismemberData">();
	}
	static class UHLLDismemberData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDismemberData>();
	}
};
static_assert(alignof(UHLLDismemberData) == 0x000008, "Wrong alignment on UHLLDismemberData");
static_assert(sizeof(UHLLDismemberData) == 0x000068, "Wrong size on UHLLDismemberData");
static_assert(offsetof(UHLLDismemberData, GoreMesh) == 0x000030, "Member 'UHLLDismemberData::GoreMesh' has a wrong offset!");
static_assert(offsetof(UHLLDismemberData, GoreMeshPhysicsAsset) == 0x000038, "Member 'UHLLDismemberData::GoreMeshPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UHLLDismemberData, COMBoneName) == 0x000040, "Member 'UHLLDismemberData::COMBoneName' has a wrong offset!");
static_assert(offsetof(UHLLDismemberData, COMImpulseScale) == 0x000048, "Member 'UHLLDismemberData::COMImpulseScale' has a wrong offset!");
static_assert(offsetof(UHLLDismemberData, TearSound) == 0x000050, "Member 'UHLLDismemberData::TearSound' has a wrong offset!");
static_assert(offsetof(UHLLDismemberData, BreakableJoints) == 0x000058, "Member 'UHLLDismemberData::BreakableJoints' has a wrong offset!");

// Class HLL.UpgradeStructureAchievement
// 0x0000 (0x0030 - 0x0030)
class UUpgradeStructureAchievement : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradeStructureAchievement">();
	}
	static class UUpgradeStructureAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradeStructureAchievement>();
	}
};
static_assert(alignof(UUpgradeStructureAchievement) == 0x000008, "Wrong alignment on UUpgradeStructureAchievement");
static_assert(sizeof(UUpgradeStructureAchievement) == 0x000030, "Wrong size on UUpgradeStructureAchievement");

// Class HLL.UpgradeBunkerAchievement
// 0x0008 (0x0038 - 0x0030)
class UUpgradeBunkerAchievement final : public UUpgradeStructureAchievement
{
public:
	EHLLAchievement                               Achievement;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1005[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpgradeBunkerAchievement">();
	}
	static class UUpgradeBunkerAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpgradeBunkerAchievement>();
	}
};
static_assert(alignof(UUpgradeBunkerAchievement) == 0x000008, "Wrong alignment on UUpgradeBunkerAchievement");
static_assert(sizeof(UUpgradeBunkerAchievement) == 0x000038, "Wrong size on UUpgradeBunkerAchievement");
static_assert(offsetof(UUpgradeBunkerAchievement, Achievement) == 0x000030, "Member 'UUpgradeBunkerAchievement::Achievement' has a wrong offset!");

// Class HLL.AntiCheatPlayerComponent
// 0x0008 (0x00B8 - 0x00B0)
class UAntiCheatPlayerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_1006[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ServerSendMessageToServer(const TArray<uint8>& Message);

	void ClientSendMessageToClient(const TArray<uint8>& Message) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntiCheatPlayerComponent">();
	}
	static class UAntiCheatPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAntiCheatPlayerComponent>();
	}
};
static_assert(alignof(UAntiCheatPlayerComponent) == 0x000008, "Wrong alignment on UAntiCheatPlayerComponent");
static_assert(sizeof(UAntiCheatPlayerComponent) == 0x0000B8, "Wrong size on UAntiCheatPlayerComponent");

// Class HLL.HLLRoundSummary
// 0x00B8 (0x02E8 - 0x0230)
class UHLLRoundSummary : public UUserWidget
{
public:
	EMatchFinaleState                             FinaleState;                                       // 0x0230(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1007[0x3];                                     // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLMatchEndInfo                       CachedMatchInfo;                                   // 0x0234(0x0014)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_InitialMatchEnd;                              // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_SwitchPage;                                   // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_MatchTimerOvertimeLoop;                       // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1008[0x8];                                     // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             WinTeamText;                                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinStateText;                                      // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MatchTimeText;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 WinTeamBackground;                                 // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLRoundSummaryTeam*                   LeftTeam;                                          // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLRoundSummaryTeam*                   RightTeam;                                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        ContentSwitcher;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             ScoreboardSlot;                                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLRoundSummaryDetails*                Scoreboard;                                        // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLRoundSummaryProgression> ProgressionClass;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             ProgressionSlot;                                   // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLRoundSummaryProgression*            Progression;                                       // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              MusicDuckMix;                                      // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerNameText;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ModeAndMapText;                                    // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         MatchEndAC;                                        // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnUserSettingsUIUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoundSummary">();
	}
	static class UHLLRoundSummary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoundSummary>();
	}
};
static_assert(alignof(UHLLRoundSummary) == 0x000008, "Wrong alignment on UHLLRoundSummary");
static_assert(sizeof(UHLLRoundSummary) == 0x0002E8, "Wrong size on UHLLRoundSummary");
static_assert(offsetof(UHLLRoundSummary, FinaleState) == 0x000230, "Member 'UHLLRoundSummary::FinaleState' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, CachedMatchInfo) == 0x000234, "Member 'UHLLRoundSummary::CachedMatchInfo' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, Anim_InitialMatchEnd) == 0x000248, "Member 'UHLLRoundSummary::Anim_InitialMatchEnd' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, Anim_SwitchPage) == 0x000250, "Member 'UHLLRoundSummary::Anim_SwitchPage' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, Anim_MatchTimerOvertimeLoop) == 0x000258, "Member 'UHLLRoundSummary::Anim_MatchTimerOvertimeLoop' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, WinTeamText) == 0x000268, "Member 'UHLLRoundSummary::WinTeamText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, WinStateText) == 0x000270, "Member 'UHLLRoundSummary::WinStateText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, MatchTimeText) == 0x000278, "Member 'UHLLRoundSummary::MatchTimeText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, WinTeamBackground) == 0x000280, "Member 'UHLLRoundSummary::WinTeamBackground' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, LeftTeam) == 0x000288, "Member 'UHLLRoundSummary::LeftTeam' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, RightTeam) == 0x000290, "Member 'UHLLRoundSummary::RightTeam' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, ContentSwitcher) == 0x000298, "Member 'UHLLRoundSummary::ContentSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, ScoreboardSlot) == 0x0002A0, "Member 'UHLLRoundSummary::ScoreboardSlot' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, Scoreboard) == 0x0002A8, "Member 'UHLLRoundSummary::Scoreboard' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, ProgressionClass) == 0x0002B0, "Member 'UHLLRoundSummary::ProgressionClass' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, ProgressionSlot) == 0x0002B8, "Member 'UHLLRoundSummary::ProgressionSlot' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, Progression) == 0x0002C0, "Member 'UHLLRoundSummary::Progression' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, MusicDuckMix) == 0x0002C8, "Member 'UHLLRoundSummary::MusicDuckMix' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, ServerNameText) == 0x0002D0, "Member 'UHLLRoundSummary::ServerNameText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, ModeAndMapText) == 0x0002D8, "Member 'UHLLRoundSummary::ModeAndMapText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummary, MatchEndAC) == 0x0002E0, "Member 'UHLLRoundSummary::MatchEndAC' has a wrong offset!");

// Class HLL.ClientBotProcessor_ToggleAction
// 0x0018 (0x0048 - 0x0030)
class UClientBotProcessor_ToggleAction final : public UClientBotProcessor
{
public:
	uint8                                         Pad_1009[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor_ToggleAction">();
	}
	static class UClientBotProcessor_ToggleAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor_ToggleAction>();
	}
};
static_assert(alignof(UClientBotProcessor_ToggleAction) == 0x000008, "Wrong alignment on UClientBotProcessor_ToggleAction");
static_assert(sizeof(UClientBotProcessor_ToggleAction) == 0x000048, "Wrong size on UClientBotProcessor_ToggleAction");

// Class HLL.HLLIndicatorBase
// 0x0080 (0x02B0 - 0x0230)
class UHLLIndicatorBase : public UUserWidget
{
public:
	float                                         ViewDistance;                                      // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyViewDistance;                                 // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalOffset;                                    // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           EnemyTint;                                         // 0x023C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              IconAlignment;                                     // 0x024C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bFadeWithHUD : 1;                                  // 0x0254(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScaleOverDistance : 1;                            // 0x0254(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCustomColourise : 1;                              // 0x0254(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowEnemy : 1;                                    // 0x0254(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowEnemyInAdminCamera : 1;                       // 0x0254(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHideWhenAimedAt : 1;                              // 0x0254(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOnlyHideInADS : 1;                                // 0x0254(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_100A[0x3];                                     // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         ZPriority;                                         // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleTolerance;                                    // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableOcclusionTest : 1;                          // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ECollisionChannel                             OcclusionTraceChannel;                             // 0x0261(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100B[0x2];                                     // 0x0262(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class UHLLIndicatorComponent>  AssignedComponent;                                 // 0x0264(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100C[0x4];                                     // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 Icon;                                              // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100D[0x38];                                    // 0x0278(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLIndicatorBase">();
	}
	static class UHLLIndicatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLIndicatorBase>();
	}
};
static_assert(alignof(UHLLIndicatorBase) == 0x000008, "Wrong alignment on UHLLIndicatorBase");
static_assert(sizeof(UHLLIndicatorBase) == 0x0002B0, "Wrong size on UHLLIndicatorBase");
static_assert(offsetof(UHLLIndicatorBase, ViewDistance) == 0x000230, "Member 'UHLLIndicatorBase::ViewDistance' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, EnemyViewDistance) == 0x000234, "Member 'UHLLIndicatorBase::EnemyViewDistance' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, VerticalOffset) == 0x000238, "Member 'UHLLIndicatorBase::VerticalOffset' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, EnemyTint) == 0x00023C, "Member 'UHLLIndicatorBase::EnemyTint' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, IconAlignment) == 0x00024C, "Member 'UHLLIndicatorBase::IconAlignment' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, ZPriority) == 0x000258, "Member 'UHLLIndicatorBase::ZPriority' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, AngleTolerance) == 0x00025C, "Member 'UHLLIndicatorBase::AngleTolerance' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, OcclusionTraceChannel) == 0x000261, "Member 'UHLLIndicatorBase::OcclusionTraceChannel' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, AssignedComponent) == 0x000264, "Member 'UHLLIndicatorBase::AssignedComponent' has a wrong offset!");
static_assert(offsetof(UHLLIndicatorBase, Icon) == 0x000270, "Member 'UHLLIndicatorBase::Icon' has a wrong offset!");

// Class HLL.HLLMedicIndicator
// 0x0010 (0x02C0 - 0x02B0)
class UHLLMedicIndicator : public UHLLIndicatorBase
{
public:
	class UTextBlock*                             DistanceText;                                      // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerName;                                        // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMedicIndicator">();
	}
	static class UHLLMedicIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMedicIndicator>();
	}
};
static_assert(alignof(UHLLMedicIndicator) == 0x000008, "Wrong alignment on UHLLMedicIndicator");
static_assert(sizeof(UHLLMedicIndicator) == 0x0002C0, "Wrong size on UHLLMedicIndicator");
static_assert(offsetof(UHLLMedicIndicator, DistanceText) == 0x0002B0, "Member 'UHLLMedicIndicator::DistanceText' has a wrong offset!");
static_assert(offsetof(UHLLMedicIndicator, PlayerName) == 0x0002B8, "Member 'UHLLMedicIndicator::PlayerName' has a wrong offset!");

// Class HLL.AntiCheatSubsystem
// 0x0008 (0x0038 - 0x0030)
class UAntiCheatSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_100E[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntiCheatSubsystem">();
	}
	static class UAntiCheatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAntiCheatSubsystem>();
	}
};
static_assert(alignof(UAntiCheatSubsystem) == 0x000008, "Wrong alignment on UAntiCheatSubsystem");
static_assert(sizeof(UAntiCheatSubsystem) == 0x000038, "Wrong size on UAntiCheatSubsystem");

// Class HLL.ClientBotProcessor_Move
// 0x0030 (0x0060 - 0x0030)
class UClientBotProcessor_Move final : public UClientBotProcessor
{
public:
	uint8                                         Pad_100F[0x30];                                    // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor_Move">();
	}
	static class UClientBotProcessor_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor_Move>();
	}
};
static_assert(alignof(UClientBotProcessor_Move) == 0x000008, "Wrong alignment on UClientBotProcessor_Move");
static_assert(sizeof(UClientBotProcessor_Move) == 0x000060, "Wrong size on UClientBotProcessor_Move");

// Class HLL.HLLMapIcon_Player
// 0x0040 (0x03A8 - 0x0368)
class UHLLMapIcon_Player : public UHLLMapIconBase
{
public:
	uint8                                         bIsHighlighted : 1;                                // 0x0368(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1010[0xF];                                     // 0x0369(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetAnimation*                       PlayerPingAnimation;                               // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       HighlightAnimation;                                // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlatoonID;                                         // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon_Star;                                         // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LocalPlayerFOV;                                    // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                RotationContainer;                                 // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Player">();
	}
	static class UHLLMapIcon_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Player>();
	}
};
static_assert(alignof(UHLLMapIcon_Player) == 0x000008, "Wrong alignment on UHLLMapIcon_Player");
static_assert(sizeof(UHLLMapIcon_Player) == 0x0003A8, "Wrong size on UHLLMapIcon_Player");
static_assert(offsetof(UHLLMapIcon_Player, PlayerPingAnimation) == 0x000378, "Member 'UHLLMapIcon_Player::PlayerPingAnimation' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Player, HighlightAnimation) == 0x000380, "Member 'UHLLMapIcon_Player::HighlightAnimation' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Player, PlatoonID) == 0x000388, "Member 'UHLLMapIcon_Player::PlatoonID' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Player, Icon_Star) == 0x000390, "Member 'UHLLMapIcon_Player::Icon_Star' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Player, LocalPlayerFOV) == 0x000398, "Member 'UHLLMapIcon_Player::LocalPlayerFOV' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Player, RotationContainer) == 0x0003A0, "Member 'UHLLMapIcon_Player::RotationContainer' has a wrong offset!");

// Class HLL.ArmyCommanderRole
// 0x0048 (0x0278 - 0x0230)
class UArmyCommanderRole : public UUserWidget
{
public:
	uint8                                         bReadOnly : 1;                                     // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1011[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 RoleIcon;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerName;                                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        ButtonSwitcher;                                    // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            ClaimRole;                                         // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            ReleaseRole;                                       // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   CommanderText;                                     // 0x0260(0x0018)(NativeAccessSpecifierPrivate)

public:
	class UUserWidget* GetClaimRoleButton();
	class UUserWidget* GetReleaseRoleButton();
	void OnClaimRoleClicked();
	void OnCommanderAvaliabilityChanged(bool Available);
	void OnReleaseRoleClicked();

	class FText GetCommanderNameText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmyCommanderRole">();
	}
	static class UArmyCommanderRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmyCommanderRole>();
	}
};
static_assert(alignof(UArmyCommanderRole) == 0x000008, "Wrong alignment on UArmyCommanderRole");
static_assert(sizeof(UArmyCommanderRole) == 0x000278, "Wrong size on UArmyCommanderRole");
static_assert(offsetof(UArmyCommanderRole, RoleIcon) == 0x000238, "Member 'UArmyCommanderRole::RoleIcon' has a wrong offset!");
static_assert(offsetof(UArmyCommanderRole, PlayerName) == 0x000240, "Member 'UArmyCommanderRole::PlayerName' has a wrong offset!");
static_assert(offsetof(UArmyCommanderRole, ButtonSwitcher) == 0x000248, "Member 'UArmyCommanderRole::ButtonSwitcher' has a wrong offset!");
static_assert(offsetof(UArmyCommanderRole, ClaimRole) == 0x000250, "Member 'UArmyCommanderRole::ClaimRole' has a wrong offset!");
static_assert(offsetof(UArmyCommanderRole, ReleaseRole) == 0x000258, "Member 'UArmyCommanderRole::ReleaseRole' has a wrong offset!");
static_assert(offsetof(UArmyCommanderRole, CommanderText) == 0x000260, "Member 'UArmyCommanderRole::CommanderText' has a wrong offset!");

// Class HLL.HLLSeatWidgetBase
// 0x0040 (0x0270 - 0x0230)
class UHLLSeatWidgetBase : public UUserWidget
{
public:
	class AHLLSeat*                               Seat;                                              // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLSeatIcon>               IconWidgetClass;                                   // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLSeatIcon*>                   ActiveSeatIcons;                                   // 0x0240(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           SeatIconVBox;                                      // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ZoomOverlay;                                       // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSeatHealthStatus*                   HealthStatusPanel;                                 // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1012[0x8];                                     // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitInventoryInfo(const class UHLLArmourInventory* InInventory);
	void InitWeaponInfo(class AHLLSeat* InSeat);
	void OnSeatSet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatWidgetBase">();
	}
	static class UHLLSeatWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSeatWidgetBase>();
	}
};
static_assert(alignof(UHLLSeatWidgetBase) == 0x000008, "Wrong alignment on UHLLSeatWidgetBase");
static_assert(sizeof(UHLLSeatWidgetBase) == 0x000270, "Wrong size on UHLLSeatWidgetBase");
static_assert(offsetof(UHLLSeatWidgetBase, Seat) == 0x000230, "Member 'UHLLSeatWidgetBase::Seat' has a wrong offset!");
static_assert(offsetof(UHLLSeatWidgetBase, IconWidgetClass) == 0x000238, "Member 'UHLLSeatWidgetBase::IconWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLSeatWidgetBase, ActiveSeatIcons) == 0x000240, "Member 'UHLLSeatWidgetBase::ActiveSeatIcons' has a wrong offset!");
static_assert(offsetof(UHLLSeatWidgetBase, SeatIconVBox) == 0x000250, "Member 'UHLLSeatWidgetBase::SeatIconVBox' has a wrong offset!");
static_assert(offsetof(UHLLSeatWidgetBase, ZoomOverlay) == 0x000258, "Member 'UHLLSeatWidgetBase::ZoomOverlay' has a wrong offset!");
static_assert(offsetof(UHLLSeatWidgetBase, HealthStatusPanel) == 0x000260, "Member 'UHLLSeatWidgetBase::HealthStatusPanel' has a wrong offset!");

// Class HLL.HLLTankSeatUI_Base
// 0x0010 (0x0280 - 0x0270)
class UHLLTankSeatUI_Base : public UHLLSeatWidgetBase
{
public:
	class UImage*                                 TankBodyImage;                                     // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TankTurretImage;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLTankSeatUI_Base">();
	}
	static class UHLLTankSeatUI_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLTankSeatUI_Base>();
	}
};
static_assert(alignof(UHLLTankSeatUI_Base) == 0x000008, "Wrong alignment on UHLLTankSeatUI_Base");
static_assert(sizeof(UHLLTankSeatUI_Base) == 0x000280, "Wrong size on UHLLTankSeatUI_Base");
static_assert(offsetof(UHLLTankSeatUI_Base, TankBodyImage) == 0x000270, "Member 'UHLLTankSeatUI_Base::TankBodyImage' has a wrong offset!");
static_assert(offsetof(UHLLTankSeatUI_Base, TankTurretImage) == 0x000278, "Member 'UHLLTankSeatUI_Base::TankTurretImage' has a wrong offset!");

// Class HLL.TankGunnerSeatUI
// 0x0050 (0x02D0 - 0x0280)
class UTankGunnerSeatUI : public UHLLTankSeatUI_Base
{
public:
	class UHLLArmourWeaponUI*                     PrimaryWeaponInfo;                                 // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourWeaponUI*                     SecondaryWeaponInfo;                               // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         ZoomKeyText;                                       // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         PrecisionKeyText;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                MuzzleOcclusion;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1013[0x28];                                    // 0x02A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankGunnerSeatUI">();
	}
	static class UTankGunnerSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTankGunnerSeatUI>();
	}
};
static_assert(alignof(UTankGunnerSeatUI) == 0x000008, "Wrong alignment on UTankGunnerSeatUI");
static_assert(sizeof(UTankGunnerSeatUI) == 0x0002D0, "Wrong size on UTankGunnerSeatUI");
static_assert(offsetof(UTankGunnerSeatUI, PrimaryWeaponInfo) == 0x000280, "Member 'UTankGunnerSeatUI::PrimaryWeaponInfo' has a wrong offset!");
static_assert(offsetof(UTankGunnerSeatUI, SecondaryWeaponInfo) == 0x000288, "Member 'UTankGunnerSeatUI::SecondaryWeaponInfo' has a wrong offset!");
static_assert(offsetof(UTankGunnerSeatUI, ZoomKeyText) == 0x000290, "Member 'UTankGunnerSeatUI::ZoomKeyText' has a wrong offset!");
static_assert(offsetof(UTankGunnerSeatUI, PrecisionKeyText) == 0x000298, "Member 'UTankGunnerSeatUI::PrecisionKeyText' has a wrong offset!");
static_assert(offsetof(UTankGunnerSeatUI, MuzzleOcclusion) == 0x0002A0, "Member 'UTankGunnerSeatUI::MuzzleOcclusion' has a wrong offset!");

// Class HLL.HLLGunnerUI_SPAHowitzer
// 0x0040 (0x0310 - 0x02D0)
class UHLLGunnerUI_SPAHowitzer final : public UTankGunnerSeatUI
{
public:
	int32                                         NumRangeEntries;                                   // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1014[0x4];                                     // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLGunnerUI_SPAHowitzerRangeItem> ItemClass;                                         // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLGunnerUI_SPAHowitzerRangeItem*> ItemList;                                          // 0x02E0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1015[0x8];                                     // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UVerticalBox*                           RangeVBox;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TraverseValue;                                     // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ElevationValue;                                    // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGunnerUI_SPAHowitzer">();
	}
	static class UHLLGunnerUI_SPAHowitzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLGunnerUI_SPAHowitzer>();
	}
};
static_assert(alignof(UHLLGunnerUI_SPAHowitzer) == 0x000008, "Wrong alignment on UHLLGunnerUI_SPAHowitzer");
static_assert(sizeof(UHLLGunnerUI_SPAHowitzer) == 0x000310, "Wrong size on UHLLGunnerUI_SPAHowitzer");
static_assert(offsetof(UHLLGunnerUI_SPAHowitzer, NumRangeEntries) == 0x0002D0, "Member 'UHLLGunnerUI_SPAHowitzer::NumRangeEntries' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_SPAHowitzer, ItemClass) == 0x0002D8, "Member 'UHLLGunnerUI_SPAHowitzer::ItemClass' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_SPAHowitzer, ItemList) == 0x0002E0, "Member 'UHLLGunnerUI_SPAHowitzer::ItemList' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_SPAHowitzer, RangeVBox) == 0x0002F8, "Member 'UHLLGunnerUI_SPAHowitzer::RangeVBox' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_SPAHowitzer, TraverseValue) == 0x000300, "Member 'UHLLGunnerUI_SPAHowitzer::TraverseValue' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_SPAHowitzer, ElevationValue) == 0x000308, "Member 'UHLLGunnerUI_SPAHowitzer::ElevationValue' has a wrong offset!");

// Class HLL.VehicleDrop
// 0x00C8 (0x02E8 - 0x0220)
class AVehicleDrop : public AActor
{
public:
	uint8                                         Pad_1016[0x68];                                    // 0x0220(0x0068)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DismantleTime;                                     // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1017[0x4];                                     // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   DisplayName;                                       // 0x0290(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       ImpactFX;                                          // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ObjectMesh;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSimpleHealthComponent*              HealthComponent;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDismantlingComponent*                  DismantlingComponent;                              // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x02D8(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x02D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1018[0x6];                                     // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerState*                    SpawnedByPlayer;                                   // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPhysicsBodyEnteredSleep(class UPrimitiveComponent* SleepingComponent, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleDrop">();
	}
	static class AVehicleDrop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleDrop>();
	}
};
static_assert(alignof(AVehicleDrop) == 0x000008, "Wrong alignment on AVehicleDrop");
static_assert(sizeof(AVehicleDrop) == 0x0002E8, "Wrong size on AVehicleDrop");
static_assert(offsetof(AVehicleDrop, DismantleTime) == 0x000288, "Member 'AVehicleDrop::DismantleTime' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, DisplayName) == 0x000290, "Member 'AVehicleDrop::DisplayName' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, ImpactFX) == 0x0002A8, "Member 'AVehicleDrop::ImpactFX' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, ObjectMesh) == 0x0002B0, "Member 'AVehicleDrop::ObjectMesh' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, IndicatorComponent) == 0x0002B8, "Member 'AVehicleDrop::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, MapComponent) == 0x0002C0, "Member 'AVehicleDrop::MapComponent' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, HealthComponent) == 0x0002C8, "Member 'AVehicleDrop::HealthComponent' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, DismantlingComponent) == 0x0002D0, "Member 'AVehicleDrop::DismantlingComponent' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, Team) == 0x0002D8, "Member 'AVehicleDrop::Team' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, DamageFilterType) == 0x0002D9, "Member 'AVehicleDrop::DamageFilterType' has a wrong offset!");
static_assert(offsetof(AVehicleDrop, SpawnedByPlayer) == 0x0002E0, "Member 'AVehicleDrop::SpawnedByPlayer' has a wrong offset!");

// Class HLL.ClientBotProcessor_NextWeapon
// 0x0000 (0x0030 - 0x0030)
class UClientBotProcessor_NextWeapon final : public UClientBotProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor_NextWeapon">();
	}
	static class UClientBotProcessor_NextWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor_NextWeapon>();
	}
};
static_assert(alignof(UClientBotProcessor_NextWeapon) == 0x000008, "Wrong alignment on UClientBotProcessor_NextWeapon");
static_assert(sizeof(UClientBotProcessor_NextWeapon) == 0x000030, "Wrong size on UClientBotProcessor_NextWeapon");

// Class HLL.ShooterWeapon
// 0x0890 (0x0AB0 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) AShooterWeapon : public AActor
{
public:
	uint8                                         Pad_1019[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	struct FWeaponFPPAnimationParams              FPPAnimationParams;                                // 0x0238(0x00B8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    WeaponMetaData;                                    // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EWeaponType                                   Type;                                              // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101A[0x3];                                     // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   AttachSocketFPP;                                   // 0x0304(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketTPP;                                   // 0x030C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraLagSettings                     AdsCameraLagSettings;                              // 0x0314(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraLagSettings                     HipCameraLagSettings;                              // 0x0330(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_101B[0x4];                                     // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRecoilAndSpread                       RecoilAndSpread;                                   // 0x0350(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FRecoilAndSpread                       RecoilAndSpread_ADS;                               // 0x0380(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FRecoilAndSpreadState                  RecoilAndSpreadState;                              // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	class AShooterCharacter*                      MyPawn;                                            // 0x03B8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWeaponData                            WeaponConfig;                                      // 0x03C0(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_101C[0x4];                                     // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UFpsSkeletalMeshComponent*              Mesh_1P;                                           // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh3P;                                            // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAudioComponent*>                MuzzleAudio;                                       // 0x03F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAudioComponent*>                MuzzleAudioTails;                                  // 0x0408(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101D[0x4];                                     // 0x0418(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   MuzzleAttachPoint;                                 // 0x041C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CasingEjectPoint;                                  // 0x0424(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101E[0x4];                                     // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystem*                        MuzzleFX;                                          // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MuzzleFX_3P;                                       // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLoopedMuzzleFX : 1;                               // 0x0440(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsePointLightMuzzleFlash : 1;                     // 0x0440(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseAdsPointLightMuzzleFlash : 1;                  // 0x0440(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_101F[0x3];                                     // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         PointLightMuzzleFxActiveTime;                      // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointLightComponent*                   MuzzlePointLightFX;                                // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointLightComponent*                   MuzzlePointLightAdsFX;                             // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointLightComponent*                   MuzzlePointLightFX_3P;                             // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        CasingFX;                                          // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        CasingFXTPP;                                       // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CasingScale1P;                                     // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1020[0x4];                                     // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystemComponent*               MuzzlePSC;                                         // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPointLightComponent*>           MuzzleFlashes;                                     // 0x0480(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               FireCameraShake;                                   // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   FireForceFeedback;                                 // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponSoundMode                              FireSoundMode;                                     // 0x04A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxTPPTails;                                       // 0x04A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxFPPTails;                                       // 0x04A2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxSingleFireSounds;                               // 0x04A3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bForceStopFireSound : 1;                           // 0x04A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSendAmmoRatioToFireSound : 1;                     // 0x04A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1021[0x3];                                     // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundCue*                              FireSound;                                         // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LastLoadedBulletFireSound;                         // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              FireTailSound;                                     // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LastLoadedBulletFireTailSound;                     // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              StopFireSound;                                     // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              OutOfAmmoSound;                                    // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              JammedSound;                                       // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              EquipSound;                                        // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              EnterADSSound;                                     // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExitADSSound;                                      // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         EquipAC;                                           // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UWeaponTPPAnimationSet>     TPPAnimationSetClass;                              // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UWeaponFPPAnimationSet>     FPPAnimationSetClass;                              // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArtificialEquipDelay;                              // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1022[0x4];                                     // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UWeaponBehindBackComponent*             BehindBackComponent;                               // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLoopedFireAnim : 1;                               // 0x0520(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1023[0x7];                                     // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterWeaponEject>        EjectedClipActorClass;                             // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ClipEjectionSocket;                                // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClipEjectionSpeed1P;                               // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClipEjectionSpeed3P;                               // 0x053C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEjectEmptyClip : 1;                               // 0x0540(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_42 : 7;                                     // 0x0040(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-69 ])
	uint8                                         Pad_1024[0x1B];                                    // 0x0541(0x001B)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         BitPad_43 : 1;                                     // 0x055C(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-69 ])
	uint8                                         bPendingReload : 1;                                // 0x055C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1025[0xF];                                     // 0x055D(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	EWeaponState                                  CurrentState;                                      // 0x056C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1026[0xF];                                     // 0x056D(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         MaxClips;                                          // 0x057C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1027[0x1];                                     // 0x057D(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	struct FWeaponAmmoInfo                        CurrentAmmoInfo;                                   // 0x057E(0x0004)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponClipInfo                        CurrentClipInfo;                                   // 0x0582(0x0003)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHLLWeaponBurstInfo                    BurstCounter;                                      // 0x0585(0x0004)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1028[0x6F];                                    // 0x0589(0x006F)(Fixing Size After Last Property [ Dumper-69 ])
	struct FWeaponADSInfo                         ADSInfo;                                           // 0x05F8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1029[0x10];                                    // 0x0688(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         CurrentZoomIndex;                                  // 0x0698(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPendingBoltCycle : 1;                             // 0x069C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_102A[0x1B];                                    // 0x069D(0x001B)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLWeaponDOFSettings                  HipSettings;                                       // 0x06B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHLLWeaponDOFSettings                  ADSSettings;                                       // 0x06D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         OverheatRatio;                                     // 0x06F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOverheatLocked : 1;                               // 0x06FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_102B[0xB];                                     // 0x06FD(0x000B)(Fixing Size After Last Property [ Dumper-69 ])
	struct FWeaponOverheatData                    OverheatConfig;                                    // 0x0708(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRepOverheatData                       PackedOverheatData;                                // 0x0730(0x0002)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_102C[0x6];                                     // 0x0732(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystemComponent*               OverheatPSC;                                       // 0x0738(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_102D[0x10];                                    // 0x0740(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRepMountableData                      DeployData;                                        // 0x0750(0x0050)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         RemoteBipodYaw;                                    // 0x07A0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_102E[0x7];                                     // 0x07A1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FMountableWeaponConfig                 MountableConfig;                                   // 0x07A8(0x0240)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_102F[0x8];                                     // 0x09E8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bForceNotifyClientOnShotFailure : 1;               // 0x09F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1030[0xF];                                     // 0x09F1(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	EWeaponCasingMode                             WeaponCasingMode;                                  // 0x0A00(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1031[0x7];                                     // 0x0A01(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLWeaponCasingSettings*               BulletCasingSettings;                              // 0x0A08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1032[0x4];                                     // 0x0A10(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bAnimationReloadLock : 1;                          // 0x0A14(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAnimationBoltLock : 1;                            // 0x0A14(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1033[0x3];                                     // 0x0A15(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         BloodAmount;                                       // 0x0A18(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1034[0x4];                                     // 0x0A1C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<EHint>                                   HintsToDisplay;                                    // 0x0A20(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bHideHintsOnUnequip : 1;                           // 0x0A70(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1035[0x3];                                     // 0x0A71(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FAdaptiveTriggerSetting                TriggerSetting;                                    // 0x0A74(0x0014)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UHLLWeaponVibrationData*                WeaponVibrationData;                               // 0x0A88(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLWeaponVibrationData*                SpecialVibrationData;                              // 0x0A90(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              FireVibrationEventController;                      // 0x0A98(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLPlayerStat                                FireIncrementStat;                                 // 0x0AA0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1036[0x7];                                     // 0x0AA1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ActivateMuzzleFlash();
	void Client_DeployFailed();
	void Client_StartDeploy(float AnchorNormalizedHeight);
	void ClientNotifyShotFailed(const struct FWeaponAmmoInfo& ServerCurrentAmmo, const struct FWeaponClipInfo& ServerCurrentClip, const EWeaponState InServerState);
	void ClientStartReload(const uint16 ServerCurrentAmmo, const uint8 ServerAmmoInWeapon);
	void DeactivateMuzzleFlash();
	void OnRep_BurstCounter(const struct FHLLWeaponBurstInfo& OldBurstInfo);
	void OnRep_ClearJam();
	void OnRep_CurrentAmmoInfo(const struct FWeaponAmmoInfo& PreviousAmmoInfo);
	void OnRep_CurrentClipInfo(const struct FWeaponClipInfo& PreviousClipInfo);
	void OnRep_DeployData(const struct FRepMountableData& PreviousData);
	void OnRep_MyPawn();
	void OnRep_OverheatData();
	void OnRep_PendingBoltCycle();
	void OnRep_Reload();
	float PlayWeaponAnimation(const struct FWeaponAnim& Animation, float PlayRate);
	void PopulatePointLightMuzzleFlashes();
	void Server_StartDeploy();
	void Server_StartUnDeploy(const bool bForce, const bool bInstant);
	void ServerAbortReload();
	void ServerCancelReload();
	void ServerStartBoltCycle();
	void ServerStartClearJam();
	void ServerStartFire(const EHLLFireMode FireMode);
	void ServerStartReload();
	void ServerStopFire(const EHLLFireMode FireMode, const bool bReleaseTrigger);
	void SetAnimBoltLock();
	void SetAnimReloadLock();
	void SpawnCartridgeEject();
	void SpawnReloadEject();
	bool StartUnDeploy(const bool bForce, const bool bInstant);
	void StopWeaponAnimation(const struct FWeaponAnim& Animation);

	class FName CanDeploy() const;
	class FName CanUndeploy() const;
	bool FindValidDeploySurface(struct FHitResult* OutSurface, int32* OutQueryIndex) const;
	int32 GetAmmoBeforeReload() const;
	int32 GetAmmoPerClip() const;
	float GetAnimationDuration(class UAnimMontage* Anim, const float PlayRate) const;
	int32 GetCurrentAmmo() const;
	int32 GetCurrentAmmoInClip() const;
	bool GetDeployAnchor(struct FTransform* OutAnchorWS, const bool bLocalOrigin) const;
	EWeaponDeployState GetDeployState() const;
	struct FWeaponFPPAnimationParams GetFPPAnimationParams() const;
	class UWeaponFPPAnimationSet* GetFPPAnimationSet() const;
	int32 GetInitialClips() const;
	int32 GetMaxAmmo() const;
	class AShooterCharacter* GetPawnOwner() const;
	class UWeaponTPPAnimationSet* GetTPPAnimationSet() const;
	class USkeletalMeshComponent* GetWeaponMesh(bool ForceTPPMesh) const;
	bool HasRoundInChamber() const;
	bool IsDeployed() const;
	bool IsDeploySurfaceValid(const struct FHitResult& SurfaceHit, const int32 QueryIndex) const;
	bool IsReloading() const;
	bool IsWeaponTargeting() const;
	void PrintDebugInfo(const float DrawTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon">();
	}
	static class AShooterWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon>();
	}
};
#pragma pack(pop)
static_assert(alignof(AShooterWeapon) == 0x000010, "Wrong alignment on AShooterWeapon");
static_assert(sizeof(AShooterWeapon) == 0x000AB0, "Wrong size on AShooterWeapon");
static_assert(offsetof(AShooterWeapon, FPPAnimationParams) == 0x000238, "Member 'AShooterWeapon::FPPAnimationParams' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, WeaponMetaData) == 0x0002F0, "Member 'AShooterWeapon::WeaponMetaData' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, Type) == 0x000300, "Member 'AShooterWeapon::Type' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, AttachSocketFPP) == 0x000304, "Member 'AShooterWeapon::AttachSocketFPP' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, AttachSocketTPP) == 0x00030C, "Member 'AShooterWeapon::AttachSocketTPP' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, AdsCameraLagSettings) == 0x000314, "Member 'AShooterWeapon::AdsCameraLagSettings' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, HipCameraLagSettings) == 0x000330, "Member 'AShooterWeapon::HipCameraLagSettings' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, RecoilAndSpread) == 0x000350, "Member 'AShooterWeapon::RecoilAndSpread' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, RecoilAndSpread_ADS) == 0x000380, "Member 'AShooterWeapon::RecoilAndSpread_ADS' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, RecoilAndSpreadState) == 0x0003B0, "Member 'AShooterWeapon::RecoilAndSpreadState' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MyPawn) == 0x0003B8, "Member 'AShooterWeapon::MyPawn' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, WeaponConfig) == 0x0003C0, "Member 'AShooterWeapon::WeaponConfig' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, Mesh_1P) == 0x0003E8, "Member 'AShooterWeapon::Mesh_1P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, Mesh3P) == 0x0003F0, "Member 'AShooterWeapon::Mesh3P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzleAudio) == 0x0003F8, "Member 'AShooterWeapon::MuzzleAudio' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzleAudioTails) == 0x000408, "Member 'AShooterWeapon::MuzzleAudioTails' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzleAttachPoint) == 0x00041C, "Member 'AShooterWeapon::MuzzleAttachPoint' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CasingEjectPoint) == 0x000424, "Member 'AShooterWeapon::CasingEjectPoint' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzleFX) == 0x000430, "Member 'AShooterWeapon::MuzzleFX' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzleFX_3P) == 0x000438, "Member 'AShooterWeapon::MuzzleFX_3P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, PointLightMuzzleFxActiveTime) == 0x000444, "Member 'AShooterWeapon::PointLightMuzzleFxActiveTime' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzlePointLightFX) == 0x000448, "Member 'AShooterWeapon::MuzzlePointLightFX' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzlePointLightAdsFX) == 0x000450, "Member 'AShooterWeapon::MuzzlePointLightAdsFX' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzlePointLightFX_3P) == 0x000458, "Member 'AShooterWeapon::MuzzlePointLightFX_3P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CasingFX) == 0x000460, "Member 'AShooterWeapon::CasingFX' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CasingFXTPP) == 0x000468, "Member 'AShooterWeapon::CasingFXTPP' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CasingScale1P) == 0x000470, "Member 'AShooterWeapon::CasingScale1P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzlePSC) == 0x000478, "Member 'AShooterWeapon::MuzzlePSC' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MuzzleFlashes) == 0x000480, "Member 'AShooterWeapon::MuzzleFlashes' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireCameraShake) == 0x000490, "Member 'AShooterWeapon::FireCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireForceFeedback) == 0x000498, "Member 'AShooterWeapon::FireForceFeedback' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireSoundMode) == 0x0004A0, "Member 'AShooterWeapon::FireSoundMode' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MaxTPPTails) == 0x0004A1, "Member 'AShooterWeapon::MaxTPPTails' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MaxFPPTails) == 0x0004A2, "Member 'AShooterWeapon::MaxFPPTails' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MaxSingleFireSounds) == 0x0004A3, "Member 'AShooterWeapon::MaxSingleFireSounds' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireSound) == 0x0004A8, "Member 'AShooterWeapon::FireSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, LastLoadedBulletFireSound) == 0x0004B0, "Member 'AShooterWeapon::LastLoadedBulletFireSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireTailSound) == 0x0004B8, "Member 'AShooterWeapon::FireTailSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, LastLoadedBulletFireTailSound) == 0x0004C0, "Member 'AShooterWeapon::LastLoadedBulletFireTailSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, StopFireSound) == 0x0004C8, "Member 'AShooterWeapon::StopFireSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, OutOfAmmoSound) == 0x0004D0, "Member 'AShooterWeapon::OutOfAmmoSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, JammedSound) == 0x0004D8, "Member 'AShooterWeapon::JammedSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, EquipSound) == 0x0004E0, "Member 'AShooterWeapon::EquipSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, EnterADSSound) == 0x0004E8, "Member 'AShooterWeapon::EnterADSSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ExitADSSound) == 0x0004F0, "Member 'AShooterWeapon::ExitADSSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, EquipAC) == 0x0004F8, "Member 'AShooterWeapon::EquipAC' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, TPPAnimationSetClass) == 0x000500, "Member 'AShooterWeapon::TPPAnimationSetClass' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FPPAnimationSetClass) == 0x000508, "Member 'AShooterWeapon::FPPAnimationSetClass' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ArtificialEquipDelay) == 0x000510, "Member 'AShooterWeapon::ArtificialEquipDelay' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, BehindBackComponent) == 0x000518, "Member 'AShooterWeapon::BehindBackComponent' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, EjectedClipActorClass) == 0x000528, "Member 'AShooterWeapon::EjectedClipActorClass' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ClipEjectionSocket) == 0x000530, "Member 'AShooterWeapon::ClipEjectionSocket' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ClipEjectionSpeed1P) == 0x000538, "Member 'AShooterWeapon::ClipEjectionSpeed1P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ClipEjectionSpeed3P) == 0x00053C, "Member 'AShooterWeapon::ClipEjectionSpeed3P' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CurrentState) == 0x00056C, "Member 'AShooterWeapon::CurrentState' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MaxClips) == 0x00057C, "Member 'AShooterWeapon::MaxClips' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CurrentAmmoInfo) == 0x00057E, "Member 'AShooterWeapon::CurrentAmmoInfo' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CurrentClipInfo) == 0x000582, "Member 'AShooterWeapon::CurrentClipInfo' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, BurstCounter) == 0x000585, "Member 'AShooterWeapon::BurstCounter' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ADSInfo) == 0x0005F8, "Member 'AShooterWeapon::ADSInfo' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, CurrentZoomIndex) == 0x000698, "Member 'AShooterWeapon::CurrentZoomIndex' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, HipSettings) == 0x0006B8, "Member 'AShooterWeapon::HipSettings' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, ADSSettings) == 0x0006D8, "Member 'AShooterWeapon::ADSSettings' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, OverheatRatio) == 0x0006F8, "Member 'AShooterWeapon::OverheatRatio' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, OverheatConfig) == 0x000708, "Member 'AShooterWeapon::OverheatConfig' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, PackedOverheatData) == 0x000730, "Member 'AShooterWeapon::PackedOverheatData' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, OverheatPSC) == 0x000738, "Member 'AShooterWeapon::OverheatPSC' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, DeployData) == 0x000750, "Member 'AShooterWeapon::DeployData' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, RemoteBipodYaw) == 0x0007A0, "Member 'AShooterWeapon::RemoteBipodYaw' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, MountableConfig) == 0x0007A8, "Member 'AShooterWeapon::MountableConfig' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, WeaponCasingMode) == 0x000A00, "Member 'AShooterWeapon::WeaponCasingMode' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, BulletCasingSettings) == 0x000A08, "Member 'AShooterWeapon::BulletCasingSettings' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, BloodAmount) == 0x000A18, "Member 'AShooterWeapon::BloodAmount' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, HintsToDisplay) == 0x000A20, "Member 'AShooterWeapon::HintsToDisplay' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, TriggerSetting) == 0x000A74, "Member 'AShooterWeapon::TriggerSetting' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, WeaponVibrationData) == 0x000A88, "Member 'AShooterWeapon::WeaponVibrationData' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, SpecialVibrationData) == 0x000A90, "Member 'AShooterWeapon::SpecialVibrationData' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireVibrationEventController) == 0x000A98, "Member 'AShooterWeapon::FireVibrationEventController' has a wrong offset!");
static_assert(offsetof(AShooterWeapon, FireIncrementStat) == 0x000AA0, "Member 'AShooterWeapon::FireIncrementStat' has a wrong offset!");

// Class HLL.ShooterWeapon_Ballistic
// 0x0080 (0x0B30 - 0x0AB0)
class AShooterWeapon_Ballistic : public AShooterWeapon
{
public:
	class UHLLBallisticsComponent_Character*      BallisticsComponent;                               // 0x0AA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FZeroAngle>                     ZeroAngles;                                        // 0x0AB0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ZeroAngleIndex;                                    // 0x0AC0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMultiShotWeapon;                                // 0x0AC1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MultiShotCount;                                    // 0x0AC2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_103C[0x5];                                     // 0x0AC3(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FShotOffset>                    MultiShotOffsets;                                  // 0x0AC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBallisticShotID                       WeaponSeed;                                        // 0x0AD8(0x0001)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_103D[0x3];                                     // 0x0AD9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRepShot                               RepShot;                                           // 0x0ADC(0x001C)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_103E[0x38];                                    // 0x0AF8(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_RepShot();
	void OnRep_WeaponSeed();
	void Server_AckBatchedNullHits(const struct FBallisticBatchedNulls& BatchedNulls);
	void Server_AckNullHit(const struct FBallisticShotID& ShotID);
	void Server_FireWeapon(const struct FBallisticShotID& FinalShotID, const struct FVector_NetQuantize& ClientBasePos, const struct FVector_NetQuantizeNormal& ClientBaseDir);
	void Server_FireWeapon_Multishot(const struct FBallisticShotID& FinalShotID, const struct FVector_NetQuantize& ClientBasePos, const struct FVector_NetQuantizeNormal& ClientBaseDir, const struct FVector_NetQuantizeNormal& ClientRightVector);
	void Server_VerifyBatchedHits(const struct FBallisticBatchedHits& BatchedHits);
	void Server_VerifyHitCharacter(const struct FBallisticHit_Character& HitData);
	void Server_VerifyHitGeneric(const struct FBallisticHit_Generic& HitData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Ballistic">();
	}
	static class AShooterWeapon_Ballistic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Ballistic>();
	}
};
static_assert(alignof(AShooterWeapon_Ballistic) == 0x000010, "Wrong alignment on AShooterWeapon_Ballistic");
static_assert(sizeof(AShooterWeapon_Ballistic) == 0x000B30, "Wrong size on AShooterWeapon_Ballistic");
static_assert(offsetof(AShooterWeapon_Ballistic, BallisticsComponent) == 0x000AA8, "Member 'AShooterWeapon_Ballistic::BallisticsComponent' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Ballistic, ZeroAngles) == 0x000AB0, "Member 'AShooterWeapon_Ballistic::ZeroAngles' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Ballistic, ZeroAngleIndex) == 0x000AC0, "Member 'AShooterWeapon_Ballistic::ZeroAngleIndex' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Ballistic, bIsMultiShotWeapon) == 0x000AC1, "Member 'AShooterWeapon_Ballistic::bIsMultiShotWeapon' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Ballistic, MultiShotCount) == 0x000AC2, "Member 'AShooterWeapon_Ballistic::MultiShotCount' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Ballistic, MultiShotOffsets) == 0x000AC8, "Member 'AShooterWeapon_Ballistic::MultiShotOffsets' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Ballistic, WeaponSeed) == 0x000AD8, "Member 'AShooterWeapon_Ballistic::WeaponSeed' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Ballistic, RepShot) == 0x000ADC, "Member 'AShooterWeapon_Ballistic::RepShot' has a wrong offset!");

// Class HLL.ArmyLogo
// 0x0018 (0x0248 - 0x0230)
class UArmyLogo : public UUserWidget
{
public:
	class UImage*                                 ArmyIcon;                                          // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ArmyName;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1041[0x8];                                     // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmyLogo">();
	}
	static class UArmyLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmyLogo>();
	}
};
static_assert(alignof(UArmyLogo) == 0x000008, "Wrong alignment on UArmyLogo");
static_assert(sizeof(UArmyLogo) == 0x000248, "Wrong size on UArmyLogo");
static_assert(offsetof(UArmyLogo, ArmyIcon) == 0x000230, "Member 'UArmyLogo::ArmyIcon' has a wrong offset!");
static_assert(offsetof(UArmyLogo, ArmyName) == 0x000238, "Member 'UArmyLogo::ArmyName' has a wrong offset!");

// Class HLL.HLLRoleProgressionItem
// 0x00E0 (0x0310 - 0x0230)
class UHLLRoleProgressionItem : public UUserWidget
{
public:
	float                                         CountTime;                                         // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1042[0x4];                                     // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateSound                            PromotedSound;                                     // 0x0238(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            LoopCountSound;                                    // 0x0250(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            StopCountSound;                                    // 0x0268(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EPlayerRole                                   Role;                                              // 0x0280(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1043[0x7];                                     // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetAnimation*                       Anim_FinishCount;                                  // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Promoted;                                     // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Show;                                         // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RoleText;                                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RoleLevelText;                                     // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RoleIcon;                                          // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           InitialBar;                                        // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           UpdateBar;                                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ExpText;                                           // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         CounterLoopingAC;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1044[0x38];                                    // 0x02D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool HasFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoleProgressionItem">();
	}
	static class UHLLRoleProgressionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoleProgressionItem>();
	}
};
static_assert(alignof(UHLLRoleProgressionItem) == 0x000008, "Wrong alignment on UHLLRoleProgressionItem");
static_assert(sizeof(UHLLRoleProgressionItem) == 0x000310, "Wrong size on UHLLRoleProgressionItem");
static_assert(offsetof(UHLLRoleProgressionItem, CountTime) == 0x000230, "Member 'UHLLRoleProgressionItem::CountTime' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, PromotedSound) == 0x000238, "Member 'UHLLRoleProgressionItem::PromotedSound' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, LoopCountSound) == 0x000250, "Member 'UHLLRoleProgressionItem::LoopCountSound' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, StopCountSound) == 0x000268, "Member 'UHLLRoleProgressionItem::StopCountSound' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, Role) == 0x000280, "Member 'UHLLRoleProgressionItem::Role' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, Anim_FinishCount) == 0x000288, "Member 'UHLLRoleProgressionItem::Anim_FinishCount' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, Anim_Promoted) == 0x000290, "Member 'UHLLRoleProgressionItem::Anim_Promoted' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, Anim_Show) == 0x000298, "Member 'UHLLRoleProgressionItem::Anim_Show' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, RoleText) == 0x0002A0, "Member 'UHLLRoleProgressionItem::RoleText' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, RoleLevelText) == 0x0002A8, "Member 'UHLLRoleProgressionItem::RoleLevelText' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, RoleIcon) == 0x0002B0, "Member 'UHLLRoleProgressionItem::RoleIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, InitialBar) == 0x0002B8, "Member 'UHLLRoleProgressionItem::InitialBar' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, UpdateBar) == 0x0002C0, "Member 'UHLLRoleProgressionItem::UpdateBar' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, ExpText) == 0x0002C8, "Member 'UHLLRoleProgressionItem::ExpText' has a wrong offset!");
static_assert(offsetof(UHLLRoleProgressionItem, CounterLoopingAC) == 0x0002D0, "Member 'UHLLRoleProgressionItem::CounterLoopingAC' has a wrong offset!");

// Class HLL.CloudSaveModuleInterface
// 0x0000 (0x0028 - 0x0028)
class ICloudSaveModuleInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudSaveModuleInterface">();
	}
	static class ICloudSaveModuleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICloudSaveModuleInterface>();
	}
};
static_assert(alignof(ICloudSaveModuleInterface) == 0x000008, "Wrong alignment on ICloudSaveModuleInterface");
static_assert(sizeof(ICloudSaveModuleInterface) == 0x000028, "Wrong size on ICloudSaveModuleInterface");

// Class HLL.HLLOverviewMapWrapper
// 0x0120 (0x0350 - 0x0230)
class UHLLOverviewMapWrapper : public UUserWidget
{
public:
	uint8                                         bAllowMarkerPlacement : 1;                         // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1045[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMarkers_MapMenu*                    CurrentMarkerMenu;                                 // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLMarkers_MapMenu>        MarkerContextMenu;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1046[0x8];                                     // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetAnimation*                       OpenCloseAnimation;                                // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                RootBorder;                                        // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MapName;                                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerCounts;                                      // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLCommanderUI*                        CommanderPanel;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLOverviewMap*                        Map;                                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                MapPlacementOverlay;                               // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         MapPlacementText;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLResourceStatus*                     ResourceStatus;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              MapKeyScaleBox;                                    // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            Hotkey_MapKey;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLFakeCursor>             FakeCursorClass;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1047[0x20];                                    // 0x02B0(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	class UScaleBox*                              MarkerInfo;                                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        MapNaviationComponent;                             // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        MapInputComponent;                                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        SelectCommanderAbilityComponent;                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        PlacementCommanderAbilityComponent;                // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        SelectionCommanderAbilityComponent;                // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        MarkerMenuInputComponent;                          // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        AxisInputComponent;                                // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UInputComponent*>                CurrentInputComponents;                            // 0x0310(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1048[0x18];                                    // 0x0320(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLCommanderUIItem*                    HoveredItem;                                       // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1049[0x8];                                     // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLFakeCursor*                         FakeCursor;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsCommander();
	void Map_ActiviateAbility();
	void Map_ConsumeEngineInput();
	void Map_ConsumeLookAxis(float AxisValue);
	void Map_Exit();
	void Map_ExpandShrinkKey();
	void Map_GotoActiveCommanderAbility();
	void Map_MarkerMenu_Exit();
	void Map_MarkerMenu_NavigateDown();
	void Map_MarkerMenu_NavigateUp();
	void Map_MarkerMenu_PlaceMarkerAndExit();
	void Map_MarkerMenuRemoveMarker();
	void Map_Navigation_CursorXAxis(float AxisValue);
	void Map_Navigation_CursorYAxis(float AxisValue);
	void Map_Navigation_ZoomIn();
	void Map_Navigation_ZoomOut();
	void Map_PlaceAbility_Activate();
	void Map_PlaceAbility_Exit();
	void Map_PlaceAbility_PlaceRemove();
	void Map_PlaceAbility_RotateAntiClockwise();
	void Map_PlaceAbility_RotateClockwise();
	void Map_SelectAbility();
	void Map_SelectAbility_Down_Pressed();
	void Map_SelectAbility_Exit();
	void Map_SelectAbility_NextGroup();
	void Map_SelectAbility_Pressed();
	void Map_SelectAbility_PreviousGroup();
	void Map_SelectAbility_Released();
	void Map_SelectAbility_Up_Pressed();
	void Map_SelectionAbility_Select();
	void Map_ToggleMapKeyVisibility();
	void OnInputChanged(bool NewValue);
	void OnKeybindsUpdated();
	void OnNewHoveredItem(class UHLLCommanderUIItem* Item);
	void ReceiveExpandShrinkKey();
	void ReceiveOnClose();
	void ReceiveOnHighlightIcon(class UHLLMapIconBase* Icon);
	void ReceiveOnNewHoveredItem(bool bInCanSelect, bool bInCanPlace, bool bInCanActivate, bool bInCanBeRotated);
	void ReceiveOnOpen();
	void ReceiveSetInputState(EMapInputState PreviousInputState, EMapInputState NewInputState);
	void SelectAbilityAbilityDown();
	void SelectAbilityAbilityUp();
	void SetInputState(EMapInputState InputState);
	void UpdateSelectedItem();

	bool CanPlaceMarkers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLOverviewMapWrapper">();
	}
	static class UHLLOverviewMapWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLOverviewMapWrapper>();
	}
};
static_assert(alignof(UHLLOverviewMapWrapper) == 0x000008, "Wrong alignment on UHLLOverviewMapWrapper");
static_assert(sizeof(UHLLOverviewMapWrapper) == 0x000350, "Wrong size on UHLLOverviewMapWrapper");
static_assert(offsetof(UHLLOverviewMapWrapper, CurrentMarkerMenu) == 0x000238, "Member 'UHLLOverviewMapWrapper::CurrentMarkerMenu' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MarkerContextMenu) == 0x000240, "Member 'UHLLOverviewMapWrapper::MarkerContextMenu' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, OpenCloseAnimation) == 0x000250, "Member 'UHLLOverviewMapWrapper::OpenCloseAnimation' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, RootBorder) == 0x000258, "Member 'UHLLOverviewMapWrapper::RootBorder' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MapName) == 0x000260, "Member 'UHLLOverviewMapWrapper::MapName' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, PlayerCounts) == 0x000268, "Member 'UHLLOverviewMapWrapper::PlayerCounts' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, CommanderPanel) == 0x000270, "Member 'UHLLOverviewMapWrapper::CommanderPanel' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, Map) == 0x000278, "Member 'UHLLOverviewMapWrapper::Map' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MapPlacementOverlay) == 0x000280, "Member 'UHLLOverviewMapWrapper::MapPlacementOverlay' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MapPlacementText) == 0x000288, "Member 'UHLLOverviewMapWrapper::MapPlacementText' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, ResourceStatus) == 0x000290, "Member 'UHLLOverviewMapWrapper::ResourceStatus' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MapKeyScaleBox) == 0x000298, "Member 'UHLLOverviewMapWrapper::MapKeyScaleBox' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, Hotkey_MapKey) == 0x0002A0, "Member 'UHLLOverviewMapWrapper::Hotkey_MapKey' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, FakeCursorClass) == 0x0002A8, "Member 'UHLLOverviewMapWrapper::FakeCursorClass' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MarkerInfo) == 0x0002D0, "Member 'UHLLOverviewMapWrapper::MarkerInfo' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MapNaviationComponent) == 0x0002D8, "Member 'UHLLOverviewMapWrapper::MapNaviationComponent' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MapInputComponent) == 0x0002E0, "Member 'UHLLOverviewMapWrapper::MapInputComponent' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, SelectCommanderAbilityComponent) == 0x0002E8, "Member 'UHLLOverviewMapWrapper::SelectCommanderAbilityComponent' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, PlacementCommanderAbilityComponent) == 0x0002F0, "Member 'UHLLOverviewMapWrapper::PlacementCommanderAbilityComponent' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, SelectionCommanderAbilityComponent) == 0x0002F8, "Member 'UHLLOverviewMapWrapper::SelectionCommanderAbilityComponent' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, MarkerMenuInputComponent) == 0x000300, "Member 'UHLLOverviewMapWrapper::MarkerMenuInputComponent' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, AxisInputComponent) == 0x000308, "Member 'UHLLOverviewMapWrapper::AxisInputComponent' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, CurrentInputComponents) == 0x000310, "Member 'UHLLOverviewMapWrapper::CurrentInputComponents' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, HoveredItem) == 0x000338, "Member 'UHLLOverviewMapWrapper::HoveredItem' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMapWrapper, FakeCursor) == 0x000348, "Member 'UHLLOverviewMapWrapper::FakeCursor' has a wrong offset!");

// Class HLL.PitchYawControllerComponent
// 0x03F8 (0x04A8 - 0x00B0)
class UPitchYawControllerComponent : public UActorComponent
{
public:
	float                                         YawRate;                                           // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLimitYawRange : 1;                                // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_104A[0x3];                                     // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MaxAllowedYaw;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRate;                                         // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAngleMin;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAngleMax;                                     // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerUpdateRate;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104B[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             PitchSound;                                        // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PitchStopSound;                                    // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             YawSound;                                          // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             YawStopSound;                                      // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104C[0x1C];                                    // 0x00F0(0x001C)(Fixing Size After Last Property [ Dumper-69 ])
	uint32                                        RemotePackedTargetPitchAndYaw;                     // 0x010C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPitchYawControllerEffectiveSpeedRep   EffectiveSpeedRep;                                 // 0x0110(0x000C)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_104D[0xC];                                     // 0x011C(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             PitchSoundPadOverride;                             // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PitchStopSoundPadOverride;                         // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             YawSoundPadOverride;                               // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             YawStopSoundPadOverride;                           // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                PitchEffect;                                       // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                PitchStopEffect;                                   // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                YawEffect;                                         // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                YawStopEffect;                                     // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104E[0x340];                                   // 0x0168(0x0340)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_RemotePackedTargetPitchAndYaw();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PitchYawControllerComponent">();
	}
	static class UPitchYawControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPitchYawControllerComponent>();
	}
};
static_assert(alignof(UPitchYawControllerComponent) == 0x000008, "Wrong alignment on UPitchYawControllerComponent");
static_assert(sizeof(UPitchYawControllerComponent) == 0x0004A8, "Wrong size on UPitchYawControllerComponent");
static_assert(offsetof(UPitchYawControllerComponent, YawRate) == 0x0000B0, "Member 'UPitchYawControllerComponent::YawRate' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, MaxAllowedYaw) == 0x0000B8, "Member 'UPitchYawControllerComponent::MaxAllowedYaw' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchRate) == 0x0000BC, "Member 'UPitchYawControllerComponent::PitchRate' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchAngleMin) == 0x0000C0, "Member 'UPitchYawControllerComponent::PitchAngleMin' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchAngleMax) == 0x0000C4, "Member 'UPitchYawControllerComponent::PitchAngleMax' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, ServerUpdateRate) == 0x0000C8, "Member 'UPitchYawControllerComponent::ServerUpdateRate' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchSound) == 0x0000D0, "Member 'UPitchYawControllerComponent::PitchSound' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchStopSound) == 0x0000D8, "Member 'UPitchYawControllerComponent::PitchStopSound' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, YawSound) == 0x0000E0, "Member 'UPitchYawControllerComponent::YawSound' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, YawStopSound) == 0x0000E8, "Member 'UPitchYawControllerComponent::YawStopSound' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, RemotePackedTargetPitchAndYaw) == 0x00010C, "Member 'UPitchYawControllerComponent::RemotePackedTargetPitchAndYaw' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, EffectiveSpeedRep) == 0x000110, "Member 'UPitchYawControllerComponent::EffectiveSpeedRep' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchSoundPadOverride) == 0x000128, "Member 'UPitchYawControllerComponent::PitchSoundPadOverride' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchStopSoundPadOverride) == 0x000130, "Member 'UPitchYawControllerComponent::PitchStopSoundPadOverride' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, YawSoundPadOverride) == 0x000138, "Member 'UPitchYawControllerComponent::YawSoundPadOverride' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, YawStopSoundPadOverride) == 0x000140, "Member 'UPitchYawControllerComponent::YawStopSoundPadOverride' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchEffect) == 0x000148, "Member 'UPitchYawControllerComponent::PitchEffect' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, PitchStopEffect) == 0x000150, "Member 'UPitchYawControllerComponent::PitchStopEffect' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, YawEffect) == 0x000158, "Member 'UPitchYawControllerComponent::YawEffect' has a wrong offset!");
static_assert(offsetof(UPitchYawControllerComponent, YawStopEffect) == 0x000160, "Member 'UPitchYawControllerComponent::YawStopEffect' has a wrong offset!");

// Class HLL.SocialButtonWidget
// 0x0010 (0x0240 - 0x0230)
class USocialButtonWidget : public UUserWidget
{
public:
	uint8                                         Pad_104F[0x10];                                    // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnNumUnreadNotificationsChangedEvent(int32 NumUnreadNotifications);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialButtonWidget">();
	}
	static class USocialButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialButtonWidget>();
	}
};
static_assert(alignof(USocialButtonWidget) == 0x000008, "Wrong alignment on USocialButtonWidget");
static_assert(sizeof(USocialButtonWidget) == 0x000240, "Wrong size on USocialButtonWidget");

// Class HLL.CloudSaveSubSystem
// 0x00F0 (0x0120 - 0x0030)
class UCloudSaveSubSystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnSaveLocalUser;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1050[0xE0];                                    // 0x0040(0x00E0)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void RemoveDataForPlayer(const class FString& PlayerId);
	void RequestSaveLocalUser();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudSaveSubSystem">();
	}
	static class UCloudSaveSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudSaveSubSystem>();
	}
};
static_assert(alignof(UCloudSaveSubSystem) == 0x000008, "Wrong alignment on UCloudSaveSubSystem");
static_assert(sizeof(UCloudSaveSubSystem) == 0x000120, "Wrong size on UCloudSaveSubSystem");
static_assert(offsetof(UCloudSaveSubSystem, OnSaveLocalUser) == 0x000030, "Member 'UCloudSaveSubSystem::OnSaveLocalUser' has a wrong offset!");

// Class HLL.ShooterDamageType
// 0x01A8 (0x01E8 - 0x0040)
class UShooterDamageType : public UDamageType
{
public:
	EHLLPlayerStat                                InfantryKillStat;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHLLPlayerStat                                InfantryDeathStat;                                 // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncrementHitStat_Point;                           // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIncrementHitStat_Radial;                          // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1051[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UForceFeedbackEffect*                   HitForceFeedback;                                  // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   KilledForceFeedback;                               // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               HitCameraShake;                                    // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitCameraShakeScale;                               // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadshotDamageMultiplier;                          // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbDamageMultiplier;                              // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggersBleed;                                    // 0x006C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstantCritHeadshot;                              // 0x006D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeadshotsBypassCritical;                          // 0x006E(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCriticalState;                               // 0x006F(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalBypassDamageThreshold;                     // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalBypassDamageDistance;                      // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyImpulse : 1;                                 // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1052[0x3];                                     // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         RagdollImpulse;                                    // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollUpKickImpulse;                              // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseFalloff;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointDamageRadius;                                 // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDismemberment : 1;                          // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1053[0x3];                                     // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MaxDistFromHitToDismember;                         // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBreaksPerHit;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyVehicleImpulseOnPointDamage : 1;             // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EHLLArmourPenetration                         ArmourPenetration;                                 // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLArmourPenetration                         RadialArmourPenetration;                           // 0x009A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLArmourDamageType                          ArmourDamageType;                                  // 0x009B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLArmourDamageType                          RadialArmourDamageType;                            // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1054[0x3];                                     // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ArmourPassthroughTraceLength;                      // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InternalModulePenetrationDepth;                    // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bBypassArmourDeflection_Impact : 1;                // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBypassArmourDeflection_Radial : 1;                // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceCarryOverArmourDamage : 1;                   // 0x00A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bApplyArmourPointDamageAsGeneralDamage : 1;        // 0x00A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1055[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SelfDamageScale;                                   // 0x00AC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendlyDamageScale;                               // 0x00B0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1056[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	int64                                         BypassFriendlyDamageScale;                         // 0x00B8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSuppressHelmetEject : 1;                          // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotifyAnimationsPointDamage : 1;                  // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotifyAnimationsRadialDamage : 1;                 // 0x00C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBypassCriticalTeamKillPunishment : 1;             // 0x00C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBypassDamageFilters : 1;                          // 0x00C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1057[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	int64                                         FriendlyDamageFilter;                              // 0x00C8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EnemyDamageFilter;                                 // 0x00D0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHLLDamageType                                DamageType;                                        // 0x00D8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1058[0x3];                                     // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MinExecutionDamage;                                // 0x00DC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PunishForTeamKill;                                 // 0x00E0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PunishForSelfKill;                                 // 0x00E4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bClearPendingPunishments : 1;                      // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRewardAllSeatsOccupants : 1;                      // 0x00E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBypassSeatProtection : 1;                         // 0x00E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasSelfKillAchievement : 1;                       // 0x00E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EHLLAchievement                               SelfKillAchievement;                               // 0x00E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1059[0x6];                                     // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<EHLLAchievementStat>                     EnemyKillStats;                                    // 0x00F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<EHLLAchievementStat>                     EnemyDownedStats;                                  // 0x0140(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bHasEnemyVehicleKillAchievement : 1;               // 0x0190(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EHLLAchievement                               VehicleKillAchievement;                            // 0x0191(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105A[0x6];                                     // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<EHLLAchievement>                         CustomAchievementImplementations;                  // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterDamageType">();
	}
	static class UShooterDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterDamageType>();
	}
};
static_assert(alignof(UShooterDamageType) == 0x000008, "Wrong alignment on UShooterDamageType");
static_assert(sizeof(UShooterDamageType) == 0x0001E8, "Wrong size on UShooterDamageType");
static_assert(offsetof(UShooterDamageType, InfantryKillStat) == 0x000040, "Member 'UShooterDamageType::InfantryKillStat' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, InfantryDeathStat) == 0x000041, "Member 'UShooterDamageType::InfantryDeathStat' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, bIncrementHitStat_Point) == 0x000042, "Member 'UShooterDamageType::bIncrementHitStat_Point' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, bIncrementHitStat_Radial) == 0x000043, "Member 'UShooterDamageType::bIncrementHitStat_Radial' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, HitForceFeedback) == 0x000048, "Member 'UShooterDamageType::HitForceFeedback' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, KilledForceFeedback) == 0x000050, "Member 'UShooterDamageType::KilledForceFeedback' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, HitCameraShake) == 0x000058, "Member 'UShooterDamageType::HitCameraShake' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, HitCameraShakeScale) == 0x000060, "Member 'UShooterDamageType::HitCameraShakeScale' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, HeadshotDamageMultiplier) == 0x000064, "Member 'UShooterDamageType::HeadshotDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, LimbDamageMultiplier) == 0x000068, "Member 'UShooterDamageType::LimbDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, bTriggersBleed) == 0x00006C, "Member 'UShooterDamageType::bTriggersBleed' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, bInstantCritHeadshot) == 0x00006D, "Member 'UShooterDamageType::bInstantCritHeadshot' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, bHeadshotsBypassCritical) == 0x00006E, "Member 'UShooterDamageType::bHeadshotsBypassCritical' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, bAllowCriticalState) == 0x00006F, "Member 'UShooterDamageType::bAllowCriticalState' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, CriticalBypassDamageThreshold) == 0x000070, "Member 'UShooterDamageType::CriticalBypassDamageThreshold' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, CriticalBypassDamageDistance) == 0x000074, "Member 'UShooterDamageType::CriticalBypassDamageDistance' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, RagdollImpulse) == 0x00007C, "Member 'UShooterDamageType::RagdollImpulse' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, RagdollUpKickImpulse) == 0x000080, "Member 'UShooterDamageType::RagdollUpKickImpulse' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, ImpulseFalloff) == 0x000084, "Member 'UShooterDamageType::ImpulseFalloff' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, PointDamageRadius) == 0x000088, "Member 'UShooterDamageType::PointDamageRadius' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, MaxDistFromHitToDismember) == 0x000090, "Member 'UShooterDamageType::MaxDistFromHitToDismember' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, MaxBreaksPerHit) == 0x000094, "Member 'UShooterDamageType::MaxBreaksPerHit' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, ArmourPenetration) == 0x000099, "Member 'UShooterDamageType::ArmourPenetration' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, RadialArmourPenetration) == 0x00009A, "Member 'UShooterDamageType::RadialArmourPenetration' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, ArmourDamageType) == 0x00009B, "Member 'UShooterDamageType::ArmourDamageType' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, RadialArmourDamageType) == 0x00009C, "Member 'UShooterDamageType::RadialArmourDamageType' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, ArmourPassthroughTraceLength) == 0x0000A0, "Member 'UShooterDamageType::ArmourPassthroughTraceLength' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, InternalModulePenetrationDepth) == 0x0000A4, "Member 'UShooterDamageType::InternalModulePenetrationDepth' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, SelfDamageScale) == 0x0000AC, "Member 'UShooterDamageType::SelfDamageScale' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, FriendlyDamageScale) == 0x0000B0, "Member 'UShooterDamageType::FriendlyDamageScale' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, BypassFriendlyDamageScale) == 0x0000B8, "Member 'UShooterDamageType::BypassFriendlyDamageScale' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, FriendlyDamageFilter) == 0x0000C8, "Member 'UShooterDamageType::FriendlyDamageFilter' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, EnemyDamageFilter) == 0x0000D0, "Member 'UShooterDamageType::EnemyDamageFilter' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, DamageType) == 0x0000D8, "Member 'UShooterDamageType::DamageType' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, MinExecutionDamage) == 0x0000DC, "Member 'UShooterDamageType::MinExecutionDamage' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, PunishForTeamKill) == 0x0000E0, "Member 'UShooterDamageType::PunishForTeamKill' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, PunishForSelfKill) == 0x0000E4, "Member 'UShooterDamageType::PunishForSelfKill' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, SelfKillAchievement) == 0x0000E9, "Member 'UShooterDamageType::SelfKillAchievement' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, EnemyKillStats) == 0x0000F0, "Member 'UShooterDamageType::EnemyKillStats' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, EnemyDownedStats) == 0x000140, "Member 'UShooterDamageType::EnemyDownedStats' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, VehicleKillAchievement) == 0x000191, "Member 'UShooterDamageType::VehicleKillAchievement' has a wrong offset!");
static_assert(offsetof(UShooterDamageType, CustomAchievementImplementations) == 0x000198, "Member 'UShooterDamageType::CustomAchievementImplementations' has a wrong offset!");

// Class HLL.HLLVehicleInactiveDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLVehicleInactiveDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleInactiveDamage">();
	}
	static class UHLLVehicleInactiveDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVehicleInactiveDamage>();
	}
};
static_assert(alignof(UHLLVehicleInactiveDamage) == 0x000008, "Wrong alignment on UHLLVehicleInactiveDamage");
static_assert(sizeof(UHLLVehicleInactiveDamage) == 0x0001E8, "Wrong size on UHLLVehicleInactiveDamage");

// Class HLL.ArtyBarrelControllerComponent
// 0x0038 (0x04E0 - 0x04A8)
class UArtyBarrelControllerComponent final : public UPitchYawControllerComponent
{
public:
	class AHLLSeat_ArtilleryGunner*               GunnerSeat;                                        // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLSeat_ArtilleryLoader*               LoaderSeat;                                        // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CharacterTurretGuard;                              // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        YawAudio;                                          // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PitchAudio;                                        // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              YawVibrationController;                            // 0x04D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              PitchVibrationController;                          // 0x04D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtyBarrelControllerComponent">();
	}
	static class UArtyBarrelControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtyBarrelControllerComponent>();
	}
};
static_assert(alignof(UArtyBarrelControllerComponent) == 0x000008, "Wrong alignment on UArtyBarrelControllerComponent");
static_assert(sizeof(UArtyBarrelControllerComponent) == 0x0004E0, "Wrong size on UArtyBarrelControllerComponent");
static_assert(offsetof(UArtyBarrelControllerComponent, GunnerSeat) == 0x0004A8, "Member 'UArtyBarrelControllerComponent::GunnerSeat' has a wrong offset!");
static_assert(offsetof(UArtyBarrelControllerComponent, LoaderSeat) == 0x0004B0, "Member 'UArtyBarrelControllerComponent::LoaderSeat' has a wrong offset!");
static_assert(offsetof(UArtyBarrelControllerComponent, CharacterTurretGuard) == 0x0004B8, "Member 'UArtyBarrelControllerComponent::CharacterTurretGuard' has a wrong offset!");
static_assert(offsetof(UArtyBarrelControllerComponent, YawAudio) == 0x0004C0, "Member 'UArtyBarrelControllerComponent::YawAudio' has a wrong offset!");
static_assert(offsetof(UArtyBarrelControllerComponent, PitchAudio) == 0x0004C8, "Member 'UArtyBarrelControllerComponent::PitchAudio' has a wrong offset!");
static_assert(offsetof(UArtyBarrelControllerComponent, YawVibrationController) == 0x0004D0, "Member 'UArtyBarrelControllerComponent::YawVibrationController' has a wrong offset!");
static_assert(offsetof(UArtyBarrelControllerComponent, PitchVibrationController) == 0x0004D8, "Member 'UArtyBarrelControllerComponent::PitchVibrationController' has a wrong offset!");

// Class HLL.ArtyTurnControllerComponent
// 0x0048 (0x04F0 - 0x04A8)
class UArtyTurnControllerComponent final : public UPitchYawControllerComponent
{
public:
	struct FRotator                               ArtillerySpawnRotation;                            // 0x04A8(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_105B[0x4];                                     // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AHLLSeat_ArtilleryGunner*               GunnerSeat;                                        // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLSeat_ArtilleryLoader*               LoaderSeat;                                        // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CharacterTurretGuard;                              // 0x04C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      PlayerL;                                           // 0x04D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      PlayerR;                                           // 0x04D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        TurnAudio;                                         // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              TurnVibrationController;                           // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtyTurnControllerComponent">();
	}
	static class UArtyTurnControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtyTurnControllerComponent>();
	}
};
static_assert(alignof(UArtyTurnControllerComponent) == 0x000008, "Wrong alignment on UArtyTurnControllerComponent");
static_assert(sizeof(UArtyTurnControllerComponent) == 0x0004F0, "Wrong size on UArtyTurnControllerComponent");
static_assert(offsetof(UArtyTurnControllerComponent, ArtillerySpawnRotation) == 0x0004A8, "Member 'UArtyTurnControllerComponent::ArtillerySpawnRotation' has a wrong offset!");
static_assert(offsetof(UArtyTurnControllerComponent, GunnerSeat) == 0x0004B8, "Member 'UArtyTurnControllerComponent::GunnerSeat' has a wrong offset!");
static_assert(offsetof(UArtyTurnControllerComponent, LoaderSeat) == 0x0004C0, "Member 'UArtyTurnControllerComponent::LoaderSeat' has a wrong offset!");
static_assert(offsetof(UArtyTurnControllerComponent, CharacterTurretGuard) == 0x0004C8, "Member 'UArtyTurnControllerComponent::CharacterTurretGuard' has a wrong offset!");
static_assert(offsetof(UArtyTurnControllerComponent, PlayerL) == 0x0004D0, "Member 'UArtyTurnControllerComponent::PlayerL' has a wrong offset!");
static_assert(offsetof(UArtyTurnControllerComponent, PlayerR) == 0x0004D8, "Member 'UArtyTurnControllerComponent::PlayerR' has a wrong offset!");
static_assert(offsetof(UArtyTurnControllerComponent, TurnAudio) == 0x0004E0, "Member 'UArtyTurnControllerComponent::TurnAudio' has a wrong offset!");
static_assert(offsetof(UArtyTurnControllerComponent, TurnVibrationController) == 0x0004E8, "Member 'UArtyTurnControllerComponent::TurnVibrationController' has a wrong offset!");

// Class HLL.VibrationEventController
// 0x0000 (0x0028 - 0x0028)
class UVibrationEventController : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VibrationEventController">();
	}
	static class UVibrationEventController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVibrationEventController>();
	}
};
static_assert(alignof(UVibrationEventController) == 0x000008, "Wrong alignment on UVibrationEventController");
static_assert(sizeof(UVibrationEventController) == 0x000028, "Wrong size on UVibrationEventController");

// Class HLL.HapticEventController
// 0x0008 (0x0030 - 0x0028)
class UHapticEventController final : public UVibrationEventController
{
public:
	class UAudioComponent*                        AudioComponent;                                    // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HapticEventController">();
	}
	static class UHapticEventController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHapticEventController>();
	}
};
static_assert(alignof(UHapticEventController) == 0x000008, "Wrong alignment on UHapticEventController");
static_assert(sizeof(UHapticEventController) == 0x000030, "Wrong size on UHapticEventController");
static_assert(offsetof(UHapticEventController, AudioComponent) == 0x000028, "Member 'UHapticEventController::AudioComponent' has a wrong offset!");

// Class HLL.AudioSplineActor
// 0x0048 (0x0268 - 0x0220)
class AAudioSplineActor final : public AActor
{
public:
	float                                         DefaultTickRate;                                   // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffDistance;                                   // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeRate;                                          // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105C[0x4];                                     // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USplineComponent*                       CachedSpline;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAudioComponent*>                AudioComponents;                                   // 0x0238(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105D[0x20];                                    // 0x0248(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioSplineActor">();
	}
	static class AAudioSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAudioSplineActor>();
	}
};
static_assert(alignof(AAudioSplineActor) == 0x000008, "Wrong alignment on AAudioSplineActor");
static_assert(sizeof(AAudioSplineActor) == 0x000268, "Wrong size on AAudioSplineActor");
static_assert(offsetof(AAudioSplineActor, DefaultTickRate) == 0x000220, "Member 'AAudioSplineActor::DefaultTickRate' has a wrong offset!");
static_assert(offsetof(AAudioSplineActor, FalloffDistance) == 0x000224, "Member 'AAudioSplineActor::FalloffDistance' has a wrong offset!");
static_assert(offsetof(AAudioSplineActor, FadeRate) == 0x000228, "Member 'AAudioSplineActor::FadeRate' has a wrong offset!");
static_assert(offsetof(AAudioSplineActor, CachedSpline) == 0x000230, "Member 'AAudioSplineActor::CachedSpline' has a wrong offset!");
static_assert(offsetof(AAudioSplineActor, AudioComponents) == 0x000238, "Member 'AAudioSplineActor::AudioComponents' has a wrong offset!");

// Class HLL.HLLMapContextWidget
// 0x0018 (0x0248 - 0x0230)
class UHLLMapContextWidget : public UUserWidget
{
public:
	TWeakObjectPtr<class UHLLOverviewMapWrapper>  OwningMap;                                         // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MapPosition;                                       // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bClosed : 1;                                       // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_105E[0x7];                                     // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void K2_Close();
	void UpdatePosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapContextWidget">();
	}
	static class UHLLMapContextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapContextWidget>();
	}
};
static_assert(alignof(UHLLMapContextWidget) == 0x000008, "Wrong alignment on UHLLMapContextWidget");
static_assert(sizeof(UHLLMapContextWidget) == 0x000248, "Wrong size on UHLLMapContextWidget");
static_assert(offsetof(UHLLMapContextWidget, OwningMap) == 0x000230, "Member 'UHLLMapContextWidget::OwningMap' has a wrong offset!");
static_assert(offsetof(UHLLMapContextWidget, MapPosition) == 0x000238, "Member 'UHLLMapContextWidget::MapPosition' has a wrong offset!");

// Class HLL.HLLMarkers_MapMenu
// 0x0038 (0x0280 - 0x0248)
class UHLLMarkers_MapMenu : public UHLLMapContextWidget
{
public:
	TSubclassOf<class UHLLMarkers_MapMenuItem>    ItemClass;                                         // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLMarkers_MapMenuItem*>        Items;                                             // 0x0250(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           Options;                                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105F[0x18];                                    // 0x0268(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UHLLOverviewMapWrapper* GetParentMapWrapper();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMarkers_MapMenu">();
	}
	static class UHLLMarkers_MapMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMarkers_MapMenu>();
	}
};
static_assert(alignof(UHLLMarkers_MapMenu) == 0x000008, "Wrong alignment on UHLLMarkers_MapMenu");
static_assert(sizeof(UHLLMarkers_MapMenu) == 0x000280, "Wrong size on UHLLMarkers_MapMenu");
static_assert(offsetof(UHLLMarkers_MapMenu, ItemClass) == 0x000248, "Member 'UHLLMarkers_MapMenu::ItemClass' has a wrong offset!");
static_assert(offsetof(UHLLMarkers_MapMenu, Items) == 0x000250, "Member 'UHLLMarkers_MapMenu::Items' has a wrong offset!");
static_assert(offsetof(UHLLMarkers_MapMenu, Options) == 0x000260, "Member 'UHLLMarkers_MapMenu::Options' has a wrong offset!");

// Class HLL.AvailableRole
// 0x0148 (0x0378 - 0x0230)
class UAvailableRole final : public UUserWidget
{
public:
	uint8                                         Pad_1060[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class USlateWidgetStyleAsset*                 StyleSet;                                          // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalTextColor;                                   // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HoveredTextColor;                                  // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectedTextColor;                                 // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DisabledTextColor;                                 // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalBgColor;                                     // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HoveredBgColor;                                    // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectedBgColor;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DisabledBgColor;                                   // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                RootBorder;                                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        NameSwitcher;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Limits;                                            // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Rifleman;                                          // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Assault;                                           // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AutomaticRifleman;                                 // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Medic;                                             // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Spotter;                                           // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Support;                                           // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HeavyMachineGunner;                                // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AntiTank;                                          // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Engineer;                                          // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Sniper;                                            // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Officer;                                           // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Crewman;                                           // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TankCommander;                                     // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1061[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             M_nameWidget;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 M_iconWidget;                                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPlayerRole                                   M_playerRole;                                      // 0x0370(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1062[0x7];                                     // 0x0371(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Role_Hovered(bool Hovered);
	void Role_Selected(bool Selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AvailableRole">();
	}
	static class UAvailableRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAvailableRole>();
	}
};
static_assert(alignof(UAvailableRole) == 0x000008, "Wrong alignment on UAvailableRole");
static_assert(sizeof(UAvailableRole) == 0x000378, "Wrong size on UAvailableRole");
static_assert(offsetof(UAvailableRole, StyleSet) == 0x000248, "Member 'UAvailableRole::StyleSet' has a wrong offset!");
static_assert(offsetof(UAvailableRole, NormalTextColor) == 0x000250, "Member 'UAvailableRole::NormalTextColor' has a wrong offset!");
static_assert(offsetof(UAvailableRole, HoveredTextColor) == 0x000260, "Member 'UAvailableRole::HoveredTextColor' has a wrong offset!");
static_assert(offsetof(UAvailableRole, SelectedTextColor) == 0x000270, "Member 'UAvailableRole::SelectedTextColor' has a wrong offset!");
static_assert(offsetof(UAvailableRole, DisabledTextColor) == 0x000280, "Member 'UAvailableRole::DisabledTextColor' has a wrong offset!");
static_assert(offsetof(UAvailableRole, NormalBgColor) == 0x000290, "Member 'UAvailableRole::NormalBgColor' has a wrong offset!");
static_assert(offsetof(UAvailableRole, HoveredBgColor) == 0x0002A0, "Member 'UAvailableRole::HoveredBgColor' has a wrong offset!");
static_assert(offsetof(UAvailableRole, SelectedBgColor) == 0x0002B0, "Member 'UAvailableRole::SelectedBgColor' has a wrong offset!");
static_assert(offsetof(UAvailableRole, DisabledBgColor) == 0x0002C0, "Member 'UAvailableRole::DisabledBgColor' has a wrong offset!");
static_assert(offsetof(UAvailableRole, RootBorder) == 0x0002D0, "Member 'UAvailableRole::RootBorder' has a wrong offset!");
static_assert(offsetof(UAvailableRole, IconImage) == 0x0002D8, "Member 'UAvailableRole::IconImage' has a wrong offset!");
static_assert(offsetof(UAvailableRole, NameSwitcher) == 0x0002E0, "Member 'UAvailableRole::NameSwitcher' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Limits) == 0x0002E8, "Member 'UAvailableRole::Limits' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Rifleman) == 0x0002F0, "Member 'UAvailableRole::Rifleman' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Assault) == 0x0002F8, "Member 'UAvailableRole::Assault' has a wrong offset!");
static_assert(offsetof(UAvailableRole, AutomaticRifleman) == 0x000300, "Member 'UAvailableRole::AutomaticRifleman' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Medic) == 0x000308, "Member 'UAvailableRole::Medic' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Spotter) == 0x000310, "Member 'UAvailableRole::Spotter' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Support) == 0x000318, "Member 'UAvailableRole::Support' has a wrong offset!");
static_assert(offsetof(UAvailableRole, HeavyMachineGunner) == 0x000320, "Member 'UAvailableRole::HeavyMachineGunner' has a wrong offset!");
static_assert(offsetof(UAvailableRole, AntiTank) == 0x000328, "Member 'UAvailableRole::AntiTank' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Engineer) == 0x000330, "Member 'UAvailableRole::Engineer' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Sniper) == 0x000338, "Member 'UAvailableRole::Sniper' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Officer) == 0x000340, "Member 'UAvailableRole::Officer' has a wrong offset!");
static_assert(offsetof(UAvailableRole, Crewman) == 0x000348, "Member 'UAvailableRole::Crewman' has a wrong offset!");
static_assert(offsetof(UAvailableRole, TankCommander) == 0x000350, "Member 'UAvailableRole::TankCommander' has a wrong offset!");
static_assert(offsetof(UAvailableRole, M_nameWidget) == 0x000360, "Member 'UAvailableRole::M_nameWidget' has a wrong offset!");
static_assert(offsetof(UAvailableRole, M_iconWidget) == 0x000368, "Member 'UAvailableRole::M_iconWidget' has a wrong offset!");
static_assert(offsetof(UAvailableRole, M_playerRole) == 0x000370, "Member 'UAvailableRole::M_playerRole' has a wrong offset!");

// Class HLL.BaseVehicle
// 0x0298 (0x0528 - 0x0290)
class ABaseVehicle : public AWheeledVehicle
{
public:
	uint8                                         Pad_1063[0x50];                                    // 0x0290(0x0050)(Fixing Size After Last Property [ Dumper-69 ])
	ETeam                                         Team;                                              // 0x02E0(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1064[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AVehicleDriverSeat*                     DriverSeat;                                        // 0x02E8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EngineWarmupDuration;                              // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EngineShutdownDuration;                            // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCrippleMovementWhenDepleted : 1;                  // 0x02F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_44 : 7;                                     // 0x00F8(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-69 ])
	uint8                                         Pad_1065[0x3];                                     // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bEngineStarted : 1;                                // 0x02FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1066[0x13];                                    // 0x02FD(0x0013)(Fixing Size After Last Property [ Dumper-69 ])
	class UPhysicalMaterial*                      LowSpeedPhysMatOverride;                           // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LowSpeedThresholdKph;                              // 0x0318(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1067[0x4];                                     // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AVehicleDriverSeat>         DriverSeatClass;                                   // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EngineSoundFadeInTime;                             // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1068[0x4];                                     // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVehicleSoundSetup                     EngineSound;                                       // 0x0330(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVehicleSoundSetup                     EngineStartSound;                                  // 0x0350(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVehicleSoundSetup                     EngineStartAbortedSound;                           // 0x0370(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVehicleSoundSetup                     EngineStopSound;                                   // 0x0390(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVehicleSoundSetup                     EngineStartFailedSound;                            // 0x03B0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAudioComponent*                        EngineAudio;                                       // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        InteriorAudio;                                     // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        ExhaustAudio;                                      // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        EngineStartAudio;                                  // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        InteriorStartAudio;                                // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        ExhaustStartAudio;                                 // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        ClutchAudio;                                       // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        InteriorHitAudio;                                  // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        HornAudio;                                         // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bHornSoundEnabled : 1;                             // 0x0418(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1069[0xF];                                     // 0x0419(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLArmourHealthComponent*              ArmourHealth;                                      // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourInventory*                    ArmourInventory;                                   // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLArmourMetaData                     ArmourMetaData;                                    // 0x0438(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UHLLVehicleInactivityComponent*         VehicleInactivityMonitor;                          // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 NameplateIndicatorComponent;                       // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehicleWorldShiftingComponent*         WorldShifting;                                     // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FReconID                               VehicleReconID;                                    // 0x0480(0x0002)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	EReconItemType                                ReconType;                                         // 0x0482(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_106A[0x5];                                     // 0x0483(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UVehicleHitComponent*                   Hitter;                                            // 0x0488(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterMovementBarrierBody;                      // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          JeepBarrier;                                       // 0x0498(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootBoneName;                                      // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           WheelCollisionBodies;                              // 0x04A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             WaterEffects;                                      // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLVehicleFXComponent*                 VehicleEffects;                                    // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehicleAntiFlipComponent*              AntiFlipComponent;                                 // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x04D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_106B[0x7];                                     // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLVehicleVibrationData*               VehicleVibrationData;                              // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              EngineVibrationController_Internal;                // 0x04E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              EngineVibrationController_External;                // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              InternalHitVibrationController;                    // 0x04F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_106C[0x30];                                    // 0x04F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClientStartEngineFailed();
	void OnRep_EngineStarted();
	void OnRep_HornSoundEnabled();
	void OnRep_Seat();
	void ServerSetHornSoundEnabled(bool Enabled);
	void ServerStartEngine();
	void ServerStopEngine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseVehicle">();
	}
	static class ABaseVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseVehicle>();
	}
};
static_assert(alignof(ABaseVehicle) == 0x000008, "Wrong alignment on ABaseVehicle");
static_assert(sizeof(ABaseVehicle) == 0x000528, "Wrong size on ABaseVehicle");
static_assert(offsetof(ABaseVehicle, Team) == 0x0002E0, "Member 'ABaseVehicle::Team' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, DriverSeat) == 0x0002E8, "Member 'ABaseVehicle::DriverSeat' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineWarmupDuration) == 0x0002F0, "Member 'ABaseVehicle::EngineWarmupDuration' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineShutdownDuration) == 0x0002F4, "Member 'ABaseVehicle::EngineShutdownDuration' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, LowSpeedPhysMatOverride) == 0x000310, "Member 'ABaseVehicle::LowSpeedPhysMatOverride' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, LowSpeedThresholdKph) == 0x000318, "Member 'ABaseVehicle::LowSpeedThresholdKph' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, DriverSeatClass) == 0x000320, "Member 'ABaseVehicle::DriverSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineSoundFadeInTime) == 0x000328, "Member 'ABaseVehicle::EngineSoundFadeInTime' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineSound) == 0x000330, "Member 'ABaseVehicle::EngineSound' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineStartSound) == 0x000350, "Member 'ABaseVehicle::EngineStartSound' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineStartAbortedSound) == 0x000370, "Member 'ABaseVehicle::EngineStartAbortedSound' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineStopSound) == 0x000390, "Member 'ABaseVehicle::EngineStopSound' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineStartFailedSound) == 0x0003B0, "Member 'ABaseVehicle::EngineStartFailedSound' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineAudio) == 0x0003D0, "Member 'ABaseVehicle::EngineAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, InteriorAudio) == 0x0003D8, "Member 'ABaseVehicle::InteriorAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, ExhaustAudio) == 0x0003E0, "Member 'ABaseVehicle::ExhaustAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineStartAudio) == 0x0003E8, "Member 'ABaseVehicle::EngineStartAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, InteriorStartAudio) == 0x0003F0, "Member 'ABaseVehicle::InteriorStartAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, ExhaustStartAudio) == 0x0003F8, "Member 'ABaseVehicle::ExhaustStartAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, ClutchAudio) == 0x000400, "Member 'ABaseVehicle::ClutchAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, InteriorHitAudio) == 0x000408, "Member 'ABaseVehicle::InteriorHitAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, HornAudio) == 0x000410, "Member 'ABaseVehicle::HornAudio' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, ArmourHealth) == 0x000428, "Member 'ABaseVehicle::ArmourHealth' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, ArmourInventory) == 0x000430, "Member 'ABaseVehicle::ArmourInventory' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, ArmourMetaData) == 0x000438, "Member 'ABaseVehicle::ArmourMetaData' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, VehicleInactivityMonitor) == 0x000460, "Member 'ABaseVehicle::VehicleInactivityMonitor' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, MapComponent) == 0x000468, "Member 'ABaseVehicle::MapComponent' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, NameplateIndicatorComponent) == 0x000470, "Member 'ABaseVehicle::NameplateIndicatorComponent' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, WorldShifting) == 0x000478, "Member 'ABaseVehicle::WorldShifting' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, VehicleReconID) == 0x000480, "Member 'ABaseVehicle::VehicleReconID' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, ReconType) == 0x000482, "Member 'ABaseVehicle::ReconType' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, Hitter) == 0x000488, "Member 'ABaseVehicle::Hitter' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, CharacterMovementBarrierBody) == 0x000490, "Member 'ABaseVehicle::CharacterMovementBarrierBody' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, JeepBarrier) == 0x000498, "Member 'ABaseVehicle::JeepBarrier' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, RootBoneName) == 0x0004A0, "Member 'ABaseVehicle::RootBoneName' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, WheelCollisionBodies) == 0x0004A8, "Member 'ABaseVehicle::WheelCollisionBodies' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, WaterEffects) == 0x0004B8, "Member 'ABaseVehicle::WaterEffects' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, VehicleEffects) == 0x0004C0, "Member 'ABaseVehicle::VehicleEffects' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, AntiFlipComponent) == 0x0004C8, "Member 'ABaseVehicle::AntiFlipComponent' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, DamageFilterType) == 0x0004D0, "Member 'ABaseVehicle::DamageFilterType' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, VehicleVibrationData) == 0x0004D8, "Member 'ABaseVehicle::VehicleVibrationData' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineVibrationController_Internal) == 0x0004E0, "Member 'ABaseVehicle::EngineVibrationController_Internal' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, EngineVibrationController_External) == 0x0004E8, "Member 'ABaseVehicle::EngineVibrationController_External' has a wrong offset!");
static_assert(offsetof(ABaseVehicle, InternalHitVibrationController) == 0x0004F0, "Member 'ABaseVehicle::InternalHitVibrationController' has a wrong offset!");

// Class HLL.BaseReconVehicle
// 0x0098 (0x05C0 - 0x0528)
class ABaseReconVehicle : public ABaseVehicle
{
public:
	class UTurretControllerComponent2*            TurretController2;                                 // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PitchAudio;                                        // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        YawAudio;                                          // 0x0538(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TurretAudioAttachSocket;                           // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterMovementBarrierTurret;                    // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterMovementBarrierBarrel;                    // 0x0550(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourCollisionMesh*                ArmourCollision_Body;                              // 0x0558(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourCollisionMesh*                ArmourCollision_Turret;                            // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourCollisionMesh*                ArmourCollision_Barrel;                            // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATankGunnerSeat>            GunnerSeatClass;                                   // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATankCommanderSeat>         CommanderSeatClass;                                // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLSeat>                   FirstPassengerSeatClass;                           // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLSeat>                   SecondPassengerSeatClass;                          // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATankGunnerSeat*                        GunnerSeat;                                        // 0x0590(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATankCommanderSeat*                     CommanderSeat;                                     // 0x0598(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLSeat*                               FirstPassengerSeat;                                // 0x05A0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLSeat*                               SecondPassengerSeat;                               // 0x05A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              PitchVibrationController;                          // 0x05B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              YawVibrationController;                            // 0x05B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_GunnerSeat();
	void OnRep_SeatCommon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseReconVehicle">();
	}
	static class ABaseReconVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseReconVehicle>();
	}
};
static_assert(alignof(ABaseReconVehicle) == 0x000008, "Wrong alignment on ABaseReconVehicle");
static_assert(sizeof(ABaseReconVehicle) == 0x0005C0, "Wrong size on ABaseReconVehicle");
static_assert(offsetof(ABaseReconVehicle, TurretController2) == 0x000528, "Member 'ABaseReconVehicle::TurretController2' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, PitchAudio) == 0x000530, "Member 'ABaseReconVehicle::PitchAudio' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, YawAudio) == 0x000538, "Member 'ABaseReconVehicle::YawAudio' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, TurretAudioAttachSocket) == 0x000540, "Member 'ABaseReconVehicle::TurretAudioAttachSocket' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, CharacterMovementBarrierTurret) == 0x000548, "Member 'ABaseReconVehicle::CharacterMovementBarrierTurret' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, CharacterMovementBarrierBarrel) == 0x000550, "Member 'ABaseReconVehicle::CharacterMovementBarrierBarrel' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, ArmourCollision_Body) == 0x000558, "Member 'ABaseReconVehicle::ArmourCollision_Body' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, ArmourCollision_Turret) == 0x000560, "Member 'ABaseReconVehicle::ArmourCollision_Turret' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, ArmourCollision_Barrel) == 0x000568, "Member 'ABaseReconVehicle::ArmourCollision_Barrel' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, GunnerSeatClass) == 0x000570, "Member 'ABaseReconVehicle::GunnerSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, CommanderSeatClass) == 0x000578, "Member 'ABaseReconVehicle::CommanderSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, FirstPassengerSeatClass) == 0x000580, "Member 'ABaseReconVehicle::FirstPassengerSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, SecondPassengerSeatClass) == 0x000588, "Member 'ABaseReconVehicle::SecondPassengerSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, GunnerSeat) == 0x000590, "Member 'ABaseReconVehicle::GunnerSeat' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, CommanderSeat) == 0x000598, "Member 'ABaseReconVehicle::CommanderSeat' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, FirstPassengerSeat) == 0x0005A0, "Member 'ABaseReconVehicle::FirstPassengerSeat' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, SecondPassengerSeat) == 0x0005A8, "Member 'ABaseReconVehicle::SecondPassengerSeat' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, PitchVibrationController) == 0x0005B0, "Member 'ABaseReconVehicle::PitchVibrationController' has a wrong offset!");
static_assert(offsetof(ABaseReconVehicle, YawVibrationController) == 0x0005B8, "Member 'ABaseReconVehicle::YawVibrationController' has a wrong offset!");

// Class HLL.HLLMapMetaTemplate
// 0x0160 (0x0188 - 0x0028)
class UHLLMapMetaTemplate final : public UObject
{
public:
	uint8                                         Pad_106D[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	ETeam                                         OffensiveModeAttackingTeam;                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeam                                         PracticeRangeTeam;                                 // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106E[0x2];                                     // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              MapCentre;                                         // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorWidth;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorHeight;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapWidth;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapHeight;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialMapZoomLevel;                               // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseInitialMapZoomLevel;                            // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106F[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FHLLSectorDefinition>           Sectors;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MapFriendlyName;                                   // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 MapId;                                             // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNightMap;                                       // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncrementMapAchievement;                          // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHLLAchievementStat                           AchievementStat;                                   // 0x0092(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1070[0x5];                                     // 0x0093(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UMapSpecificAchievements*               MapSpecificAchievementData;                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MapMetaDataAmbientSound;                           // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MapShortName;                                      // 0x00A8(0x0018)(Deprecated, NativeAccessSpecifierPublic)
	EMapOrientation                               Orientation;                                       // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideWarmUpBoundsVolume;                        // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1071[0x2];                                     // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              WarmUpVolumeSize;                                  // 0x00C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WarmUpVolumePosition;                              // 0x00CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1072[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UProhibitedAchievementsData*            ProhibitedAchievementsData;                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDivision>                             CosmeticDivisions;                                 // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingConquestRuleset;                             // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1073[0x1];                                     // 0x00F1(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	uint16                                        InitialConquestTickets;                            // 0x00F2(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1074[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSoftObjectPtr<class UTexture2D>              OverviewImage;                                     // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CompassOffset;                                     // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFaction                                      AxisFaction;                                       // 0x0124(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFaction                                      AlliesFaction;                                     // 0x0125(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1075[0x2];                                     // 0x0126(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMapAbilityData*                     AxisAbilityData;                                   // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLMapAbilityData*                     AlliesAbilityData;                                 // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLWeatherManagerData*                 WeatherManagerData;                                // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlatoonOverrideData*                   PlatoonOverrideData;                               // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponOverrideData*                    AlliesLoadoutOverrideData;                         // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponOverrideData*                    AxisLoadoutOverrideData;                           // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommanderOverrideData*                 AlliesCommanderOverrideData;                       // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommanderOverrideData*                 AxisCommanderOverrideData;                         // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceOverrideData*                  AlliesResourceOverrideData;                        // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceOverrideData*                  AxisResourceOverrideData;                          // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPersonalStatsListDataAsset*            AlliesStatOverrideData;                            // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPersonalStatsListDataAsset*            AxisStatOverrideData;                              // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapMetaTemplate">();
	}
	static class UHLLMapMetaTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapMetaTemplate>();
	}
};
static_assert(alignof(UHLLMapMetaTemplate) == 0x000008, "Wrong alignment on UHLLMapMetaTemplate");
static_assert(sizeof(UHLLMapMetaTemplate) == 0x000188, "Wrong size on UHLLMapMetaTemplate");
static_assert(offsetof(UHLLMapMetaTemplate, OffensiveModeAttackingTeam) == 0x000030, "Member 'UHLLMapMetaTemplate::OffensiveModeAttackingTeam' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, PracticeRangeTeam) == 0x000031, "Member 'UHLLMapMetaTemplate::PracticeRangeTeam' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, MapCentre) == 0x000034, "Member 'UHLLMapMetaTemplate::MapCentre' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, SectorWidth) == 0x00003C, "Member 'UHLLMapMetaTemplate::SectorWidth' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, SectorHeight) == 0x000040, "Member 'UHLLMapMetaTemplate::SectorHeight' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, MapWidth) == 0x000044, "Member 'UHLLMapMetaTemplate::MapWidth' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, MapHeight) == 0x000048, "Member 'UHLLMapMetaTemplate::MapHeight' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, InitialMapZoomLevel) == 0x00004C, "Member 'UHLLMapMetaTemplate::InitialMapZoomLevel' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, UseInitialMapZoomLevel) == 0x000050, "Member 'UHLLMapMetaTemplate::UseInitialMapZoomLevel' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, Sectors) == 0x000058, "Member 'UHLLMapMetaTemplate::Sectors' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, MapFriendlyName) == 0x000068, "Member 'UHLLMapMetaTemplate::MapFriendlyName' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, MapId) == 0x000080, "Member 'UHLLMapMetaTemplate::MapId' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, bIsNightMap) == 0x000090, "Member 'UHLLMapMetaTemplate::bIsNightMap' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, bIncrementMapAchievement) == 0x000091, "Member 'UHLLMapMetaTemplate::bIncrementMapAchievement' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AchievementStat) == 0x000092, "Member 'UHLLMapMetaTemplate::AchievementStat' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, MapSpecificAchievementData) == 0x000098, "Member 'UHLLMapMetaTemplate::MapSpecificAchievementData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, MapMetaDataAmbientSound) == 0x0000A0, "Member 'UHLLMapMetaTemplate::MapMetaDataAmbientSound' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, MapShortName) == 0x0000A8, "Member 'UHLLMapMetaTemplate::MapShortName' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, Orientation) == 0x0000C0, "Member 'UHLLMapMetaTemplate::Orientation' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, OverrideWarmUpBoundsVolume) == 0x0000C1, "Member 'UHLLMapMetaTemplate::OverrideWarmUpBoundsVolume' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, WarmUpVolumeSize) == 0x0000C4, "Member 'UHLLMapMetaTemplate::WarmUpVolumeSize' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, WarmUpVolumePosition) == 0x0000CC, "Member 'UHLLMapMetaTemplate::WarmUpVolumePosition' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, ProhibitedAchievementsData) == 0x0000D8, "Member 'UHLLMapMetaTemplate::ProhibitedAchievementsData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, CosmeticDivisions) == 0x0000E0, "Member 'UHLLMapMetaTemplate::CosmeticDivisions' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, bUsingConquestRuleset) == 0x0000F0, "Member 'UHLLMapMetaTemplate::bUsingConquestRuleset' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, InitialConquestTickets) == 0x0000F2, "Member 'UHLLMapMetaTemplate::InitialConquestTickets' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, OverviewImage) == 0x0000F8, "Member 'UHLLMapMetaTemplate::OverviewImage' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, CompassOffset) == 0x000120, "Member 'UHLLMapMetaTemplate::CompassOffset' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AxisFaction) == 0x000124, "Member 'UHLLMapMetaTemplate::AxisFaction' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AlliesFaction) == 0x000125, "Member 'UHLLMapMetaTemplate::AlliesFaction' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AxisAbilityData) == 0x000128, "Member 'UHLLMapMetaTemplate::AxisAbilityData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AlliesAbilityData) == 0x000130, "Member 'UHLLMapMetaTemplate::AlliesAbilityData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, WeatherManagerData) == 0x000138, "Member 'UHLLMapMetaTemplate::WeatherManagerData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, PlatoonOverrideData) == 0x000140, "Member 'UHLLMapMetaTemplate::PlatoonOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AlliesLoadoutOverrideData) == 0x000148, "Member 'UHLLMapMetaTemplate::AlliesLoadoutOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AxisLoadoutOverrideData) == 0x000150, "Member 'UHLLMapMetaTemplate::AxisLoadoutOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AlliesCommanderOverrideData) == 0x000158, "Member 'UHLLMapMetaTemplate::AlliesCommanderOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AxisCommanderOverrideData) == 0x000160, "Member 'UHLLMapMetaTemplate::AxisCommanderOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AlliesResourceOverrideData) == 0x000168, "Member 'UHLLMapMetaTemplate::AlliesResourceOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AxisResourceOverrideData) == 0x000170, "Member 'UHLLMapMetaTemplate::AxisResourceOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AlliesStatOverrideData) == 0x000178, "Member 'UHLLMapMetaTemplate::AlliesStatOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLMapMetaTemplate, AxisStatOverrideData) == 0x000180, "Member 'UHLLMapMetaTemplate::AxisStatOverrideData' has a wrong offset!");

// Class HLL.ShooterWeapon_Instant
// 0x0090 (0x0B40 - 0x0AB0)
class AShooterWeapon_Instant final : public AShooterWeapon
{
public:
	struct FInstantWeaponData                     InstantConfig;                                     // 0x0AA8(0x0038)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       ImpactTemplate;                                    // 0x0AE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLTracerProperties                   TracerProperties;                                  // 0x0AE8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FInstantHitInfo                        HitNotify;                                         // 0x0B00(0x0018)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SuppressionBulletRadius;                           // 0x0B18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionBulletAmount;                           // 0x0B1C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionBulletFalloff;                          // 0x0B20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionScoreModifier;                          // 0x0B24(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSuppressionShotsForScore;                       // 0x0B28(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1076[0x4];                                     // 0x0B2C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Cached_MaxRange;                                   // 0x0B30(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Cached_MaxTravelTime;                              // 0x0B34(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TracerCounter;                                     // 0x0B38(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1077[0x7];                                     // 0x0B39(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_HitNotify();
	void ServerNotifyHit(const struct FHitResult& Impact, const struct FVector_NetQuantize& TraceOrigin, const struct FVector_NetQuantizeNormal& ShootDir, int32 RandomSeed, float ReticleSpread);
	void ServerNotifyMiss(const struct FVector_NetQuantize& TraceOrigin, const struct FVector_NetQuantizeNormal& ShootDir, int32 RandomSeed, float ReticleSpread);

	float GetDamageAtRange(const float InRange) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Instant">();
	}
	static class AShooterWeapon_Instant* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Instant>();
	}
};
static_assert(alignof(AShooterWeapon_Instant) == 0x000010, "Wrong alignment on AShooterWeapon_Instant");
static_assert(sizeof(AShooterWeapon_Instant) == 0x000B40, "Wrong size on AShooterWeapon_Instant");
static_assert(offsetof(AShooterWeapon_Instant, InstantConfig) == 0x000AA8, "Member 'AShooterWeapon_Instant::InstantConfig' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, ImpactTemplate) == 0x000AE0, "Member 'AShooterWeapon_Instant::ImpactTemplate' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, TracerProperties) == 0x000AE8, "Member 'AShooterWeapon_Instant::TracerProperties' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, HitNotify) == 0x000B00, "Member 'AShooterWeapon_Instant::HitNotify' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, SuppressionBulletRadius) == 0x000B18, "Member 'AShooterWeapon_Instant::SuppressionBulletRadius' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, SuppressionBulletAmount) == 0x000B1C, "Member 'AShooterWeapon_Instant::SuppressionBulletAmount' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, SuppressionBulletFalloff) == 0x000B20, "Member 'AShooterWeapon_Instant::SuppressionBulletFalloff' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, SuppressionScoreModifier) == 0x000B24, "Member 'AShooterWeapon_Instant::SuppressionScoreModifier' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, NumSuppressionShotsForScore) == 0x000B28, "Member 'AShooterWeapon_Instant::NumSuppressionShotsForScore' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, Cached_MaxRange) == 0x000B30, "Member 'AShooterWeapon_Instant::Cached_MaxRange' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, Cached_MaxTravelTime) == 0x000B34, "Member 'AShooterWeapon_Instant::Cached_MaxTravelTime' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Instant, TracerCounter) == 0x000B38, "Member 'AShooterWeapon_Instant::TracerCounter' has a wrong offset!");

// Class HLL.BA10
// 0x0000 (0x05C0 - 0x05C0)
class ABA10 final : public ABaseReconVehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BA10">();
	}
	static class ABA10* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABA10>();
	}
};
static_assert(alignof(ABA10) == 0x000008, "Wrong alignment on ABA10");
static_assert(sizeof(ABA10) == 0x0005C0, "Wrong size on ABA10");

// Class HLL.HLLCommanderAbility
// 0x0140 (0x0360 - 0x0220)
class AHLLCommanderAbility : public AActor
{
public:
	uint8                                         Pad_1078[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	EGameResource                                 ResourceCategory;                                  // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1079[0x3];                                     // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         ResourceCost;                                      // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownTime;                                      // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_107A[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   AbilityName;                                       // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   AbilityTooltip;                                    // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            AbilityIcon;                                       // 0x0278(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bTickWhileActive : 1;                              // 0x0300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_107B[0x3];                                     // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         UserInterfacePriority;                             // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionScoreOnExecute;                              // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   UISubCategory;                                     // 0x0310(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bEnableFilters : 1;                                // 0x0328(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_107C[0x3];                                     // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         Filters;                                           // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowChatMessageWhenUsed : 1;                      // 0x0330(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_107D[0x3];                                     // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	uint32                                        SpawnLimit;                                        // 0x0334(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRepAbilityState                       ActivationState;                                   // 0x0338(0x000C)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ETeam                                         AbilityTeam;                                       // 0x0344(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_107E[0x3];                                     // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerState*                    StartedBy;                                         // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        DummyRoot;                                         // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_107F[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void K2_OnAbilityStarted();
	void K2_OnAbilityStopped();
	void OnRep_ActivationState(const struct FRepAbilityState& OldValue);
	void Server_ExecuteAbility();
	void Server_NotifyMapInteraction(const bool bEnabled);

	bool CanActivateAbility() const;
	bool CanSelectAbility() const;
	float GetActiveTime() const;
	float GetActiveTimeRemaining(const bool bUseAuthTime) const;
	float GetCooldownTime() const;
	float GetCooldownTimeRemaining(const bool bUseAuthTime) const;
	float GetProgress(const bool bUseAuthTime) const;
	bool IsActive() const;
	bool IsMapInteractionEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility">();
	}
	static class AHLLCommanderAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility>();
	}
};
static_assert(alignof(AHLLCommanderAbility) == 0x000008, "Wrong alignment on AHLLCommanderAbility");
static_assert(sizeof(AHLLCommanderAbility) == 0x000360, "Wrong size on AHLLCommanderAbility");
static_assert(offsetof(AHLLCommanderAbility, ResourceCategory) == 0x000238, "Member 'AHLLCommanderAbility::ResourceCategory' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, ResourceCost) == 0x00023C, "Member 'AHLLCommanderAbility::ResourceCost' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, CooldownTime) == 0x000240, "Member 'AHLLCommanderAbility::CooldownTime' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, AbilityName) == 0x000248, "Member 'AHLLCommanderAbility::AbilityName' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, AbilityTooltip) == 0x000260, "Member 'AHLLCommanderAbility::AbilityTooltip' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, AbilityIcon) == 0x000278, "Member 'AHLLCommanderAbility::AbilityIcon' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, UserInterfacePriority) == 0x000304, "Member 'AHLLCommanderAbility::UserInterfacePriority' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, ActionScoreOnExecute) == 0x000308, "Member 'AHLLCommanderAbility::ActionScoreOnExecute' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, UISubCategory) == 0x000310, "Member 'AHLLCommanderAbility::UISubCategory' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, Filters) == 0x00032C, "Member 'AHLLCommanderAbility::Filters' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, SpawnLimit) == 0x000334, "Member 'AHLLCommanderAbility::SpawnLimit' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, ActivationState) == 0x000338, "Member 'AHLLCommanderAbility::ActivationState' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, AbilityTeam) == 0x000344, "Member 'AHLLCommanderAbility::AbilityTeam' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, StartedBy) == 0x000348, "Member 'AHLLCommanderAbility::StartedBy' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility, DummyRoot) == 0x000350, "Member 'AHLLCommanderAbility::DummyRoot' has a wrong offset!");

// Class HLL.HLLAbility_PassiveBase
// 0x0010 (0x0370 - 0x0360)
class AHLLAbility_PassiveBase : public AHLLCommanderAbility
{
public:
	float                                         AbilityTime;                                       // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1083[0xC];                                     // 0x0364(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbility_PassiveBase">();
	}
	static class AHLLAbility_PassiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbility_PassiveBase>();
	}
};
static_assert(alignof(AHLLAbility_PassiveBase) == 0x000008, "Wrong alignment on AHLLAbility_PassiveBase");
static_assert(sizeof(AHLLAbility_PassiveBase) == 0x000370, "Wrong size on AHLLAbility_PassiveBase");
static_assert(offsetof(AHLLAbility_PassiveBase, AbilityTime) == 0x000360, "Member 'AHLLAbility_PassiveBase::AbilityTime' has a wrong offset!");

// Class HLL.BaseAutomatedTestAction
// 0x0020 (0x0050 - 0x0030)
class UBaseAutomatedTestAction : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_1084[0x10];                                    // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnComplete;                                        // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAutomatedTestAction">();
	}
	static class UBaseAutomatedTestAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAutomatedTestAction>();
	}
};
static_assert(alignof(UBaseAutomatedTestAction) == 0x000008, "Wrong alignment on UBaseAutomatedTestAction");
static_assert(sizeof(UBaseAutomatedTestAction) == 0x000050, "Wrong size on UBaseAutomatedTestAction");
static_assert(offsetof(UBaseAutomatedTestAction, OnComplete) == 0x000040, "Member 'UBaseAutomatedTestAction::OnComplete' has a wrong offset!");

// Class HLL.SoundPlayedOnlyWhileAnimationRuns
// 0x0028 (0x0058 - 0x0030)
class USoundPlayedOnlyWhileAnimationRuns final : public UAnimNotifyState
{
public:
	class USoundBase*                             Sound;                                             // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollow : 1;                                       // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1085[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   AttachName;                                        // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1086[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UAudioComponent*                        PlayingSound;                                      // 0x0050(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPlayedOnlyWhileAnimationRuns">();
	}
	static class USoundPlayedOnlyWhileAnimationRuns* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundPlayedOnlyWhileAnimationRuns>();
	}
};
static_assert(alignof(USoundPlayedOnlyWhileAnimationRuns) == 0x000008, "Wrong alignment on USoundPlayedOnlyWhileAnimationRuns");
static_assert(sizeof(USoundPlayedOnlyWhileAnimationRuns) == 0x000058, "Wrong size on USoundPlayedOnlyWhileAnimationRuns");
static_assert(offsetof(USoundPlayedOnlyWhileAnimationRuns, Sound) == 0x000030, "Member 'USoundPlayedOnlyWhileAnimationRuns::Sound' has a wrong offset!");
static_assert(offsetof(USoundPlayedOnlyWhileAnimationRuns, VolumeMultiplier) == 0x000038, "Member 'USoundPlayedOnlyWhileAnimationRuns::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(USoundPlayedOnlyWhileAnimationRuns, PitchMultiplier) == 0x00003C, "Member 'USoundPlayedOnlyWhileAnimationRuns::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(USoundPlayedOnlyWhileAnimationRuns, AttachName) == 0x000044, "Member 'USoundPlayedOnlyWhileAnimationRuns::AttachName' has a wrong offset!");
static_assert(offsetof(USoundPlayedOnlyWhileAnimationRuns, PlayingSound) == 0x000050, "Member 'USoundPlayedOnlyWhileAnimationRuns::PlayingSound' has a wrong offset!");

// Class HLL.BaseAutomatedTestActor
// 0x0008 (0x0228 - 0x0220)
class ABaseAutomatedTestActor final : public AActor
{
public:
	uint8                                         Pad_1087[0x8];                                     // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void FailTest(const class FString& Reason);
	void OnTestFailed();
	void OnTestPassed();
	void PassTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAutomatedTestActor">();
	}
	static class ABaseAutomatedTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseAutomatedTestActor>();
	}
};
static_assert(alignof(ABaseAutomatedTestActor) == 0x000008, "Wrong alignment on ABaseAutomatedTestActor");
static_assert(sizeof(ABaseAutomatedTestActor) == 0x000228, "Wrong size on ABaseAutomatedTestActor");

// Class HLL.BaseCompassIndicator
// 0x0020 (0x0250 - 0x0230)
class UBaseCompassIndicator : public UUserWidget
{
public:
	bool                                          bShouldShowOffscreen;                              // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1088[0x3];                                     // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         OpaqueDistance;                                    // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransparentDistance;                               // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Alignment;                                         // 0x023C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnScreen : 1;                                     // 0x0244(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1089[0x3];                                     // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         NormalisedPosition;                                // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108A[0x4];                                     // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCompassIndicator">();
	}
	static class UBaseCompassIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCompassIndicator>();
	}
};
static_assert(alignof(UBaseCompassIndicator) == 0x000008, "Wrong alignment on UBaseCompassIndicator");
static_assert(sizeof(UBaseCompassIndicator) == 0x000250, "Wrong size on UBaseCompassIndicator");
static_assert(offsetof(UBaseCompassIndicator, bShouldShowOffscreen) == 0x000230, "Member 'UBaseCompassIndicator::bShouldShowOffscreen' has a wrong offset!");
static_assert(offsetof(UBaseCompassIndicator, OpaqueDistance) == 0x000234, "Member 'UBaseCompassIndicator::OpaqueDistance' has a wrong offset!");
static_assert(offsetof(UBaseCompassIndicator, TransparentDistance) == 0x000238, "Member 'UBaseCompassIndicator::TransparentDistance' has a wrong offset!");
static_assert(offsetof(UBaseCompassIndicator, Alignment) == 0x00023C, "Member 'UBaseCompassIndicator::Alignment' has a wrong offset!");
static_assert(offsetof(UBaseCompassIndicator, NormalisedPosition) == 0x000248, "Member 'UBaseCompassIndicator::NormalisedPosition' has a wrong offset!");

// Class HLL.HLLTooltipBase
// 0x0030 (0x0260 - 0x0230)
class UHLLTooltipBase : public UUserWidget
{
public:
	float                                         ViewportEdgePadding;                               // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAnchorAtBottom : 1;                               // 0x0234(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_108B[0x3];                                     // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetAnimation*                       ShowAnimation;                                     // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Animation_ShowRate;                                // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Animation_HideRate;                                // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsDisplayed : 1;                                  // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_108C[0x3];                                     // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class UWidget>                 CurrentContextItem;                                // 0x024C(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108D[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidget*                                GeometryRestriction;                               // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFinishedHide();
	void OnFinishedShow();
	void OnHide();
	void OnShow(class UWidget* ContextItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLTooltipBase">();
	}
	static class UHLLTooltipBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLTooltipBase>();
	}
};
static_assert(alignof(UHLLTooltipBase) == 0x000008, "Wrong alignment on UHLLTooltipBase");
static_assert(sizeof(UHLLTooltipBase) == 0x000260, "Wrong size on UHLLTooltipBase");
static_assert(offsetof(UHLLTooltipBase, ViewportEdgePadding) == 0x000230, "Member 'UHLLTooltipBase::ViewportEdgePadding' has a wrong offset!");
static_assert(offsetof(UHLLTooltipBase, ShowAnimation) == 0x000238, "Member 'UHLLTooltipBase::ShowAnimation' has a wrong offset!");
static_assert(offsetof(UHLLTooltipBase, Animation_ShowRate) == 0x000240, "Member 'UHLLTooltipBase::Animation_ShowRate' has a wrong offset!");
static_assert(offsetof(UHLLTooltipBase, Animation_HideRate) == 0x000244, "Member 'UHLLTooltipBase::Animation_HideRate' has a wrong offset!");
static_assert(offsetof(UHLLTooltipBase, CurrentContextItem) == 0x00024C, "Member 'UHLLTooltipBase::CurrentContextItem' has a wrong offset!");
static_assert(offsetof(UHLLTooltipBase, GeometryRestriction) == 0x000258, "Member 'UHLLTooltipBase::GeometryRestriction' has a wrong offset!");

// Class HLL.HLLMapTooltip_Player
// 0x0018 (0x0278 - 0x0260)
class UHLLMapTooltip_Player : public UHLLTooltipBase
{
public:
	class UTextBlock*                             PlayerName;                                        // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerIcon;                                        // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerDistance;                                    // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapTooltip_Player">();
	}
	static class UHLLMapTooltip_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapTooltip_Player>();
	}
};
static_assert(alignof(UHLLMapTooltip_Player) == 0x000008, "Wrong alignment on UHLLMapTooltip_Player");
static_assert(sizeof(UHLLMapTooltip_Player) == 0x000278, "Wrong size on UHLLMapTooltip_Player");
static_assert(offsetof(UHLLMapTooltip_Player, PlayerName) == 0x000260, "Member 'UHLLMapTooltip_Player::PlayerName' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Player, PlayerIcon) == 0x000268, "Member 'UHLLMapTooltip_Player::PlayerIcon' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Player, PlayerDistance) == 0x000270, "Member 'UHLLMapTooltip_Player::PlayerDistance' has a wrong offset!");

// Class HLL.SoundNodeDistanceDelay
// 0x0010 (0x0058 - 0x0048)
class USoundNodeDistanceDelay final : public USoundNode
{
public:
	float                                         SpeedOfSound;                                      // 0x0048(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BypassDistance;                                    // 0x004C(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDelay;                                          // 0x0050(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108E[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeDistanceDelay">();
	}
	static class USoundNodeDistanceDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeDistanceDelay>();
	}
};
static_assert(alignof(USoundNodeDistanceDelay) == 0x000008, "Wrong alignment on USoundNodeDistanceDelay");
static_assert(sizeof(USoundNodeDistanceDelay) == 0x000058, "Wrong size on USoundNodeDistanceDelay");
static_assert(offsetof(USoundNodeDistanceDelay, SpeedOfSound) == 0x000048, "Member 'USoundNodeDistanceDelay::SpeedOfSound' has a wrong offset!");
static_assert(offsetof(USoundNodeDistanceDelay, BypassDistance) == 0x00004C, "Member 'USoundNodeDistanceDelay::BypassDistance' has a wrong offset!");
static_assert(offsetof(USoundNodeDistanceDelay, MaxDelay) == 0x000050, "Member 'USoundNodeDistanceDelay::MaxDelay' has a wrong offset!");

// Class HLL.BaseTruck
// 0x0040 (0x0568 - 0x0528)
class ABaseTruck : public ABaseVehicle
{
public:
	uint8                                         Pad_108F[0x8];                                     // 0x0528(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AHLLSeat>                   FrontPassengerSeatClass;                           // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumBackPassengerSeats;                             // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1090[0x4];                                     // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AHLLSeat>                   BackPassengerSeatClass;                            // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLSeat*                               FrontPassengerSeat;                                // 0x0548(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHLLSeat*>                       BackPassengerSeats;                                // 0x0550(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourCollisionMesh*                ArmourCollision_Body;                              // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_FrontPassengerSeat();
	void OnRep_SeatCommon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTruck">();
	}
	static class ABaseTruck* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseTruck>();
	}
};
static_assert(alignof(ABaseTruck) == 0x000008, "Wrong alignment on ABaseTruck");
static_assert(sizeof(ABaseTruck) == 0x000568, "Wrong size on ABaseTruck");
static_assert(offsetof(ABaseTruck, FrontPassengerSeatClass) == 0x000530, "Member 'ABaseTruck::FrontPassengerSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseTruck, NumBackPassengerSeats) == 0x000538, "Member 'ABaseTruck::NumBackPassengerSeats' has a wrong offset!");
static_assert(offsetof(ABaseTruck, BackPassengerSeatClass) == 0x000540, "Member 'ABaseTruck::BackPassengerSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseTruck, FrontPassengerSeat) == 0x000548, "Member 'ABaseTruck::FrontPassengerSeat' has a wrong offset!");
static_assert(offsetof(ABaseTruck, BackPassengerSeats) == 0x000550, "Member 'ABaseTruck::BackPassengerSeats' has a wrong offset!");
static_assert(offsetof(ABaseTruck, ArmourCollision_Body) == 0x000560, "Member 'ABaseTruck::ArmourCollision_Body' has a wrong offset!");

// Class HLL.HLLMouseCursor
// 0x0008 (0x0238 - 0x0230)
class UHLLMouseCursor : public UUserWidget
{
public:
	uint8                                         Pad_1091[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InputChanged(bool bUsingGamepad);
	void ReceiveSetCursorVisiblity(bool bCursorHidden);
	void UpdateCursorVisiblity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMouseCursor">();
	}
	static class UHLLMouseCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMouseCursor>();
	}
};
static_assert(alignof(UHLLMouseCursor) == 0x000008, "Wrong alignment on UHLLMouseCursor");
static_assert(sizeof(UHLLMouseCursor) == 0x000238, "Wrong size on UHLLMouseCursor");

// Class HLL.BaseHalftrack
// 0x0050 (0x05B8 - 0x0568)
class ABaseHalftrack : public ABaseTruck
{
public:
	TSubclassOf<class AMobileSpawn>               MobileSpawnClass;                                  // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHalfTrackSpawnAudioMode                      SpawnAudioMode;                                    // 0x0570(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1092[0x7];                                     // 0x0571(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AMobileSpawn*                           MobileSpawn;                                       // 0x0578(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        TracksAudio;                                       // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        SpawnAudio;                                        // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHLLArmourCollisionMesh*                ArmourCollision_Tracks;                            // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TurretAudioAttachSocket;                           // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehicleMGController*                   MGController;                                      // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHalfTrackTurretController*             TurretController;                                  // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        TurretYawAudio;                                    // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_SpawnAudioMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseHalftrack">();
	}
	static class ABaseHalftrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseHalftrack>();
	}
};
static_assert(alignof(ABaseHalftrack) == 0x000008, "Wrong alignment on ABaseHalftrack");
static_assert(sizeof(ABaseHalftrack) == 0x0005B8, "Wrong size on ABaseHalftrack");
static_assert(offsetof(ABaseHalftrack, MobileSpawnClass) == 0x000568, "Member 'ABaseHalftrack::MobileSpawnClass' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, SpawnAudioMode) == 0x000570, "Member 'ABaseHalftrack::SpawnAudioMode' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, MobileSpawn) == 0x000578, "Member 'ABaseHalftrack::MobileSpawn' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, TracksAudio) == 0x000580, "Member 'ABaseHalftrack::TracksAudio' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, SpawnAudio) == 0x000588, "Member 'ABaseHalftrack::SpawnAudio' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, ArmourCollision_Tracks) == 0x000590, "Member 'ABaseHalftrack::ArmourCollision_Tracks' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, TurretAudioAttachSocket) == 0x000598, "Member 'ABaseHalftrack::TurretAudioAttachSocket' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, MGController) == 0x0005A0, "Member 'ABaseHalftrack::MGController' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, TurretController) == 0x0005A8, "Member 'ABaseHalftrack::TurretController' has a wrong offset!");
static_assert(offsetof(ABaseHalftrack, TurretYawAudio) == 0x0005B0, "Member 'ABaseHalftrack::TurretYawAudio' has a wrong offset!");

// Class HLL.ShooterWeapon_Hammer
// 0x0030 (0x0AE0 - 0x0AB0)
class AShooterWeapon_Hammer : public AShooterWeapon
{
public:
	float                                         UpgradeRange;                                      // 0x0AA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Timer;                                             // 0x0AAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UpgradePerTimer;                                   // 0x0AB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  CurrentUpgradeTarget;                              // 0x0AB4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TierWhenStarted;                                   // 0x0ABC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1093[0x23];                                    // 0x0ABD(0x0023)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClientStopUpgrading(const bool bWasInProgress);
	void OnFreelookStart();
	void ServerStartUpgrading(class AActor* Target, const uint8 ClientTier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Hammer">();
	}
	static class AShooterWeapon_Hammer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Hammer>();
	}
};
static_assert(alignof(AShooterWeapon_Hammer) == 0x000010, "Wrong alignment on AShooterWeapon_Hammer");
static_assert(sizeof(AShooterWeapon_Hammer) == 0x000AE0, "Wrong size on AShooterWeapon_Hammer");
static_assert(offsetof(AShooterWeapon_Hammer, UpgradeRange) == 0x000AA8, "Member 'AShooterWeapon_Hammer::UpgradeRange' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Hammer, Timer) == 0x000AAC, "Member 'AShooterWeapon_Hammer::Timer' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Hammer, UpgradePerTimer) == 0x000AB0, "Member 'AShooterWeapon_Hammer::UpgradePerTimer' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Hammer, CurrentUpgradeTarget) == 0x000AB4, "Member 'AShooterWeapon_Hammer::CurrentUpgradeTarget' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Hammer, TierWhenStarted) == 0x000ABC, "Member 'AShooterWeapon_Hammer::TierWhenStarted' has a wrong offset!");

// Class HLL.BaseJeep
// 0x0000 (0x0568 - 0x0568)
class ABaseJeep final : public ABaseTruck
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseJeep">();
	}
	static class ABaseJeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseJeep>();
	}
};
static_assert(alignof(ABaseJeep) == 0x000008, "Wrong alignment on ABaseJeep");
static_assert(sizeof(ABaseJeep) == 0x000568, "Wrong size on ABaseJeep");

// Class HLL.DynamicSpawn
// 0x01E8 (0x0408 - 0x0220)
class ADynamicSpawn : public AActor
{
public:
	uint8                                         Pad_1095[0x68];                                    // 0x0220(0x0068)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDynamicSpawnGatherParams              SpawnGatherParams;                                 // 0x0288(0x0014)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         WaveIntervalSeconds;                               // 0x029C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLPlatoon*                            M_owningPlatoon;                                   // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         M_OwningTeam;                                      // 0x02A8(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1096[0x3];                                     // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         M_nextWaveTime;                                    // 0x02AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DismantleTime;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDynamicSpawnType                             DynamicSpawnType;                                  // 0x02B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x02B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1097[0x2];                                     // 0x02B6(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   UnitSpawnOnScoreAction;                            // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TeamSpawnOnScoreAction;                            // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionScoreNameDismantle;                          // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x02D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         DestroyedByEnemyManpowerPenalty;                   // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinEnemyPlayersToOverrun;                          // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             EnemyDestroyedSound;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   EnemyDestroyedMessage;                             // 0x02F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         OverrunSphereRadius;                               // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  OverrunQuery;                                      // 0x0314(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1098[0x34];                                    // 0x031C(0x0034)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerState*                    SpawnedByPlayer;                                   // 0x0350(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        DummyRoot;                                         // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LoopingAC;                                         // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          GhostBlockerComponent;                             // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSimpleHealthComponent*              HealthComponent;                                   // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDismantlingComponent*                  DismantlingComponent;                              // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRepGhostBarrier                       GhostBarrierInfo;                                  // 0x0398(0x0010)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UNearbySpawnEnemyDetection*             NearbySpawnEnemyDetection;                         // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1099[0x18];                                    // 0x03B0(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bDetectNearbyEnemies : 1;                          // 0x03C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_109A[0x3];                                     // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         EnemyDetectionDistance;                            // 0x03CC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyBlockingDistance;                             // 0x03D0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NonFriendlySectorBlockingDistance;                 // 0x03D4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnBlockingCooldown;                             // 0x03D8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanBeRemovedByCommander : 1;                      // 0x03DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, DisableEditOnInstance, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_109B[0x3];                                     // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   OwnerMessageWhenRemoved;                           // 0x03E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                             AbilityRemovedSound;                               // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHint                                         HintWhenSpawnedOn;                                 // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109C[0x7];                                     // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnKilled(class UHLLSimpleHealthComponent* HealtComp);
	void OnRep_GhostBarrierInfo();

	bool CanBeRemovedByCommander() const;
	bool CanPlayerSelectForSpawn(const class AShooterPlayerState* InPS) const;
	bool IsSpawningBlocked() const;
	float NextWaveTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicSpawn">();
	}
	static class ADynamicSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicSpawn>();
	}
};
static_assert(alignof(ADynamicSpawn) == 0x000008, "Wrong alignment on ADynamicSpawn");
static_assert(sizeof(ADynamicSpawn) == 0x000408, "Wrong size on ADynamicSpawn");
static_assert(offsetof(ADynamicSpawn, SpawnGatherParams) == 0x000288, "Member 'ADynamicSpawn::SpawnGatherParams' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, WaveIntervalSeconds) == 0x00029C, "Member 'ADynamicSpawn::WaveIntervalSeconds' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, M_owningPlatoon) == 0x0002A0, "Member 'ADynamicSpawn::M_owningPlatoon' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, M_OwningTeam) == 0x0002A8, "Member 'ADynamicSpawn::M_OwningTeam' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, M_nextWaveTime) == 0x0002AC, "Member 'ADynamicSpawn::M_nextWaveTime' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, DismantleTime) == 0x0002B0, "Member 'ADynamicSpawn::DismantleTime' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, DynamicSpawnType) == 0x0002B4, "Member 'ADynamicSpawn::DynamicSpawnType' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, DamageFilterType) == 0x0002B5, "Member 'ADynamicSpawn::DamageFilterType' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, UnitSpawnOnScoreAction) == 0x0002B8, "Member 'ADynamicSpawn::UnitSpawnOnScoreAction' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, TeamSpawnOnScoreAction) == 0x0002C0, "Member 'ADynamicSpawn::TeamSpawnOnScoreAction' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, ActionScoreNameDismantle) == 0x0002C8, "Member 'ADynamicSpawn::ActionScoreNameDismantle' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, DisplayName) == 0x0002D0, "Member 'ADynamicSpawn::DisplayName' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, DestroyedByEnemyManpowerPenalty) == 0x0002E8, "Member 'ADynamicSpawn::DestroyedByEnemyManpowerPenalty' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, MinEnemyPlayersToOverrun) == 0x0002EC, "Member 'ADynamicSpawn::MinEnemyPlayersToOverrun' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, EnemyDestroyedSound) == 0x0002F0, "Member 'ADynamicSpawn::EnemyDestroyedSound' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, EnemyDestroyedMessage) == 0x0002F8, "Member 'ADynamicSpawn::EnemyDestroyedMessage' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, OverrunSphereRadius) == 0x000310, "Member 'ADynamicSpawn::OverrunSphereRadius' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, OverrunQuery) == 0x000314, "Member 'ADynamicSpawn::OverrunQuery' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, SpawnedByPlayer) == 0x000350, "Member 'ADynamicSpawn::SpawnedByPlayer' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, DummyRoot) == 0x000358, "Member 'ADynamicSpawn::DummyRoot' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, MeshComponent) == 0x000360, "Member 'ADynamicSpawn::MeshComponent' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, LoopingAC) == 0x000368, "Member 'ADynamicSpawn::LoopingAC' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, MapComponent) == 0x000370, "Member 'ADynamicSpawn::MapComponent' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, IndicatorComponent) == 0x000378, "Member 'ADynamicSpawn::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, GhostBlockerComponent) == 0x000380, "Member 'ADynamicSpawn::GhostBlockerComponent' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, HealthComponent) == 0x000388, "Member 'ADynamicSpawn::HealthComponent' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, DismantlingComponent) == 0x000390, "Member 'ADynamicSpawn::DismantlingComponent' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, GhostBarrierInfo) == 0x000398, "Member 'ADynamicSpawn::GhostBarrierInfo' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, NearbySpawnEnemyDetection) == 0x0003A8, "Member 'ADynamicSpawn::NearbySpawnEnemyDetection' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, EnemyDetectionDistance) == 0x0003CC, "Member 'ADynamicSpawn::EnemyDetectionDistance' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, EnemyBlockingDistance) == 0x0003D0, "Member 'ADynamicSpawn::EnemyBlockingDistance' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, NonFriendlySectorBlockingDistance) == 0x0003D4, "Member 'ADynamicSpawn::NonFriendlySectorBlockingDistance' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, SpawnBlockingCooldown) == 0x0003D8, "Member 'ADynamicSpawn::SpawnBlockingCooldown' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, OwnerMessageWhenRemoved) == 0x0003E0, "Member 'ADynamicSpawn::OwnerMessageWhenRemoved' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, AbilityRemovedSound) == 0x0003F8, "Member 'ADynamicSpawn::AbilityRemovedSound' has a wrong offset!");
static_assert(offsetof(ADynamicSpawn, HintWhenSpawnedOn) == 0x000400, "Member 'ADynamicSpawn::HintWhenSpawnedOn' has a wrong offset!");

// Class HLL.HLLMapTooltip_Supplies
// 0x0010 (0x0270 - 0x0260)
class UHLLMapTooltip_Supplies : public UHLLTooltipBase
{
public:
	class UTextBlock*                             TypeText;                                          // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RemainingText;                                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapTooltip_Supplies">();
	}
	static class UHLLMapTooltip_Supplies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapTooltip_Supplies>();
	}
};
static_assert(alignof(UHLLMapTooltip_Supplies) == 0x000008, "Wrong alignment on UHLLMapTooltip_Supplies");
static_assert(sizeof(UHLLMapTooltip_Supplies) == 0x000270, "Wrong size on UHLLMapTooltip_Supplies");
static_assert(offsetof(UHLLMapTooltip_Supplies, TypeText) == 0x000260, "Member 'UHLLMapTooltip_Supplies::TypeText' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Supplies, RemainingText) == 0x000268, "Member 'UHLLMapTooltip_Supplies::RemainingText' has a wrong offset!");

// Class HLL.SmoothNetworkedMovement
// 0x0070 (0x0120 - 0x00B0)
class alignas(0x10) USmoothNetworkedMovement final : public UActorComponent
{
public:
	uint8                                         bInterpMovement : 1;                               // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInterpRotation : 1;                               // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109E[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         InterpLocationTime;                                // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpRotationTime;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpLocationMaxLagDistance;                      // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpLocationSnapToTargetDistance;                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalLocationInterpSpeed;                          // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        UpdatedComponent;                                  // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109F[0x50];                                    // 0x00D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothNetworkedMovement">();
	}
	static class USmoothNetworkedMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothNetworkedMovement>();
	}
};
static_assert(alignof(USmoothNetworkedMovement) == 0x000010, "Wrong alignment on USmoothNetworkedMovement");
static_assert(sizeof(USmoothNetworkedMovement) == 0x000120, "Wrong size on USmoothNetworkedMovement");
static_assert(offsetof(USmoothNetworkedMovement, InterpLocationTime) == 0x0000B4, "Member 'USmoothNetworkedMovement::InterpLocationTime' has a wrong offset!");
static_assert(offsetof(USmoothNetworkedMovement, InterpRotationTime) == 0x0000B8, "Member 'USmoothNetworkedMovement::InterpRotationTime' has a wrong offset!");
static_assert(offsetof(USmoothNetworkedMovement, InterpLocationMaxLagDistance) == 0x0000BC, "Member 'USmoothNetworkedMovement::InterpLocationMaxLagDistance' has a wrong offset!");
static_assert(offsetof(USmoothNetworkedMovement, InterpLocationSnapToTargetDistance) == 0x0000C0, "Member 'USmoothNetworkedMovement::InterpLocationSnapToTargetDistance' has a wrong offset!");
static_assert(offsetof(USmoothNetworkedMovement, FinalLocationInterpSpeed) == 0x0000C4, "Member 'USmoothNetworkedMovement::FinalLocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(USmoothNetworkedMovement, UpdatedComponent) == 0x0000C8, "Member 'USmoothNetworkedMovement::UpdatedComponent' has a wrong offset!");

// Class HLL.PreplacedSpawn
// 0x0058 (0x0460 - 0x0408)
class APreplacedSpawn : public ADynamicSpawn
{
public:
	struct FSupportedGameModes                    SupportedGameModes;                                // 0x0408(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         Group;                                             // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A0[0x4];                                     // 0x045C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreplacedSpawn">();
	}
	static class APreplacedSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreplacedSpawn>();
	}
};
static_assert(alignof(APreplacedSpawn) == 0x000008, "Wrong alignment on APreplacedSpawn");
static_assert(sizeof(APreplacedSpawn) == 0x000460, "Wrong size on APreplacedSpawn");
static_assert(offsetof(APreplacedSpawn, SupportedGameModes) == 0x000408, "Member 'APreplacedSpawn::SupportedGameModes' has a wrong offset!");
static_assert(offsetof(APreplacedSpawn, Group) == 0x000458, "Member 'APreplacedSpawn::Group' has a wrong offset!");

// Class HLL.HLLMapDataBase
// 0x0018 (0x0238 - 0x0220)
class AHLLMapDataBase : public AActor
{
public:
	TSubclassOf<class UHLLMapIconBase>            IconClass;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRepMapPosition                        MapPosition;                                       // 0x0228(0x0008)(Edit, Net, DisableEditOnInstance, EditConst, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bOwnerIsMovable : 1;                               // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_10A1[0x7];                                     // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_MapPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapDataBase">();
	}
	static class AHLLMapDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapDataBase>();
	}
};
static_assert(alignof(AHLLMapDataBase) == 0x000008, "Wrong alignment on AHLLMapDataBase");
static_assert(sizeof(AHLLMapDataBase) == 0x000238, "Wrong size on AHLLMapDataBase");
static_assert(offsetof(AHLLMapDataBase, IconClass) == 0x000220, "Member 'AHLLMapDataBase::IconClass' has a wrong offset!");
static_assert(offsetof(AHLLMapDataBase, MapPosition) == 0x000228, "Member 'AHLLMapDataBase::MapPosition' has a wrong offset!");

// Class HLL.HLLMapData_Basic
// 0x0010 (0x0248 - 0x0238)
class AHLLMapData_Basic : public AHLLMapDataBase
{
public:
	uint8                                         Pad_10A2[0x8];                                     // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	ETeam                                         ObjectTeam;                                        // 0x0240(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A3[0x7];                                     // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Basic">();
	}
	static class AHLLMapData_Basic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Basic>();
	}
};
static_assert(alignof(AHLLMapData_Basic) == 0x000008, "Wrong alignment on AHLLMapData_Basic");
static_assert(sizeof(AHLLMapData_Basic) == 0x000248, "Wrong size on AHLLMapData_Basic");
static_assert(offsetof(AHLLMapData_Basic, ObjectTeam) == 0x000240, "Member 'AHLLMapData_Basic::ObjectTeam' has a wrong offset!");

// Class HLL.HLLMapData_SeatBase
// 0x0018 (0x0260 - 0x0248)
class AHLLMapData_SeatBase : public AHLLMapData_Basic
{
public:
	TArray<class AShooterPlayerState*>            Occupants;                                         // 0x0248(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RepYaw;                                            // 0x0258(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReplicateYaw : 1;                                 // 0x0259(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_10A4[0x6];                                     // 0x025A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_SeatBase">();
	}
	static class AHLLMapData_SeatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_SeatBase>();
	}
};
static_assert(alignof(AHLLMapData_SeatBase) == 0x000008, "Wrong alignment on AHLLMapData_SeatBase");
static_assert(sizeof(AHLLMapData_SeatBase) == 0x000260, "Wrong size on AHLLMapData_SeatBase");
static_assert(offsetof(AHLLMapData_SeatBase, Occupants) == 0x000248, "Member 'AHLLMapData_SeatBase::Occupants' has a wrong offset!");
static_assert(offsetof(AHLLMapData_SeatBase, RepYaw) == 0x000258, "Member 'AHLLMapData_SeatBase::RepYaw' has a wrong offset!");

// Class HLL.HLLMapData_Vehicle
// 0x0000 (0x0260 - 0x0260)
class AHLLMapData_Vehicle : public AHLLMapData_SeatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Vehicle">();
	}
	static class AHLLMapData_Vehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Vehicle>();
	}
};
static_assert(alignof(AHLLMapData_Vehicle) == 0x000008, "Wrong alignment on AHLLMapData_Vehicle");
static_assert(sizeof(AHLLMapData_Vehicle) == 0x000260, "Wrong size on AHLLMapData_Vehicle");

// Class HLL.HLLMapData_HalfTrack
// 0x0008 (0x0268 - 0x0260)
class AHLLMapData_HalfTrack final : public AHLLMapData_Vehicle
{
public:
	class AMobileSpawn*                           LinkedSpawn;                                       // 0x0260(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_HalfTrack">();
	}
	static class AHLLMapData_HalfTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_HalfTrack>();
	}
};
static_assert(alignof(AHLLMapData_HalfTrack) == 0x000008, "Wrong alignment on AHLLMapData_HalfTrack");
static_assert(sizeof(AHLLMapData_HalfTrack) == 0x000268, "Wrong size on AHLLMapData_HalfTrack");
static_assert(offsetof(AHLLMapData_HalfTrack, LinkedSpawn) == 0x000260, "Member 'AHLLMapData_HalfTrack::LinkedSpawn' has a wrong offset!");

// Class HLL.BaseLineSectorSpawn
// 0x0000 (0x0460 - 0x0460)
class ABaseLineSectorSpawn final : public APreplacedSpawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLineSectorSpawn">();
	}
	static class ABaseLineSectorSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseLineSectorSpawn>();
	}
};
static_assert(alignof(ABaseLineSectorSpawn) == 0x000008, "Wrong alignment on ABaseLineSectorSpawn");
static_assert(sizeof(ABaseLineSectorSpawn) == 0x000460, "Wrong size on ABaseLineSectorSpawn");

// Class HLL.HLLParticleModule_Base
// 0x0000 (0x0030 - 0x0030)
class UHLLParticleModule_Base : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLParticleModule_Base">();
	}
	static class UHLLParticleModule_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLParticleModule_Base>();
	}
};
static_assert(alignof(UHLLParticleModule_Base) == 0x000008, "Wrong alignment on UHLLParticleModule_Base");
static_assert(sizeof(UHLLParticleModule_Base) == 0x000030, "Wrong size on UHLLParticleModule_Base");

// Class HLL.HLLParticleModule_KillSphere
// 0x0030 (0x0060 - 0x0030)
class UHLLParticleModule_KillSphere final : public UHLLParticleModule_Base
{
public:
	struct FRawDistributionFloat                  SphereRadius;                                      // 0x0030(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLParticleModule_KillSphere">();
	}
	static class UHLLParticleModule_KillSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLParticleModule_KillSphere>();
	}
};
static_assert(alignof(UHLLParticleModule_KillSphere) == 0x000008, "Wrong alignment on UHLLParticleModule_KillSphere");
static_assert(sizeof(UHLLParticleModule_KillSphere) == 0x000060, "Wrong size on UHLLParticleModule_KillSphere");
static_assert(offsetof(UHLLParticleModule_KillSphere, SphereRadius) == 0x000030, "Member 'UHLLParticleModule_KillSphere::SphereRadius' has a wrong offset!");

// Class HLL.VoipMicCheckWidget
// 0x0020 (0x0250 - 0x0230)
class UVoipMicCheckWidget : public UUserWidget
{
public:
	class USlider*                                MicVolumeSlider;                                   // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlider*                                VoiceVolumeSlider;                                 // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UComboBoxString*                        InputDevice;                                       // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UComboBoxString*                        OutputDevice;                                      // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnInputDeviceChanged(const class FString& SelectedItem, ESelectInfo SelectionType);
	void OnOutputDeviceChanged(const class FString& SelectedItem, ESelectInfo SelectionType);
	void OnSliderValueChanged(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipMicCheckWidget">();
	}
	static class UVoipMicCheckWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipMicCheckWidget>();
	}
};
static_assert(alignof(UVoipMicCheckWidget) == 0x000008, "Wrong alignment on UVoipMicCheckWidget");
static_assert(sizeof(UVoipMicCheckWidget) == 0x000250, "Wrong size on UVoipMicCheckWidget");
static_assert(offsetof(UVoipMicCheckWidget, MicVolumeSlider) == 0x000230, "Member 'UVoipMicCheckWidget::MicVolumeSlider' has a wrong offset!");
static_assert(offsetof(UVoipMicCheckWidget, VoiceVolumeSlider) == 0x000238, "Member 'UVoipMicCheckWidget::VoiceVolumeSlider' has a wrong offset!");
static_assert(offsetof(UVoipMicCheckWidget, InputDevice) == 0x000240, "Member 'UVoipMicCheckWidget::InputDevice' has a wrong offset!");
static_assert(offsetof(UVoipMicCheckWidget, OutputDevice) == 0x000248, "Member 'UVoipMicCheckWidget::OutputDevice' has a wrong offset!");

// Class HLL.BaseTank
// 0x0358 (0x05F8 - 0x02A0)
class ABaseTank : public ATrackedVehicle
{
public:
	uint8                                         Pad_10A7[0x50];                                    // 0x02A0(0x0050)(Fixing Size After Last Property [ Dumper-69 ])
	class UVehicleHitComponent*                   Hitter;                                            // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterMovementBarrierBody;                      // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterMovementBarrierTurret;                    // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterMovementBarrierBarrel;                    // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          JeepBarrier;                                       // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourCollisionMesh*                ArmourCollision_Body;                              // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourCollisionMesh*                ArmourCollision_Tracks;                            // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourCollisionMesh*                ArmourCollision_Turret;                            // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourCollisionMesh*                ArmourCollision_Barrel;                            // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EngineWarmupDuration;                              // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EngineShutdownDuration;                            // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EngineSoundFadeInTime;                             // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A8[0x4];                                     // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVehicleSoundSetup                     EngineSound;                                       // 0x0348(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVehicleSoundSetup                     EngineStartSound;                                  // 0x0368(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVehicleSoundSetup                     EngineStartAbortedSound;                           // 0x0388(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVehicleSoundSetup                     EngineStopSound;                                   // 0x03A8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVehicleSoundSetup                     EngineStartFailedSound;                            // 0x03C8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAudioComponent*                        EngineAudio;                                       // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        InteriorAudio;                                     // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        ExhaustAudio;                                      // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        TracksAudio;                                       // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        EngineStartAudio;                                  // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        InteriorStartAudio;                                // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        ExhaustStartAudio;                                 // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEngineStarted : 1;                                // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_10A9[0x17];                                    // 0x0421(0x0017)(Fixing Size After Last Property [ Dumper-69 ])
	class UAudioComponent*                        ClutchAudio;                                       // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATankDriverSeat>            DriverSeatClass;                                   // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATankGunnerSeat>            GunnerSeatClass;                                   // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATankCommanderSeat>         CommanderSeatClass;                                // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATankDriverSeat*                        DriverSeat;                                        // 0x0458(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATankGunnerSeat*                        GunnerSeat;                                        // 0x0460(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATankCommanderSeat*                     CommanderSeat;                                     // 0x0468(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTurretControllerComponent2*            TurretController2;                                 // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PitchAudio;                                        // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        YawAudio;                                          // 0x0480(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TurretAudioAttachSocket;                           // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             TurretPitchSound;                                  // 0x0490(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             TurretPitchStopSound;                              // 0x0498(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             TurretYawSound;                                    // 0x04A0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             TurretYawStopSound;                                // 0x04A8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawRate;                                           // 0x04B0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTurretRotationScale;                            // 0x04B4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchRate;                                         // 0x04B8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchAngleMin;                                     // 0x04BC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchAngleMax;                                     // 0x04C0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Turret_ServerUpdateRate;                           // 0x04C4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        InteriorHitAudio;                                  // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourHealthComponent*              ArmourHealth;                                      // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourInventory*                    ArmourInventory;                                   // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLArmourMetaData                     ArmourMetaData;                                    // 0x04E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         DamageImpulseMagnitude;                            // 0x0508(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10AA[0x4];                                     // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UPhysicalMaterial*                      LowSpeedPhysMatOverride;                           // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LowSpeedThresholdKph;                              // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10AB[0x4];                                     // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	ETeam                                         Team;                                              // 0x0520(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10AC[0x7];                                     // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLVehicleFXComponent*                 VehicleEffects;                                    // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLVehicleInactivityComponent*         InactivityMonitor;                                 // 0x0538(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLIndicatorComponent*                 NameplateIndicatorComponent;                       // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVehicleWorldShiftingComponent*         WorldShifting;                                     // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVehicleMGController*                   HullMGController;                                  // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVehicleAntiFlipComponent*              AntiFlipComponent;                                 // 0x0558(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RootBoneName;                                      // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           RollerBones;                                       // 0x0568(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TurretBoneName;                                    // 0x0578(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BarrelBoneName;                                    // 0x0580(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             WaterEffects;                                      // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FReconID                               VehicleReconID;                                    // 0x0590(0x0002)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	EReconItemType                                ReconType;                                         // 0x0592(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x0593(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10AD[0x4];                                     // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLVehicleVibrationData*               VehicleVibrationData;                              // 0x0598(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10AE[0x8];                                     // 0x05A0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UVibrationEventController*              EngineVibrationController_Internal;                // 0x05A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVibrationEventController*              EngineVibrationController_External;                // 0x05B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVibrationEventController*              PitchVibrationController;                          // 0x05B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVibrationEventController*              YawVibrationController;                            // 0x05C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVibrationEventController*              InternalHitVibrationController;                    // 0x05C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10AF[0x28];                                    // 0x05D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClientStartEngineFailed();
	void OnRep_EngineStarted();
	void OnRep_Seat();
	void ServerStartEngine();
	void ServerStopEngine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTank">();
	}
	static class ABaseTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseTank>();
	}
};
static_assert(alignof(ABaseTank) == 0x000008, "Wrong alignment on ABaseTank");
static_assert(sizeof(ABaseTank) == 0x0005F8, "Wrong size on ABaseTank");
static_assert(offsetof(ABaseTank, Hitter) == 0x0002F0, "Member 'ABaseTank::Hitter' has a wrong offset!");
static_assert(offsetof(ABaseTank, CharacterMovementBarrierBody) == 0x0002F8, "Member 'ABaseTank::CharacterMovementBarrierBody' has a wrong offset!");
static_assert(offsetof(ABaseTank, CharacterMovementBarrierTurret) == 0x000300, "Member 'ABaseTank::CharacterMovementBarrierTurret' has a wrong offset!");
static_assert(offsetof(ABaseTank, CharacterMovementBarrierBarrel) == 0x000308, "Member 'ABaseTank::CharacterMovementBarrierBarrel' has a wrong offset!");
static_assert(offsetof(ABaseTank, JeepBarrier) == 0x000310, "Member 'ABaseTank::JeepBarrier' has a wrong offset!");
static_assert(offsetof(ABaseTank, ArmourCollision_Body) == 0x000318, "Member 'ABaseTank::ArmourCollision_Body' has a wrong offset!");
static_assert(offsetof(ABaseTank, ArmourCollision_Tracks) == 0x000320, "Member 'ABaseTank::ArmourCollision_Tracks' has a wrong offset!");
static_assert(offsetof(ABaseTank, ArmourCollision_Turret) == 0x000328, "Member 'ABaseTank::ArmourCollision_Turret' has a wrong offset!");
static_assert(offsetof(ABaseTank, ArmourCollision_Barrel) == 0x000330, "Member 'ABaseTank::ArmourCollision_Barrel' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineWarmupDuration) == 0x000338, "Member 'ABaseTank::EngineWarmupDuration' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineShutdownDuration) == 0x00033C, "Member 'ABaseTank::EngineShutdownDuration' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineSoundFadeInTime) == 0x000340, "Member 'ABaseTank::EngineSoundFadeInTime' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineSound) == 0x000348, "Member 'ABaseTank::EngineSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineStartSound) == 0x000368, "Member 'ABaseTank::EngineStartSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineStartAbortedSound) == 0x000388, "Member 'ABaseTank::EngineStartAbortedSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineStopSound) == 0x0003A8, "Member 'ABaseTank::EngineStopSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineStartFailedSound) == 0x0003C8, "Member 'ABaseTank::EngineStartFailedSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineAudio) == 0x0003E8, "Member 'ABaseTank::EngineAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, InteriorAudio) == 0x0003F0, "Member 'ABaseTank::InteriorAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, ExhaustAudio) == 0x0003F8, "Member 'ABaseTank::ExhaustAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, TracksAudio) == 0x000400, "Member 'ABaseTank::TracksAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineStartAudio) == 0x000408, "Member 'ABaseTank::EngineStartAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, InteriorStartAudio) == 0x000410, "Member 'ABaseTank::InteriorStartAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, ExhaustStartAudio) == 0x000418, "Member 'ABaseTank::ExhaustStartAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, ClutchAudio) == 0x000438, "Member 'ABaseTank::ClutchAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, DriverSeatClass) == 0x000440, "Member 'ABaseTank::DriverSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseTank, GunnerSeatClass) == 0x000448, "Member 'ABaseTank::GunnerSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseTank, CommanderSeatClass) == 0x000450, "Member 'ABaseTank::CommanderSeatClass' has a wrong offset!");
static_assert(offsetof(ABaseTank, DriverSeat) == 0x000458, "Member 'ABaseTank::DriverSeat' has a wrong offset!");
static_assert(offsetof(ABaseTank, GunnerSeat) == 0x000460, "Member 'ABaseTank::GunnerSeat' has a wrong offset!");
static_assert(offsetof(ABaseTank, CommanderSeat) == 0x000468, "Member 'ABaseTank::CommanderSeat' has a wrong offset!");
static_assert(offsetof(ABaseTank, TurretController2) == 0x000470, "Member 'ABaseTank::TurretController2' has a wrong offset!");
static_assert(offsetof(ABaseTank, PitchAudio) == 0x000478, "Member 'ABaseTank::PitchAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, YawAudio) == 0x000480, "Member 'ABaseTank::YawAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, TurretAudioAttachSocket) == 0x000488, "Member 'ABaseTank::TurretAudioAttachSocket' has a wrong offset!");
static_assert(offsetof(ABaseTank, TurretPitchSound) == 0x000490, "Member 'ABaseTank::TurretPitchSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, TurretPitchStopSound) == 0x000498, "Member 'ABaseTank::TurretPitchStopSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, TurretYawSound) == 0x0004A0, "Member 'ABaseTank::TurretYawSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, TurretYawStopSound) == 0x0004A8, "Member 'ABaseTank::TurretYawStopSound' has a wrong offset!");
static_assert(offsetof(ABaseTank, YawRate) == 0x0004B0, "Member 'ABaseTank::YawRate' has a wrong offset!");
static_assert(offsetof(ABaseTank, MinTurretRotationScale) == 0x0004B4, "Member 'ABaseTank::MinTurretRotationScale' has a wrong offset!");
static_assert(offsetof(ABaseTank, PitchRate) == 0x0004B8, "Member 'ABaseTank::PitchRate' has a wrong offset!");
static_assert(offsetof(ABaseTank, PitchAngleMin) == 0x0004BC, "Member 'ABaseTank::PitchAngleMin' has a wrong offset!");
static_assert(offsetof(ABaseTank, PitchAngleMax) == 0x0004C0, "Member 'ABaseTank::PitchAngleMax' has a wrong offset!");
static_assert(offsetof(ABaseTank, Turret_ServerUpdateRate) == 0x0004C4, "Member 'ABaseTank::Turret_ServerUpdateRate' has a wrong offset!");
static_assert(offsetof(ABaseTank, InteriorHitAudio) == 0x0004C8, "Member 'ABaseTank::InteriorHitAudio' has a wrong offset!");
static_assert(offsetof(ABaseTank, ArmourHealth) == 0x0004D0, "Member 'ABaseTank::ArmourHealth' has a wrong offset!");
static_assert(offsetof(ABaseTank, ArmourInventory) == 0x0004D8, "Member 'ABaseTank::ArmourInventory' has a wrong offset!");
static_assert(offsetof(ABaseTank, ArmourMetaData) == 0x0004E0, "Member 'ABaseTank::ArmourMetaData' has a wrong offset!");
static_assert(offsetof(ABaseTank, DamageImpulseMagnitude) == 0x000508, "Member 'ABaseTank::DamageImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(ABaseTank, LowSpeedPhysMatOverride) == 0x000510, "Member 'ABaseTank::LowSpeedPhysMatOverride' has a wrong offset!");
static_assert(offsetof(ABaseTank, LowSpeedThresholdKph) == 0x000518, "Member 'ABaseTank::LowSpeedThresholdKph' has a wrong offset!");
static_assert(offsetof(ABaseTank, Team) == 0x000520, "Member 'ABaseTank::Team' has a wrong offset!");
static_assert(offsetof(ABaseTank, VehicleEffects) == 0x000528, "Member 'ABaseTank::VehicleEffects' has a wrong offset!");
static_assert(offsetof(ABaseTank, MapComponent) == 0x000530, "Member 'ABaseTank::MapComponent' has a wrong offset!");
static_assert(offsetof(ABaseTank, InactivityMonitor) == 0x000538, "Member 'ABaseTank::InactivityMonitor' has a wrong offset!");
static_assert(offsetof(ABaseTank, NameplateIndicatorComponent) == 0x000540, "Member 'ABaseTank::NameplateIndicatorComponent' has a wrong offset!");
static_assert(offsetof(ABaseTank, WorldShifting) == 0x000548, "Member 'ABaseTank::WorldShifting' has a wrong offset!");
static_assert(offsetof(ABaseTank, HullMGController) == 0x000550, "Member 'ABaseTank::HullMGController' has a wrong offset!");
static_assert(offsetof(ABaseTank, AntiFlipComponent) == 0x000558, "Member 'ABaseTank::AntiFlipComponent' has a wrong offset!");
static_assert(offsetof(ABaseTank, RootBoneName) == 0x000560, "Member 'ABaseTank::RootBoneName' has a wrong offset!");
static_assert(offsetof(ABaseTank, RollerBones) == 0x000568, "Member 'ABaseTank::RollerBones' has a wrong offset!");
static_assert(offsetof(ABaseTank, TurretBoneName) == 0x000578, "Member 'ABaseTank::TurretBoneName' has a wrong offset!");
static_assert(offsetof(ABaseTank, BarrelBoneName) == 0x000580, "Member 'ABaseTank::BarrelBoneName' has a wrong offset!");
static_assert(offsetof(ABaseTank, WaterEffects) == 0x000588, "Member 'ABaseTank::WaterEffects' has a wrong offset!");
static_assert(offsetof(ABaseTank, VehicleReconID) == 0x000590, "Member 'ABaseTank::VehicleReconID' has a wrong offset!");
static_assert(offsetof(ABaseTank, ReconType) == 0x000592, "Member 'ABaseTank::ReconType' has a wrong offset!");
static_assert(offsetof(ABaseTank, DamageFilterType) == 0x000593, "Member 'ABaseTank::DamageFilterType' has a wrong offset!");
static_assert(offsetof(ABaseTank, VehicleVibrationData) == 0x000598, "Member 'ABaseTank::VehicleVibrationData' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineVibrationController_Internal) == 0x0005A8, "Member 'ABaseTank::EngineVibrationController_Internal' has a wrong offset!");
static_assert(offsetof(ABaseTank, EngineVibrationController_External) == 0x0005B0, "Member 'ABaseTank::EngineVibrationController_External' has a wrong offset!");
static_assert(offsetof(ABaseTank, PitchVibrationController) == 0x0005B8, "Member 'ABaseTank::PitchVibrationController' has a wrong offset!");
static_assert(offsetof(ABaseTank, YawVibrationController) == 0x0005C0, "Member 'ABaseTank::YawVibrationController' has a wrong offset!");
static_assert(offsetof(ABaseTank, InternalHitVibrationController) == 0x0005C8, "Member 'ABaseTank::InternalHitVibrationController' has a wrong offset!");

// Class HLL.BasicTrainingManager
// 0x0028 (0x0248 - 0x0220)
class ABasicTrainingManager : public AActor
{
public:
	struct FSoftObjectPath                        PracticeRangeFactionDataTablePath;                 // 0x0220(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10B0[0x10];                                    // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void LoadFactionPracticeRangeMap(const class FString& MapUrl);

	TArray<struct FPracticeRangeFactionData> GetPracticeRangeFactionTableRows() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasicTrainingManager">();
	}
	static class ABasicTrainingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasicTrainingManager>();
	}
};
static_assert(alignof(ABasicTrainingManager) == 0x000008, "Wrong alignment on ABasicTrainingManager");
static_assert(sizeof(ABasicTrainingManager) == 0x000248, "Wrong size on ABasicTrainingManager");
static_assert(offsetof(ABasicTrainingManager, PracticeRangeFactionDataTablePath) == 0x000220, "Member 'ABasicTrainingManager::PracticeRangeFactionDataTablePath' has a wrong offset!");

// Class HLL.HLLRoundSummaryStat
// 0x0068 (0x0298 - 0x0230)
class UHLLRoundSummaryStat : public UUserWidget
{
public:
	EHLLPlayerStat                                Stat;                                              // 0x0230(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B1[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateColor                            HostileTeamColour;                                 // 0x0238(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            FriendlyTeamColour;                                // 0x0260(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             TitleText;                                         // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             StatText;                                          // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoundSummaryStat">();
	}
	static class UHLLRoundSummaryStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoundSummaryStat>();
	}
};
static_assert(alignof(UHLLRoundSummaryStat) == 0x000008, "Wrong alignment on UHLLRoundSummaryStat");
static_assert(sizeof(UHLLRoundSummaryStat) == 0x000298, "Wrong size on UHLLRoundSummaryStat");
static_assert(offsetof(UHLLRoundSummaryStat, Stat) == 0x000230, "Member 'UHLLRoundSummaryStat::Stat' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryStat, HostileTeamColour) == 0x000238, "Member 'UHLLRoundSummaryStat::HostileTeamColour' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryStat, FriendlyTeamColour) == 0x000260, "Member 'UHLLRoundSummaryStat::FriendlyTeamColour' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryStat, TitleText) == 0x000288, "Member 'UHLLRoundSummaryStat::TitleText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryStat, StatText) == 0x000290, "Member 'UHLLRoundSummaryStat::StatText' has a wrong offset!");

// Class HLL.BipodRotationLimitsVolume
// 0x0018 (0x0238 - 0x0220)
class ABipodRotationLimitsVolume final : public AActor
{
public:
	class UBoxComponent*                          CollisionBox;                                      // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMountableWeaponDataAsset*              OverrideMountableWeaponDataAsset;                  // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMountableWeaponDataAsset*              OverrideTestMountableWeaponDataAsset;              // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UMountableWeaponDataAsset* GetMountableWeaponDataAsset() const;
	class UMountableWeaponDataAsset* GetTestMountableWeaponDataAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BipodRotationLimitsVolume">();
	}
	static class ABipodRotationLimitsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABipodRotationLimitsVolume>();
	}
};
static_assert(alignof(ABipodRotationLimitsVolume) == 0x000008, "Wrong alignment on ABipodRotationLimitsVolume");
static_assert(sizeof(ABipodRotationLimitsVolume) == 0x000238, "Wrong size on ABipodRotationLimitsVolume");
static_assert(offsetof(ABipodRotationLimitsVolume, CollisionBox) == 0x000220, "Member 'ABipodRotationLimitsVolume::CollisionBox' has a wrong offset!");
static_assert(offsetof(ABipodRotationLimitsVolume, OverrideMountableWeaponDataAsset) == 0x000228, "Member 'ABipodRotationLimitsVolume::OverrideMountableWeaponDataAsset' has a wrong offset!");
static_assert(offsetof(ABipodRotationLimitsVolume, OverrideTestMountableWeaponDataAsset) == 0x000230, "Member 'ABipodRotationLimitsVolume::OverrideTestMountableWeaponDataAsset' has a wrong offset!");

// Class HLL.BlockPlayerCommunicationsSubsystem
// 0x0060 (0x0090 - 0x0030)
class UBlockPlayerCommunicationsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_10B2[0x60];                                    // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockPlayerCommunicationsSubsystem">();
	}
	static class UBlockPlayerCommunicationsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockPlayerCommunicationsSubsystem>();
	}
};
static_assert(alignof(UBlockPlayerCommunicationsSubsystem) == 0x000008, "Wrong alignment on UBlockPlayerCommunicationsSubsystem");
static_assert(sizeof(UBlockPlayerCommunicationsSubsystem) == 0x000090, "Wrong size on UBlockPlayerCommunicationsSubsystem");

// Class HLL.BloodDecal
// 0x0010 (0x0238 - 0x0228)
class ABloodDecal final : public ADecalActor
{
public:
	TArray<class UMaterialInterface*>             DecalMaterials;                                    // 0x0228(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodDecal">();
	}
	static class ABloodDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABloodDecal>();
	}
};
static_assert(alignof(ABloodDecal) == 0x000008, "Wrong alignment on ABloodDecal");
static_assert(sizeof(ABloodDecal) == 0x000238, "Wrong size on ABloodDecal");
static_assert(offsetof(ABloodDecal, DecalMaterials) == 0x000228, "Member 'ABloodDecal::DecalMaterials' has a wrong offset!");

// Class HLL.HLLRoundSummaryProgression
// 0x0478 (0x06A8 - 0x0230)
class UHLLRoundSummaryProgression : public UUserWidget
{
public:
	TSubclassOf<class UHLLXPItem>                 XPItemClass;                                       // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLXPItem*>                     XPItems;                                           // 0x0238(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLRoleProgressionItem>    RoleProgressionClass;                              // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLRoleProgressionItem*>        RoleProgressionItems;                              // 0x0250(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRoleItemCols;                                   // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B3[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateSound                            PromotedSound;                                     // 0x0268(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            PrestigeSound;                                     // 0x0280(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            ItemCountSound;                                    // 0x0298(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            ItemFinishedSound;                                 // 0x02B0(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            FinishedCountingSound;                             // 0x02C8(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            TimeXPIcon;                                        // 0x02E0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CombatXPIcon;                                      // 0x0368(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            OffenseXPIcon;                                     // 0x03F0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DefenceXPIcon;                                     // 0x0478(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            SupportXPIcon;                                     // 0x0500(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Initial;                                      // 0x0588(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Promoted;                                     // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Prestige;                                     // 0x0598(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_XPComplete;                                   // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLMatchProgressionInfo               CachedMatchEndInfo;                                // 0x05A8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         TimePerItem;                                       // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemInterpSpeed;                                   // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenXPItems;                               // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenRoleItems;                             // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayAfterCompletion;                              // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B4[0x4];                                     // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 RadialInitial;                                     // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialNew;                                         // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RankIcon;                                          // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           XPItemContainer;                                   // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LevelText;                                         // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             XPValue_Total;                                     // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      RoleXPContainer;                                   // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         CounterLoopingAC;                                  // 0x0648(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10B5[0x58];                                    // 0x0650(0x0058)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoundSummaryProgression">();
	}
	static class UHLLRoundSummaryProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoundSummaryProgression>();
	}
};
static_assert(alignof(UHLLRoundSummaryProgression) == 0x000008, "Wrong alignment on UHLLRoundSummaryProgression");
static_assert(sizeof(UHLLRoundSummaryProgression) == 0x0006A8, "Wrong size on UHLLRoundSummaryProgression");
static_assert(offsetof(UHLLRoundSummaryProgression, XPItemClass) == 0x000230, "Member 'UHLLRoundSummaryProgression::XPItemClass' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, XPItems) == 0x000238, "Member 'UHLLRoundSummaryProgression::XPItems' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, RoleProgressionClass) == 0x000248, "Member 'UHLLRoundSummaryProgression::RoleProgressionClass' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, RoleProgressionItems) == 0x000250, "Member 'UHLLRoundSummaryProgression::RoleProgressionItems' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, MaxRoleItemCols) == 0x000260, "Member 'UHLLRoundSummaryProgression::MaxRoleItemCols' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, PromotedSound) == 0x000268, "Member 'UHLLRoundSummaryProgression::PromotedSound' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, PrestigeSound) == 0x000280, "Member 'UHLLRoundSummaryProgression::PrestigeSound' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, ItemCountSound) == 0x000298, "Member 'UHLLRoundSummaryProgression::ItemCountSound' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, ItemFinishedSound) == 0x0002B0, "Member 'UHLLRoundSummaryProgression::ItemFinishedSound' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, FinishedCountingSound) == 0x0002C8, "Member 'UHLLRoundSummaryProgression::FinishedCountingSound' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, TimeXPIcon) == 0x0002E0, "Member 'UHLLRoundSummaryProgression::TimeXPIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, CombatXPIcon) == 0x000368, "Member 'UHLLRoundSummaryProgression::CombatXPIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, OffenseXPIcon) == 0x0003F0, "Member 'UHLLRoundSummaryProgression::OffenseXPIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, DefenceXPIcon) == 0x000478, "Member 'UHLLRoundSummaryProgression::DefenceXPIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, SupportXPIcon) == 0x000500, "Member 'UHLLRoundSummaryProgression::SupportXPIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, Anim_Initial) == 0x000588, "Member 'UHLLRoundSummaryProgression::Anim_Initial' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, Anim_Promoted) == 0x000590, "Member 'UHLLRoundSummaryProgression::Anim_Promoted' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, Anim_Prestige) == 0x000598, "Member 'UHLLRoundSummaryProgression::Anim_Prestige' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, Anim_XPComplete) == 0x0005A0, "Member 'UHLLRoundSummaryProgression::Anim_XPComplete' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, CachedMatchEndInfo) == 0x0005A8, "Member 'UHLLRoundSummaryProgression::CachedMatchEndInfo' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, TimePerItem) == 0x0005F8, "Member 'UHLLRoundSummaryProgression::TimePerItem' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, ItemInterpSpeed) == 0x0005FC, "Member 'UHLLRoundSummaryProgression::ItemInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, DelayBetweenXPItems) == 0x000600, "Member 'UHLLRoundSummaryProgression::DelayBetweenXPItems' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, DelayBetweenRoleItems) == 0x000604, "Member 'UHLLRoundSummaryProgression::DelayBetweenRoleItems' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, DelayAfterCompletion) == 0x000608, "Member 'UHLLRoundSummaryProgression::DelayAfterCompletion' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, RadialInitial) == 0x000610, "Member 'UHLLRoundSummaryProgression::RadialInitial' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, RadialNew) == 0x000618, "Member 'UHLLRoundSummaryProgression::RadialNew' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, RankIcon) == 0x000620, "Member 'UHLLRoundSummaryProgression::RankIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, XPItemContainer) == 0x000628, "Member 'UHLLRoundSummaryProgression::XPItemContainer' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, LevelText) == 0x000630, "Member 'UHLLRoundSummaryProgression::LevelText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, XPValue_Total) == 0x000638, "Member 'UHLLRoundSummaryProgression::XPValue_Total' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, RoleXPContainer) == 0x000640, "Member 'UHLLRoundSummaryProgression::RoleXPContainer' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryProgression, CounterLoopingAC) == 0x000648, "Member 'UHLLRoundSummaryProgression::CounterLoopingAC' has a wrong offset!");

// Class HLL.BoatSpawnComponent
// 0x00B0 (0x0160 - 0x00B0)
class UBoatSpawnComponent final : public UActorComponent
{
public:
	TSubclassOf<class AInfantryCarrierBoat>       InfantryCarrierBoatClass;                          // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnInterval;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FirstWaveDelay;                                    // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DockedDuration;                                    // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeployedPlayerTravelDuration;                      // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoatTravelSpeedKnots;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPlayersPerBoat;                                 // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreferredPlayersPerBoat;                           // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpawnGroup;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABoatSpawnPath*>                 Paths;                                             // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextWaveTime;                                      // 0x00E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B6[0x14];                                    // 0x00EC(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class ABoatSpawnPath*>                 NotAllocatedPaths;                                 // 0x0100(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, class ABoatSpawnPath*>    AllocatedPaths;                                    // 0x0110(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnBoatDestroyed(class AActor* Boat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoatSpawnComponent">();
	}
	static class UBoatSpawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoatSpawnComponent>();
	}
};
static_assert(alignof(UBoatSpawnComponent) == 0x000008, "Wrong alignment on UBoatSpawnComponent");
static_assert(sizeof(UBoatSpawnComponent) == 0x000160, "Wrong size on UBoatSpawnComponent");
static_assert(offsetof(UBoatSpawnComponent, InfantryCarrierBoatClass) == 0x0000B0, "Member 'UBoatSpawnComponent::InfantryCarrierBoatClass' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, SpawnInterval) == 0x0000B8, "Member 'UBoatSpawnComponent::SpawnInterval' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, FirstWaveDelay) == 0x0000BC, "Member 'UBoatSpawnComponent::FirstWaveDelay' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, DockedDuration) == 0x0000C0, "Member 'UBoatSpawnComponent::DockedDuration' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, DeployedPlayerTravelDuration) == 0x0000C4, "Member 'UBoatSpawnComponent::DeployedPlayerTravelDuration' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, BoatTravelSpeedKnots) == 0x0000C8, "Member 'UBoatSpawnComponent::BoatTravelSpeedKnots' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, MaxPlayersPerBoat) == 0x0000CC, "Member 'UBoatSpawnComponent::MaxPlayersPerBoat' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, PreferredPlayersPerBoat) == 0x0000D0, "Member 'UBoatSpawnComponent::PreferredPlayersPerBoat' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, SpawnGroup) == 0x0000D4, "Member 'UBoatSpawnComponent::SpawnGroup' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, Paths) == 0x0000D8, "Member 'UBoatSpawnComponent::Paths' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, NextWaveTime) == 0x0000E8, "Member 'UBoatSpawnComponent::NextWaveTime' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, NotAllocatedPaths) == 0x000100, "Member 'UBoatSpawnComponent::NotAllocatedPaths' has a wrong offset!");
static_assert(offsetof(UBoatSpawnComponent, AllocatedPaths) == 0x000110, "Member 'UBoatSpawnComponent::AllocatedPaths' has a wrong offset!");

// Class HLL.HLLPlanes
// 0x0028 (0x0248 - 0x0220)
class AHLLPlanes final : public AActor
{
public:
	class USplineComponent*                       FollowSpline;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PlaneMesh;                                         // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PlaneAudio;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        PlaneTransform;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeed;                                     // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementTime;                                      // 0x0244(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnStartedMovement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPlanes">();
	}
	static class AHLLPlanes* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLPlanes>();
	}
};
static_assert(alignof(AHLLPlanes) == 0x000008, "Wrong alignment on AHLLPlanes");
static_assert(sizeof(AHLLPlanes) == 0x000248, "Wrong size on AHLLPlanes");
static_assert(offsetof(AHLLPlanes, FollowSpline) == 0x000220, "Member 'AHLLPlanes::FollowSpline' has a wrong offset!");
static_assert(offsetof(AHLLPlanes, PlaneMesh) == 0x000228, "Member 'AHLLPlanes::PlaneMesh' has a wrong offset!");
static_assert(offsetof(AHLLPlanes, PlaneAudio) == 0x000230, "Member 'AHLLPlanes::PlaneAudio' has a wrong offset!");
static_assert(offsetof(AHLLPlanes, PlaneTransform) == 0x000238, "Member 'AHLLPlanes::PlaneTransform' has a wrong offset!");
static_assert(offsetof(AHLLPlanes, MovementSpeed) == 0x000240, "Member 'AHLLPlanes::MovementSpeed' has a wrong offset!");
static_assert(offsetof(AHLLPlanes, MovementTime) == 0x000244, "Member 'AHLLPlanes::MovementTime' has a wrong offset!");

// Class HLL.BoatSpawnPath
// 0x0010 (0x0230 - 0x0220)
class ABoatSpawnPath final : public AActor
{
public:
	int32                                         SpawnGroup;                                        // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B7[0x4];                                     // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USplineComponent*                       PathSpline;                                        // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoatSpawnPath">();
	}
	static class ABoatSpawnPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABoatSpawnPath>();
	}
};
static_assert(alignof(ABoatSpawnPath) == 0x000008, "Wrong alignment on ABoatSpawnPath");
static_assert(sizeof(ABoatSpawnPath) == 0x000230, "Wrong size on ABoatSpawnPath");
static_assert(offsetof(ABoatSpawnPath, SpawnGroup) == 0x000220, "Member 'ABoatSpawnPath::SpawnGroup' has a wrong offset!");
static_assert(offsetof(ABoatSpawnPath, PathSpline) == 0x000228, "Member 'ABoatSpawnPath::PathSpline' has a wrong offset!");

// Class HLL.SectorCaptureBooster
// 0x0060 (0x0280 - 0x0220)
class ASectorCaptureBooster : public AActor
{
public:
	float                                         AdditionalManpower;                                // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B8[0x4];                                     // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMapComponent*                       MapComponent;                                      // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B9[0x50];                                    // 0x0230(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SectorCaptureBooster">();
	}
	static class ASectorCaptureBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASectorCaptureBooster>();
	}
};
static_assert(alignof(ASectorCaptureBooster) == 0x000008, "Wrong alignment on ASectorCaptureBooster");
static_assert(sizeof(ASectorCaptureBooster) == 0x000280, "Wrong size on ASectorCaptureBooster");
static_assert(offsetof(ASectorCaptureBooster, AdditionalManpower) == 0x000220, "Member 'ASectorCaptureBooster::AdditionalManpower' has a wrong offset!");
static_assert(offsetof(ASectorCaptureBooster, MapComponent) == 0x000228, "Member 'ASectorCaptureBooster::MapComponent' has a wrong offset!");

// Class HLL.BoxSectorCaptureBooster
// 0x0008 (0x0288 - 0x0280)
class ABoxSectorCaptureBooster final : public ASectorCaptureBooster
{
public:
	class UBoxComponent*                          TriggerShape;                                      // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxSectorCaptureBooster">();
	}
	static class ABoxSectorCaptureBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABoxSectorCaptureBooster>();
	}
};
static_assert(alignof(ABoxSectorCaptureBooster) == 0x000008, "Wrong alignment on ABoxSectorCaptureBooster");
static_assert(sizeof(ABoxSectorCaptureBooster) == 0x000288, "Wrong size on ABoxSectorCaptureBooster");
static_assert(offsetof(ABoxSectorCaptureBooster, TriggerShape) == 0x000280, "Member 'ABoxSectorCaptureBooster::TriggerShape' has a wrong offset!");

// Class HLL.HLLExplosive
// 0x01A8 (0x03C8 - 0x0220)
class AHLLExplosive : public AActor
{
public:
	uint8                                         Pad_10BA[0x68];                                    // 0x0220(0x0068)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMapComponent*                       MapComponent;                                      // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSimpleHealthComponent*              HealthComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDismantlingComponent*                  DismantlingComponent;                              // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         OwningTeam;                                        // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10BB[0x3];                                     // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRepExplosion                          RepExplosionInfo;                                  // 0x02AC(0x0098)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x0344(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10BC[0x3];                                     // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterImpactEffect>       ExplosionEffectClass;                              // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostExplodeLifespan;                               // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRadius;                                      // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageFalloff;                                     // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreDamageOcclusion : 1;                        // 0x0368(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSuppressAllTeams : 1;                             // 0x0368(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreSuppressionOcclusion : 1;                   // 0x0368(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_10BD[0x3];                                     // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Suppression;                                       // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionRadius;                                 // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionFalloff;                                // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DamageSourceName;                                  // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterPlayerState*                    SpawnedByPlayer;                                   // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            ExplosionInstigator;                               // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanBeDismantled : 1;                              // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRecoverAmmoOnDismantle : 1;                       // 0x0398(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_10BE[0x7];                                     // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   DismantleItemName;                                 // 0x03A0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DismantleTime;                                     // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EnemyDismantleScore;                               // 0x03BC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10BF[0x4];                                     // 0x03C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnKilled(class UHLLSimpleHealthComponent* HealthComp);
	void OnRep_ExplosionInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLExplosive">();
	}
	static class AHLLExplosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLExplosive>();
	}
};
static_assert(alignof(AHLLExplosive) == 0x000008, "Wrong alignment on AHLLExplosive");
static_assert(sizeof(AHLLExplosive) == 0x0003C8, "Wrong size on AHLLExplosive");
static_assert(offsetof(AHLLExplosive, MapComponent) == 0x000288, "Member 'AHLLExplosive::MapComponent' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, IndicatorComponent) == 0x000290, "Member 'AHLLExplosive::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, HealthComponent) == 0x000298, "Member 'AHLLExplosive::HealthComponent' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, DismantlingComponent) == 0x0002A0, "Member 'AHLLExplosive::DismantlingComponent' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, OwningTeam) == 0x0002A8, "Member 'AHLLExplosive::OwningTeam' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, RepExplosionInfo) == 0x0002AC, "Member 'AHLLExplosive::RepExplosionInfo' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, DamageFilterType) == 0x000344, "Member 'AHLLExplosive::DamageFilterType' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, ExplosionEffectClass) == 0x000348, "Member 'AHLLExplosive::ExplosionEffectClass' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, PostExplodeLifespan) == 0x000350, "Member 'AHLLExplosive::PostExplodeLifespan' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, Damage) == 0x000354, "Member 'AHLLExplosive::Damage' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, DamageRadius) == 0x000358, "Member 'AHLLExplosive::DamageRadius' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, DamageFalloff) == 0x00035C, "Member 'AHLLExplosive::DamageFalloff' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, DamageType) == 0x000360, "Member 'AHLLExplosive::DamageType' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, Suppression) == 0x00036C, "Member 'AHLLExplosive::Suppression' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, SuppressionRadius) == 0x000370, "Member 'AHLLExplosive::SuppressionRadius' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, SuppressionFalloff) == 0x000374, "Member 'AHLLExplosive::SuppressionFalloff' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, DamageSourceName) == 0x000378, "Member 'AHLLExplosive::DamageSourceName' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, SpawnedByPlayer) == 0x000388, "Member 'AHLLExplosive::SpawnedByPlayer' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, ExplosionInstigator) == 0x000390, "Member 'AHLLExplosive::ExplosionInstigator' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, DismantleItemName) == 0x0003A0, "Member 'AHLLExplosive::DismantleItemName' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, DismantleTime) == 0x0003B8, "Member 'AHLLExplosive::DismantleTime' has a wrong offset!");
static_assert(offsetof(AHLLExplosive, EnemyDismantleScore) == 0x0003BC, "Member 'AHLLExplosive::EnemyDismantleScore' has a wrong offset!");

// Class HLL.HLLSatchelCharge
// 0x0020 (0x03E8 - 0x03C8)
class AHLLSatchelCharge : public AHLLExplosive
{
public:
	class UStaticMeshComponent*                   SatchelMesh;                                       // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         DetonationTimeSeconds;                             // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C0[0x3];                                     // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ServerTimeAtDetonation;                            // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  HitQueryProfile;                                   // 0x03D8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_SatchelDetonate;                                // 0x03E0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAttachParentDestroyed(class AActor* Parent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSatchelCharge">();
	}
	static class AHLLSatchelCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSatchelCharge>();
	}
};
static_assert(alignof(AHLLSatchelCharge) == 0x000008, "Wrong alignment on AHLLSatchelCharge");
static_assert(sizeof(AHLLSatchelCharge) == 0x0003E8, "Wrong size on AHLLSatchelCharge");
static_assert(offsetof(AHLLSatchelCharge, SatchelMesh) == 0x0003C8, "Member 'AHLLSatchelCharge::SatchelMesh' has a wrong offset!");
static_assert(offsetof(AHLLSatchelCharge, DetonationTimeSeconds) == 0x0003D0, "Member 'AHLLSatchelCharge::DetonationTimeSeconds' has a wrong offset!");
static_assert(offsetof(AHLLSatchelCharge, ServerTimeAtDetonation) == 0x0003D4, "Member 'AHLLSatchelCharge::ServerTimeAtDetonation' has a wrong offset!");
static_assert(offsetof(AHLLSatchelCharge, HitQueryProfile) == 0x0003D8, "Member 'AHLLSatchelCharge::HitQueryProfile' has a wrong offset!");
static_assert(offsetof(AHLLSatchelCharge, TH_SatchelDetonate) == 0x0003E0, "Member 'AHLLSatchelCharge::TH_SatchelDetonate' has a wrong offset!");

// Class HLL.BTDecorator_HasLoSTo
// 0x0028 (0x0090 - 0x0068)
class UBTDecorator_HasLoSTo final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 EnemyKey;                                          // 0x0068(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasLoSTo">();
	}
	static class UBTDecorator_HasLoSTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasLoSTo>();
	}
};
static_assert(alignof(UBTDecorator_HasLoSTo) == 0x000008, "Wrong alignment on UBTDecorator_HasLoSTo");
static_assert(sizeof(UBTDecorator_HasLoSTo) == 0x000090, "Wrong size on UBTDecorator_HasLoSTo");
static_assert(offsetof(UBTDecorator_HasLoSTo, EnemyKey) == 0x000068, "Member 'UBTDecorator_HasLoSTo::EnemyKey' has a wrong offset!");

// Class HLL.TankCommanderSeatUI
// 0x0010 (0x0290 - 0x0280)
class UTankCommanderSeatUI : public UHLLTankSeatUI_Base
{
public:
	class URichTextBlock*                         ZoomKeyText;                                       // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         PingKeyText;                                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankCommanderSeatUI">();
	}
	static class UTankCommanderSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTankCommanderSeatUI>();
	}
};
static_assert(alignof(UTankCommanderSeatUI) == 0x000008, "Wrong alignment on UTankCommanderSeatUI");
static_assert(sizeof(UTankCommanderSeatUI) == 0x000290, "Wrong size on UTankCommanderSeatUI");
static_assert(offsetof(UTankCommanderSeatUI, ZoomKeyText) == 0x000280, "Member 'UTankCommanderSeatUI::ZoomKeyText' has a wrong offset!");
static_assert(offsetof(UTankCommanderSeatUI, PingKeyText) == 0x000288, "Member 'UTankCommanderSeatUI::PingKeyText' has a wrong offset!");

// Class HLL.ReconCommanderSeatUI
// 0x0018 (0x02A8 - 0x0290)
class UReconCommanderSeatUI final : public UTankCommanderSeatUI
{
public:
	class UHLLArmourWeaponUI*                     ReconWeaponInfo;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         FireKeyText;                                       // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         AimKeyText;                                        // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReconCommanderSeatUI">();
	}
	static class UReconCommanderSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReconCommanderSeatUI>();
	}
};
static_assert(alignof(UReconCommanderSeatUI) == 0x000008, "Wrong alignment on UReconCommanderSeatUI");
static_assert(sizeof(UReconCommanderSeatUI) == 0x0002A8, "Wrong size on UReconCommanderSeatUI");
static_assert(offsetof(UReconCommanderSeatUI, ReconWeaponInfo) == 0x000290, "Member 'UReconCommanderSeatUI::ReconWeaponInfo' has a wrong offset!");
static_assert(offsetof(UReconCommanderSeatUI, FireKeyText) == 0x000298, "Member 'UReconCommanderSeatUI::FireKeyText' has a wrong offset!");
static_assert(offsetof(UReconCommanderSeatUI, AimKeyText) == 0x0002A0, "Member 'UReconCommanderSeatUI::AimKeyText' has a wrong offset!");

// Class HLL.BTTask_FindPickup
// 0x0000 (0x0098 - 0x0098)
class UBTTask_FindPickup final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindPickup">();
	}
	static class UBTTask_FindPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindPickup>();
	}
};
static_assert(alignof(UBTTask_FindPickup) == 0x000008, "Wrong alignment on UBTTask_FindPickup");
static_assert(sizeof(UBTTask_FindPickup) == 0x000098, "Wrong size on UBTTask_FindPickup");

// Class HLL.HLLAbility_FinalStand
// 0x0000 (0x0370 - 0x0370)
class AHLLAbility_FinalStand final : public AHLLAbility_PassiveBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbility_FinalStand">();
	}
	static class AHLLAbility_FinalStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbility_FinalStand>();
	}
};
static_assert(alignof(AHLLAbility_FinalStand) == 0x000008, "Wrong alignment on AHLLAbility_FinalStand");
static_assert(sizeof(AHLLAbility_FinalStand) == 0x000370, "Wrong size on AHLLAbility_FinalStand");

// Class HLL.BTTask_FindPointNearEnemy
// 0x0000 (0x0098 - 0x0098)
class UBTTask_FindPointNearEnemy final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindPointNearEnemy">();
	}
	static class UBTTask_FindPointNearEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindPointNearEnemy>();
	}
};
static_assert(alignof(UBTTask_FindPointNearEnemy) == 0x000008, "Wrong alignment on UBTTask_FindPointNearEnemy");
static_assert(sizeof(UBTTask_FindPointNearEnemy) == 0x000098, "Wrong size on UBTTask_FindPointNearEnemy");

// Class HLL.HLLRconState
// 0x0040 (0x0260 - 0x0220)
class AHLLRconState final : public AInfo
{
public:
	FMulticastInlineDelegateProperty_             SayMessageUpdatedEvent;                            // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 M_CurrentRconSay;                                  // 0x0230(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C1[0x20];                                    // 0x0240(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class AHLLRconState* GetInstance();

	void OnRep_RconSay();
	void RconSayUpdatedHandler__DelegateSignature(class AHLLRconState* Sender, const class FString& Message);

	class FString GetCurrentRconSay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRconState">();
	}
	static class AHLLRconState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLRconState>();
	}
};
static_assert(alignof(AHLLRconState) == 0x000008, "Wrong alignment on AHLLRconState");
static_assert(sizeof(AHLLRconState) == 0x000260, "Wrong size on AHLLRconState");
static_assert(offsetof(AHLLRconState, SayMessageUpdatedEvent) == 0x000220, "Member 'AHLLRconState::SayMessageUpdatedEvent' has a wrong offset!");
static_assert(offsetof(AHLLRconState, M_CurrentRconSay) == 0x000230, "Member 'AHLLRconState::M_CurrentRconSay' has a wrong offset!");

// Class HLL.BurningComponent
// 0x0070 (0x0120 - 0x00B0)
class UBurningComponent final : public UActorComponent
{
public:
	float                                         MaxBurn;                                           // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BurnInterpSpeed;                                   // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownDelay;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownRate;                                      // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BurnedSurfaceCooldownDelay;                        // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BurnedSurfaceCooldownRate;                         // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        BurnTemplate;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               BurnPSC;                                           // 0x00D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             BurnSound;                                         // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        BurnAC;                                            // 0x00E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C2[0x38];                                    // 0x00E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BurningComponent">();
	}
	static class UBurningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBurningComponent>();
	}
};
static_assert(alignof(UBurningComponent) == 0x000008, "Wrong alignment on UBurningComponent");
static_assert(sizeof(UBurningComponent) == 0x000120, "Wrong size on UBurningComponent");
static_assert(offsetof(UBurningComponent, MaxBurn) == 0x0000B0, "Member 'UBurningComponent::MaxBurn' has a wrong offset!");
static_assert(offsetof(UBurningComponent, BurnInterpSpeed) == 0x0000B4, "Member 'UBurningComponent::BurnInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBurningComponent, CooldownDelay) == 0x0000B8, "Member 'UBurningComponent::CooldownDelay' has a wrong offset!");
static_assert(offsetof(UBurningComponent, CooldownRate) == 0x0000BC, "Member 'UBurningComponent::CooldownRate' has a wrong offset!");
static_assert(offsetof(UBurningComponent, BurnedSurfaceCooldownDelay) == 0x0000C0, "Member 'UBurningComponent::BurnedSurfaceCooldownDelay' has a wrong offset!");
static_assert(offsetof(UBurningComponent, BurnedSurfaceCooldownRate) == 0x0000C4, "Member 'UBurningComponent::BurnedSurfaceCooldownRate' has a wrong offset!");
static_assert(offsetof(UBurningComponent, BurnTemplate) == 0x0000C8, "Member 'UBurningComponent::BurnTemplate' has a wrong offset!");
static_assert(offsetof(UBurningComponent, BurnPSC) == 0x0000D0, "Member 'UBurningComponent::BurnPSC' has a wrong offset!");
static_assert(offsetof(UBurningComponent, BurnSound) == 0x0000D8, "Member 'UBurningComponent::BurnSound' has a wrong offset!");
static_assert(offsetof(UBurningComponent, BurnAC) == 0x0000E0, "Member 'UBurningComponent::BurnAC' has a wrong offset!");

// Class HLL.VaultingComponent
// 0x0068 (0x0118 - 0x00B0)
class UVaultingComponent final : public UActorComponent
{
public:
	float                                         MinObstacleHeight;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxObstacleHeight;                                 // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxObstacleThicknessToVaultOver;                   // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToObstacle;                             // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAllowedAngleFromFacingObstacleStraight;         // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOpeningWidthForVaulting;                        // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOpeningHeightForVaulting;                       // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxClimbableObstacleHeightStillClassifiedAsVault;  // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C3[0x48];                                    // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool InProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultingComponent">();
	}
	static class UVaultingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultingComponent>();
	}
};
static_assert(alignof(UVaultingComponent) == 0x000008, "Wrong alignment on UVaultingComponent");
static_assert(sizeof(UVaultingComponent) == 0x000118, "Wrong size on UVaultingComponent");
static_assert(offsetof(UVaultingComponent, MinObstacleHeight) == 0x0000B0, "Member 'UVaultingComponent::MinObstacleHeight' has a wrong offset!");
static_assert(offsetof(UVaultingComponent, MaxObstacleHeight) == 0x0000B4, "Member 'UVaultingComponent::MaxObstacleHeight' has a wrong offset!");
static_assert(offsetof(UVaultingComponent, MaxObstacleThicknessToVaultOver) == 0x0000B8, "Member 'UVaultingComponent::MaxObstacleThicknessToVaultOver' has a wrong offset!");
static_assert(offsetof(UVaultingComponent, MaxDistanceToObstacle) == 0x0000BC, "Member 'UVaultingComponent::MaxDistanceToObstacle' has a wrong offset!");
static_assert(offsetof(UVaultingComponent, MaxAllowedAngleFromFacingObstacleStraight) == 0x0000C0, "Member 'UVaultingComponent::MaxAllowedAngleFromFacingObstacleStraight' has a wrong offset!");
static_assert(offsetof(UVaultingComponent, MinOpeningWidthForVaulting) == 0x0000C4, "Member 'UVaultingComponent::MinOpeningWidthForVaulting' has a wrong offset!");
static_assert(offsetof(UVaultingComponent, MinOpeningHeightForVaulting) == 0x0000C8, "Member 'UVaultingComponent::MinOpeningHeightForVaulting' has a wrong offset!");
static_assert(offsetof(UVaultingComponent, MaxClimbableObstacleHeightStillClassifiedAsVault) == 0x0000CC, "Member 'UVaultingComponent::MaxClimbableObstacleHeightStillClassifiedAsVault' has a wrong offset!");

// Class HLL.ButtonPrompt
// 0x0158 (0x0388 - 0x0230)
class UButtonPrompt : public UUserWidget
{
public:
	uint8                                         Pad_10C4[0x20];                                    // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             Timeout;                                           // 0x0250(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              GamepadIcon;                                       // 0x0258(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              SecondaryGamepadIcon;                              // 0x0280(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C5[0xE0];                                    // 0x02A8(0x00E0)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddPrimaryButtonDelegate(TDelegate<void()> Delegate);
	void AddScondaryButtonDelegate(TDelegate<void()> Delegate);
	TSoftObjectPtr<class UTexture2D> GetPrimaryGamepadIcon();
	TSoftObjectPtr<class UTexture2D> GetSecondaryGamepadIcon();
	class UButton* GiveButton();
	bool HasSecondaryGamepadIcon();
	void OnButtonDelegateRemoved();
	void PrimaryGamepadButtonReleased();
	void ReceiveEnabledState(bool bEnabled);
	void ReceiveInitialisedButtonPrompt();
	void ReceiveNewLabel();
	void ReceiveNewTimeoutText(const struct FTimespan& TimeRemaining);
	void RemoveButtonDelegate();
	void SecondaryGamepadButtonReleased();

	uint8 GetButtonID() const;
	EHLLButtonInputType GetButtonInputType() const;
	class FText GetButtonLabel() const;
	bool IsGamepadOnlyButton() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonPrompt">();
	}
	static class UButtonPrompt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonPrompt>();
	}
};
static_assert(alignof(UButtonPrompt) == 0x000008, "Wrong alignment on UButtonPrompt");
static_assert(sizeof(UButtonPrompt) == 0x000388, "Wrong size on UButtonPrompt");
static_assert(offsetof(UButtonPrompt, Timeout) == 0x000250, "Member 'UButtonPrompt::Timeout' has a wrong offset!");
static_assert(offsetof(UButtonPrompt, GamepadIcon) == 0x000258, "Member 'UButtonPrompt::GamepadIcon' has a wrong offset!");
static_assert(offsetof(UButtonPrompt, SecondaryGamepadIcon) == 0x000280, "Member 'UButtonPrompt::SecondaryGamepadIcon' has a wrong offset!");

// Class HLL.HLLCosmeticManager
// 0x0120 (0x0148 - 0x0028)
class UHLLCosmeticManager final : public UObject
{
public:
	uint8                                         Pad_10C6[0xF0];                                    // 0x0028(0x00F0)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             CheckCosmeticsDelegate;                            // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C7[0x20];                                    // 0x0128(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class FName Character_GetNetID(const EHLLCosmeticType Type, const EPlayerRole Role, const EFaction Faction, const class FName InCosmeticID);
	static class FName Character_GetSafeID(const EHLLCosmeticType Type, const EPlayerRole Role, const EFaction Faction, const class FName InCosmeticID);
	static class UHLLCosmeticManager* GetChecked(const class UObject* WorldContextObject);

	void HLLCheckCosmetics__DelegateSignature();
	void OnStatsManagerStatsUpdate(const struct FUniqueNetIdRepl& UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCosmeticManager">();
	}
	static class UHLLCosmeticManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCosmeticManager>();
	}
};
static_assert(alignof(UHLLCosmeticManager) == 0x000008, "Wrong alignment on UHLLCosmeticManager");
static_assert(sizeof(UHLLCosmeticManager) == 0x000148, "Wrong size on UHLLCosmeticManager");
static_assert(offsetof(UHLLCosmeticManager, CheckCosmeticsDelegate) == 0x000118, "Member 'UHLLCosmeticManager::CheckCosmeticsDelegate' has a wrong offset!");

// Class HLL.ButtonPromptInfo
// 0x0028 (0x0258 - 0x0230)
class UButtonPromptInfo : public UUserWidget
{
public:
	class UHorizontalBox*                         ButtonPrompts;                                     // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10CA[0x10];                                    // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UInputComponent*                        ButtonPromptInputComponent;                        // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UButtonPromptInfo* GetButtonPrompts(class UObject* WorldContextObject);

	EHLLAddResult AddButton(const uint8 ButtonID, const class FText& ButtonLabel, const bool bGamepadOnly, const EHLLGamepadButtons SelectedButton, const struct FKey& GamepadButton, const TDelegate<void()> Delegate);
	EHLLAddResult AddButton_NEW(const uint8 InButtonID, const class FText& InButtonLabel, const EHLLButtonInputType InButtonInputType, const EHLLGamepadButtons InPrimarySelectedButton, const EHLLGamepadButtons InSecondarySelectedButton, const struct FKey& InPrimaryGamepadButton, const struct FKey& InSecondaryGamepadButton, const TDelegate<void()> InPrimaryDelegate, const TDelegate<void()> InSecondaryDelegate);
	EHLLAddResult AddButton_Single(const uint8 ButtonID, const class FText& ButtonLabel, const EHLLButtonInputType InButtonInputType, const EHLLGamepadButtons SelectedButton, const struct FKey& GamepadButton, const TDelegate<void()> Delegate);
	void ChangeButtonEnabledState(const uint8 ButtonID, const bool bEnabled);
	void ChangeButtonLabel(const uint8 ButtonID, const class FText& NewLabel);
	void CleanUp();
	EHLLGamepadButtons GetButtonIcon(const class FName& Action);
	class UButtonPrompt* GetButtonPromptByID(const uint8 ButtonID);
	TSoftObjectPtr<class UTexture2D> GetGamepadIcon(const EHLLGamepadButtons SelectedButton);
	bool IsButtonPromptEnabled(const uint8 ButtonID);
	bool IsTimerActive(const uint8 ButtonID);
	class UButtonPrompt* MakeButtonPrompt();
	void ReceiveGamepadOnlyPrompt();
	void RegisterButtonPrompt();
	EHLLRemoveResult RemoveButton(const uint8 ButtonID);
	void SetButtonVisibility(const uint8 ButtonID, const ESlateVisibility NewVisibility);
	void UpdateTimeoutText(const uint8 ButtonID, const struct FTimespan& TimeRemaining);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonPromptInfo">();
	}
	static class UButtonPromptInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonPromptInfo>();
	}
};
static_assert(alignof(UButtonPromptInfo) == 0x000008, "Wrong alignment on UButtonPromptInfo");
static_assert(sizeof(UButtonPromptInfo) == 0x000258, "Wrong size on UButtonPromptInfo");
static_assert(offsetof(UButtonPromptInfo, ButtonPrompts) == 0x000230, "Member 'UButtonPromptInfo::ButtonPrompts' has a wrong offset!");
static_assert(offsetof(UButtonPromptInfo, ViewportClient) == 0x000238, "Member 'UButtonPromptInfo::ViewportClient' has a wrong offset!");
static_assert(offsetof(UButtonPromptInfo, ButtonPromptInputComponent) == 0x000250, "Member 'UButtonPromptInfo::ButtonPromptInputComponent' has a wrong offset!");

// Class HLL.HLLPlatoon
// 0x0038 (0x0258 - 0x0220)
class AHLLPlatoon final : public AActor
{
public:
	uint8                                         Pad_10D9[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         ID;                                                // 0x0228(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlatoonType                                  Type;                                              // 0x022C(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeam                                         Team;                                              // 0x022D(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10DA[0x2];                                     // 0x022E(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerState*                    Officer;                                           // 0x0230(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlatoonMeta                           PlatoonMeta;                                       // 0x0238(0x0002)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10DB[0x6];                                     // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AShooterPlayerState*>            Members;                                           // 0x0240(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           SuppressionModifierCurve;                          // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Members();
	void OnRep_Officer();

	int32 GetMemberCount() const;
	TArray<class AShooterPlayerState*> GetPlatoonMembers() const;
	int32 MaxMemberCount() const;
	int32 MaxMemberCountForRole(EPlayerRole PlayerRole) const;
	int32 NumMembersWithRole(EPlayerRole PlayerRole) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPlatoon">();
	}
	static class AHLLPlatoon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLPlatoon>();
	}
};
static_assert(alignof(AHLLPlatoon) == 0x000008, "Wrong alignment on AHLLPlatoon");
static_assert(sizeof(AHLLPlatoon) == 0x000258, "Wrong size on AHLLPlatoon");
static_assert(offsetof(AHLLPlatoon, ID) == 0x000228, "Member 'AHLLPlatoon::ID' has a wrong offset!");
static_assert(offsetof(AHLLPlatoon, Type) == 0x00022C, "Member 'AHLLPlatoon::Type' has a wrong offset!");
static_assert(offsetof(AHLLPlatoon, Team) == 0x00022D, "Member 'AHLLPlatoon::Team' has a wrong offset!");
static_assert(offsetof(AHLLPlatoon, Officer) == 0x000230, "Member 'AHLLPlatoon::Officer' has a wrong offset!");
static_assert(offsetof(AHLLPlatoon, PlatoonMeta) == 0x000238, "Member 'AHLLPlatoon::PlatoonMeta' has a wrong offset!");
static_assert(offsetof(AHLLPlatoon, Members) == 0x000240, "Member 'AHLLPlatoon::Members' has a wrong offset!");
static_assert(offsetof(AHLLPlatoon, SuppressionModifierCurve) == 0x000250, "Member 'AHLLPlatoon::SuppressionModifierCurve' has a wrong offset!");

// Class HLL.HLLProjectile
// 0x0108 (0x0138 - 0x0030)
class UHLLProjectile : public UDataAsset
{
public:
	ECollisionChannel                             SweepChannel;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10DE[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MaxFlightTime;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpireVelocity;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10DF[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UShooterDamageType>         DamageType;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DamageCurve;                                       // 0x0048(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DamageScale;                                       // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressRadius;                                    // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressScale;                                     // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressFalloff;                                   // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSuppressAllTeams : 1;                             // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_10E0[0x3];                                     // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SuppressionSegmentLength;                          // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionMinDist;                                // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFPPOnly : 1;                                      // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBeDisabledForFPP : 1;                          // 0x00EC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_10E1[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystem*                        ParticleTemplate;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactEffectCullDistance;                          // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E2[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterImpactEffect>       ImpactTemplate;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FlybySound;                                        // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSeparateFlybySounds : 1;                          // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_10E3[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             FriendlyFlybySound;                                // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlybyOffsetDistance;                               // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationRadiusOffset;                           // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInitialDist;                                    // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlybySkipAngle;                                    // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationCheckDistance;                          // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E4[0x4];                                     // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLProjectile">();
	}
	static class UHLLProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLProjectile>();
	}
};
static_assert(alignof(UHLLProjectile) == 0x000008, "Wrong alignment on UHLLProjectile");
static_assert(sizeof(UHLLProjectile) == 0x000138, "Wrong size on UHLLProjectile");
static_assert(offsetof(UHLLProjectile, SweepChannel) == 0x000030, "Member 'UHLLProjectile::SweepChannel' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, MaxFlightTime) == 0x000034, "Member 'UHLLProjectile::MaxFlightTime' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, ExpireVelocity) == 0x000038, "Member 'UHLLProjectile::ExpireVelocity' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, DamageType) == 0x000040, "Member 'UHLLProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, DamageCurve) == 0x000048, "Member 'UHLLProjectile::DamageCurve' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, DamageScale) == 0x0000D0, "Member 'UHLLProjectile::DamageScale' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, SuppressRadius) == 0x0000D4, "Member 'UHLLProjectile::SuppressRadius' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, SuppressScale) == 0x0000D8, "Member 'UHLLProjectile::SuppressScale' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, SuppressFalloff) == 0x0000DC, "Member 'UHLLProjectile::SuppressFalloff' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, SuppressionSegmentLength) == 0x0000E4, "Member 'UHLLProjectile::SuppressionSegmentLength' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, SuppressionMinDist) == 0x0000E8, "Member 'UHLLProjectile::SuppressionMinDist' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, ParticleTemplate) == 0x0000F0, "Member 'UHLLProjectile::ParticleTemplate' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, ImpactEffectCullDistance) == 0x0000F8, "Member 'UHLLProjectile::ImpactEffectCullDistance' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, ImpactTemplate) == 0x000100, "Member 'UHLLProjectile::ImpactTemplate' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, FlybySound) == 0x000108, "Member 'UHLLProjectile::FlybySound' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, FriendlyFlybySound) == 0x000118, "Member 'UHLLProjectile::FriendlyFlybySound' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, FlybyOffsetDistance) == 0x000120, "Member 'UHLLProjectile::FlybyOffsetDistance' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, AttenuationRadiusOffset) == 0x000124, "Member 'UHLLProjectile::AttenuationRadiusOffset' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, MinInitialDist) == 0x000128, "Member 'UHLLProjectile::MinInitialDist' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, FlybySkipAngle) == 0x00012C, "Member 'UHLLProjectile::FlybySkipAngle' has a wrong offset!");
static_assert(offsetof(UHLLProjectile, AttenuationCheckDistance) == 0x000130, "Member 'UHLLProjectile::AttenuationCheckDistance' has a wrong offset!");

// Class HLL.HLLProjectile_Bullet
// 0x0030 (0x0168 - 0x0138)
class UHLLProjectile_Bullet : public UHLLProjectile
{
public:
	float                                         InstantTravelTime;                                 // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MuzzleVelocity;                                    // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MassG;                                             // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiameterMM;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistance;                                     // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormFactor;                                        // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxPenetrations;                                   // 0x0154(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E5[0x3];                                     // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         PenetrationPower;                                  // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E6[0x4];                                     // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterImpactEffect>       ExitTemplate;                                      // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLProjectile_Bullet">();
	}
	static class UHLLProjectile_Bullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLProjectile_Bullet>();
	}
};
static_assert(alignof(UHLLProjectile_Bullet) == 0x000008, "Wrong alignment on UHLLProjectile_Bullet");
static_assert(sizeof(UHLLProjectile_Bullet) == 0x000168, "Wrong size on UHLLProjectile_Bullet");
static_assert(offsetof(UHLLProjectile_Bullet, InstantTravelTime) == 0x000138, "Member 'UHLLProjectile_Bullet::InstantTravelTime' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, MuzzleVelocity) == 0x00013C, "Member 'UHLLProjectile_Bullet::MuzzleVelocity' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, GravityScale) == 0x000140, "Member 'UHLLProjectile_Bullet::GravityScale' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, MassG) == 0x000144, "Member 'UHLLProjectile_Bullet::MassG' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, DiameterMM) == 0x000148, "Member 'UHLLProjectile_Bullet::DiameterMM' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, AirResistance) == 0x00014C, "Member 'UHLLProjectile_Bullet::AirResistance' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, FormFactor) == 0x000150, "Member 'UHLLProjectile_Bullet::FormFactor' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, MaxPenetrations) == 0x000154, "Member 'UHLLProjectile_Bullet::MaxPenetrations' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, PenetrationPower) == 0x000158, "Member 'UHLLProjectile_Bullet::PenetrationPower' has a wrong offset!");
static_assert(offsetof(UHLLProjectile_Bullet, ExitTemplate) == 0x000160, "Member 'UHLLProjectile_Bullet::ExitTemplate' has a wrong offset!");

// Class HLL.HLLProjectile_VehicleBullet
// 0x0000 (0x0168 - 0x0168)
class UHLLProjectile_VehicleBullet final : public UHLLProjectile_Bullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLProjectile_VehicleBullet">();
	}
	static class UHLLProjectile_VehicleBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLProjectile_VehicleBullet>();
	}
};
static_assert(alignof(UHLLProjectile_VehicleBullet) == 0x000008, "Wrong alignment on UHLLProjectile_VehicleBullet");
static_assert(sizeof(UHLLProjectile_VehicleBullet) == 0x000168, "Wrong size on UHLLProjectile_VehicleBullet");

// Class HLL.RecentPlayersGameSubsystem
// 0x0018 (0x0048 - 0x0030)
class URecentPlayersGameSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_10E7[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRecentPlayersData                     M_RecentPlayersData;                               // 0x0038(0x0010)(NativeAccessSpecifierPrivate)

public:
	const struct FRecentPlayersData GetRecentPlayersList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecentPlayersGameSubsystem">();
	}
	static class URecentPlayersGameSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecentPlayersGameSubsystem>();
	}
};
static_assert(alignof(URecentPlayersGameSubsystem) == 0x000008, "Wrong alignment on URecentPlayersGameSubsystem");
static_assert(sizeof(URecentPlayersGameSubsystem) == 0x000048, "Wrong size on URecentPlayersGameSubsystem");
static_assert(offsetof(URecentPlayersGameSubsystem, M_RecentPlayersData) == 0x000038, "Member 'URecentPlayersGameSubsystem::M_RecentPlayersData' has a wrong offset!");

// Class HLL.CharacterPreviewWorldSubsystem
// 0x0088 (0x00B8 - 0x0030)
class UCharacterPreviewWorldSubsystem final : public UWorldSubsystem
{
public:
	class AHLLCosmeticCharacter*                  CosmeticPreviewActor;                              // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10E8[0x80];                                    // 0x0038(0x0080)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void PreviewCosmetic(const EHLLCosmeticType CosmeticType, const class FName CosmeticRowName);
	void RestorePreviewCharacterState();
	void SetPreviewCharacter(const class AHLLCosmeticCharacter* InActor);

	const class AHLLCosmeticCharacter* GetCosmeticCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPreviewWorldSubsystem">();
	}
	static class UCharacterPreviewWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPreviewWorldSubsystem>();
	}
};
static_assert(alignof(UCharacterPreviewWorldSubsystem) == 0x000008, "Wrong alignment on UCharacterPreviewWorldSubsystem");
static_assert(sizeof(UCharacterPreviewWorldSubsystem) == 0x0000B8, "Wrong size on UCharacterPreviewWorldSubsystem");
static_assert(offsetof(UCharacterPreviewWorldSubsystem, CosmeticPreviewActor) == 0x000030, "Member 'UCharacterPreviewWorldSubsystem::CosmeticPreviewActor' has a wrong offset!");

// Class HLL.Chat
// 0x0000 (0x0230 - 0x0230)
class UChat : public UUserWidget
{
public:
	class UEditableTextBox* GetFocusTarget();
	void InternalAddAbilityUse(const class FText& String);
	void InternalAddLine(EChatChannel Channel, EPlayerRole PlayerRole, const class FText& SenderName, const class FText& ChatString);
	void InternalHideChat(bool bHide);
	void InternalShowPrompt(EChatChannel Channel);

	bool IsHidden() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Chat">();
	}
	static class UChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChat>();
	}
};
static_assert(alignof(UChat) == 0x000008, "Wrong alignment on UChat");
static_assert(sizeof(UChat) == 0x000230, "Wrong size on UChat");

// Class HLL.HLLDamageNotifyInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLDamageNotifyInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDamageNotifyInterface">();
	}
	static class IHLLDamageNotifyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLDamageNotifyInterface>();
	}
};
static_assert(alignof(IHLLDamageNotifyInterface) == 0x000008, "Wrong alignment on IHLLDamageNotifyInterface");
static_assert(sizeof(IHLLDamageNotifyInterface) == 0x000028, "Wrong size on IHLLDamageNotifyInterface");

// Class HLL.RepairAchievement
// 0x0000 (0x0030 - 0x0030)
class URepairAchievement : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairAchievement">();
	}
	static class URepairAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepairAchievement>();
	}
};
static_assert(alignof(URepairAchievement) == 0x000008, "Wrong alignment on URepairAchievement");
static_assert(sizeof(URepairAchievement) == 0x000030, "Wrong size on URepairAchievement");

// Class HLL.RepairVehiclesAsFactionProgressionAchievement
// 0x0008 (0x0038 - 0x0030)
class URepairVehiclesAsFactionProgressionAchievement final : public URepairAchievement
{
public:
	EFaction                                      Faction;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLAchievementStat                           AchievementStat;                                   // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10EB[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairVehiclesAsFactionProgressionAchievement">();
	}
	static class URepairVehiclesAsFactionProgressionAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepairVehiclesAsFactionProgressionAchievement>();
	}
};
static_assert(alignof(URepairVehiclesAsFactionProgressionAchievement) == 0x000008, "Wrong alignment on URepairVehiclesAsFactionProgressionAchievement");
static_assert(sizeof(URepairVehiclesAsFactionProgressionAchievement) == 0x000038, "Wrong size on URepairVehiclesAsFactionProgressionAchievement");
static_assert(offsetof(URepairVehiclesAsFactionProgressionAchievement, Faction) == 0x000030, "Member 'URepairVehiclesAsFactionProgressionAchievement::Faction' has a wrong offset!");
static_assert(offsetof(URepairVehiclesAsFactionProgressionAchievement, AchievementStat) == 0x000031, "Member 'URepairVehiclesAsFactionProgressionAchievement::AchievementStat' has a wrong offset!");

// Class HLL.ChatOverlay
// 0x0050 (0x0280 - 0x0230)
class UChatOverlay : public UUserWidget
{
public:
	class UChat*                                  Chat;                                              // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PromptText;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLKeyText*                            PromptKey;                                         // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                PromptBorder;                                      // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdminMessageText;                                  // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             AdminMessageScroller;                              // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ToggleAdminMessage;                                // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScrollSpeed;                                       // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdminMessage_InitialDelay;                         // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdminMessage_CompletionTime;                       // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10EC[0xC];                                     // 0x0274(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnAdminMessage(const class FText& Message);
	void SetConsumeClickButtonVisibility(bool bIsVisible);
	void SetConsumeClickButtonVisibilityEvent(const ESlateVisibility& ButtonVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatOverlay">();
	}
	static class UChatOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatOverlay>();
	}
};
static_assert(alignof(UChatOverlay) == 0x000008, "Wrong alignment on UChatOverlay");
static_assert(sizeof(UChatOverlay) == 0x000280, "Wrong size on UChatOverlay");
static_assert(offsetof(UChatOverlay, Chat) == 0x000230, "Member 'UChatOverlay::Chat' has a wrong offset!");
static_assert(offsetof(UChatOverlay, PromptText) == 0x000238, "Member 'UChatOverlay::PromptText' has a wrong offset!");
static_assert(offsetof(UChatOverlay, PromptKey) == 0x000240, "Member 'UChatOverlay::PromptKey' has a wrong offset!");
static_assert(offsetof(UChatOverlay, PromptBorder) == 0x000248, "Member 'UChatOverlay::PromptBorder' has a wrong offset!");
static_assert(offsetof(UChatOverlay, AdminMessageText) == 0x000250, "Member 'UChatOverlay::AdminMessageText' has a wrong offset!");
static_assert(offsetof(UChatOverlay, AdminMessageScroller) == 0x000258, "Member 'UChatOverlay::AdminMessageScroller' has a wrong offset!");
static_assert(offsetof(UChatOverlay, ToggleAdminMessage) == 0x000260, "Member 'UChatOverlay::ToggleAdminMessage' has a wrong offset!");
static_assert(offsetof(UChatOverlay, ScrollSpeed) == 0x000268, "Member 'UChatOverlay::ScrollSpeed' has a wrong offset!");
static_assert(offsetof(UChatOverlay, AdminMessage_InitialDelay) == 0x00026C, "Member 'UChatOverlay::AdminMessage_InitialDelay' has a wrong offset!");
static_assert(offsetof(UChatOverlay, AdminMessage_CompletionTime) == 0x000270, "Member 'UChatOverlay::AdminMessage_CompletionTime' has a wrong offset!");

// Class HLL.HLLPlayerAchievements
// 0x0778 (0x07A8 - 0x0030)
class UHLLPlayerAchievements final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_10ED[0x748];                                   // 0x0030(0x0748)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSoftObjectPath                        AchievementStatTablePath;                          // 0x0778(0x0018)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        AchievementTablePath;                              // 0x0790(0x0018)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void Debug_GenerateComboOptions(TArray<class FString>* Achievements, TArray<class FString>* AchievementStats);
	static void Debug_IncrementAchievementStat(const class APlayerController* Player, const EHLLAchievementStat Stat, const int32 Amount);
	static void Debug_ResetAchievements(const class APlayerController* Player);
	static bool Debug_UnlockAchievement(const class APlayerController* Player, const EHLLAchievement Achievement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPlayerAchievements">();
	}
	static class UHLLPlayerAchievements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPlayerAchievements>();
	}
};
static_assert(alignof(UHLLPlayerAchievements) == 0x000008, "Wrong alignment on UHLLPlayerAchievements");
static_assert(sizeof(UHLLPlayerAchievements) == 0x0007A8, "Wrong size on UHLLPlayerAchievements");
static_assert(offsetof(UHLLPlayerAchievements, AchievementStatTablePath) == 0x000778, "Member 'UHLLPlayerAchievements::AchievementStatTablePath' has a wrong offset!");
static_assert(offsetof(UHLLPlayerAchievements, AchievementTablePath) == 0x000790, "Member 'UHLLPlayerAchievements::AchievementTablePath' has a wrong offset!");

// Class HLL.CinematicPantherStub
// 0x0618 (0x0838 - 0x0220)
class ACinematicPantherStub final : public AActor
{
public:
	class USkeletalMeshComponent*                 TankMesh;                                          // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           AllTrackTiles;                                     // 0x0228(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_000;                                     // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_001;                                     // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_002;                                     // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_003;                                     // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_004;                                     // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_005;                                     // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_006;                                     // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_007;                                     // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_008;                                     // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_009;                                     // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_010;                                     // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_011;                                     // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_012;                                     // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_013;                                     // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_014;                                     // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_015;                                     // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_016;                                     // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_017;                                     // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_018;                                     // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_019;                                     // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_020;                                     // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_021;                                     // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_022;                                     // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_023;                                     // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_024;                                     // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_025;                                     // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_026;                                     // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_027;                                     // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_028;                                     // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_029;                                     // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_030;                                     // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_031;                                     // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_032;                                     // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_033;                                     // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_034;                                     // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_035;                                     // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_036;                                     // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_037;                                     // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_038;                                     // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_039;                                     // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_040;                                     // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_041;                                     // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_042;                                     // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_043;                                     // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_044;                                     // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_045;                                     // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_046;                                     // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_047;                                     // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_048;                                     // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_049;                                     // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_050;                                     // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_051;                                     // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_052;                                     // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_053;                                     // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_054;                                     // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_055;                                     // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_056;                                     // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_057;                                     // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_058;                                     // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_059;                                     // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_060;                                     // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_061;                                     // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_062;                                     // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_063;                                     // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_064;                                     // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_065;                                     // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_066;                                     // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_067;                                     // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_068;                                     // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_069;                                     // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_070;                                     // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_071;                                     // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_072;                                     // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_073;                                     // 0x0480(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_074;                                     // 0x0488(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_075;                                     // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_076;                                     // 0x0498(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_077;                                     // 0x04A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_078;                                     // 0x04A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_079;                                     // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_080;                                     // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_081;                                     // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_082;                                     // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_083;                                     // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_084;                                     // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_085;                                     // 0x04E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_086;                                     // 0x04E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_087;                                     // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_088;                                     // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_089;                                     // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_090;                                     // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_091;                                     // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_092;                                     // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_093;                                     // 0x0520(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_094;                                     // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_095;                                     // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_096;                                     // 0x0538(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_097;                                     // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_098;                                     // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_099;                                     // 0x0550(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_100;                                     // 0x0558(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_101;                                     // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_102;                                     // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_103;                                     // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_104;                                     // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_105;                                     // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_106;                                     // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_107;                                     // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_108;                                     // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_109;                                     // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_110;                                     // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_111;                                     // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_112;                                     // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_113;                                     // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_114;                                     // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_115;                                     // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_116;                                     // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_117;                                     // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_118;                                     // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_119;                                     // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_120;                                     // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_121;                                     // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_122;                                     // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_123;                                     // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_124;                                     // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_125;                                     // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_126;                                     // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_127;                                     // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_128;                                     // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_129;                                     // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_130;                                     // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_131;                                     // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_132;                                     // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_133;                                     // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_134;                                     // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_135;                                     // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_136;                                     // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_137;                                     // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_138;                                     // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_139;                                     // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_140;                                     // 0x0698(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_141;                                     // 0x06A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_142;                                     // 0x06A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_143;                                     // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_144;                                     // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_145;                                     // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_146;                                     // 0x06C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_147;                                     // 0x06D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_148;                                     // 0x06D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_149;                                     // 0x06E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_150;                                     // 0x06E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_151;                                     // 0x06F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_152;                                     // 0x06F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_153;                                     // 0x0700(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_154;                                     // 0x0708(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_155;                                     // 0x0710(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_156;                                     // 0x0718(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_157;                                     // 0x0720(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_158;                                     // 0x0728(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_159;                                     // 0x0730(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_160;                                     // 0x0738(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_161;                                     // 0x0740(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_162;                                     // 0x0748(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_163;                                     // 0x0750(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_164;                                     // 0x0758(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_165;                                     // 0x0760(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_166;                                     // 0x0768(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_167;                                     // 0x0770(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_168;                                     // 0x0778(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_169;                                     // 0x0780(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_170;                                     // 0x0788(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_171;                                     // 0x0790(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_172;                                     // 0x0798(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_173;                                     // 0x07A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_174;                                     // 0x07A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_175;                                     // 0x07B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_176;                                     // 0x07B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_177;                                     // 0x07C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_178;                                     // 0x07C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_179;                                     // 0x07D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_180;                                     // 0x07D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_181;                                     // 0x07E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_182;                                     // 0x07E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_183;                                     // 0x07F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_184;                                     // 0x07F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_185;                                     // 0x0800(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_186;                                     // 0x0808(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_187;                                     // 0x0810(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_188;                                     // 0x0818(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_189;                                     // 0x0820(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_190;                                     // 0x0828(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_191;                                     // 0x0830(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicPantherStub">();
	}
	static class ACinematicPantherStub* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACinematicPantherStub>();
	}
};
static_assert(alignof(ACinematicPantherStub) == 0x000008, "Wrong alignment on ACinematicPantherStub");
static_assert(sizeof(ACinematicPantherStub) == 0x000838, "Wrong size on ACinematicPantherStub");
static_assert(offsetof(ACinematicPantherStub, TankMesh) == 0x000220, "Member 'ACinematicPantherStub::TankMesh' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, AllTrackTiles) == 0x000228, "Member 'ACinematicPantherStub::AllTrackTiles' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_000) == 0x000238, "Member 'ACinematicPantherStub::TrackTile_000' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_001) == 0x000240, "Member 'ACinematicPantherStub::TrackTile_001' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_002) == 0x000248, "Member 'ACinematicPantherStub::TrackTile_002' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_003) == 0x000250, "Member 'ACinematicPantherStub::TrackTile_003' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_004) == 0x000258, "Member 'ACinematicPantherStub::TrackTile_004' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_005) == 0x000260, "Member 'ACinematicPantherStub::TrackTile_005' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_006) == 0x000268, "Member 'ACinematicPantherStub::TrackTile_006' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_007) == 0x000270, "Member 'ACinematicPantherStub::TrackTile_007' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_008) == 0x000278, "Member 'ACinematicPantherStub::TrackTile_008' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_009) == 0x000280, "Member 'ACinematicPantherStub::TrackTile_009' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_010) == 0x000288, "Member 'ACinematicPantherStub::TrackTile_010' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_011) == 0x000290, "Member 'ACinematicPantherStub::TrackTile_011' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_012) == 0x000298, "Member 'ACinematicPantherStub::TrackTile_012' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_013) == 0x0002A0, "Member 'ACinematicPantherStub::TrackTile_013' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_014) == 0x0002A8, "Member 'ACinematicPantherStub::TrackTile_014' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_015) == 0x0002B0, "Member 'ACinematicPantherStub::TrackTile_015' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_016) == 0x0002B8, "Member 'ACinematicPantherStub::TrackTile_016' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_017) == 0x0002C0, "Member 'ACinematicPantherStub::TrackTile_017' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_018) == 0x0002C8, "Member 'ACinematicPantherStub::TrackTile_018' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_019) == 0x0002D0, "Member 'ACinematicPantherStub::TrackTile_019' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_020) == 0x0002D8, "Member 'ACinematicPantherStub::TrackTile_020' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_021) == 0x0002E0, "Member 'ACinematicPantherStub::TrackTile_021' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_022) == 0x0002E8, "Member 'ACinematicPantherStub::TrackTile_022' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_023) == 0x0002F0, "Member 'ACinematicPantherStub::TrackTile_023' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_024) == 0x0002F8, "Member 'ACinematicPantherStub::TrackTile_024' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_025) == 0x000300, "Member 'ACinematicPantherStub::TrackTile_025' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_026) == 0x000308, "Member 'ACinematicPantherStub::TrackTile_026' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_027) == 0x000310, "Member 'ACinematicPantherStub::TrackTile_027' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_028) == 0x000318, "Member 'ACinematicPantherStub::TrackTile_028' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_029) == 0x000320, "Member 'ACinematicPantherStub::TrackTile_029' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_030) == 0x000328, "Member 'ACinematicPantherStub::TrackTile_030' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_031) == 0x000330, "Member 'ACinematicPantherStub::TrackTile_031' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_032) == 0x000338, "Member 'ACinematicPantherStub::TrackTile_032' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_033) == 0x000340, "Member 'ACinematicPantherStub::TrackTile_033' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_034) == 0x000348, "Member 'ACinematicPantherStub::TrackTile_034' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_035) == 0x000350, "Member 'ACinematicPantherStub::TrackTile_035' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_036) == 0x000358, "Member 'ACinematicPantherStub::TrackTile_036' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_037) == 0x000360, "Member 'ACinematicPantherStub::TrackTile_037' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_038) == 0x000368, "Member 'ACinematicPantherStub::TrackTile_038' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_039) == 0x000370, "Member 'ACinematicPantherStub::TrackTile_039' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_040) == 0x000378, "Member 'ACinematicPantherStub::TrackTile_040' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_041) == 0x000380, "Member 'ACinematicPantherStub::TrackTile_041' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_042) == 0x000388, "Member 'ACinematicPantherStub::TrackTile_042' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_043) == 0x000390, "Member 'ACinematicPantherStub::TrackTile_043' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_044) == 0x000398, "Member 'ACinematicPantherStub::TrackTile_044' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_045) == 0x0003A0, "Member 'ACinematicPantherStub::TrackTile_045' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_046) == 0x0003A8, "Member 'ACinematicPantherStub::TrackTile_046' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_047) == 0x0003B0, "Member 'ACinematicPantherStub::TrackTile_047' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_048) == 0x0003B8, "Member 'ACinematicPantherStub::TrackTile_048' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_049) == 0x0003C0, "Member 'ACinematicPantherStub::TrackTile_049' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_050) == 0x0003C8, "Member 'ACinematicPantherStub::TrackTile_050' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_051) == 0x0003D0, "Member 'ACinematicPantherStub::TrackTile_051' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_052) == 0x0003D8, "Member 'ACinematicPantherStub::TrackTile_052' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_053) == 0x0003E0, "Member 'ACinematicPantherStub::TrackTile_053' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_054) == 0x0003E8, "Member 'ACinematicPantherStub::TrackTile_054' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_055) == 0x0003F0, "Member 'ACinematicPantherStub::TrackTile_055' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_056) == 0x0003F8, "Member 'ACinematicPantherStub::TrackTile_056' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_057) == 0x000400, "Member 'ACinematicPantherStub::TrackTile_057' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_058) == 0x000408, "Member 'ACinematicPantherStub::TrackTile_058' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_059) == 0x000410, "Member 'ACinematicPantherStub::TrackTile_059' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_060) == 0x000418, "Member 'ACinematicPantherStub::TrackTile_060' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_061) == 0x000420, "Member 'ACinematicPantherStub::TrackTile_061' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_062) == 0x000428, "Member 'ACinematicPantherStub::TrackTile_062' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_063) == 0x000430, "Member 'ACinematicPantherStub::TrackTile_063' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_064) == 0x000438, "Member 'ACinematicPantherStub::TrackTile_064' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_065) == 0x000440, "Member 'ACinematicPantherStub::TrackTile_065' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_066) == 0x000448, "Member 'ACinematicPantherStub::TrackTile_066' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_067) == 0x000450, "Member 'ACinematicPantherStub::TrackTile_067' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_068) == 0x000458, "Member 'ACinematicPantherStub::TrackTile_068' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_069) == 0x000460, "Member 'ACinematicPantherStub::TrackTile_069' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_070) == 0x000468, "Member 'ACinematicPantherStub::TrackTile_070' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_071) == 0x000470, "Member 'ACinematicPantherStub::TrackTile_071' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_072) == 0x000478, "Member 'ACinematicPantherStub::TrackTile_072' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_073) == 0x000480, "Member 'ACinematicPantherStub::TrackTile_073' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_074) == 0x000488, "Member 'ACinematicPantherStub::TrackTile_074' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_075) == 0x000490, "Member 'ACinematicPantherStub::TrackTile_075' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_076) == 0x000498, "Member 'ACinematicPantherStub::TrackTile_076' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_077) == 0x0004A0, "Member 'ACinematicPantherStub::TrackTile_077' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_078) == 0x0004A8, "Member 'ACinematicPantherStub::TrackTile_078' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_079) == 0x0004B0, "Member 'ACinematicPantherStub::TrackTile_079' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_080) == 0x0004B8, "Member 'ACinematicPantherStub::TrackTile_080' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_081) == 0x0004C0, "Member 'ACinematicPantherStub::TrackTile_081' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_082) == 0x0004C8, "Member 'ACinematicPantherStub::TrackTile_082' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_083) == 0x0004D0, "Member 'ACinematicPantherStub::TrackTile_083' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_084) == 0x0004D8, "Member 'ACinematicPantherStub::TrackTile_084' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_085) == 0x0004E0, "Member 'ACinematicPantherStub::TrackTile_085' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_086) == 0x0004E8, "Member 'ACinematicPantherStub::TrackTile_086' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_087) == 0x0004F0, "Member 'ACinematicPantherStub::TrackTile_087' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_088) == 0x0004F8, "Member 'ACinematicPantherStub::TrackTile_088' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_089) == 0x000500, "Member 'ACinematicPantherStub::TrackTile_089' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_090) == 0x000508, "Member 'ACinematicPantherStub::TrackTile_090' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_091) == 0x000510, "Member 'ACinematicPantherStub::TrackTile_091' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_092) == 0x000518, "Member 'ACinematicPantherStub::TrackTile_092' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_093) == 0x000520, "Member 'ACinematicPantherStub::TrackTile_093' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_094) == 0x000528, "Member 'ACinematicPantherStub::TrackTile_094' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_095) == 0x000530, "Member 'ACinematicPantherStub::TrackTile_095' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_096) == 0x000538, "Member 'ACinematicPantherStub::TrackTile_096' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_097) == 0x000540, "Member 'ACinematicPantherStub::TrackTile_097' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_098) == 0x000548, "Member 'ACinematicPantherStub::TrackTile_098' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_099) == 0x000550, "Member 'ACinematicPantherStub::TrackTile_099' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_100) == 0x000558, "Member 'ACinematicPantherStub::TrackTile_100' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_101) == 0x000560, "Member 'ACinematicPantherStub::TrackTile_101' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_102) == 0x000568, "Member 'ACinematicPantherStub::TrackTile_102' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_103) == 0x000570, "Member 'ACinematicPantherStub::TrackTile_103' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_104) == 0x000578, "Member 'ACinematicPantherStub::TrackTile_104' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_105) == 0x000580, "Member 'ACinematicPantherStub::TrackTile_105' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_106) == 0x000588, "Member 'ACinematicPantherStub::TrackTile_106' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_107) == 0x000590, "Member 'ACinematicPantherStub::TrackTile_107' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_108) == 0x000598, "Member 'ACinematicPantherStub::TrackTile_108' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_109) == 0x0005A0, "Member 'ACinematicPantherStub::TrackTile_109' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_110) == 0x0005A8, "Member 'ACinematicPantherStub::TrackTile_110' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_111) == 0x0005B0, "Member 'ACinematicPantherStub::TrackTile_111' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_112) == 0x0005B8, "Member 'ACinematicPantherStub::TrackTile_112' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_113) == 0x0005C0, "Member 'ACinematicPantherStub::TrackTile_113' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_114) == 0x0005C8, "Member 'ACinematicPantherStub::TrackTile_114' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_115) == 0x0005D0, "Member 'ACinematicPantherStub::TrackTile_115' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_116) == 0x0005D8, "Member 'ACinematicPantherStub::TrackTile_116' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_117) == 0x0005E0, "Member 'ACinematicPantherStub::TrackTile_117' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_118) == 0x0005E8, "Member 'ACinematicPantherStub::TrackTile_118' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_119) == 0x0005F0, "Member 'ACinematicPantherStub::TrackTile_119' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_120) == 0x0005F8, "Member 'ACinematicPantherStub::TrackTile_120' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_121) == 0x000600, "Member 'ACinematicPantherStub::TrackTile_121' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_122) == 0x000608, "Member 'ACinematicPantherStub::TrackTile_122' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_123) == 0x000610, "Member 'ACinematicPantherStub::TrackTile_123' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_124) == 0x000618, "Member 'ACinematicPantherStub::TrackTile_124' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_125) == 0x000620, "Member 'ACinematicPantherStub::TrackTile_125' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_126) == 0x000628, "Member 'ACinematicPantherStub::TrackTile_126' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_127) == 0x000630, "Member 'ACinematicPantherStub::TrackTile_127' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_128) == 0x000638, "Member 'ACinematicPantherStub::TrackTile_128' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_129) == 0x000640, "Member 'ACinematicPantherStub::TrackTile_129' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_130) == 0x000648, "Member 'ACinematicPantherStub::TrackTile_130' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_131) == 0x000650, "Member 'ACinematicPantherStub::TrackTile_131' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_132) == 0x000658, "Member 'ACinematicPantherStub::TrackTile_132' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_133) == 0x000660, "Member 'ACinematicPantherStub::TrackTile_133' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_134) == 0x000668, "Member 'ACinematicPantherStub::TrackTile_134' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_135) == 0x000670, "Member 'ACinematicPantherStub::TrackTile_135' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_136) == 0x000678, "Member 'ACinematicPantherStub::TrackTile_136' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_137) == 0x000680, "Member 'ACinematicPantherStub::TrackTile_137' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_138) == 0x000688, "Member 'ACinematicPantherStub::TrackTile_138' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_139) == 0x000690, "Member 'ACinematicPantherStub::TrackTile_139' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_140) == 0x000698, "Member 'ACinematicPantherStub::TrackTile_140' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_141) == 0x0006A0, "Member 'ACinematicPantherStub::TrackTile_141' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_142) == 0x0006A8, "Member 'ACinematicPantherStub::TrackTile_142' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_143) == 0x0006B0, "Member 'ACinematicPantherStub::TrackTile_143' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_144) == 0x0006B8, "Member 'ACinematicPantherStub::TrackTile_144' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_145) == 0x0006C0, "Member 'ACinematicPantherStub::TrackTile_145' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_146) == 0x0006C8, "Member 'ACinematicPantherStub::TrackTile_146' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_147) == 0x0006D0, "Member 'ACinematicPantherStub::TrackTile_147' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_148) == 0x0006D8, "Member 'ACinematicPantherStub::TrackTile_148' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_149) == 0x0006E0, "Member 'ACinematicPantherStub::TrackTile_149' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_150) == 0x0006E8, "Member 'ACinematicPantherStub::TrackTile_150' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_151) == 0x0006F0, "Member 'ACinematicPantherStub::TrackTile_151' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_152) == 0x0006F8, "Member 'ACinematicPantherStub::TrackTile_152' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_153) == 0x000700, "Member 'ACinematicPantherStub::TrackTile_153' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_154) == 0x000708, "Member 'ACinematicPantherStub::TrackTile_154' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_155) == 0x000710, "Member 'ACinematicPantherStub::TrackTile_155' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_156) == 0x000718, "Member 'ACinematicPantherStub::TrackTile_156' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_157) == 0x000720, "Member 'ACinematicPantherStub::TrackTile_157' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_158) == 0x000728, "Member 'ACinematicPantherStub::TrackTile_158' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_159) == 0x000730, "Member 'ACinematicPantherStub::TrackTile_159' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_160) == 0x000738, "Member 'ACinematicPantherStub::TrackTile_160' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_161) == 0x000740, "Member 'ACinematicPantherStub::TrackTile_161' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_162) == 0x000748, "Member 'ACinematicPantherStub::TrackTile_162' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_163) == 0x000750, "Member 'ACinematicPantherStub::TrackTile_163' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_164) == 0x000758, "Member 'ACinematicPantherStub::TrackTile_164' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_165) == 0x000760, "Member 'ACinematicPantherStub::TrackTile_165' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_166) == 0x000768, "Member 'ACinematicPantherStub::TrackTile_166' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_167) == 0x000770, "Member 'ACinematicPantherStub::TrackTile_167' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_168) == 0x000778, "Member 'ACinematicPantherStub::TrackTile_168' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_169) == 0x000780, "Member 'ACinematicPantherStub::TrackTile_169' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_170) == 0x000788, "Member 'ACinematicPantherStub::TrackTile_170' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_171) == 0x000790, "Member 'ACinematicPantherStub::TrackTile_171' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_172) == 0x000798, "Member 'ACinematicPantherStub::TrackTile_172' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_173) == 0x0007A0, "Member 'ACinematicPantherStub::TrackTile_173' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_174) == 0x0007A8, "Member 'ACinematicPantherStub::TrackTile_174' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_175) == 0x0007B0, "Member 'ACinematicPantherStub::TrackTile_175' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_176) == 0x0007B8, "Member 'ACinematicPantherStub::TrackTile_176' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_177) == 0x0007C0, "Member 'ACinematicPantherStub::TrackTile_177' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_178) == 0x0007C8, "Member 'ACinematicPantherStub::TrackTile_178' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_179) == 0x0007D0, "Member 'ACinematicPantherStub::TrackTile_179' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_180) == 0x0007D8, "Member 'ACinematicPantherStub::TrackTile_180' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_181) == 0x0007E0, "Member 'ACinematicPantherStub::TrackTile_181' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_182) == 0x0007E8, "Member 'ACinematicPantherStub::TrackTile_182' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_183) == 0x0007F0, "Member 'ACinematicPantherStub::TrackTile_183' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_184) == 0x0007F8, "Member 'ACinematicPantherStub::TrackTile_184' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_185) == 0x000800, "Member 'ACinematicPantherStub::TrackTile_185' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_186) == 0x000808, "Member 'ACinematicPantherStub::TrackTile_186' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_187) == 0x000810, "Member 'ACinematicPantherStub::TrackTile_187' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_188) == 0x000818, "Member 'ACinematicPantherStub::TrackTile_188' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_189) == 0x000820, "Member 'ACinematicPantherStub::TrackTile_189' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_190) == 0x000828, "Member 'ACinematicPantherStub::TrackTile_190' has a wrong offset!");
static_assert(offsetof(ACinematicPantherStub, TrackTile_191) == 0x000830, "Member 'ACinematicPantherStub::TrackTile_191' has a wrong offset!");

// Class HLL.CinematicShermanJumboStub
// 0x04F8 (0x0718 - 0x0220)
class ACinematicShermanJumboStub final : public AActor
{
public:
	class USkeletalMeshComponent*                 TankMesh;                                          // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           AllLeftTrackTiles;                                 // 0x0228(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           AllRightTrackTiles;                                // 0x0238(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_000;                                // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_001;                                // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_002;                                // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_003;                                // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_004;                                // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_005;                                // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_006;                                // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_007;                                // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_008;                                // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_009;                                // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_010;                                // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_011;                                // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_012;                                // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_013;                                // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_014;                                // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_015;                                // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_016;                                // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_017;                                // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_018;                                // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_019;                                // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_020;                                // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_021;                                // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_022;                                // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_023;                                // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_024;                                // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_025;                                // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_026;                                // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_027;                                // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_028;                                // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_029;                                // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_030;                                // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_031;                                // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_032;                                // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_033;                                // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_034;                                // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_035;                                // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_036;                                // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_037;                                // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_038;                                // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_039;                                // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_040;                                // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_041;                                // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_042;                                // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_043;                                // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_044;                                // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_045;                                // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_046;                                // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_047;                                // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_048;                                // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_049;                                // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_050;                                // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_051;                                // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_052;                                // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_053;                                // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_054;                                // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_055;                                // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_056;                                // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_057;                                // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_058;                                // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_059;                                // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_060;                                // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_061;                                // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_062;                                // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_063;                                // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_064;                                // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_065;                                // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_066;                                // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_067;                                // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_068;                                // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_069;                                // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_070;                                // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_071;                                // 0x0480(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_072;                                // 0x0488(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_073;                                // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_074;                                // 0x0498(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_075;                                // 0x04A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RightTrackTile_076;                                // 0x04A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_000;                                 // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_001;                                 // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_002;                                 // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_003;                                 // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_004;                                 // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_005;                                 // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_006;                                 // 0x04E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_007;                                 // 0x04E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_008;                                 // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_009;                                 // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_010;                                 // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_011;                                 // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_012;                                 // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_013;                                 // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_014;                                 // 0x0520(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_015;                                 // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_016;                                 // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_017;                                 // 0x0538(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_018;                                 // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_019;                                 // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_020;                                 // 0x0550(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_021;                                 // 0x0558(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_022;                                 // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_023;                                 // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_024;                                 // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_025;                                 // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_026;                                 // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_027;                                 // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_028;                                 // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_029;                                 // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_030;                                 // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_031;                                 // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_032;                                 // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_033;                                 // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_034;                                 // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_035;                                 // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_036;                                 // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_037;                                 // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_038;                                 // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_039;                                 // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_040;                                 // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_041;                                 // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_042;                                 // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_043;                                 // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_044;                                 // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_045;                                 // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_046;                                 // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_047;                                 // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_048;                                 // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_049;                                 // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_050;                                 // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_051;                                 // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_052;                                 // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_053;                                 // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_054;                                 // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_055;                                 // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_056;                                 // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_057;                                 // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_058;                                 // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_059;                                 // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_060;                                 // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_061;                                 // 0x0698(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_062;                                 // 0x06A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_063;                                 // 0x06A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_064;                                 // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_065;                                 // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_066;                                 // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_067;                                 // 0x06C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_068;                                 // 0x06D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_069;                                 // 0x06D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_070;                                 // 0x06E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_071;                                 // 0x06E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_072;                                 // 0x06F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_073;                                 // 0x06F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_074;                                 // 0x0700(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_075;                                 // 0x0708(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   LeftTrackTile_076;                                 // 0x0710(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicShermanJumboStub">();
	}
	static class ACinematicShermanJumboStub* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACinematicShermanJumboStub>();
	}
};
static_assert(alignof(ACinematicShermanJumboStub) == 0x000008, "Wrong alignment on ACinematicShermanJumboStub");
static_assert(sizeof(ACinematicShermanJumboStub) == 0x000718, "Wrong size on ACinematicShermanJumboStub");
static_assert(offsetof(ACinematicShermanJumboStub, TankMesh) == 0x000220, "Member 'ACinematicShermanJumboStub::TankMesh' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, AllLeftTrackTiles) == 0x000228, "Member 'ACinematicShermanJumboStub::AllLeftTrackTiles' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, AllRightTrackTiles) == 0x000238, "Member 'ACinematicShermanJumboStub::AllRightTrackTiles' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_000) == 0x000248, "Member 'ACinematicShermanJumboStub::RightTrackTile_000' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_001) == 0x000250, "Member 'ACinematicShermanJumboStub::RightTrackTile_001' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_002) == 0x000258, "Member 'ACinematicShermanJumboStub::RightTrackTile_002' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_003) == 0x000260, "Member 'ACinematicShermanJumboStub::RightTrackTile_003' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_004) == 0x000268, "Member 'ACinematicShermanJumboStub::RightTrackTile_004' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_005) == 0x000270, "Member 'ACinematicShermanJumboStub::RightTrackTile_005' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_006) == 0x000278, "Member 'ACinematicShermanJumboStub::RightTrackTile_006' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_007) == 0x000280, "Member 'ACinematicShermanJumboStub::RightTrackTile_007' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_008) == 0x000288, "Member 'ACinematicShermanJumboStub::RightTrackTile_008' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_009) == 0x000290, "Member 'ACinematicShermanJumboStub::RightTrackTile_009' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_010) == 0x000298, "Member 'ACinematicShermanJumboStub::RightTrackTile_010' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_011) == 0x0002A0, "Member 'ACinematicShermanJumboStub::RightTrackTile_011' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_012) == 0x0002A8, "Member 'ACinematicShermanJumboStub::RightTrackTile_012' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_013) == 0x0002B0, "Member 'ACinematicShermanJumboStub::RightTrackTile_013' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_014) == 0x0002B8, "Member 'ACinematicShermanJumboStub::RightTrackTile_014' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_015) == 0x0002C0, "Member 'ACinematicShermanJumboStub::RightTrackTile_015' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_016) == 0x0002C8, "Member 'ACinematicShermanJumboStub::RightTrackTile_016' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_017) == 0x0002D0, "Member 'ACinematicShermanJumboStub::RightTrackTile_017' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_018) == 0x0002D8, "Member 'ACinematicShermanJumboStub::RightTrackTile_018' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_019) == 0x0002E0, "Member 'ACinematicShermanJumboStub::RightTrackTile_019' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_020) == 0x0002E8, "Member 'ACinematicShermanJumboStub::RightTrackTile_020' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_021) == 0x0002F0, "Member 'ACinematicShermanJumboStub::RightTrackTile_021' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_022) == 0x0002F8, "Member 'ACinematicShermanJumboStub::RightTrackTile_022' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_023) == 0x000300, "Member 'ACinematicShermanJumboStub::RightTrackTile_023' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_024) == 0x000308, "Member 'ACinematicShermanJumboStub::RightTrackTile_024' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_025) == 0x000310, "Member 'ACinematicShermanJumboStub::RightTrackTile_025' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_026) == 0x000318, "Member 'ACinematicShermanJumboStub::RightTrackTile_026' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_027) == 0x000320, "Member 'ACinematicShermanJumboStub::RightTrackTile_027' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_028) == 0x000328, "Member 'ACinematicShermanJumboStub::RightTrackTile_028' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_029) == 0x000330, "Member 'ACinematicShermanJumboStub::RightTrackTile_029' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_030) == 0x000338, "Member 'ACinematicShermanJumboStub::RightTrackTile_030' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_031) == 0x000340, "Member 'ACinematicShermanJumboStub::RightTrackTile_031' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_032) == 0x000348, "Member 'ACinematicShermanJumboStub::RightTrackTile_032' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_033) == 0x000350, "Member 'ACinematicShermanJumboStub::RightTrackTile_033' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_034) == 0x000358, "Member 'ACinematicShermanJumboStub::RightTrackTile_034' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_035) == 0x000360, "Member 'ACinematicShermanJumboStub::RightTrackTile_035' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_036) == 0x000368, "Member 'ACinematicShermanJumboStub::RightTrackTile_036' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_037) == 0x000370, "Member 'ACinematicShermanJumboStub::RightTrackTile_037' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_038) == 0x000378, "Member 'ACinematicShermanJumboStub::RightTrackTile_038' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_039) == 0x000380, "Member 'ACinematicShermanJumboStub::RightTrackTile_039' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_040) == 0x000388, "Member 'ACinematicShermanJumboStub::RightTrackTile_040' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_041) == 0x000390, "Member 'ACinematicShermanJumboStub::RightTrackTile_041' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_042) == 0x000398, "Member 'ACinematicShermanJumboStub::RightTrackTile_042' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_043) == 0x0003A0, "Member 'ACinematicShermanJumboStub::RightTrackTile_043' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_044) == 0x0003A8, "Member 'ACinematicShermanJumboStub::RightTrackTile_044' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_045) == 0x0003B0, "Member 'ACinematicShermanJumboStub::RightTrackTile_045' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_046) == 0x0003B8, "Member 'ACinematicShermanJumboStub::RightTrackTile_046' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_047) == 0x0003C0, "Member 'ACinematicShermanJumboStub::RightTrackTile_047' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_048) == 0x0003C8, "Member 'ACinematicShermanJumboStub::RightTrackTile_048' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_049) == 0x0003D0, "Member 'ACinematicShermanJumboStub::RightTrackTile_049' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_050) == 0x0003D8, "Member 'ACinematicShermanJumboStub::RightTrackTile_050' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_051) == 0x0003E0, "Member 'ACinematicShermanJumboStub::RightTrackTile_051' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_052) == 0x0003E8, "Member 'ACinematicShermanJumboStub::RightTrackTile_052' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_053) == 0x0003F0, "Member 'ACinematicShermanJumboStub::RightTrackTile_053' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_054) == 0x0003F8, "Member 'ACinematicShermanJumboStub::RightTrackTile_054' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_055) == 0x000400, "Member 'ACinematicShermanJumboStub::RightTrackTile_055' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_056) == 0x000408, "Member 'ACinematicShermanJumboStub::RightTrackTile_056' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_057) == 0x000410, "Member 'ACinematicShermanJumboStub::RightTrackTile_057' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_058) == 0x000418, "Member 'ACinematicShermanJumboStub::RightTrackTile_058' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_059) == 0x000420, "Member 'ACinematicShermanJumboStub::RightTrackTile_059' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_060) == 0x000428, "Member 'ACinematicShermanJumboStub::RightTrackTile_060' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_061) == 0x000430, "Member 'ACinematicShermanJumboStub::RightTrackTile_061' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_062) == 0x000438, "Member 'ACinematicShermanJumboStub::RightTrackTile_062' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_063) == 0x000440, "Member 'ACinematicShermanJumboStub::RightTrackTile_063' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_064) == 0x000448, "Member 'ACinematicShermanJumboStub::RightTrackTile_064' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_065) == 0x000450, "Member 'ACinematicShermanJumboStub::RightTrackTile_065' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_066) == 0x000458, "Member 'ACinematicShermanJumboStub::RightTrackTile_066' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_067) == 0x000460, "Member 'ACinematicShermanJumboStub::RightTrackTile_067' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_068) == 0x000468, "Member 'ACinematicShermanJumboStub::RightTrackTile_068' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_069) == 0x000470, "Member 'ACinematicShermanJumboStub::RightTrackTile_069' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_070) == 0x000478, "Member 'ACinematicShermanJumboStub::RightTrackTile_070' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_071) == 0x000480, "Member 'ACinematicShermanJumboStub::RightTrackTile_071' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_072) == 0x000488, "Member 'ACinematicShermanJumboStub::RightTrackTile_072' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_073) == 0x000490, "Member 'ACinematicShermanJumboStub::RightTrackTile_073' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_074) == 0x000498, "Member 'ACinematicShermanJumboStub::RightTrackTile_074' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_075) == 0x0004A0, "Member 'ACinematicShermanJumboStub::RightTrackTile_075' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, RightTrackTile_076) == 0x0004A8, "Member 'ACinematicShermanJumboStub::RightTrackTile_076' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_000) == 0x0004B0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_000' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_001) == 0x0004B8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_001' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_002) == 0x0004C0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_002' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_003) == 0x0004C8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_003' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_004) == 0x0004D0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_004' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_005) == 0x0004D8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_005' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_006) == 0x0004E0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_006' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_007) == 0x0004E8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_007' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_008) == 0x0004F0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_008' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_009) == 0x0004F8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_009' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_010) == 0x000500, "Member 'ACinematicShermanJumboStub::LeftTrackTile_010' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_011) == 0x000508, "Member 'ACinematicShermanJumboStub::LeftTrackTile_011' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_012) == 0x000510, "Member 'ACinematicShermanJumboStub::LeftTrackTile_012' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_013) == 0x000518, "Member 'ACinematicShermanJumboStub::LeftTrackTile_013' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_014) == 0x000520, "Member 'ACinematicShermanJumboStub::LeftTrackTile_014' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_015) == 0x000528, "Member 'ACinematicShermanJumboStub::LeftTrackTile_015' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_016) == 0x000530, "Member 'ACinematicShermanJumboStub::LeftTrackTile_016' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_017) == 0x000538, "Member 'ACinematicShermanJumboStub::LeftTrackTile_017' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_018) == 0x000540, "Member 'ACinematicShermanJumboStub::LeftTrackTile_018' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_019) == 0x000548, "Member 'ACinematicShermanJumboStub::LeftTrackTile_019' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_020) == 0x000550, "Member 'ACinematicShermanJumboStub::LeftTrackTile_020' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_021) == 0x000558, "Member 'ACinematicShermanJumboStub::LeftTrackTile_021' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_022) == 0x000560, "Member 'ACinematicShermanJumboStub::LeftTrackTile_022' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_023) == 0x000568, "Member 'ACinematicShermanJumboStub::LeftTrackTile_023' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_024) == 0x000570, "Member 'ACinematicShermanJumboStub::LeftTrackTile_024' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_025) == 0x000578, "Member 'ACinematicShermanJumboStub::LeftTrackTile_025' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_026) == 0x000580, "Member 'ACinematicShermanJumboStub::LeftTrackTile_026' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_027) == 0x000588, "Member 'ACinematicShermanJumboStub::LeftTrackTile_027' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_028) == 0x000590, "Member 'ACinematicShermanJumboStub::LeftTrackTile_028' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_029) == 0x000598, "Member 'ACinematicShermanJumboStub::LeftTrackTile_029' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_030) == 0x0005A0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_030' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_031) == 0x0005A8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_031' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_032) == 0x0005B0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_032' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_033) == 0x0005B8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_033' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_034) == 0x0005C0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_034' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_035) == 0x0005C8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_035' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_036) == 0x0005D0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_036' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_037) == 0x0005D8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_037' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_038) == 0x0005E0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_038' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_039) == 0x0005E8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_039' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_040) == 0x0005F0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_040' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_041) == 0x0005F8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_041' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_042) == 0x000600, "Member 'ACinematicShermanJumboStub::LeftTrackTile_042' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_043) == 0x000608, "Member 'ACinematicShermanJumboStub::LeftTrackTile_043' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_044) == 0x000610, "Member 'ACinematicShermanJumboStub::LeftTrackTile_044' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_045) == 0x000618, "Member 'ACinematicShermanJumboStub::LeftTrackTile_045' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_046) == 0x000620, "Member 'ACinematicShermanJumboStub::LeftTrackTile_046' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_047) == 0x000628, "Member 'ACinematicShermanJumboStub::LeftTrackTile_047' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_048) == 0x000630, "Member 'ACinematicShermanJumboStub::LeftTrackTile_048' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_049) == 0x000638, "Member 'ACinematicShermanJumboStub::LeftTrackTile_049' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_050) == 0x000640, "Member 'ACinematicShermanJumboStub::LeftTrackTile_050' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_051) == 0x000648, "Member 'ACinematicShermanJumboStub::LeftTrackTile_051' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_052) == 0x000650, "Member 'ACinematicShermanJumboStub::LeftTrackTile_052' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_053) == 0x000658, "Member 'ACinematicShermanJumboStub::LeftTrackTile_053' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_054) == 0x000660, "Member 'ACinematicShermanJumboStub::LeftTrackTile_054' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_055) == 0x000668, "Member 'ACinematicShermanJumboStub::LeftTrackTile_055' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_056) == 0x000670, "Member 'ACinematicShermanJumboStub::LeftTrackTile_056' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_057) == 0x000678, "Member 'ACinematicShermanJumboStub::LeftTrackTile_057' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_058) == 0x000680, "Member 'ACinematicShermanJumboStub::LeftTrackTile_058' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_059) == 0x000688, "Member 'ACinematicShermanJumboStub::LeftTrackTile_059' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_060) == 0x000690, "Member 'ACinematicShermanJumboStub::LeftTrackTile_060' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_061) == 0x000698, "Member 'ACinematicShermanJumboStub::LeftTrackTile_061' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_062) == 0x0006A0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_062' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_063) == 0x0006A8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_063' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_064) == 0x0006B0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_064' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_065) == 0x0006B8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_065' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_066) == 0x0006C0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_066' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_067) == 0x0006C8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_067' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_068) == 0x0006D0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_068' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_069) == 0x0006D8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_069' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_070) == 0x0006E0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_070' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_071) == 0x0006E8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_071' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_072) == 0x0006F0, "Member 'ACinematicShermanJumboStub::LeftTrackTile_072' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_073) == 0x0006F8, "Member 'ACinematicShermanJumboStub::LeftTrackTile_073' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_074) == 0x000700, "Member 'ACinematicShermanJumboStub::LeftTrackTile_074' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_075) == 0x000708, "Member 'ACinematicShermanJumboStub::LeftTrackTile_075' has a wrong offset!");
static_assert(offsetof(ACinematicShermanJumboStub, LeftTrackTile_076) == 0x000710, "Member 'ACinematicShermanJumboStub::LeftTrackTile_076' has a wrong offset!");

// Class HLL.VehicleDrop_Ammo
// 0x0008 (0x02F0 - 0x02E8)
class AVehicleDrop_Ammo final : public AVehicleDrop
{
public:
	class UHLLAmmoComponent*                      AmmoComponent;                                     // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleDrop_Ammo">();
	}
	static class AVehicleDrop_Ammo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleDrop_Ammo>();
	}
};
static_assert(alignof(AVehicleDrop_Ammo) == 0x000008, "Wrong alignment on AVehicleDrop_Ammo");
static_assert(sizeof(AVehicleDrop_Ammo) == 0x0002F0, "Wrong size on AVehicleDrop_Ammo");
static_assert(offsetof(AVehicleDrop_Ammo, AmmoComponent) == 0x0002E8, "Member 'AVehicleDrop_Ammo::AmmoComponent' has a wrong offset!");

// Class HLL.CinematicShermanStub
// 0x0508 (0x0728 - 0x0220)
class ACinematicShermanStub final : public AActor
{
public:
	class USkeletalMeshComponent*                 TankMesh;                                          // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           AllTrackTiles;                                     // 0x0228(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_000;                                     // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_001;                                     // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_002;                                     // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_003;                                     // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_004;                                     // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_005;                                     // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_006;                                     // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_007;                                     // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_008;                                     // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_009;                                     // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_010;                                     // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_011;                                     // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_012;                                     // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_013;                                     // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_014;                                     // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_015;                                     // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_016;                                     // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_017;                                     // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_018;                                     // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_019;                                     // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_020;                                     // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_021;                                     // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_022;                                     // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_023;                                     // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_024;                                     // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_025;                                     // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_026;                                     // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_027;                                     // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_028;                                     // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_029;                                     // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_030;                                     // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_031;                                     // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_032;                                     // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_033;                                     // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_034;                                     // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_035;                                     // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_036;                                     // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_037;                                     // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_038;                                     // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_039;                                     // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_040;                                     // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_041;                                     // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_042;                                     // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_043;                                     // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_044;                                     // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_045;                                     // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_046;                                     // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_047;                                     // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_048;                                     // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_049;                                     // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_050;                                     // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_051;                                     // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_052;                                     // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_053;                                     // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_054;                                     // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_055;                                     // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_056;                                     // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_057;                                     // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_058;                                     // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_059;                                     // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_060;                                     // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_061;                                     // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_062;                                     // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_063;                                     // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_064;                                     // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_065;                                     // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_066;                                     // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_067;                                     // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_068;                                     // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_069;                                     // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_070;                                     // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_071;                                     // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_072;                                     // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_073;                                     // 0x0480(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_074;                                     // 0x0488(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_075;                                     // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_076;                                     // 0x0498(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_077;                                     // 0x04A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_078;                                     // 0x04A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_079;                                     // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_080;                                     // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_081;                                     // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_082;                                     // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_083;                                     // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_084;                                     // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_085;                                     // 0x04E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_086;                                     // 0x04E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_087;                                     // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_088;                                     // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_089;                                     // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_090;                                     // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_091;                                     // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_092;                                     // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_093;                                     // 0x0520(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_094;                                     // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_095;                                     // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_096;                                     // 0x0538(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_097;                                     // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_098;                                     // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_099;                                     // 0x0550(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_100;                                     // 0x0558(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_101;                                     // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_102;                                     // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_103;                                     // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_104;                                     // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_105;                                     // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_106;                                     // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_107;                                     // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_108;                                     // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_109;                                     // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_110;                                     // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_111;                                     // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_112;                                     // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_113;                                     // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_114;                                     // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_115;                                     // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_116;                                     // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_117;                                     // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_118;                                     // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_119;                                     // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_120;                                     // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_121;                                     // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_122;                                     // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_123;                                     // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_124;                                     // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_125;                                     // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_126;                                     // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_127;                                     // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_128;                                     // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_129;                                     // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_130;                                     // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_131;                                     // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_132;                                     // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_133;                                     // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_134;                                     // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_135;                                     // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_136;                                     // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_137;                                     // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_138;                                     // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_139;                                     // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_140;                                     // 0x0698(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_141;                                     // 0x06A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_142;                                     // 0x06A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_143;                                     // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_144;                                     // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_145;                                     // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_146;                                     // 0x06C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_147;                                     // 0x06D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_148;                                     // 0x06D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_149;                                     // 0x06E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_150;                                     // 0x06E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_151;                                     // 0x06F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_152;                                     // 0x06F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_153;                                     // 0x0700(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_154;                                     // 0x0708(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_155;                                     // 0x0710(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_156;                                     // 0x0718(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackTile_157;                                     // 0x0720(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicShermanStub">();
	}
	static class ACinematicShermanStub* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACinematicShermanStub>();
	}
};
static_assert(alignof(ACinematicShermanStub) == 0x000008, "Wrong alignment on ACinematicShermanStub");
static_assert(sizeof(ACinematicShermanStub) == 0x000728, "Wrong size on ACinematicShermanStub");
static_assert(offsetof(ACinematicShermanStub, TankMesh) == 0x000220, "Member 'ACinematicShermanStub::TankMesh' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, AllTrackTiles) == 0x000228, "Member 'ACinematicShermanStub::AllTrackTiles' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_000) == 0x000238, "Member 'ACinematicShermanStub::TrackTile_000' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_001) == 0x000240, "Member 'ACinematicShermanStub::TrackTile_001' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_002) == 0x000248, "Member 'ACinematicShermanStub::TrackTile_002' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_003) == 0x000250, "Member 'ACinematicShermanStub::TrackTile_003' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_004) == 0x000258, "Member 'ACinematicShermanStub::TrackTile_004' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_005) == 0x000260, "Member 'ACinematicShermanStub::TrackTile_005' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_006) == 0x000268, "Member 'ACinematicShermanStub::TrackTile_006' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_007) == 0x000270, "Member 'ACinematicShermanStub::TrackTile_007' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_008) == 0x000278, "Member 'ACinematicShermanStub::TrackTile_008' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_009) == 0x000280, "Member 'ACinematicShermanStub::TrackTile_009' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_010) == 0x000288, "Member 'ACinematicShermanStub::TrackTile_010' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_011) == 0x000290, "Member 'ACinematicShermanStub::TrackTile_011' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_012) == 0x000298, "Member 'ACinematicShermanStub::TrackTile_012' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_013) == 0x0002A0, "Member 'ACinematicShermanStub::TrackTile_013' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_014) == 0x0002A8, "Member 'ACinematicShermanStub::TrackTile_014' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_015) == 0x0002B0, "Member 'ACinematicShermanStub::TrackTile_015' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_016) == 0x0002B8, "Member 'ACinematicShermanStub::TrackTile_016' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_017) == 0x0002C0, "Member 'ACinematicShermanStub::TrackTile_017' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_018) == 0x0002C8, "Member 'ACinematicShermanStub::TrackTile_018' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_019) == 0x0002D0, "Member 'ACinematicShermanStub::TrackTile_019' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_020) == 0x0002D8, "Member 'ACinematicShermanStub::TrackTile_020' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_021) == 0x0002E0, "Member 'ACinematicShermanStub::TrackTile_021' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_022) == 0x0002E8, "Member 'ACinematicShermanStub::TrackTile_022' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_023) == 0x0002F0, "Member 'ACinematicShermanStub::TrackTile_023' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_024) == 0x0002F8, "Member 'ACinematicShermanStub::TrackTile_024' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_025) == 0x000300, "Member 'ACinematicShermanStub::TrackTile_025' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_026) == 0x000308, "Member 'ACinematicShermanStub::TrackTile_026' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_027) == 0x000310, "Member 'ACinematicShermanStub::TrackTile_027' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_028) == 0x000318, "Member 'ACinematicShermanStub::TrackTile_028' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_029) == 0x000320, "Member 'ACinematicShermanStub::TrackTile_029' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_030) == 0x000328, "Member 'ACinematicShermanStub::TrackTile_030' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_031) == 0x000330, "Member 'ACinematicShermanStub::TrackTile_031' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_032) == 0x000338, "Member 'ACinematicShermanStub::TrackTile_032' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_033) == 0x000340, "Member 'ACinematicShermanStub::TrackTile_033' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_034) == 0x000348, "Member 'ACinematicShermanStub::TrackTile_034' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_035) == 0x000350, "Member 'ACinematicShermanStub::TrackTile_035' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_036) == 0x000358, "Member 'ACinematicShermanStub::TrackTile_036' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_037) == 0x000360, "Member 'ACinematicShermanStub::TrackTile_037' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_038) == 0x000368, "Member 'ACinematicShermanStub::TrackTile_038' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_039) == 0x000370, "Member 'ACinematicShermanStub::TrackTile_039' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_040) == 0x000378, "Member 'ACinematicShermanStub::TrackTile_040' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_041) == 0x000380, "Member 'ACinematicShermanStub::TrackTile_041' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_042) == 0x000388, "Member 'ACinematicShermanStub::TrackTile_042' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_043) == 0x000390, "Member 'ACinematicShermanStub::TrackTile_043' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_044) == 0x000398, "Member 'ACinematicShermanStub::TrackTile_044' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_045) == 0x0003A0, "Member 'ACinematicShermanStub::TrackTile_045' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_046) == 0x0003A8, "Member 'ACinematicShermanStub::TrackTile_046' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_047) == 0x0003B0, "Member 'ACinematicShermanStub::TrackTile_047' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_048) == 0x0003B8, "Member 'ACinematicShermanStub::TrackTile_048' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_049) == 0x0003C0, "Member 'ACinematicShermanStub::TrackTile_049' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_050) == 0x0003C8, "Member 'ACinematicShermanStub::TrackTile_050' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_051) == 0x0003D0, "Member 'ACinematicShermanStub::TrackTile_051' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_052) == 0x0003D8, "Member 'ACinematicShermanStub::TrackTile_052' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_053) == 0x0003E0, "Member 'ACinematicShermanStub::TrackTile_053' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_054) == 0x0003E8, "Member 'ACinematicShermanStub::TrackTile_054' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_055) == 0x0003F0, "Member 'ACinematicShermanStub::TrackTile_055' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_056) == 0x0003F8, "Member 'ACinematicShermanStub::TrackTile_056' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_057) == 0x000400, "Member 'ACinematicShermanStub::TrackTile_057' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_058) == 0x000408, "Member 'ACinematicShermanStub::TrackTile_058' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_059) == 0x000410, "Member 'ACinematicShermanStub::TrackTile_059' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_060) == 0x000418, "Member 'ACinematicShermanStub::TrackTile_060' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_061) == 0x000420, "Member 'ACinematicShermanStub::TrackTile_061' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_062) == 0x000428, "Member 'ACinematicShermanStub::TrackTile_062' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_063) == 0x000430, "Member 'ACinematicShermanStub::TrackTile_063' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_064) == 0x000438, "Member 'ACinematicShermanStub::TrackTile_064' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_065) == 0x000440, "Member 'ACinematicShermanStub::TrackTile_065' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_066) == 0x000448, "Member 'ACinematicShermanStub::TrackTile_066' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_067) == 0x000450, "Member 'ACinematicShermanStub::TrackTile_067' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_068) == 0x000458, "Member 'ACinematicShermanStub::TrackTile_068' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_069) == 0x000460, "Member 'ACinematicShermanStub::TrackTile_069' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_070) == 0x000468, "Member 'ACinematicShermanStub::TrackTile_070' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_071) == 0x000470, "Member 'ACinematicShermanStub::TrackTile_071' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_072) == 0x000478, "Member 'ACinematicShermanStub::TrackTile_072' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_073) == 0x000480, "Member 'ACinematicShermanStub::TrackTile_073' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_074) == 0x000488, "Member 'ACinematicShermanStub::TrackTile_074' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_075) == 0x000490, "Member 'ACinematicShermanStub::TrackTile_075' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_076) == 0x000498, "Member 'ACinematicShermanStub::TrackTile_076' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_077) == 0x0004A0, "Member 'ACinematicShermanStub::TrackTile_077' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_078) == 0x0004A8, "Member 'ACinematicShermanStub::TrackTile_078' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_079) == 0x0004B0, "Member 'ACinematicShermanStub::TrackTile_079' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_080) == 0x0004B8, "Member 'ACinematicShermanStub::TrackTile_080' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_081) == 0x0004C0, "Member 'ACinematicShermanStub::TrackTile_081' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_082) == 0x0004C8, "Member 'ACinematicShermanStub::TrackTile_082' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_083) == 0x0004D0, "Member 'ACinematicShermanStub::TrackTile_083' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_084) == 0x0004D8, "Member 'ACinematicShermanStub::TrackTile_084' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_085) == 0x0004E0, "Member 'ACinematicShermanStub::TrackTile_085' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_086) == 0x0004E8, "Member 'ACinematicShermanStub::TrackTile_086' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_087) == 0x0004F0, "Member 'ACinematicShermanStub::TrackTile_087' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_088) == 0x0004F8, "Member 'ACinematicShermanStub::TrackTile_088' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_089) == 0x000500, "Member 'ACinematicShermanStub::TrackTile_089' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_090) == 0x000508, "Member 'ACinematicShermanStub::TrackTile_090' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_091) == 0x000510, "Member 'ACinematicShermanStub::TrackTile_091' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_092) == 0x000518, "Member 'ACinematicShermanStub::TrackTile_092' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_093) == 0x000520, "Member 'ACinematicShermanStub::TrackTile_093' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_094) == 0x000528, "Member 'ACinematicShermanStub::TrackTile_094' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_095) == 0x000530, "Member 'ACinematicShermanStub::TrackTile_095' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_096) == 0x000538, "Member 'ACinematicShermanStub::TrackTile_096' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_097) == 0x000540, "Member 'ACinematicShermanStub::TrackTile_097' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_098) == 0x000548, "Member 'ACinematicShermanStub::TrackTile_098' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_099) == 0x000550, "Member 'ACinematicShermanStub::TrackTile_099' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_100) == 0x000558, "Member 'ACinematicShermanStub::TrackTile_100' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_101) == 0x000560, "Member 'ACinematicShermanStub::TrackTile_101' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_102) == 0x000568, "Member 'ACinematicShermanStub::TrackTile_102' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_103) == 0x000570, "Member 'ACinematicShermanStub::TrackTile_103' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_104) == 0x000578, "Member 'ACinematicShermanStub::TrackTile_104' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_105) == 0x000580, "Member 'ACinematicShermanStub::TrackTile_105' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_106) == 0x000588, "Member 'ACinematicShermanStub::TrackTile_106' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_107) == 0x000590, "Member 'ACinematicShermanStub::TrackTile_107' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_108) == 0x000598, "Member 'ACinematicShermanStub::TrackTile_108' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_109) == 0x0005A0, "Member 'ACinematicShermanStub::TrackTile_109' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_110) == 0x0005A8, "Member 'ACinematicShermanStub::TrackTile_110' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_111) == 0x0005B0, "Member 'ACinematicShermanStub::TrackTile_111' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_112) == 0x0005B8, "Member 'ACinematicShermanStub::TrackTile_112' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_113) == 0x0005C0, "Member 'ACinematicShermanStub::TrackTile_113' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_114) == 0x0005C8, "Member 'ACinematicShermanStub::TrackTile_114' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_115) == 0x0005D0, "Member 'ACinematicShermanStub::TrackTile_115' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_116) == 0x0005D8, "Member 'ACinematicShermanStub::TrackTile_116' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_117) == 0x0005E0, "Member 'ACinematicShermanStub::TrackTile_117' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_118) == 0x0005E8, "Member 'ACinematicShermanStub::TrackTile_118' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_119) == 0x0005F0, "Member 'ACinematicShermanStub::TrackTile_119' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_120) == 0x0005F8, "Member 'ACinematicShermanStub::TrackTile_120' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_121) == 0x000600, "Member 'ACinematicShermanStub::TrackTile_121' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_122) == 0x000608, "Member 'ACinematicShermanStub::TrackTile_122' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_123) == 0x000610, "Member 'ACinematicShermanStub::TrackTile_123' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_124) == 0x000618, "Member 'ACinematicShermanStub::TrackTile_124' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_125) == 0x000620, "Member 'ACinematicShermanStub::TrackTile_125' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_126) == 0x000628, "Member 'ACinematicShermanStub::TrackTile_126' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_127) == 0x000630, "Member 'ACinematicShermanStub::TrackTile_127' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_128) == 0x000638, "Member 'ACinematicShermanStub::TrackTile_128' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_129) == 0x000640, "Member 'ACinematicShermanStub::TrackTile_129' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_130) == 0x000648, "Member 'ACinematicShermanStub::TrackTile_130' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_131) == 0x000650, "Member 'ACinematicShermanStub::TrackTile_131' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_132) == 0x000658, "Member 'ACinematicShermanStub::TrackTile_132' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_133) == 0x000660, "Member 'ACinematicShermanStub::TrackTile_133' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_134) == 0x000668, "Member 'ACinematicShermanStub::TrackTile_134' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_135) == 0x000670, "Member 'ACinematicShermanStub::TrackTile_135' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_136) == 0x000678, "Member 'ACinematicShermanStub::TrackTile_136' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_137) == 0x000680, "Member 'ACinematicShermanStub::TrackTile_137' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_138) == 0x000688, "Member 'ACinematicShermanStub::TrackTile_138' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_139) == 0x000690, "Member 'ACinematicShermanStub::TrackTile_139' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_140) == 0x000698, "Member 'ACinematicShermanStub::TrackTile_140' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_141) == 0x0006A0, "Member 'ACinematicShermanStub::TrackTile_141' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_142) == 0x0006A8, "Member 'ACinematicShermanStub::TrackTile_142' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_143) == 0x0006B0, "Member 'ACinematicShermanStub::TrackTile_143' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_144) == 0x0006B8, "Member 'ACinematicShermanStub::TrackTile_144' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_145) == 0x0006C0, "Member 'ACinematicShermanStub::TrackTile_145' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_146) == 0x0006C8, "Member 'ACinematicShermanStub::TrackTile_146' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_147) == 0x0006D0, "Member 'ACinematicShermanStub::TrackTile_147' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_148) == 0x0006D8, "Member 'ACinematicShermanStub::TrackTile_148' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_149) == 0x0006E0, "Member 'ACinematicShermanStub::TrackTile_149' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_150) == 0x0006E8, "Member 'ACinematicShermanStub::TrackTile_150' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_151) == 0x0006F0, "Member 'ACinematicShermanStub::TrackTile_151' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_152) == 0x0006F8, "Member 'ACinematicShermanStub::TrackTile_152' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_153) == 0x000700, "Member 'ACinematicShermanStub::TrackTile_153' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_154) == 0x000708, "Member 'ACinematicShermanStub::TrackTile_154' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_155) == 0x000710, "Member 'ACinematicShermanStub::TrackTile_155' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_156) == 0x000718, "Member 'ACinematicShermanStub::TrackTile_156' has a wrong offset!");
static_assert(offsetof(ACinematicShermanStub, TrackTile_157) == 0x000720, "Member 'ACinematicShermanStub::TrackTile_157' has a wrong offset!");

// Class HLL.HLLOverviewMap
// 0x0230 (0x0460 - 0x0230)
class UHLLOverviewMap : public UUserWidget
{
public:
	uint8                                         Pad_10F0[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLMapIconBase*>                MapIcons;                                          // 0x0248(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F1[0x2C];                                    // 0x0258(0x002C)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         IconFilters;                                       // 0x0284(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHighlightLocked : 1;                              // 0x0288(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_10F2[0x7];                                     // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMapIconBase*                        HighlightedIcon;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RootPanel;                                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLScrollZoom*                         MapImage;                                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           IconPanel;                                         // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ZoomText;                                          // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            FriendlySectorBrush;                               // 0x02B8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            EnemySectorBrush;                                  // 0x0340(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            NeutralSectorBrush;                                // 0x03C8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHLLMapIconBase>         SelectedIcon;                                      // 0x0450(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10F3[0x8];                                     // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddObjectIcon(class AHLLMapDataBase* InNewData);
	void ClearHighlightedIcon(const bool bReleaseLock);
	bool OnHighlightIcon(class UHLLMapIconBase* Icon, const bool bLock);
	bool OnUnhighlightIcon(class UHLLMapIconBase* Icon);
	void RemoveObjectIcon(class AHLLMapDataBase* InOldData);
	void ResetMapZoom();
	void SetIconSelectionEnabled(const bool bNewEnabled);
	void SetPulseSpawnIcons(const bool bPulseEnabled);
	bool SetSelectedData(class AHLLMapDataBase* InData);
	bool SetSelectedIcon(class UHLLMapIconBase* InIcon);

	class UHLLMapIconBase* GetSelectedIcon() const;
	bool IsPulsingSpawnIcons() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLOverviewMap">();
	}
	static class UHLLOverviewMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLOverviewMap>();
	}
};
static_assert(alignof(UHLLOverviewMap) == 0x000008, "Wrong alignment on UHLLOverviewMap");
static_assert(sizeof(UHLLOverviewMap) == 0x000460, "Wrong size on UHLLOverviewMap");
static_assert(offsetof(UHLLOverviewMap, MapIcons) == 0x000248, "Member 'UHLLOverviewMap::MapIcons' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, IconFilters) == 0x000284, "Member 'UHLLOverviewMap::IconFilters' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, HighlightedIcon) == 0x000290, "Member 'UHLLOverviewMap::HighlightedIcon' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, RootPanel) == 0x000298, "Member 'UHLLOverviewMap::RootPanel' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, MapImage) == 0x0002A0, "Member 'UHLLOverviewMap::MapImage' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, IconPanel) == 0x0002A8, "Member 'UHLLOverviewMap::IconPanel' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, ZoomText) == 0x0002B0, "Member 'UHLLOverviewMap::ZoomText' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, FriendlySectorBrush) == 0x0002B8, "Member 'UHLLOverviewMap::FriendlySectorBrush' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, EnemySectorBrush) == 0x000340, "Member 'UHLLOverviewMap::EnemySectorBrush' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, NeutralSectorBrush) == 0x0003C8, "Member 'UHLLOverviewMap::NeutralSectorBrush' has a wrong offset!");
static_assert(offsetof(UHLLOverviewMap, SelectedIcon) == 0x000450, "Member 'UHLLOverviewMap::SelectedIcon' has a wrong offset!");

// Class HLL.ShooterWeapon_Grenade
// 0x0110 (0x0BC0 - 0x0AB0)
class AShooterWeapon_Grenade : public AShooterWeapon
{
public:
	struct FGrenadeWeaponData                     GrenadeConfig;                                     // 0x0AA8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponAnim                            AimOverhandAnimation;                              // 0x0AD8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponAnim                            AimUnderhandAnimation;                             // 0x0B00(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponAnim                            ThrowOverhandAnimation;                            // 0x0B28(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponAnim                            ThrowUnderhandAnimation;                           // 0x0B50(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         M_throwOverhandCounter;                            // 0x0B78(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         M_throwUnderhandCounter;                           // 0x0B79(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         M_aimOverhandCounter;                              // 0x0B7A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         M_aimUnderhandCounter;                             // 0x0B7B(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10F8[0x24];                                    // 0x0B7C(0x0024)(Fixing Size After Last Property [ Dumper-69 ])
	class AGrenadeProjectile*                     M_projectile;                                      // 0x0BA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGlobalGrenadeThrowSettings*            M_globalThrowSettings;                             // 0x0BA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10F9[0x10];                                    // 0x0BB0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void IgniteFuse();
	void MulticastDrawDebugThrow(const struct FVector& ReleaseLocation);
	void OnRep_AimOverhand();
	void OnRep_AimUnderhand();
	void OnRep_ThrowOverhand();
	void OnRep_ThrowUnderhand();
	void PrimeGrenade();
	void ReleaseGrenade(EGrenadeThrowType ThrowType);
	void ServerExecuteThrow(EGrenadeThrowType ThrowType);
	void ServerIgniteFuse();
	void ServerPrimeGrenade();
	void ServerReleaseGrenadeForThrow(EGrenadeThrowType ThrowType, const struct FVector& ReleaseLocation);
	void ServerStartThrow(EGrenadeThrowType ThrowType);

	bool IsThrowing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Grenade">();
	}
	static class AShooterWeapon_Grenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Grenade>();
	}
};
static_assert(alignof(AShooterWeapon_Grenade) == 0x000010, "Wrong alignment on AShooterWeapon_Grenade");
static_assert(sizeof(AShooterWeapon_Grenade) == 0x000BC0, "Wrong size on AShooterWeapon_Grenade");
static_assert(offsetof(AShooterWeapon_Grenade, GrenadeConfig) == 0x000AA8, "Member 'AShooterWeapon_Grenade::GrenadeConfig' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, AimOverhandAnimation) == 0x000AD8, "Member 'AShooterWeapon_Grenade::AimOverhandAnimation' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, AimUnderhandAnimation) == 0x000B00, "Member 'AShooterWeapon_Grenade::AimUnderhandAnimation' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, ThrowOverhandAnimation) == 0x000B28, "Member 'AShooterWeapon_Grenade::ThrowOverhandAnimation' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, ThrowUnderhandAnimation) == 0x000B50, "Member 'AShooterWeapon_Grenade::ThrowUnderhandAnimation' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, M_throwOverhandCounter) == 0x000B78, "Member 'AShooterWeapon_Grenade::M_throwOverhandCounter' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, M_throwUnderhandCounter) == 0x000B79, "Member 'AShooterWeapon_Grenade::M_throwUnderhandCounter' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, M_aimOverhandCounter) == 0x000B7A, "Member 'AShooterWeapon_Grenade::M_aimOverhandCounter' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, M_aimUnderhandCounter) == 0x000B7B, "Member 'AShooterWeapon_Grenade::M_aimUnderhandCounter' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, M_projectile) == 0x000BA0, "Member 'AShooterWeapon_Grenade::M_projectile' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Grenade, M_globalThrowSettings) == 0x000BA8, "Member 'AShooterWeapon_Grenade::M_globalThrowSettings' has a wrong offset!");

// Class HLL.ShooterWeapon_Molotov
// 0x0000 (0x0BC0 - 0x0BC0)
class AShooterWeapon_Molotov final : public AShooterWeapon_Grenade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Molotov">();
	}
	static class AShooterWeapon_Molotov* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Molotov>();
	}
};
static_assert(alignof(AShooterWeapon_Molotov) == 0x000010, "Wrong alignment on AShooterWeapon_Molotov");
static_assert(sizeof(AShooterWeapon_Molotov) == 0x000BC0, "Wrong size on AShooterWeapon_Molotov");

// Class HLL.ClientBotProcessor_TriggerAction
// 0x0010 (0x0040 - 0x0030)
class UClientBotProcessor_TriggerAction final : public UClientBotProcessor
{
public:
	uint8                                         Pad_10FB[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor_TriggerAction">();
	}
	static class UClientBotProcessor_TriggerAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor_TriggerAction>();
	}
};
static_assert(alignof(UClientBotProcessor_TriggerAction) == 0x000008, "Wrong alignment on UClientBotProcessor_TriggerAction");
static_assert(sizeof(UClientBotProcessor_TriggerAction) == 0x000040, "Wrong size on UClientBotProcessor_TriggerAction");

// Class HLL.ClientBotProcessor_Attack
// 0x0010 (0x0040 - 0x0030)
class UClientBotProcessor_Attack final : public UClientBotProcessor
{
public:
	uint8                                         Pad_10FC[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor_Attack">();
	}
	static class UClientBotProcessor_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor_Attack>();
	}
};
static_assert(alignof(UClientBotProcessor_Attack) == 0x000008, "Wrong alignment on UClientBotProcessor_Attack");
static_assert(sizeof(UClientBotProcessor_Attack) == 0x000040, "Wrong size on UClientBotProcessor_Attack");

// Class HLL.HLLMapIcon_Marker
// 0x0010 (0x0378 - 0x0368)
class UHLLMapIcon_Marker : public UHLLMapIconBase
{
public:
	class UTextBlock*                             PlatoonIDText;                                     // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       MovedOrPlacedAnim;                                 // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMovedOrPlaced();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Marker">();
	}
	static class UHLLMapIcon_Marker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Marker>();
	}
};
static_assert(alignof(UHLLMapIcon_Marker) == 0x000008, "Wrong alignment on UHLLMapIcon_Marker");
static_assert(sizeof(UHLLMapIcon_Marker) == 0x000378, "Wrong size on UHLLMapIcon_Marker");
static_assert(offsetof(UHLLMapIcon_Marker, PlatoonIDText) == 0x000368, "Member 'UHLLMapIcon_Marker::PlatoonIDText' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Marker, MovedOrPlacedAnim) == 0x000370, "Member 'UHLLMapIcon_Marker::MovedOrPlacedAnim' has a wrong offset!");

// Class HLL.GlobalGrenadeThrowSettings
// 0x0018 (0x0048 - 0x0030)
class UGlobalGrenadeThrowSettings final : public UDataAsset
{
public:
	float                                         StartingVelocityOverhand;                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingVelocityUnderhand;                         // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalTrajectoryFactorOverhand;                  // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalTrajectoryFactorUnderhand;                 // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingThrowPowerFactor;                            // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FD[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalGrenadeThrowSettings">();
	}
	static class UGlobalGrenadeThrowSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalGrenadeThrowSettings>();
	}
};
static_assert(alignof(UGlobalGrenadeThrowSettings) == 0x000008, "Wrong alignment on UGlobalGrenadeThrowSettings");
static_assert(sizeof(UGlobalGrenadeThrowSettings) == 0x000048, "Wrong size on UGlobalGrenadeThrowSettings");
static_assert(offsetof(UGlobalGrenadeThrowSettings, StartingVelocityOverhand) == 0x000030, "Member 'UGlobalGrenadeThrowSettings::StartingVelocityOverhand' has a wrong offset!");
static_assert(offsetof(UGlobalGrenadeThrowSettings, StartingVelocityUnderhand) == 0x000034, "Member 'UGlobalGrenadeThrowSettings::StartingVelocityUnderhand' has a wrong offset!");
static_assert(offsetof(UGlobalGrenadeThrowSettings, VerticalTrajectoryFactorOverhand) == 0x000038, "Member 'UGlobalGrenadeThrowSettings::VerticalTrajectoryFactorOverhand' has a wrong offset!");
static_assert(offsetof(UGlobalGrenadeThrowSettings, VerticalTrajectoryFactorUnderhand) == 0x00003C, "Member 'UGlobalGrenadeThrowSettings::VerticalTrajectoryFactorUnderhand' has a wrong offset!");
static_assert(offsetof(UGlobalGrenadeThrowSettings, MovingThrowPowerFactor) == 0x000040, "Member 'UGlobalGrenadeThrowSettings::MovingThrowPowerFactor' has a wrong offset!");

// Class HLL.ClientBotProcessor_GrenadeFire
// 0x0020 (0x0050 - 0x0030)
class UClientBotProcessor_GrenadeFire final : public UClientBotProcessor
{
public:
	uint8                                         Pad_10FE[0x20];                                    // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor_GrenadeFire">();
	}
	static class UClientBotProcessor_GrenadeFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor_GrenadeFire>();
	}
};
static_assert(alignof(UClientBotProcessor_GrenadeFire) == 0x000008, "Wrong alignment on UClientBotProcessor_GrenadeFire");
static_assert(sizeof(UClientBotProcessor_GrenadeFire) == 0x000050, "Wrong size on UClientBotProcessor_GrenadeFire");

// Class HLL.HLLRepairIndicator
// 0x0008 (0x02B8 - 0x02B0)
class UHLLRepairIndicator : public UHLLIndicatorBase
{
public:
	class UBorder*                                RepairBorder;                                      // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRepairIndicator">();
	}
	static class UHLLRepairIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRepairIndicator>();
	}
};
static_assert(alignof(UHLLRepairIndicator) == 0x000008, "Wrong alignment on UHLLRepairIndicator");
static_assert(sizeof(UHLLRepairIndicator) == 0x0002B8, "Wrong size on UHLLRepairIndicator");
static_assert(offsetof(UHLLRepairIndicator, RepairBorder) == 0x0002B0, "Member 'UHLLRepairIndicator::RepairBorder' has a wrong offset!");

// Class HLL.ClientBotProcessor_GrenadeLook
// 0x0000 (0x0030 - 0x0030)
class UClientBotProcessor_GrenadeLook final : public UClientBotProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBotProcessor_GrenadeLook">();
	}
	static class UClientBotProcessor_GrenadeLook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBotProcessor_GrenadeLook>();
	}
};
static_assert(alignof(UClientBotProcessor_GrenadeLook) == 0x000008, "Wrong alignment on UClientBotProcessor_GrenadeLook");
static_assert(sizeof(UClientBotProcessor_GrenadeLook) == 0x000030, "Wrong size on UClientBotProcessor_GrenadeLook");

// Class HLL.CollisionToolBase
// 0x0008 (0x0228 - 0x0220)
class ACollisionToolBase : public AActor
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            CollisionResponse;                                 // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FF[0x6];                                     // 0x0222(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class FString GetCustomDepthValue();
	TArray<class FName> ListProfilesWithResponseToChannel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionToolBase">();
	}
	static class ACollisionToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollisionToolBase>();
	}
};
static_assert(alignof(ACollisionToolBase) == 0x000008, "Wrong alignment on ACollisionToolBase");
static_assert(sizeof(ACollisionToolBase) == 0x000228, "Wrong size on ACollisionToolBase");
static_assert(offsetof(ACollisionToolBase, CollisionChannel) == 0x000220, "Member 'ACollisionToolBase::CollisionChannel' has a wrong offset!");
static_assert(offsetof(ACollisionToolBase, CollisionResponse) == 0x000221, "Member 'ACollisionToolBase::CollisionResponse' has a wrong offset!");

// Class HLL.HLLMapIcon_SectorBooster
// 0x0010 (0x0378 - 0x0368)
class UHLLMapIcon_SectorBooster : public UHLLMapIconBase
{
public:
	class UWidgetSwitcher*                        ProfileSwitcher;                                   // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               RootSBox;                                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_SectorBooster">();
	}
	static class UHLLMapIcon_SectorBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_SectorBooster>();
	}
};
static_assert(alignof(UHLLMapIcon_SectorBooster) == 0x000008, "Wrong alignment on UHLLMapIcon_SectorBooster");
static_assert(sizeof(UHLLMapIcon_SectorBooster) == 0x000378, "Wrong size on UHLLMapIcon_SectorBooster");
static_assert(offsetof(UHLLMapIcon_SectorBooster, ProfileSwitcher) == 0x000368, "Member 'UHLLMapIcon_SectorBooster::ProfileSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SectorBooster, RootSBox) == 0x000370, "Member 'UHLLMapIcon_SectorBooster::RootSBox' has a wrong offset!");

// Class HLL.ShooterWeapon_Projectile
// 0x0010 (0x0AC0 - 0x0AB0)
class AShooterWeapon_Projectile : public AShooterWeapon
{
public:
	TSubclassOf<class AShooterProjectile>         ProjectileClass;                                   // 0x0AA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1100[0x10];                                    // 0x0AB0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnFreelookStart();
	void ServerFireProjectile(const struct FVector& Origin, const struct FVector_NetQuantizeNormal& ShootDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Projectile">();
	}
	static class AShooterWeapon_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Projectile>();
	}
};
static_assert(alignof(AShooterWeapon_Projectile) == 0x000010, "Wrong alignment on AShooterWeapon_Projectile");
static_assert(sizeof(AShooterWeapon_Projectile) == 0x000AC0, "Wrong size on AShooterWeapon_Projectile");
static_assert(offsetof(AShooterWeapon_Projectile, ProjectileClass) == 0x000AA8, "Member 'AShooterWeapon_Projectile::ProjectileClass' has a wrong offset!");

// Class HLL.CollisionResponsesTool
// 0x00A0 (0x02C8 - 0x0228)
class ACollisionResponsesTool final : public ACollisionToolBase
{
public:
	class UMaterialInterface*                     PPMaterial;                                        // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               PPDynamicMaterial;                                 // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1101[0x20];                                    // 0x0238(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 LastCorrectColor;                                  // 0x0258(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LastIncorrectColor;                                // 0x0268(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, bool>        PrimitiveComponentMap;                             // 0x0278(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void FindActorsWithCorrectCollisionValues();
	void ResetDepth();
	void SetCollisionResponseColor(const class FString& VectorParamName, const struct FColor& NewColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionResponsesTool">();
	}
	static class ACollisionResponsesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollisionResponsesTool>();
	}
};
static_assert(alignof(ACollisionResponsesTool) == 0x000008, "Wrong alignment on ACollisionResponsesTool");
static_assert(sizeof(ACollisionResponsesTool) == 0x0002C8, "Wrong size on ACollisionResponsesTool");
static_assert(offsetof(ACollisionResponsesTool, PPMaterial) == 0x000228, "Member 'ACollisionResponsesTool::PPMaterial' has a wrong offset!");
static_assert(offsetof(ACollisionResponsesTool, PPDynamicMaterial) == 0x000230, "Member 'ACollisionResponsesTool::PPDynamicMaterial' has a wrong offset!");
static_assert(offsetof(ACollisionResponsesTool, LastCorrectColor) == 0x000258, "Member 'ACollisionResponsesTool::LastCorrectColor' has a wrong offset!");
static_assert(offsetof(ACollisionResponsesTool, LastIncorrectColor) == 0x000268, "Member 'ACollisionResponsesTool::LastIncorrectColor' has a wrong offset!");
static_assert(offsetof(ACollisionResponsesTool, PrimitiveComponentMap) == 0x000278, "Member 'ACollisionResponsesTool::PrimitiveComponentMap' has a wrong offset!");

// Class HLL.HLLResourceNode
// 0x0188 (0x03A8 - 0x0220)
class AHLLResourceNode : public AActor
{
public:
	uint8                                         Pad_1103[0x70];                                    // 0x0220(0x0070)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          PrePlacedNode;                                     // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1104[0x7];                                     // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        DummyRoot;                                         // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLResourceGenerator*                  ResourceComponent;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSimpleHealthComponent*              HealthComponent;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDismantlingComponent*                  DismantlingComponent;                              // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DismantleTime;                                     // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         OwningTeam;                                        // 0x02D4(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RegenerationTypes;                                 // 0x02D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1105[0x2];                                     // 0x02D6(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         AmmoRegenRadius;                                   // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  AmmoRegenQuery;                                    // 0x02DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AmmoRegenLength;                                   // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RegenerationScoreName;                             // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLUpgradeInfo                        UpgradeData;                                       // 0x02F0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UHLLUpgradeGhostComponent*              UpgradeGhostComponent;                             // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1106[0x3];                                     // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   ActionScoreNameDismantleEnemyNode;                 // 0x0384(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1107[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerState*                    SpawnedByPlayer;                                   // 0x0390(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1108[0x8];                                     // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         NodeID;                                            // 0x03A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1109[0x4];                                     // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_UpgradeData(const struct FHLLUpgradeInfo& OldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLResourceNode">();
	}
	static class AHLLResourceNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLResourceNode>();
	}
};
static_assert(alignof(AHLLResourceNode) == 0x000008, "Wrong alignment on AHLLResourceNode");
static_assert(sizeof(AHLLResourceNode) == 0x0003A8, "Wrong size on AHLLResourceNode");
static_assert(offsetof(AHLLResourceNode, PrePlacedNode) == 0x000290, "Member 'AHLLResourceNode::PrePlacedNode' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, DummyRoot) == 0x000298, "Member 'AHLLResourceNode::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, Mesh) == 0x0002A0, "Member 'AHLLResourceNode::Mesh' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, MapComponent) == 0x0002A8, "Member 'AHLLResourceNode::MapComponent' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, IndicatorComponent) == 0x0002B0, "Member 'AHLLResourceNode::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, ResourceComponent) == 0x0002B8, "Member 'AHLLResourceNode::ResourceComponent' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, HealthComponent) == 0x0002C0, "Member 'AHLLResourceNode::HealthComponent' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, DismantlingComponent) == 0x0002C8, "Member 'AHLLResourceNode::DismantlingComponent' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, DismantleTime) == 0x0002D0, "Member 'AHLLResourceNode::DismantleTime' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, OwningTeam) == 0x0002D4, "Member 'AHLLResourceNode::OwningTeam' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, RegenerationTypes) == 0x0002D5, "Member 'AHLLResourceNode::RegenerationTypes' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, AmmoRegenRadius) == 0x0002D8, "Member 'AHLLResourceNode::AmmoRegenRadius' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, AmmoRegenQuery) == 0x0002DC, "Member 'AHLLResourceNode::AmmoRegenQuery' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, AmmoRegenLength) == 0x0002E4, "Member 'AHLLResourceNode::AmmoRegenLength' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, RegenerationScoreName) == 0x0002E8, "Member 'AHLLResourceNode::RegenerationScoreName' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, UpgradeData) == 0x0002F0, "Member 'AHLLResourceNode::UpgradeData' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, UpgradeGhostComponent) == 0x000378, "Member 'AHLLResourceNode::UpgradeGhostComponent' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, DamageFilterType) == 0x000380, "Member 'AHLLResourceNode::DamageFilterType' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, ActionScoreNameDismantleEnemyNode) == 0x000384, "Member 'AHLLResourceNode::ActionScoreNameDismantleEnemyNode' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, SpawnedByPlayer) == 0x000390, "Member 'AHLLResourceNode::SpawnedByPlayer' has a wrong offset!");
static_assert(offsetof(AHLLResourceNode, NodeID) == 0x0003A0, "Member 'AHLLResourceNode::NodeID' has a wrong offset!");

// Class HLL.CommanderOverrideData
// 0x0018 (0x0048 - 0x0030)
class UCommanderOverrideData final : public UDataAsset
{
public:
	class FText                                   CommanderName;                                     // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommanderOverrideData">();
	}
	static class UCommanderOverrideData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommanderOverrideData>();
	}
};
static_assert(alignof(UCommanderOverrideData) == 0x000008, "Wrong alignment on UCommanderOverrideData");
static_assert(sizeof(UCommanderOverrideData) == 0x000048, "Wrong size on UCommanderOverrideData");
static_assert(offsetof(UCommanderOverrideData, CommanderName) == 0x000030, "Member 'UCommanderOverrideData::CommanderName' has a wrong offset!");

// Class HLL.VehicleAntiFlipComponent
// 0x0028 (0x00D8 - 0x00B0)
class UVehicleAntiFlipComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            CorrectiveForceCurve;                              // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCorrectiveVelocity;                             // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CorrectionProbeInterval;                           // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CorrectionBurstDuration;                           // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110A[0x14];                                    // 0x00C4(0x0014)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleAntiFlipComponent">();
	}
	static class UVehicleAntiFlipComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleAntiFlipComponent>();
	}
};
static_assert(alignof(UVehicleAntiFlipComponent) == 0x000008, "Wrong alignment on UVehicleAntiFlipComponent");
static_assert(sizeof(UVehicleAntiFlipComponent) == 0x0000D8, "Wrong size on UVehicleAntiFlipComponent");
static_assert(offsetof(UVehicleAntiFlipComponent, CorrectiveForceCurve) == 0x0000B0, "Member 'UVehicleAntiFlipComponent::CorrectiveForceCurve' has a wrong offset!");
static_assert(offsetof(UVehicleAntiFlipComponent, MaxCorrectiveVelocity) == 0x0000B8, "Member 'UVehicleAntiFlipComponent::MaxCorrectiveVelocity' has a wrong offset!");
static_assert(offsetof(UVehicleAntiFlipComponent, CorrectionProbeInterval) == 0x0000BC, "Member 'UVehicleAntiFlipComponent::CorrectionProbeInterval' has a wrong offset!");
static_assert(offsetof(UVehicleAntiFlipComponent, CorrectionBurstDuration) == 0x0000C0, "Member 'UVehicleAntiFlipComponent::CorrectionBurstDuration' has a wrong offset!");

// Class HLL.ControlPointProgressionHUD
// 0x01C0 (0x03F0 - 0x0230)
class UControlPointProgressionHUD : public UUserWidget
{
public:
	class UProgressBar*                           ProgressionBar;                                    // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           PB_ProgressLine;                                   // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BannerImage;                                       // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SectorIcon;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASeedingControlPoint*                   AssignedControlPoint;                              // 0x0250(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            OffensiveIcon;                                     // 0x0258(0x0088)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            DefensiveIcon;                                     // 0x02E0(0x0088)(Edit, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            ControlPointLockedIcon;                            // 0x0368(0x0088)(Edit, NativeAccessSpecifierPrivate)

public:
	void OnEnterControlPoint(const class ASeedingControlPoint* ControlPoint);
	void OnExitControlPoint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlPointProgressionHUD">();
	}
	static class UControlPointProgressionHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlPointProgressionHUD>();
	}
};
static_assert(alignof(UControlPointProgressionHUD) == 0x000008, "Wrong alignment on UControlPointProgressionHUD");
static_assert(sizeof(UControlPointProgressionHUD) == 0x0003F0, "Wrong size on UControlPointProgressionHUD");
static_assert(offsetof(UControlPointProgressionHUD, ProgressionBar) == 0x000230, "Member 'UControlPointProgressionHUD::ProgressionBar' has a wrong offset!");
static_assert(offsetof(UControlPointProgressionHUD, PB_ProgressLine) == 0x000238, "Member 'UControlPointProgressionHUD::PB_ProgressLine' has a wrong offset!");
static_assert(offsetof(UControlPointProgressionHUD, BannerImage) == 0x000240, "Member 'UControlPointProgressionHUD::BannerImage' has a wrong offset!");
static_assert(offsetof(UControlPointProgressionHUD, SectorIcon) == 0x000248, "Member 'UControlPointProgressionHUD::SectorIcon' has a wrong offset!");
static_assert(offsetof(UControlPointProgressionHUD, AssignedControlPoint) == 0x000250, "Member 'UControlPointProgressionHUD::AssignedControlPoint' has a wrong offset!");
static_assert(offsetof(UControlPointProgressionHUD, OffensiveIcon) == 0x000258, "Member 'UControlPointProgressionHUD::OffensiveIcon' has a wrong offset!");
static_assert(offsetof(UControlPointProgressionHUD, DefensiveIcon) == 0x0002E0, "Member 'UControlPointProgressionHUD::DefensiveIcon' has a wrong offset!");
static_assert(offsetof(UControlPointProgressionHUD, ControlPointLockedIcon) == 0x000368, "Member 'UControlPointProgressionHUD::ControlPointLockedIcon' has a wrong offset!");

// Class HLL.Daimler
// 0x0000 (0x05C0 - 0x05C0)
class ADaimler final : public ABaseReconVehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Daimler">();
	}
	static class ADaimler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADaimler>();
	}
};
static_assert(alignof(ADaimler) == 0x000008, "Wrong alignment on ADaimler");
static_assert(sizeof(ADaimler) == 0x0005C0, "Wrong size on ADaimler");

// Class HLL.HLLReconDataComponent
// 0x0468 (0x0518 - 0x00B0)
class UHLLReconDataComponent final : public UActorComponent
{
public:
	float                                         DataExpireTime;                                    // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110B[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FReconDataContainer                    AxisReconData;                                     // 0x00B8(0x0118)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FReconDataContainer                    AlliedReconData;                                   // 0x01D0(0x0118)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110C[0x230];                                   // 0x02E8(0x0230)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UHLLReconDataComponent* Get(const class UObject* WorldContextObject);

	bool AddOrUpdateRecon(const class AActor* Target, const ETeam ReconTeam, const EReconSourceType Source);
	void OnRep_AlliedReconData();
	void OnRep_AxisReconData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLReconDataComponent">();
	}
	static class UHLLReconDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLReconDataComponent>();
	}
};
static_assert(alignof(UHLLReconDataComponent) == 0x000008, "Wrong alignment on UHLLReconDataComponent");
static_assert(sizeof(UHLLReconDataComponent) == 0x000518, "Wrong size on UHLLReconDataComponent");
static_assert(offsetof(UHLLReconDataComponent, DataExpireTime) == 0x0000B0, "Member 'UHLLReconDataComponent::DataExpireTime' has a wrong offset!");
static_assert(offsetof(UHLLReconDataComponent, AxisReconData) == 0x0000B8, "Member 'UHLLReconDataComponent::AxisReconData' has a wrong offset!");
static_assert(offsetof(UHLLReconDataComponent, AlliedReconData) == 0x0001D0, "Member 'UHLLReconDataComponent::AlliedReconData' has a wrong offset!");

// Class HLL.VehicleAudioComponentsHost
// 0x0000 (0x0028 - 0x0028)
class IVehicleAudioComponentsHost final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleAudioComponentsHost">();
	}
	static class IVehicleAudioComponentsHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVehicleAudioComponentsHost>();
	}
};
static_assert(alignof(IVehicleAudioComponentsHost) == 0x000008, "Wrong alignment on IVehicleAudioComponentsHost");
static_assert(sizeof(IVehicleAudioComponentsHost) == 0x000028, "Wrong size on IVehicleAudioComponentsHost");

// Class HLL.DA_WeatherManager_Clouds
// 0x0018 (0x0048 - 0x0030)
class UDA_WeatherManager_Clouds final : public UDataAsset
{
public:
	float                                         Layer01Density;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Layer01Speed;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Layer02Density;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Layer02Speed;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverallDensity;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110E[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_Clouds">();
	}
	static class UDA_WeatherManager_Clouds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_Clouds>();
	}
};
static_assert(alignof(UDA_WeatherManager_Clouds) == 0x000008, "Wrong alignment on UDA_WeatherManager_Clouds");
static_assert(sizeof(UDA_WeatherManager_Clouds) == 0x000048, "Wrong size on UDA_WeatherManager_Clouds");
static_assert(offsetof(UDA_WeatherManager_Clouds, Layer01Density) == 0x000030, "Member 'UDA_WeatherManager_Clouds::Layer01Density' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Clouds, Layer01Speed) == 0x000034, "Member 'UDA_WeatherManager_Clouds::Layer01Speed' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Clouds, Layer02Density) == 0x000038, "Member 'UDA_WeatherManager_Clouds::Layer02Density' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Clouds, Layer02Speed) == 0x00003C, "Member 'UDA_WeatherManager_Clouds::Layer02Speed' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Clouds, OverallDensity) == 0x000040, "Member 'UDA_WeatherManager_Clouds::OverallDensity' has a wrong offset!");

// Class HLL.DA_WeatherManager_Fog
// 0x0020 (0x0050 - 0x0030)
class UDA_WeatherManager_Fog final : public UDataAsset
{
public:
	float                                         FogDensity;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VolumetricFog;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110F[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ScatteringDistribution;                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtinctionScale;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewDistance;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFog;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1110[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_Fog">();
	}
	static class UDA_WeatherManager_Fog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_Fog>();
	}
};
static_assert(alignof(UDA_WeatherManager_Fog) == 0x000008, "Wrong alignment on UDA_WeatherManager_Fog");
static_assert(sizeof(UDA_WeatherManager_Fog) == 0x000050, "Wrong size on UDA_WeatherManager_Fog");
static_assert(offsetof(UDA_WeatherManager_Fog, FogDensity) == 0x000030, "Member 'UDA_WeatherManager_Fog::FogDensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Fog, FogHeightFalloff) == 0x000034, "Member 'UDA_WeatherManager_Fog::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Fog, VolumetricFog) == 0x000038, "Member 'UDA_WeatherManager_Fog::VolumetricFog' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Fog, ScatteringDistribution) == 0x00003C, "Member 'UDA_WeatherManager_Fog::ScatteringDistribution' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Fog, ExtinctionScale) == 0x000040, "Member 'UDA_WeatherManager_Fog::ExtinctionScale' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Fog, ViewDistance) == 0x000044, "Member 'UDA_WeatherManager_Fog::ViewDistance' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Fog, GroundFog) == 0x000048, "Member 'UDA_WeatherManager_Fog::GroundFog' has a wrong offset!");

// Class HLL.ServerBrowserFilterDataAsset
// 0x0008 (0x0038 - 0x0030)
class UServerBrowserFilterDataAsset : public UDataAsset
{
public:
	int32                                         FilterIndex;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1111[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	int32 GetFilterIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerBrowserFilterDataAsset">();
	}
	static class UServerBrowserFilterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerBrowserFilterDataAsset>();
	}
};
static_assert(alignof(UServerBrowserFilterDataAsset) == 0x000008, "Wrong alignment on UServerBrowserFilterDataAsset");
static_assert(sizeof(UServerBrowserFilterDataAsset) == 0x000038, "Wrong size on UServerBrowserFilterDataAsset");
static_assert(offsetof(UServerBrowserFilterDataAsset, FilterIndex) == 0x000030, "Member 'UServerBrowserFilterDataAsset::FilterIndex' has a wrong offset!");

// Class HLL.WeatherUiData
// 0x0040 (0x0078 - 0x0038)
class UWeatherUiData final : public UServerBrowserFilterDataAsset
{
public:
	class FText                                   WeatherText;                                       // 0x0038(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              WeatherIcon;                                       // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	TSoftObjectPtr<class UTexture2D> GetWeatherIcon() const;
	class FText GetWeatherText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherUiData">();
	}
	static class UWeatherUiData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherUiData>();
	}
};
static_assert(alignof(UWeatherUiData) == 0x000008, "Wrong alignment on UWeatherUiData");
static_assert(sizeof(UWeatherUiData) == 0x000078, "Wrong size on UWeatherUiData");
static_assert(offsetof(UWeatherUiData, WeatherText) == 0x000038, "Member 'UWeatherUiData::WeatherText' has a wrong offset!");
static_assert(offsetof(UWeatherUiData, WeatherIcon) == 0x000050, "Member 'UWeatherUiData::WeatherIcon' has a wrong offset!");

// Class HLL.DA_WeatherManager_Lightning
// 0x0008 (0x0038 - 0x0030)
class UDA_WeatherManager_Lightning final : public UDataAsset
{
public:
	float                                         StormIntensity;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StormDistnace;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_Lightning">();
	}
	static class UDA_WeatherManager_Lightning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_Lightning>();
	}
};
static_assert(alignof(UDA_WeatherManager_Lightning) == 0x000008, "Wrong alignment on UDA_WeatherManager_Lightning");
static_assert(sizeof(UDA_WeatherManager_Lightning) == 0x000038, "Wrong size on UDA_WeatherManager_Lightning");
static_assert(offsetof(UDA_WeatherManager_Lightning, StormIntensity) == 0x000030, "Member 'UDA_WeatherManager_Lightning::StormIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Lightning, StormDistnace) == 0x000034, "Member 'UDA_WeatherManager_Lightning::StormDistnace' has a wrong offset!");

// Class HLL.DA_WeatherManager_Rain
// 0x0008 (0x0038 - 0x0030)
class UDA_WeatherManager_Rain final : public UDataAsset
{
public:
	float                                         RainDensity;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainIntensity;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_Rain">();
	}
	static class UDA_WeatherManager_Rain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_Rain>();
	}
};
static_assert(alignof(UDA_WeatherManager_Rain) == 0x000008, "Wrong alignment on UDA_WeatherManager_Rain");
static_assert(sizeof(UDA_WeatherManager_Rain) == 0x000038, "Wrong size on UDA_WeatherManager_Rain");
static_assert(offsetof(UDA_WeatherManager_Rain, RainDensity) == 0x000030, "Member 'UDA_WeatherManager_Rain::RainDensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Rain, RainIntensity) == 0x000034, "Member 'UDA_WeatherManager_Rain::RainIntensity' has a wrong offset!");

// Class HLL.HLLReplicationGraph
// 0x0140 (0x05E0 - 0x04A0)
class UHLLReplicationGraph final : public UReplicationGraph
{
public:
	TArray<class UClass*>                         SpatializedClasses;                                // 0x0498(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         NonSpatializedChildClasses;                        // 0x04A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         AlwaysRelevantClasses;                             // 0x04B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLReplicationGraphNode_Team*          TeamNode;                                          // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLReplicationGraphNode_CommanderAbilities* CommanderAbilitiesNode;                            // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1112[0xE8];                                    // 0x04E8(0x00E8)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class APawn>                      PlayerPawnClass;                                   // 0x05D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1113[0x8];                                     // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLReplicationGraph">();
	}
	static class UHLLReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLReplicationGraph>();
	}
};
static_assert(alignof(UHLLReplicationGraph) == 0x000010, "Wrong alignment on UHLLReplicationGraph");
static_assert(sizeof(UHLLReplicationGraph) == 0x0005E0, "Wrong size on UHLLReplicationGraph");
static_assert(offsetof(UHLLReplicationGraph, SpatializedClasses) == 0x000498, "Member 'UHLLReplicationGraph::SpatializedClasses' has a wrong offset!");
static_assert(offsetof(UHLLReplicationGraph, NonSpatializedChildClasses) == 0x0004A8, "Member 'UHLLReplicationGraph::NonSpatializedChildClasses' has a wrong offset!");
static_assert(offsetof(UHLLReplicationGraph, AlwaysRelevantClasses) == 0x0004B8, "Member 'UHLLReplicationGraph::AlwaysRelevantClasses' has a wrong offset!");
static_assert(offsetof(UHLLReplicationGraph, GridNode) == 0x0004C8, "Member 'UHLLReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UHLLReplicationGraph, AlwaysRelevantNode) == 0x0004D0, "Member 'UHLLReplicationGraph::AlwaysRelevantNode' has a wrong offset!");
static_assert(offsetof(UHLLReplicationGraph, TeamNode) == 0x0004D8, "Member 'UHLLReplicationGraph::TeamNode' has a wrong offset!");
static_assert(offsetof(UHLLReplicationGraph, CommanderAbilitiesNode) == 0x0004E0, "Member 'UHLLReplicationGraph::CommanderAbilitiesNode' has a wrong offset!");
static_assert(offsetof(UHLLReplicationGraph, PlayerPawnClass) == 0x0005D0, "Member 'UHLLReplicationGraph::PlayerPawnClass' has a wrong offset!");

// Class HLL.WarfareGameMode
// 0x0028 (0x05C0 - 0x0598)
class AWarfareGameMode final : public AShooterGameMode
{
public:
	int32                                         NumBaseLineCapsToWin;                              // 0x0598(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1114[0x24];                                    // 0x059C(0x0024)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WarfareGameMode">();
	}
	static class AWarfareGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWarfareGameMode>();
	}
};
static_assert(alignof(AWarfareGameMode) == 0x000008, "Wrong alignment on AWarfareGameMode");
static_assert(sizeof(AWarfareGameMode) == 0x0005C0, "Wrong size on AWarfareGameMode");
static_assert(offsetof(AWarfareGameMode, NumBaseLineCapsToWin) == 0x000598, "Member 'AWarfareGameMode::NumBaseLineCapsToWin' has a wrong offset!");

// Class HLL.DA_WeatherManager_Sky
// 0x0060 (0x0090 - 0x0030)
class UDA_WeatherManager_Sky final : public UDataAsset
{
public:
	bool                                          NightTime;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1115[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         TimeOfDay;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunLightIntensity;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SunLightColour;                                    // 0x003C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunInderectLightIntensity;                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunLightScatterIntensity;                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunSize;                                           // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonDirLightIntensity;                             // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MoonLightColour;                                   // 0x005C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonInderectLightIntensity;                        // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonLightScatterIntensity;                         // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonSize;                                          // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonBrightness;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonPhase;                                         // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarAmount;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarIntensity;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarTwinkleSpeed;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1116[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_Sky">();
	}
	static class UDA_WeatherManager_Sky* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_Sky>();
	}
};
static_assert(alignof(UDA_WeatherManager_Sky) == 0x000008, "Wrong alignment on UDA_WeatherManager_Sky");
static_assert(sizeof(UDA_WeatherManager_Sky) == 0x000090, "Wrong size on UDA_WeatherManager_Sky");
static_assert(offsetof(UDA_WeatherManager_Sky, NightTime) == 0x000030, "Member 'UDA_WeatherManager_Sky::NightTime' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, TimeOfDay) == 0x000034, "Member 'UDA_WeatherManager_Sky::TimeOfDay' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, SunLightIntensity) == 0x000038, "Member 'UDA_WeatherManager_Sky::SunLightIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, SunLightColour) == 0x00003C, "Member 'UDA_WeatherManager_Sky::SunLightColour' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, SunInderectLightIntensity) == 0x00004C, "Member 'UDA_WeatherManager_Sky::SunInderectLightIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, SunLightScatterIntensity) == 0x000050, "Member 'UDA_WeatherManager_Sky::SunLightScatterIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, SunSize) == 0x000054, "Member 'UDA_WeatherManager_Sky::SunSize' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, MoonDirLightIntensity) == 0x000058, "Member 'UDA_WeatherManager_Sky::MoonDirLightIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, MoonLightColour) == 0x00005C, "Member 'UDA_WeatherManager_Sky::MoonLightColour' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, MoonInderectLightIntensity) == 0x00006C, "Member 'UDA_WeatherManager_Sky::MoonInderectLightIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, MoonLightScatterIntensity) == 0x000070, "Member 'UDA_WeatherManager_Sky::MoonLightScatterIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, MoonSize) == 0x000074, "Member 'UDA_WeatherManager_Sky::MoonSize' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, MoonBrightness) == 0x000078, "Member 'UDA_WeatherManager_Sky::MoonBrightness' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, MoonPhase) == 0x00007C, "Member 'UDA_WeatherManager_Sky::MoonPhase' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, StarAmount) == 0x000080, "Member 'UDA_WeatherManager_Sky::StarAmount' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, StarIntensity) == 0x000084, "Member 'UDA_WeatherManager_Sky::StarIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Sky, StarTwinkleSpeed) == 0x000088, "Member 'UDA_WeatherManager_Sky::StarTwinkleSpeed' has a wrong offset!");

// Class HLL.HLLRoundSummaryPlatoon
// 0x0060 (0x0290 - 0x0230)
class UHLLRoundSummaryPlatoon : public UUserWidget
{
public:
	uint8                                         Pad_1117[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UVerticalBox*                           PlayerVBox;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlatoonName;                                       // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ExpandIcon;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DesignationIcon;                                   // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TeamCombatValue;                                   // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TeamOffenseValue;                                  // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TeamDefenseValue;                                  // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TeamSupportValue;                                  // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1118[0x18];                                    // 0x0278(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ReceiveInit();
	void ReceiveUpdatePlatoonWidget();
	void ToggleExpanded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoundSummaryPlatoon">();
	}
	static class UHLLRoundSummaryPlatoon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoundSummaryPlatoon>();
	}
};
static_assert(alignof(UHLLRoundSummaryPlatoon) == 0x000008, "Wrong alignment on UHLLRoundSummaryPlatoon");
static_assert(sizeof(UHLLRoundSummaryPlatoon) == 0x000290, "Wrong size on UHLLRoundSummaryPlatoon");
static_assert(offsetof(UHLLRoundSummaryPlatoon, PlayerVBox) == 0x000238, "Member 'UHLLRoundSummaryPlatoon::PlayerVBox' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlatoon, PlatoonName) == 0x000240, "Member 'UHLLRoundSummaryPlatoon::PlatoonName' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlatoon, ExpandIcon) == 0x000248, "Member 'UHLLRoundSummaryPlatoon::ExpandIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlatoon, DesignationIcon) == 0x000250, "Member 'UHLLRoundSummaryPlatoon::DesignationIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlatoon, TeamCombatValue) == 0x000258, "Member 'UHLLRoundSummaryPlatoon::TeamCombatValue' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlatoon, TeamOffenseValue) == 0x000260, "Member 'UHLLRoundSummaryPlatoon::TeamOffenseValue' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlatoon, TeamDefenseValue) == 0x000268, "Member 'UHLLRoundSummaryPlatoon::TeamDefenseValue' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlatoon, TeamSupportValue) == 0x000270, "Member 'UHLLRoundSummaryPlatoon::TeamSupportValue' has a wrong offset!");

// Class HLL.DA_WeatherManager_Snow
// 0x0008 (0x0038 - 0x0030)
class UDA_WeatherManager_Snow final : public UDataAsset
{
public:
	float                                         SnowDensity;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnowIntensity;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_Snow">();
	}
	static class UDA_WeatherManager_Snow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_Snow>();
	}
};
static_assert(alignof(UDA_WeatherManager_Snow) == 0x000008, "Wrong alignment on UDA_WeatherManager_Snow");
static_assert(sizeof(UDA_WeatherManager_Snow) == 0x000038, "Wrong size on UDA_WeatherManager_Snow");
static_assert(offsetof(UDA_WeatherManager_Snow, SnowDensity) == 0x000030, "Member 'UDA_WeatherManager_Snow::SnowDensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Snow, SnowIntensity) == 0x000034, "Member 'UDA_WeatherManager_Snow::SnowIntensity' has a wrong offset!");

// Class HLL.VehicleMGController
// 0x0070 (0x0120 - 0x00B0)
class UVehicleMGController final : public UActorComponent
{
public:
	class FName                                   BoneName;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PitchBoneName;                                     // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSeparatePitchBone : 1;                            // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetRotationOnReload : 1;                        // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockPitchOnCrouch : 1;                            // 0x00C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1119[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<uint8>                                 SeatWeaponIndices;                                 // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MG_ServerUpdateRate;                               // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MG_YawRate;                                        // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MG_YawAngleMax;                                    // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MG_PitchRate;                                      // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MG_PitchAngleMin;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MG_PitchAngleMax;                                  // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemoteInterpolationSpeed;                          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResetInterpolationSpeed;                           // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111A[0x14];                                    // 0x00F8(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	uint16                                        RemotePackedPitchAndYaw_HullMG;                    // 0x010C(0x0002)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111B[0xA];                                     // 0x010E(0x000A)(Fixing Size After Last Property [ Dumper-69 ])
	class AHLLSeat*                               ControllingSeat;                                   // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetCurrentMGPitch() const;
	float GetCurrentMGYaw() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleMGController">();
	}
	static class UVehicleMGController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleMGController>();
	}
};
static_assert(alignof(UVehicleMGController) == 0x000008, "Wrong alignment on UVehicleMGController");
static_assert(sizeof(UVehicleMGController) == 0x000120, "Wrong size on UVehicleMGController");
static_assert(offsetof(UVehicleMGController, BoneName) == 0x0000B0, "Member 'UVehicleMGController::BoneName' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, PitchBoneName) == 0x0000B8, "Member 'UVehicleMGController::PitchBoneName' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, SeatWeaponIndices) == 0x0000C8, "Member 'UVehicleMGController::SeatWeaponIndices' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, MG_ServerUpdateRate) == 0x0000D8, "Member 'UVehicleMGController::MG_ServerUpdateRate' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, MG_YawRate) == 0x0000DC, "Member 'UVehicleMGController::MG_YawRate' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, MG_YawAngleMax) == 0x0000E0, "Member 'UVehicleMGController::MG_YawAngleMax' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, MG_PitchRate) == 0x0000E4, "Member 'UVehicleMGController::MG_PitchRate' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, MG_PitchAngleMin) == 0x0000E8, "Member 'UVehicleMGController::MG_PitchAngleMin' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, MG_PitchAngleMax) == 0x0000EC, "Member 'UVehicleMGController::MG_PitchAngleMax' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, RemoteInterpolationSpeed) == 0x0000F0, "Member 'UVehicleMGController::RemoteInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, ResetInterpolationSpeed) == 0x0000F4, "Member 'UVehicleMGController::ResetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, RemotePackedPitchAndYaw_HullMG) == 0x00010C, "Member 'UVehicleMGController::RemotePackedPitchAndYaw_HullMG' has a wrong offset!");
static_assert(offsetof(UVehicleMGController, ControllingSeat) == 0x000118, "Member 'UVehicleMGController::ControllingSeat' has a wrong offset!");

// Class HLL.DA_WeatherManager_WeatherPresets
// 0x0040 (0x0070 - 0x0030)
class UDA_WeatherManager_WeatherPresets final : public UDataAsset
{
public:
	class UDA_WeatherManager_Sky*                 Sky;                                               // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Clouds*              Clouds;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Fog*                 Fog;                                               // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Wind*                Wind;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Rain*                Rain;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Wetness*             Wetness;                                           // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Lightning*           Lightning;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Snow*                Snow;                                              // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_WeatherPresets">();
	}
	static class UDA_WeatherManager_WeatherPresets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_WeatherPresets>();
	}
};
static_assert(alignof(UDA_WeatherManager_WeatherPresets) == 0x000008, "Wrong alignment on UDA_WeatherManager_WeatherPresets");
static_assert(sizeof(UDA_WeatherManager_WeatherPresets) == 0x000070, "Wrong size on UDA_WeatherManager_WeatherPresets");
static_assert(offsetof(UDA_WeatherManager_WeatherPresets, Sky) == 0x000030, "Member 'UDA_WeatherManager_WeatherPresets::Sky' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_WeatherPresets, Clouds) == 0x000038, "Member 'UDA_WeatherManager_WeatherPresets::Clouds' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_WeatherPresets, Fog) == 0x000040, "Member 'UDA_WeatherManager_WeatherPresets::Fog' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_WeatherPresets, Wind) == 0x000048, "Member 'UDA_WeatherManager_WeatherPresets::Wind' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_WeatherPresets, Rain) == 0x000050, "Member 'UDA_WeatherManager_WeatherPresets::Rain' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_WeatherPresets, Wetness) == 0x000058, "Member 'UDA_WeatherManager_WeatherPresets::Wetness' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_WeatherPresets, Lightning) == 0x000060, "Member 'UDA_WeatherManager_WeatherPresets::Lightning' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_WeatherPresets, Snow) == 0x000068, "Member 'UDA_WeatherManager_WeatherPresets::Snow' has a wrong offset!");

// Class HLL.DA_WeatherManager_Wetness
// 0x0008 (0x0038 - 0x0030)
class UDA_WeatherManager_Wetness final : public UDataAsset
{
public:
	float                                         Wetness;                                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111C[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_Wetness">();
	}
	static class UDA_WeatherManager_Wetness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_Wetness>();
	}
};
static_assert(alignof(UDA_WeatherManager_Wetness) == 0x000008, "Wrong alignment on UDA_WeatherManager_Wetness");
static_assert(sizeof(UDA_WeatherManager_Wetness) == 0x000038, "Wrong size on UDA_WeatherManager_Wetness");
static_assert(offsetof(UDA_WeatherManager_Wetness, Wetness) == 0x000030, "Member 'UDA_WeatherManager_Wetness::Wetness' has a wrong offset!");

// Class HLL.HLLReplicationGraphNode_CommanderAbilities
// 0x0040 (0x0090 - 0x0050)
class UHLLReplicationGraphNode_CommanderAbilities final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_111D[0x40];                                    // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLReplicationGraphNode_CommanderAbilities">();
	}
	static class UHLLReplicationGraphNode_CommanderAbilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLReplicationGraphNode_CommanderAbilities>();
	}
};
static_assert(alignof(UHLLReplicationGraphNode_CommanderAbilities) == 0x000008, "Wrong alignment on UHLLReplicationGraphNode_CommanderAbilities");
static_assert(sizeof(UHLLReplicationGraphNode_CommanderAbilities) == 0x000090, "Wrong size on UHLLReplicationGraphNode_CommanderAbilities");

// Class HLL.VoipSubsystem
// 0x0280 (0x02B0 - 0x0030)
class UVoipSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_111E[0x280];                                   // 0x0030(0x0280)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipSubsystem">();
	}
	static class UVoipSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipSubsystem>();
	}
};
static_assert(alignof(UVoipSubsystem) == 0x000008, "Wrong alignment on UVoipSubsystem");
static_assert(sizeof(UVoipSubsystem) == 0x0002B0, "Wrong size on UVoipSubsystem");

// Class HLL.DA_WeatherManager_Wind
// 0x0010 (0x0040 - 0x0030)
class UDA_WeatherManager_Wind final : public UDataAsset
{
public:
	float                                         WindDirection;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindIntensity;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindTurbulance;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111F[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DA_WeatherManager_Wind">();
	}
	static class UDA_WeatherManager_Wind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDA_WeatherManager_Wind>();
	}
};
static_assert(alignof(UDA_WeatherManager_Wind) == 0x000008, "Wrong alignment on UDA_WeatherManager_Wind");
static_assert(sizeof(UDA_WeatherManager_Wind) == 0x000040, "Wrong size on UDA_WeatherManager_Wind");
static_assert(offsetof(UDA_WeatherManager_Wind, WindDirection) == 0x000030, "Member 'UDA_WeatherManager_Wind::WindDirection' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Wind, WindIntensity) == 0x000034, "Member 'UDA_WeatherManager_Wind::WindIntensity' has a wrong offset!");
static_assert(offsetof(UDA_WeatherManager_Wind, WindTurbulance) == 0x000038, "Member 'UDA_WeatherManager_Wind::WindTurbulance' has a wrong offset!");

// Class HLL.DeathCamera
// 0x0060 (0x0280 - 0x0220)
class ADeathCamera : public AActor
{
public:
	uint8                                         Pad_1120[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UCameraComponent*                       Camera;                                            // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       Collision;                                         // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileMovementComponent*           Movement;                                          // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationAxisConeHalfAngle;                         // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationSpeed;                                     // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationDecelerationSpeed;                         // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FadeToBlackTime;                                   // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FadeToSkyViewTime;                                 // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlownUpDeathScreenDelay;                           // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1121[0x18];                                    // 0x0268(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathCamera">();
	}
	static class ADeathCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathCamera>();
	}
};
static_assert(alignof(ADeathCamera) == 0x000008, "Wrong alignment on ADeathCamera");
static_assert(sizeof(ADeathCamera) == 0x000280, "Wrong size on ADeathCamera");
static_assert(offsetof(ADeathCamera, Camera) == 0x000238, "Member 'ADeathCamera::Camera' has a wrong offset!");
static_assert(offsetof(ADeathCamera, Collision) == 0x000240, "Member 'ADeathCamera::Collision' has a wrong offset!");
static_assert(offsetof(ADeathCamera, Movement) == 0x000248, "Member 'ADeathCamera::Movement' has a wrong offset!");
static_assert(offsetof(ADeathCamera, RotationAxisConeHalfAngle) == 0x000250, "Member 'ADeathCamera::RotationAxisConeHalfAngle' has a wrong offset!");
static_assert(offsetof(ADeathCamera, RotationSpeed) == 0x000254, "Member 'ADeathCamera::RotationSpeed' has a wrong offset!");
static_assert(offsetof(ADeathCamera, RotationDecelerationSpeed) == 0x000258, "Member 'ADeathCamera::RotationDecelerationSpeed' has a wrong offset!");
static_assert(offsetof(ADeathCamera, FadeToBlackTime) == 0x00025C, "Member 'ADeathCamera::FadeToBlackTime' has a wrong offset!");
static_assert(offsetof(ADeathCamera, FadeToSkyViewTime) == 0x000260, "Member 'ADeathCamera::FadeToSkyViewTime' has a wrong offset!");
static_assert(offsetof(ADeathCamera, BlownUpDeathScreenDelay) == 0x000264, "Member 'ADeathCamera::BlownUpDeathScreenDelay' has a wrong offset!");

// Class HLL.DebugGridRendereringTool
// 0x0008 (0x0228 - 0x0220)
class ADebugGridRendereringTool final : public AActor
{
public:
	bool                                          bIsMapVertical;                                    // 0x0220(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1122[0x7];                                     // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugGridRendereringTool">();
	}
	static class ADebugGridRendereringTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugGridRendereringTool>();
	}
};
static_assert(alignof(ADebugGridRendereringTool) == 0x000008, "Wrong alignment on ADebugGridRendereringTool");
static_assert(sizeof(ADebugGridRendereringTool) == 0x000228, "Wrong size on ADebugGridRendereringTool");
static_assert(offsetof(ADebugGridRendereringTool, bIsMapVertical) == 0x000220, "Member 'ADebugGridRendereringTool::bIsMapVertical' has a wrong offset!");

// Class HLL.DeploymentLogic
// 0x0060 (0x0110 - 0x00B0)
class UDeploymentLogic : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerPlatoonChanged;                            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlatoonMembersChanged;                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCreatePlatoonSucceeded;                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCreatePlatoonFailed;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerPlatoonJoined;                             // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerInitiatedLeavingPlatoon;                   // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void CheckJoinPlatoonAchievements(const class AHLLPlatoon* Platoon);
	void ClientCreatePlatoonFailed(const class FText& Error);
	void ClientCreatePlatoonSucceeded();
	void ClientDisplayPlatoonManagementNotification(const struct FPlatoonManagementNotification& Notification);
	void ClientReceivePlatoonInvitation(class AHLLPlatoon* Platoon);
	void ClientReceivePlatoonInviteRequestFrom(class AShooterPlayerState* RequestSender);
	void ClientReceiveTeamKillerPunishmentRequestFor(class AShooterPlayerState* TeamKiller);
	void CreatePlatoon(class AShooterPlayerState* Officer, ETeam Team, EPlatoonType Type, const struct FPlatoonMeta& Meta, bool bCreateEmptyPlatoon);
	void JoinPlatoon(class AHLLPlatoon* Platoon);
	void LeavePlatoon();
	void OnCreatePlatoonFailed__DelegateSignature(const class FText& Error);
	void OnCreatePlatoonSucceeded__DelegateSignature();
	void OnPlatoonMembersChanged__DelegateSignature(class AHLLPlatoon* Platoon);
	void OnPlayerInitiatedLeavingPlatoon__DelegateSignature();
	void OnPlayerPlatoonChanged__DelegateSignature();
	void OnPlayerPlatoonJoined__DelegateSignature();
	void ServerCreatePlatoon(class AShooterPlayerState* Officer, ETeam Team, EPlatoonType Type, const struct FPlatoonMeta& InitialMeta, bool bCreateEmptyPlatoon);
	void ServerInvitePlayersToPlatoon(class AHLLPlatoon* Platoon, const TArray<class AShooterPlayerState*>& InvitedPlayers);
	void ServerKickPlayerOutOfOwnedPlatoon(class AShooterPlayerState* KickedPlayer, EPlatoonKickReason Reason);
	void ServerLeavePlatoon();
	void ServerProcessInviteResponse(class AHLLPlatoon* Platoon, bool Accepted);
	void ServerPunishTeamKiller(class AShooterPlayerState* TeamKiller);
	void ServerRejectRequestToJoinLockedPlatoonFrom(class AShooterPlayerState* Player, class AHLLPlatoon* Platoon);
	void ServerRequestInviteTo(class AHLLPlatoon* Platoon);
	void ServerSetPlatoonMeta(class AHLLPlatoon* Platoon, const struct FPlatoonMeta& Meta);
	void SetPlatoonMeta(class AHLLPlatoon* Platoon, const struct FPlatoonMeta& Meta);

	bool CanEverDeploy() const;
	EPlayerRole OverridePlayerRoleForJoiningPlatoon(class AHLLPlatoon* Platoon, class AShooterPlayerState* Player, EPlayerRole DesiredRole) const;
	struct FUnitLimits PlatoonLimits() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeploymentLogic">();
	}
	static class UDeploymentLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeploymentLogic>();
	}
};
static_assert(alignof(UDeploymentLogic) == 0x000008, "Wrong alignment on UDeploymentLogic");
static_assert(sizeof(UDeploymentLogic) == 0x000110, "Wrong size on UDeploymentLogic");
static_assert(offsetof(UDeploymentLogic, OnPlayerPlatoonChanged) == 0x0000B0, "Member 'UDeploymentLogic::OnPlayerPlatoonChanged' has a wrong offset!");
static_assert(offsetof(UDeploymentLogic, OnPlatoonMembersChanged) == 0x0000C0, "Member 'UDeploymentLogic::OnPlatoonMembersChanged' has a wrong offset!");
static_assert(offsetof(UDeploymentLogic, OnCreatePlatoonSucceeded) == 0x0000D0, "Member 'UDeploymentLogic::OnCreatePlatoonSucceeded' has a wrong offset!");
static_assert(offsetof(UDeploymentLogic, OnCreatePlatoonFailed) == 0x0000E0, "Member 'UDeploymentLogic::OnCreatePlatoonFailed' has a wrong offset!");
static_assert(offsetof(UDeploymentLogic, OnPlayerPlatoonJoined) == 0x0000F0, "Member 'UDeploymentLogic::OnPlayerPlatoonJoined' has a wrong offset!");
static_assert(offsetof(UDeploymentLogic, OnPlayerInitiatedLeavingPlatoon) == 0x000100, "Member 'UDeploymentLogic::OnPlayerInitiatedLeavingPlatoon' has a wrong offset!");

// Class HLL.HLLResourceStatus
// 0x0058 (0x0288 - 0x0230)
class UHLLResourceStatus : public UUserWidget
{
public:
	EHLLResourceStatusMode                        StatusMode;                                        // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLResourceStatusMode                        NodeMode;                                          // 0x0231(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         StatusTeam;                                        // 0x0232(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112A[0x5];                                     // 0x0233(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   UnknownText;                                       // 0x0238(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             Manpower;                                          // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Fuel;                                              // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Munitions;                                         // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ManpowerNodes;                                     // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FuelNodes;                                         // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MunitionsNodes;                                    // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_Fuel;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetGeneratorMode(const EHLLResourceStatusMode InMode);
	void SetStatusMode(const EHLLResourceStatusMode InMode);
	void SetStatusTeam(const ETeam ForTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLResourceStatus">();
	}
	static class UHLLResourceStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLResourceStatus>();
	}
};
static_assert(alignof(UHLLResourceStatus) == 0x000008, "Wrong alignment on UHLLResourceStatus");
static_assert(sizeof(UHLLResourceStatus) == 0x000288, "Wrong size on UHLLResourceStatus");
static_assert(offsetof(UHLLResourceStatus, StatusMode) == 0x000230, "Member 'UHLLResourceStatus::StatusMode' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, NodeMode) == 0x000231, "Member 'UHLLResourceStatus::NodeMode' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, StatusTeam) == 0x000232, "Member 'UHLLResourceStatus::StatusTeam' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, UnknownText) == 0x000238, "Member 'UHLLResourceStatus::UnknownText' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, Manpower) == 0x000250, "Member 'UHLLResourceStatus::Manpower' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, Fuel) == 0x000258, "Member 'UHLLResourceStatus::Fuel' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, Munitions) == 0x000260, "Member 'UHLLResourceStatus::Munitions' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, ManpowerNodes) == 0x000268, "Member 'UHLLResourceStatus::ManpowerNodes' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, FuelNodes) == 0x000270, "Member 'UHLLResourceStatus::FuelNodes' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, MunitionsNodes) == 0x000278, "Member 'UHLLResourceStatus::MunitionsNodes' has a wrong offset!");
static_assert(offsetof(UHLLResourceStatus, HB_Fuel) == 0x000280, "Member 'UHLLResourceStatus::HB_Fuel' has a wrong offset!");

// Class HLL.EndMatchAchievement
// 0x0008 (0x0038 - 0x0030)
class UEndMatchAchievement : public UDataAsset
{
public:
	bool                                          RequiresVictory;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112B[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMatchAchievement">();
	}
	static class UEndMatchAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMatchAchievement>();
	}
};
static_assert(alignof(UEndMatchAchievement) == 0x000008, "Wrong alignment on UEndMatchAchievement");
static_assert(sizeof(UEndMatchAchievement) == 0x000038, "Wrong size on UEndMatchAchievement");
static_assert(offsetof(UEndMatchAchievement, RequiresVictory) == 0x000030, "Member 'UEndMatchAchievement::RequiresVictory' has a wrong offset!");

// Class HLL.WinMatchNoObjectivesDestroyedAchievement
// 0x0008 (0x0040 - 0x0038)
class UWinMatchNoObjectivesDestroyedAchievement final : public UEndMatchAchievement
{
public:
	EHLLAchievement                               AchievementToUnlock;                               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTeamSpecific;                                   // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x003A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112C[0x5];                                     // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinMatchNoObjectivesDestroyedAchievement">();
	}
	static class UWinMatchNoObjectivesDestroyedAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinMatchNoObjectivesDestroyedAchievement>();
	}
};
static_assert(alignof(UWinMatchNoObjectivesDestroyedAchievement) == 0x000008, "Wrong alignment on UWinMatchNoObjectivesDestroyedAchievement");
static_assert(sizeof(UWinMatchNoObjectivesDestroyedAchievement) == 0x000040, "Wrong size on UWinMatchNoObjectivesDestroyedAchievement");
static_assert(offsetof(UWinMatchNoObjectivesDestroyedAchievement, AchievementToUnlock) == 0x000038, "Member 'UWinMatchNoObjectivesDestroyedAchievement::AchievementToUnlock' has a wrong offset!");
static_assert(offsetof(UWinMatchNoObjectivesDestroyedAchievement, bIsTeamSpecific) == 0x000039, "Member 'UWinMatchNoObjectivesDestroyedAchievement::bIsTeamSpecific' has a wrong offset!");
static_assert(offsetof(UWinMatchNoObjectivesDestroyedAchievement, Team) == 0x00003A, "Member 'UWinMatchNoObjectivesDestroyedAchievement::Team' has a wrong offset!");

// Class HLL.DeployTestAction
// 0x0000 (0x0050 - 0x0050)
class UDeployTestAction final : public UBaseAutomatedTestAction
{
public:
	static class UDeployTestAction* Deploy(class ABaseAutomatedTestActor* Actor, ETeam Team, EPlayerRole PlayerRole);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployTestAction">();
	}
	static class UDeployTestAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployTestAction>();
	}
};
static_assert(alignof(UDeployTestAction) == 0x000008, "Wrong alignment on UDeployTestAction");
static_assert(sizeof(UDeployTestAction) == 0x000050, "Wrong size on UDeployTestAction");

// Class HLL.ObjectDestroyedAchievement
// 0x0000 (0x0030 - 0x0030)
class UObjectDestroyedAchievement : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectDestroyedAchievement">();
	}
	static class UObjectDestroyedAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectDestroyedAchievement>();
	}
};
static_assert(alignof(UObjectDestroyedAchievement) == 0x000008, "Wrong alignment on UObjectDestroyedAchievement");
static_assert(sizeof(UObjectDestroyedAchievement) == 0x000030, "Wrong size on UObjectDestroyedAchievement");

// Class HLL.DestroyEnemyTanksPorgressionAchievement
// 0x0008 (0x0038 - 0x0030)
class UDestroyEnemyTanksPorgressionAchievement final : public UObjectDestroyedAchievement
{
public:
	EHLLAchievementStat                           AchievementStat;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112E[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyEnemyTanksPorgressionAchievement">();
	}
	static class UDestroyEnemyTanksPorgressionAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyEnemyTanksPorgressionAchievement>();
	}
};
static_assert(alignof(UDestroyEnemyTanksPorgressionAchievement) == 0x000008, "Wrong alignment on UDestroyEnemyTanksPorgressionAchievement");
static_assert(sizeof(UDestroyEnemyTanksPorgressionAchievement) == 0x000038, "Wrong size on UDestroyEnemyTanksPorgressionAchievement");
static_assert(offsetof(UDestroyEnemyTanksPorgressionAchievement, AchievementStat) == 0x000030, "Member 'UDestroyEnemyTanksPorgressionAchievement::AchievementStat' has a wrong offset!");

// Class HLL.HLLPhysicsVolume
// 0x0008 (0x0270 - 0x0268)
class AHLLPhysicsVolume : public APhysicsVolume
{
public:
	uint8                                         CharacterMovementFlags;                            // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112F[0x7];                                     // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPhysicsVolume">();
	}
	static class AHLLPhysicsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLPhysicsVolume>();
	}
};
static_assert(alignof(AHLLPhysicsVolume) == 0x000008, "Wrong alignment on AHLLPhysicsVolume");
static_assert(sizeof(AHLLPhysicsVolume) == 0x000270, "Wrong size on AHLLPhysicsVolume");
static_assert(offsetof(AHLLPhysicsVolume, CharacterMovementFlags) == 0x000268, "Member 'AHLLPhysicsVolume::CharacterMovementFlags' has a wrong offset!");

// Class HLL.HLLBarbedWireVolume
// 0x0090 (0x0300 - 0x0270)
class AHLLBarbedWireVolume final : public AHLLPhysicsVolume
{
public:
	float                                         MaxCharacterMovementSpeed;                         // 0x0270(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapParticleDelay;                              // 0x0274(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapSoundDelay;                                 // 0x0278(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapPainDelay;                                  // 0x027C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemoveTimeTolerance;                               // 0x0280(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityTolerance;                                 // 0x0284(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UParticleSystem>         OverlapParticle;                                   // 0x0288(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              OverlapSound;                                      // 0x02B0(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipParticlesForLocalPlayer;                      // 0x02D8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1130[0x7];                                     // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystem*                        LoadedParticle;                                    // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             LoadedSound;                                       // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1131[0x10];                                    // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class AHLLBarbedWireVolume* GetDefaultBarbedWireVolume(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBarbedWireVolume">();
	}
	static class AHLLBarbedWireVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLBarbedWireVolume>();
	}
};
static_assert(alignof(AHLLBarbedWireVolume) == 0x000008, "Wrong alignment on AHLLBarbedWireVolume");
static_assert(sizeof(AHLLBarbedWireVolume) == 0x000300, "Wrong size on AHLLBarbedWireVolume");
static_assert(offsetof(AHLLBarbedWireVolume, MaxCharacterMovementSpeed) == 0x000270, "Member 'AHLLBarbedWireVolume::MaxCharacterMovementSpeed' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, OverlapParticleDelay) == 0x000274, "Member 'AHLLBarbedWireVolume::OverlapParticleDelay' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, OverlapSoundDelay) == 0x000278, "Member 'AHLLBarbedWireVolume::OverlapSoundDelay' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, OverlapPainDelay) == 0x00027C, "Member 'AHLLBarbedWireVolume::OverlapPainDelay' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, RemoveTimeTolerance) == 0x000280, "Member 'AHLLBarbedWireVolume::RemoveTimeTolerance' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, VelocityTolerance) == 0x000284, "Member 'AHLLBarbedWireVolume::VelocityTolerance' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, OverlapParticle) == 0x000288, "Member 'AHLLBarbedWireVolume::OverlapParticle' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, OverlapSound) == 0x0002B0, "Member 'AHLLBarbedWireVolume::OverlapSound' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, bSkipParticlesForLocalPlayer) == 0x0002D8, "Member 'AHLLBarbedWireVolume::bSkipParticlesForLocalPlayer' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, LoadedParticle) == 0x0002E0, "Member 'AHLLBarbedWireVolume::LoadedParticle' has a wrong offset!");
static_assert(offsetof(AHLLBarbedWireVolume, LoadedSound) == 0x0002E8, "Member 'AHLLBarbedWireVolume::LoadedSound' has a wrong offset!");

// Class HLL.RCONCommand
// 0x0000 (0x0028 - 0x0028)
class URCONCommand : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommand">();
	}
	static class URCONCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommand>();
	}
};
static_assert(alignof(URCONCommand) == 0x000008, "Wrong alignment on URCONCommand");
static_assert(sizeof(URCONCommand) == 0x000028, "Wrong size on URCONCommand");

// Class HLL.RCONCommandTemporaryBanPlayer
// 0x0000 (0x0028 - 0x0028)
class URCONCommandTemporaryBanPlayer final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandTemporaryBanPlayer">();
	}
	static class URCONCommandTemporaryBanPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandTemporaryBanPlayer>();
	}
};
static_assert(alignof(URCONCommandTemporaryBanPlayer) == 0x000008, "Wrong alignment on URCONCommandTemporaryBanPlayer");
static_assert(sizeof(URCONCommandTemporaryBanPlayer) == 0x000028, "Wrong size on URCONCommandTemporaryBanPlayer");

// Class HLL.GameStateEventAchievement
// 0x0000 (0x0030 - 0x0030)
class UGameStateEventAchievement : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateEventAchievement">();
	}
	static class UGameStateEventAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateEventAchievement>();
	}
};
static_assert(alignof(UGameStateEventAchievement) == 0x000008, "Wrong alignment on UGameStateEventAchievement");
static_assert(sizeof(UGameStateEventAchievement) == 0x000030, "Wrong size on UGameStateEventAchievement");

// Class HLL.DestroyObjectiveAchievement
// 0x0008 (0x0038 - 0x0030)
class UDestroyObjectiveAchievement final : public UGameStateEventAchievement
{
public:
	EHLLAchievement                               AchievementToUnlock;                               // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1132[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnObjectiveDestroyed(class APlantObjectiveArea* PlantObjectiveArea);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyObjectiveAchievement">();
	}
	static class UDestroyObjectiveAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyObjectiveAchievement>();
	}
};
static_assert(alignof(UDestroyObjectiveAchievement) == 0x000008, "Wrong alignment on UDestroyObjectiveAchievement");
static_assert(sizeof(UDestroyObjectiveAchievement) == 0x000038, "Wrong size on UDestroyObjectiveAchievement");
static_assert(offsetof(UDestroyObjectiveAchievement, AchievementToUnlock) == 0x000030, "Member 'UDestroyObjectiveAchievement::AchievementToUnlock' has a wrong offset!");

// Class HLL.ReconVehicleAnimInstance
// 0x0720 (0x10A0 - 0x0980)
class UReconVehicleAnimInstance final : public UVehicleAnimInstance
{
public:
	uint8                                         Pad_1133[0x728];                                   // 0x0978(0x0728)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReconVehicleAnimInstance">();
	}
	static class UReconVehicleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReconVehicleAnimInstance>();
	}
};
static_assert(alignof(UReconVehicleAnimInstance) == 0x000010, "Wrong alignment on UReconVehicleAnimInstance");
static_assert(sizeof(UReconVehicleAnimInstance) == 0x0010A0, "Wrong size on UReconVehicleAnimInstance");

// Class HLL.DirectoryServiceSetupSubsystem
// 0x0030 (0x0060 - 0x0030)
class UDirectoryServiceSetupSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_1134[0x30];                                    // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectoryServiceSetupSubsystem">();
	}
	static class UDirectoryServiceSetupSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectoryServiceSetupSubsystem>();
	}
};
static_assert(alignof(UDirectoryServiceSetupSubsystem) == 0x000008, "Wrong alignment on UDirectoryServiceSetupSubsystem");
static_assert(sizeof(UDirectoryServiceSetupSubsystem) == 0x000060, "Wrong size on UDirectoryServiceSetupSubsystem");

// Class HLL.DismantlingComponent
// 0x0028 (0x00D8 - 0x00B0)
class UDismantlingComponent final : public UActorComponent
{
public:
	float                                         ContinuationWaitingTime;                           // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1135[0x14];                                    // 0x00B4(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CachedProgress;                                    // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProgressChangingRate;                              // 0x00CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastCacheTime;                                     // 0x00D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1136[0x4];                                     // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DismantlingComponent">();
	}
	static class UDismantlingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDismantlingComponent>();
	}
};
static_assert(alignof(UDismantlingComponent) == 0x000008, "Wrong alignment on UDismantlingComponent");
static_assert(sizeof(UDismantlingComponent) == 0x0000D8, "Wrong size on UDismantlingComponent");
static_assert(offsetof(UDismantlingComponent, ContinuationWaitingTime) == 0x0000B0, "Member 'UDismantlingComponent::ContinuationWaitingTime' has a wrong offset!");
static_assert(offsetof(UDismantlingComponent, CachedProgress) == 0x0000C8, "Member 'UDismantlingComponent::CachedProgress' has a wrong offset!");
static_assert(offsetof(UDismantlingComponent, ProgressChangingRate) == 0x0000CC, "Member 'UDismantlingComponent::ProgressChangingRate' has a wrong offset!");
static_assert(offsetof(UDismantlingComponent, LastCacheTime) == 0x0000D0, "Member 'UDismantlingComponent::LastCacheTime' has a wrong offset!");

// Class HLL.HLLCharacterAnimInstance
// 0x0070 (0x02E0 - 0x0270)
class UHLLCharacterAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_1137[0x10];                                    // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CharacterVelocity;                                 // 0x0288(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CharacterActorRotation;                            // 0x0294(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CharacterBaseAimRotation;                          // 0x02A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          IsCharacterMoving;                                 // 0x02AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharacterMoving2D;                               // 0x02AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharacterRunning;                                // 0x02AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharacterProne;                                  // 0x02AF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharacterCrouching;                              // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDiveToProne;                                // 0x02B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1138[0x2];                                     // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DiveSpeedScale;                                    // 0x02B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharacterTargeting;                              // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharacterInAir;                                  // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1139[0x2];                                     // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CharacterAimYaw;                                   // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterAimPitch;                                 // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterDirection;                                // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterSpeed;                                    // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterLeanAngleDegrees;                         // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 CharacterMovementMode;                             // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         CharacterCustomMovementMode;                       // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsReloadDry;                                       // 0x02D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponType                                   WeaponType;                                        // 0x02D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponDeployState                            WeaponDeployState;                                 // 0x02D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsWeaponDeployed;                                  // 0x02D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharacterAnimationPaused;                        // 0x02D6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLHealthState                               CharacterHealthState;                              // 0x02D7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_113A[0x8];                                     // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BlueprintOnWeaponChanged(class AShooterWeapon* LastWeapon, class AShooterWeapon* NewWeapon);
	void BlueprintOnWeaponDeployStateChanged(EWeaponDeployState LastDeployState, EWeaponDeployState NewDeployState);
	void OnFinishedVaulting();
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnPointDamage(const float Damage, const struct FHitResult& Hit, const struct FVector& ShotDirection);
	void OnRadialDamage(const float Damage, const struct FHitResult& Hit, const struct FVector& ImpulseDirection);
	void OnStartedVaulting(float ObstacleDistance, float ObstacleHeight, EVaultingMoveType MoveType);
	void OnWeaponChanged(class AShooterWeapon* LastWeapon, class AShooterWeapon* NewWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCharacterAnimInstance">();
	}
	static class UHLLCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCharacterAnimInstance>();
	}
};
static_assert(alignof(UHLLCharacterAnimInstance) == 0x000010, "Wrong alignment on UHLLCharacterAnimInstance");
static_assert(sizeof(UHLLCharacterAnimInstance) == 0x0002E0, "Wrong size on UHLLCharacterAnimInstance");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterMovementComponent) == 0x000280, "Member 'UHLLCharacterAnimInstance::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterVelocity) == 0x000288, "Member 'UHLLCharacterAnimInstance::CharacterVelocity' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterActorRotation) == 0x000294, "Member 'UHLLCharacterAnimInstance::CharacterActorRotation' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterBaseAimRotation) == 0x0002A0, "Member 'UHLLCharacterAnimInstance::CharacterBaseAimRotation' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsCharacterMoving) == 0x0002AC, "Member 'UHLLCharacterAnimInstance::IsCharacterMoving' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsCharacterMoving2D) == 0x0002AD, "Member 'UHLLCharacterAnimInstance::IsCharacterMoving2D' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsCharacterRunning) == 0x0002AE, "Member 'UHLLCharacterAnimInstance::IsCharacterRunning' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsCharacterProne) == 0x0002AF, "Member 'UHLLCharacterAnimInstance::IsCharacterProne' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsCharacterCrouching) == 0x0002B0, "Member 'UHLLCharacterAnimInstance::IsCharacterCrouching' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, bShouldDiveToProne) == 0x0002B1, "Member 'UHLLCharacterAnimInstance::bShouldDiveToProne' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, DiveSpeedScale) == 0x0002B4, "Member 'UHLLCharacterAnimInstance::DiveSpeedScale' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsCharacterTargeting) == 0x0002B8, "Member 'UHLLCharacterAnimInstance::IsCharacterTargeting' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsCharacterInAir) == 0x0002B9, "Member 'UHLLCharacterAnimInstance::IsCharacterInAir' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterAimYaw) == 0x0002BC, "Member 'UHLLCharacterAnimInstance::CharacterAimYaw' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterAimPitch) == 0x0002C0, "Member 'UHLLCharacterAnimInstance::CharacterAimPitch' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterDirection) == 0x0002C4, "Member 'UHLLCharacterAnimInstance::CharacterDirection' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterSpeed) == 0x0002C8, "Member 'UHLLCharacterAnimInstance::CharacterSpeed' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterLeanAngleDegrees) == 0x0002CC, "Member 'UHLLCharacterAnimInstance::CharacterLeanAngleDegrees' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterMovementMode) == 0x0002D0, "Member 'UHLLCharacterAnimInstance::CharacterMovementMode' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterCustomMovementMode) == 0x0002D1, "Member 'UHLLCharacterAnimInstance::CharacterCustomMovementMode' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsReloadDry) == 0x0002D2, "Member 'UHLLCharacterAnimInstance::IsReloadDry' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, WeaponType) == 0x0002D3, "Member 'UHLLCharacterAnimInstance::WeaponType' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, WeaponDeployState) == 0x0002D4, "Member 'UHLLCharacterAnimInstance::WeaponDeployState' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsWeaponDeployed) == 0x0002D5, "Member 'UHLLCharacterAnimInstance::IsWeaponDeployed' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, IsCharacterAnimationPaused) == 0x0002D6, "Member 'UHLLCharacterAnimInstance::IsCharacterAnimationPaused' has a wrong offset!");
static_assert(offsetof(UHLLCharacterAnimInstance, CharacterHealthState) == 0x0002D7, "Member 'UHLLCharacterAnimInstance::CharacterHealthState' has a wrong offset!");

// Class HLL.RCONServerInfo
// 0x0000 (0x0028 - 0x0028)
class URCONServerInfo : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerInfo">();
	}
	static class URCONServerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerInfo>();
	}
};
static_assert(alignof(URCONServerInfo) == 0x000008, "Wrong alignment on URCONServerInfo");
static_assert(sizeof(URCONServerInfo) == 0x000028, "Wrong size on URCONServerInfo");

// Class HLL.RCONServerInfoSessionDetails
// 0x0000 (0x0028 - 0x0028)
class URCONServerInfoSessionDetails final : public URCONServerInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerInfoSessionDetails">();
	}
	static class URCONServerInfoSessionDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerInfoSessionDetails>();
	}
};
static_assert(alignof(URCONServerInfoSessionDetails) == 0x000008, "Wrong alignment on URCONServerInfoSessionDetails");
static_assert(sizeof(URCONServerInfoSessionDetails) == 0x000028, "Wrong size on URCONServerInfoSessionDetails");

// Class HLL.ItemDispensedAchievement
// 0x0000 (0x0030 - 0x0030)
class UItemDispensedAchievement : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDispensedAchievement">();
	}
	static class UItemDispensedAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDispensedAchievement>();
	}
};
static_assert(alignof(UItemDispensedAchievement) == 0x000008, "Wrong alignment on UItemDispensedAchievement");
static_assert(sizeof(UItemDispensedAchievement) == 0x000030, "Wrong size on UItemDispensedAchievement");

// Class HLL.HLLDispenserItem_Base
// 0x02F8 (0x0518 - 0x0220)
class AHLLDispenserItem_Base : public AActor
{
public:
	struct FGhostPlacementInfo                    LastPlacementInfo;                                 // 0x0220(0x0038)(ZeroConstructor, Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         LastPlacementYaw[0x2];                             // 0x0258(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DummyRoot;                                         // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   GhostMesh;                                         // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PlacementGuard;                                    // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     GhostMaterial;                                     // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               GhostMeshDMI;                                      // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                GhostOwnerObject;                                  // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     ItemToDispense;                                    // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDestroyItemsWhenKilled : 1;                       // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanEditAutoDestroy : 1;                           // 0x0298(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoDestroyItems : 1;                             // 0x0298(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         MaxTotalDispensedItems;                            // 0x0299(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMaxBuildDepthOverride : 1;                        // 0x029A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_113D[0x1];                                     // 0x029B(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MaxBuildDepthOverride;                             // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScoreTypeWhenPlaced;                               // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreModifier;                                     // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHLLPlayerStat                                StatIncrementType;                                 // 0x02AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bBlockInEnemySectors : 1;                          // 0x02AD(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockInNeutralSectors : 1;                        // 0x02AD(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockInFriendlyBaseSectors : 1;                   // 0x02AD(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideBlockInPracticeMode : 1;                  // 0x02AD(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EHLLDispenseSectorRule                        LockedEnemySectorRule;                             // 0x02AE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHLLDispenseSectorRule                        UnlockedEnemySectorRule;                           // 0x02AF(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSupportedGameModes                    SupportedGameModes;                                // 0x02B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EHLLDispenseSurfaceRule                       SurfaceRule;                                       // 0x0300(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_113E[0x3];                                     // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         TraceDistance;                                     // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHeight;                                       // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceErrorMargin;                                // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropTime;                                          // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSurfaceAngle;                                   // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             FloorChannel;                                      // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             SurfaceChannel;                                    // 0x0319(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionResponseContainer            SurfaceResponses;                                  // 0x031A(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_113F[0x6];                                     // 0x033A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<TSubclassOf<class AActor>>             AttachWhitelist;                                   // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             AttachBlacklist;                                   // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0360(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ItemBrush;                                         // 0x0378(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UHLLDispenserListItem>      ListItemWidgetClass;                               // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DispenseParticle;                                  // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DispenseSound;                                     // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCountsAsSmallItem;                                // 0x0418(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAttachToArmour;                                // 0x0419(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseComplexCollisionForPlacement;                  // 0x041A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1140[0x5];                                     // 0x041B(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   InvalidPlacement_Generic;                          // 0x0420(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlacement_PlayerLocation;                   // 0x0438(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlacement_EnemySector;                      // 0x0450(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlacement_NeutralSector;                    // 0x0468(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlacement_LockedSector;                     // 0x0480(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlacement_LockedBase;                       // 0x0498(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlacement_ReconOnly;                        // 0x04B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlacement_FriendlyBaseSector;               // 0x04C8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bIncrementAchievement : 1;                         // 0x04E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EHLLAchievementStat                           AchievementStat;                                   // 0x04E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1141[0x2];                                     // 0x04E2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	uint32                                        IncrementAmount;                                   // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHint                                         HintWhenSelected;                                  // 0x04E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxPerTeam;                                        // 0x04E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1142[0x18];                                    // 0x04EA(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bCanEverSnap : 1;                                  // 0x0502(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSnappingEnabled : 1;                              // 0x0502(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1143[0x5];                                     // 0x0503(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLSnapQueryComponent*                 SnapQueryComponent;                                // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScriptStruct*                          PerItemNetworkDataStruct;                          // 0x0510(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_Base">();
	}
	static class AHLLDispenserItem_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_Base>();
	}
};
static_assert(alignof(AHLLDispenserItem_Base) == 0x000008, "Wrong alignment on AHLLDispenserItem_Base");
static_assert(sizeof(AHLLDispenserItem_Base) == 0x000518, "Wrong size on AHLLDispenserItem_Base");
static_assert(offsetof(AHLLDispenserItem_Base, LastPlacementInfo) == 0x000220, "Member 'AHLLDispenserItem_Base::LastPlacementInfo' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, LastPlacementYaw) == 0x000258, "Member 'AHLLDispenserItem_Base::LastPlacementYaw' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, DummyRoot) == 0x000260, "Member 'AHLLDispenserItem_Base::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, GhostMesh) == 0x000268, "Member 'AHLLDispenserItem_Base::GhostMesh' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, PlacementGuard) == 0x000270, "Member 'AHLLDispenserItem_Base::PlacementGuard' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, GhostMaterial) == 0x000278, "Member 'AHLLDispenserItem_Base::GhostMaterial' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, GhostMeshDMI) == 0x000280, "Member 'AHLLDispenserItem_Base::GhostMeshDMI' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, GhostOwnerObject) == 0x000288, "Member 'AHLLDispenserItem_Base::GhostOwnerObject' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, ItemToDispense) == 0x000290, "Member 'AHLLDispenserItem_Base::ItemToDispense' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, MaxTotalDispensedItems) == 0x000299, "Member 'AHLLDispenserItem_Base::MaxTotalDispensedItems' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, MaxBuildDepthOverride) == 0x00029C, "Member 'AHLLDispenserItem_Base::MaxBuildDepthOverride' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, ScoreTypeWhenPlaced) == 0x0002A0, "Member 'AHLLDispenserItem_Base::ScoreTypeWhenPlaced' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, ScoreModifier) == 0x0002A8, "Member 'AHLLDispenserItem_Base::ScoreModifier' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, StatIncrementType) == 0x0002AC, "Member 'AHLLDispenserItem_Base::StatIncrementType' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, LockedEnemySectorRule) == 0x0002AE, "Member 'AHLLDispenserItem_Base::LockedEnemySectorRule' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, UnlockedEnemySectorRule) == 0x0002AF, "Member 'AHLLDispenserItem_Base::UnlockedEnemySectorRule' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, SupportedGameModes) == 0x0002B0, "Member 'AHLLDispenserItem_Base::SupportedGameModes' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, SurfaceRule) == 0x000300, "Member 'AHLLDispenserItem_Base::SurfaceRule' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, TraceDistance) == 0x000304, "Member 'AHLLDispenserItem_Base::TraceDistance' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, TraceHeight) == 0x000308, "Member 'AHLLDispenserItem_Base::TraceHeight' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, SurfaceErrorMargin) == 0x00030C, "Member 'AHLLDispenserItem_Base::SurfaceErrorMargin' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, DropTime) == 0x000310, "Member 'AHLLDispenserItem_Base::DropTime' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, MaxSurfaceAngle) == 0x000314, "Member 'AHLLDispenserItem_Base::MaxSurfaceAngle' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, FloorChannel) == 0x000318, "Member 'AHLLDispenserItem_Base::FloorChannel' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, SurfaceChannel) == 0x000319, "Member 'AHLLDispenserItem_Base::SurfaceChannel' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, SurfaceResponses) == 0x00031A, "Member 'AHLLDispenserItem_Base::SurfaceResponses' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, AttachWhitelist) == 0x000340, "Member 'AHLLDispenserItem_Base::AttachWhitelist' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, AttachBlacklist) == 0x000350, "Member 'AHLLDispenserItem_Base::AttachBlacklist' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, ItemName) == 0x000360, "Member 'AHLLDispenserItem_Base::ItemName' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, ItemBrush) == 0x000378, "Member 'AHLLDispenserItem_Base::ItemBrush' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, ListItemWidgetClass) == 0x000400, "Member 'AHLLDispenserItem_Base::ListItemWidgetClass' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, DispenseParticle) == 0x000408, "Member 'AHLLDispenserItem_Base::DispenseParticle' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, DispenseSound) == 0x000410, "Member 'AHLLDispenserItem_Base::DispenseSound' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, bCountsAsSmallItem) == 0x000418, "Member 'AHLLDispenserItem_Base::bCountsAsSmallItem' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, bCanAttachToArmour) == 0x000419, "Member 'AHLLDispenserItem_Base::bCanAttachToArmour' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, bUseComplexCollisionForPlacement) == 0x00041A, "Member 'AHLLDispenserItem_Base::bUseComplexCollisionForPlacement' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, InvalidPlacement_Generic) == 0x000420, "Member 'AHLLDispenserItem_Base::InvalidPlacement_Generic' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, InvalidPlacement_PlayerLocation) == 0x000438, "Member 'AHLLDispenserItem_Base::InvalidPlacement_PlayerLocation' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, InvalidPlacement_EnemySector) == 0x000450, "Member 'AHLLDispenserItem_Base::InvalidPlacement_EnemySector' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, InvalidPlacement_NeutralSector) == 0x000468, "Member 'AHLLDispenserItem_Base::InvalidPlacement_NeutralSector' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, InvalidPlacement_LockedSector) == 0x000480, "Member 'AHLLDispenserItem_Base::InvalidPlacement_LockedSector' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, InvalidPlacement_LockedBase) == 0x000498, "Member 'AHLLDispenserItem_Base::InvalidPlacement_LockedBase' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, InvalidPlacement_ReconOnly) == 0x0004B0, "Member 'AHLLDispenserItem_Base::InvalidPlacement_ReconOnly' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, InvalidPlacement_FriendlyBaseSector) == 0x0004C8, "Member 'AHLLDispenserItem_Base::InvalidPlacement_FriendlyBaseSector' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, AchievementStat) == 0x0004E1, "Member 'AHLLDispenserItem_Base::AchievementStat' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, IncrementAmount) == 0x0004E4, "Member 'AHLLDispenserItem_Base::IncrementAmount' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, HintWhenSelected) == 0x0004E8, "Member 'AHLLDispenserItem_Base::HintWhenSelected' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, MaxPerTeam) == 0x0004E9, "Member 'AHLLDispenserItem_Base::MaxPerTeam' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, SnapQueryComponent) == 0x000508, "Member 'AHLLDispenserItem_Base::SnapQueryComponent' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_Base, PerItemNetworkDataStruct) == 0x000510, "Member 'AHLLDispenserItem_Base::PerItemNetworkDataStruct' has a wrong offset!");

// Class HLL.HLLDispenserItem_StructureBase
// 0x0018 (0x0530 - 0x0518)
class AHLLDispenserItem_StructureBase : public AHLLDispenserItem_Base
{
public:
	int32                                         SuppliesCost;                                      // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDifferentCostInNonFriendlySector;                 // 0x051C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1144[0x3];                                     // 0x051D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         NonFriendlySectorSuppliesCost;                     // 0x0520(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1145[0xC];                                     // 0x0524(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_StructureBase">();
	}
	static class AHLLDispenserItem_StructureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_StructureBase>();
	}
};
static_assert(alignof(AHLLDispenserItem_StructureBase) == 0x000008, "Wrong alignment on AHLLDispenserItem_StructureBase");
static_assert(sizeof(AHLLDispenserItem_StructureBase) == 0x000530, "Wrong size on AHLLDispenserItem_StructureBase");
static_assert(offsetof(AHLLDispenserItem_StructureBase, SuppliesCost) == 0x000518, "Member 'AHLLDispenserItem_StructureBase::SuppliesCost' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_StructureBase, bDifferentCostInNonFriendlySector) == 0x00051C, "Member 'AHLLDispenserItem_StructureBase::bDifferentCostInNonFriendlySector' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_StructureBase, NonFriendlySectorSuppliesCost) == 0x000520, "Member 'AHLLDispenserItem_StructureBase::NonFriendlySectorSuppliesCost' has a wrong offset!");

// Class HLL.HLLDispenserItem_StructureAdv
// 0x0028 (0x0558 - 0x0530)
class AHLLDispenserItem_StructureAdv : public AHLLDispenserItem_StructureBase
{
public:
	int32                                         RequiredNearbyPlatoonMembers;                      // 0x0530(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1146[0x4];                                     // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<TSubclassOf<class AActor>>             DistanceCheckClasses;                              // 0x0538(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceToOther;                                // 0x0548(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAllowedEnemyDistance;                           // 0x054C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlatoonMemberDistance;                          // 0x0550(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1147[0x4];                                     // 0x0554(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_StructureAdv">();
	}
	static class AHLLDispenserItem_StructureAdv* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_StructureAdv>();
	}
};
static_assert(alignof(AHLLDispenserItem_StructureAdv) == 0x000008, "Wrong alignment on AHLLDispenserItem_StructureAdv");
static_assert(sizeof(AHLLDispenserItem_StructureAdv) == 0x000558, "Wrong size on AHLLDispenserItem_StructureAdv");
static_assert(offsetof(AHLLDispenserItem_StructureAdv, RequiredNearbyPlatoonMembers) == 0x000530, "Member 'AHLLDispenserItem_StructureAdv::RequiredNearbyPlatoonMembers' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_StructureAdv, DistanceCheckClasses) == 0x000538, "Member 'AHLLDispenserItem_StructureAdv::DistanceCheckClasses' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_StructureAdv, MinDistanceToOther) == 0x000548, "Member 'AHLLDispenserItem_StructureAdv::MinDistanceToOther' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_StructureAdv, MinAllowedEnemyDistance) == 0x00054C, "Member 'AHLLDispenserItem_StructureAdv::MinAllowedEnemyDistance' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_StructureAdv, MaxPlatoonMemberDistance) == 0x000550, "Member 'AHLLDispenserItem_StructureAdv::MaxPlatoonMemberDistance' has a wrong offset!");

// Class HLL.HLLDispenserItem_AntiTank
// 0x0000 (0x0558 - 0x0558)
class AHLLDispenserItem_AntiTank : public AHLLDispenserItem_StructureAdv
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_AntiTank">();
	}
	static class AHLLDispenserItem_AntiTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_AntiTank>();
	}
};
static_assert(alignof(AHLLDispenserItem_AntiTank) == 0x000008, "Wrong alignment on AHLLDispenserItem_AntiTank");
static_assert(sizeof(AHLLDispenserItem_AntiTank) == 0x000558, "Wrong size on AHLLDispenserItem_AntiTank");

// Class HLL.DropSuppliesProgressionAchievement
// 0x0008 (0x0038 - 0x0030)
class UDropSuppliesProgressionAchievement final : public UItemDispensedAchievement
{
public:
	EHLLAchievementStat                           AchievementStat;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1148[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropSuppliesProgressionAchievement">();
	}
	static class UDropSuppliesProgressionAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropSuppliesProgressionAchievement>();
	}
};
static_assert(alignof(UDropSuppliesProgressionAchievement) == 0x000008, "Wrong alignment on UDropSuppliesProgressionAchievement");
static_assert(sizeof(UDropSuppliesProgressionAchievement) == 0x000038, "Wrong size on UDropSuppliesProgressionAchievement");
static_assert(offsetof(UDropSuppliesProgressionAchievement, AchievementStat) == 0x000030, "Member 'UDropSuppliesProgressionAchievement::AchievementStat' has a wrong offset!");

// Class HLL.RCONCommandSetVoteKickThreshold
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetVoteKickThreshold final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetVoteKickThreshold">();
	}
	static class URCONCommandSetVoteKickThreshold* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetVoteKickThreshold>();
	}
};
static_assert(alignof(URCONCommandSetVoteKickThreshold) == 0x000008, "Wrong alignment on URCONCommandSetVoteKickThreshold");
static_assert(sizeof(URCONCommandSetVoteKickThreshold) == 0x000028, "Wrong size on URCONCommandSetVoteKickThreshold");

// Class HLL.DynamicSpawnInterface
// 0x0000 (0x0028 - 0x0028)
class IDynamicSpawnInterface final : public IInterface
{
public:
	float NextWaveTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicSpawnInterface">();
	}
	static class IDynamicSpawnInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicSpawnInterface>();
	}
};
static_assert(alignof(IDynamicSpawnInterface) == 0x000008, "Wrong alignment on IDynamicSpawnInterface");
static_assert(sizeof(IDynamicSpawnInterface) == 0x000028, "Wrong size on IDynamicSpawnInterface");

// Class HLL.HLLComboOption
// 0x0010 (0x0240 - 0x0230)
class UHLLComboOption : public UUserWidget
{
public:
	uint8                                         Pad_1149[0x10];                                    // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnHighlightEvent(bool bHighlighted);
	void SetParentComboBoxWidget(class UComboBoxString* InParentComboBox);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLComboOption">();
	}
	static class UHLLComboOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLComboOption>();
	}
};
static_assert(alignof(UHLLComboOption) == 0x000008, "Wrong alignment on UHLLComboOption");
static_assert(sizeof(UHLLComboOption) == 0x000240, "Wrong size on UHLLComboOption");

// Class HLL.RCONServerInfoMapSequence
// 0x0000 (0x0028 - 0x0028)
class URCONServerInfoMapSequence final : public URCONServerInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerInfoMapSequence">();
	}
	static class URCONServerInfoMapSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerInfoMapSequence>();
	}
};
static_assert(alignof(URCONServerInfoMapSequence) == 0x000008, "Wrong alignment on URCONServerInfoMapSequence");
static_assert(sizeof(URCONServerInfoMapSequence) == 0x000028, "Wrong size on URCONServerInfoMapSequence");

// Class HLL.EndMatchAchievementStat
// 0x0018 (0x0050 - 0x0038)
class UEndMatchAchievementStat final : public UEndMatchAchievement
{
public:
	EHLLAchievementStat                           AchievementStat;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114A[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<EGameModeType>                         SupportedGameModes;                                // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMatchAchievementStat">();
	}
	static class UEndMatchAchievementStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMatchAchievementStat>();
	}
};
static_assert(alignof(UEndMatchAchievementStat) == 0x000008, "Wrong alignment on UEndMatchAchievementStat");
static_assert(sizeof(UEndMatchAchievementStat) == 0x000050, "Wrong size on UEndMatchAchievementStat");
static_assert(offsetof(UEndMatchAchievementStat, AchievementStat) == 0x000038, "Member 'UEndMatchAchievementStat::AchievementStat' has a wrong offset!");
static_assert(offsetof(UEndMatchAchievementStat, SupportedGameModes) == 0x000040, "Member 'UEndMatchAchievementStat::SupportedGameModes' has a wrong offset!");

// Class HLL.EndMatchAchievementUnlock
// 0x0008 (0x0040 - 0x0038)
class UEndMatchAchievementUnlock final : public UEndMatchAchievement
{
public:
	EHLLAchievement                               Achievement;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114B[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMatchAchievementUnlock">();
	}
	static class UEndMatchAchievementUnlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMatchAchievementUnlock>();
	}
};
static_assert(alignof(UEndMatchAchievementUnlock) == 0x000008, "Wrong alignment on UEndMatchAchievementUnlock");
static_assert(sizeof(UEndMatchAchievementUnlock) == 0x000040, "Wrong size on UEndMatchAchievementUnlock");
static_assert(offsetof(UEndMatchAchievementUnlock, Achievement) == 0x000038, "Member 'UEndMatchAchievementUnlock::Achievement' has a wrong offset!");

// Class HLL.ResourceOverrideData
// 0x0008 (0x0038 - 0x0030)
class UResourceOverrideData final : public UDataAsset
{
public:
	bool                                          DisableMunitionsResource;                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableManpowerResource;                           // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableFuelResource;                               // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114C[0x5];                                     // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceOverrideData">();
	}
	static class UResourceOverrideData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResourceOverrideData>();
	}
};
static_assert(alignof(UResourceOverrideData) == 0x000008, "Wrong alignment on UResourceOverrideData");
static_assert(sizeof(UResourceOverrideData) == 0x000038, "Wrong size on UResourceOverrideData");
static_assert(offsetof(UResourceOverrideData, DisableMunitionsResource) == 0x000030, "Member 'UResourceOverrideData::DisableMunitionsResource' has a wrong offset!");
static_assert(offsetof(UResourceOverrideData, DisableManpowerResource) == 0x000031, "Member 'UResourceOverrideData::DisableManpowerResource' has a wrong offset!");
static_assert(offsetof(UResourceOverrideData, DisableFuelResource) == 0x000032, "Member 'UResourceOverrideData::DisableFuelResource' has a wrong offset!");

// Class HLL.EndMatchAsFactionAchievementUnlock
// 0x0008 (0x0040 - 0x0038)
class UEndMatchAsFactionAchievementUnlock final : public UEndMatchAchievement
{
public:
	EHLLAchievement                               Achievement;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFaction                                      FactionToWin;                                      // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114D[0x6];                                     // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMatchAsFactionAchievementUnlock">();
	}
	static class UEndMatchAsFactionAchievementUnlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMatchAsFactionAchievementUnlock>();
	}
};
static_assert(alignof(UEndMatchAsFactionAchievementUnlock) == 0x000008, "Wrong alignment on UEndMatchAsFactionAchievementUnlock");
static_assert(sizeof(UEndMatchAsFactionAchievementUnlock) == 0x000040, "Wrong size on UEndMatchAsFactionAchievementUnlock");
static_assert(offsetof(UEndMatchAsFactionAchievementUnlock, Achievement) == 0x000038, "Member 'UEndMatchAsFactionAchievementUnlock::Achievement' has a wrong offset!");
static_assert(offsetof(UEndMatchAsFactionAchievementUnlock, FactionToWin) == 0x000039, "Member 'UEndMatchAsFactionAchievementUnlock::FactionToWin' has a wrong offset!");

// Class HLL.EnterMatchAchievement
// 0x0008 (0x0038 - 0x0030)
class UEnterMatchAchievement final : public UGameStateEventAchievement
{
public:
	EHLLAchievement                               AchievementToUnlock;                               // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114E[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnterMatchAchievement">();
	}
	static class UEnterMatchAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnterMatchAchievement>();
	}
};
static_assert(alignof(UEnterMatchAchievement) == 0x000008, "Wrong alignment on UEnterMatchAchievement");
static_assert(sizeof(UEnterMatchAchievement) == 0x000038, "Wrong size on UEnterMatchAchievement");
static_assert(offsetof(UEnterMatchAchievement, AchievementToUnlock) == 0x000030, "Member 'UEnterMatchAchievement::AchievementToUnlock' has a wrong offset!");

// Class HLL.HLLCommanderUISubCategory
// 0x0028 (0x0258 - 0x0230)
class UHLLCommanderUISubCategory : public UUserWidget
{
public:
	class FText                                   SubCategoryTitle;                                  // 0x0230(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ItemVBox;                                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CategoryHeading;                                   // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_PostInit(const class FText& InSubCategoryTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderUISubCategory">();
	}
	static class UHLLCommanderUISubCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCommanderUISubCategory>();
	}
};
static_assert(alignof(UHLLCommanderUISubCategory) == 0x000008, "Wrong alignment on UHLLCommanderUISubCategory");
static_assert(sizeof(UHLLCommanderUISubCategory) == 0x000258, "Wrong size on UHLLCommanderUISubCategory");
static_assert(offsetof(UHLLCommanderUISubCategory, SubCategoryTitle) == 0x000230, "Member 'UHLLCommanderUISubCategory::SubCategoryTitle' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUISubCategory, ItemVBox) == 0x000248, "Member 'UHLLCommanderUISubCategory::ItemVBox' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUISubCategory, CategoryHeading) == 0x000250, "Member 'UHLLCommanderUISubCategory::CategoryHeading' has a wrong offset!");

// Class HLL.TankCommanderSeat
// 0x0020 (0x09F0 - 0x09D0)
class ATankCommanderSeat : public ATankSeatBase
{
public:
	class UStaticMeshComponent*                   InteriorMesh;                                      // 0x09D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USeatCameraController*                  CameraController;                                  // 0x09D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchMin;                                          // 0x09E0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchMax;                                          // 0x09E4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchRate;                                         // 0x09E8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawRate;                                           // 0x09EC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankCommanderSeat">();
	}
	static class ATankCommanderSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATankCommanderSeat>();
	}
};
static_assert(alignof(ATankCommanderSeat) == 0x000010, "Wrong alignment on ATankCommanderSeat");
static_assert(sizeof(ATankCommanderSeat) == 0x0009F0, "Wrong size on ATankCommanderSeat");
static_assert(offsetof(ATankCommanderSeat, InteriorMesh) == 0x0009D0, "Member 'ATankCommanderSeat::InteriorMesh' has a wrong offset!");
static_assert(offsetof(ATankCommanderSeat, CameraController) == 0x0009D8, "Member 'ATankCommanderSeat::CameraController' has a wrong offset!");
static_assert(offsetof(ATankCommanderSeat, PitchMin) == 0x0009E0, "Member 'ATankCommanderSeat::PitchMin' has a wrong offset!");
static_assert(offsetof(ATankCommanderSeat, PitchMax) == 0x0009E4, "Member 'ATankCommanderSeat::PitchMax' has a wrong offset!");
static_assert(offsetof(ATankCommanderSeat, PitchRate) == 0x0009E8, "Member 'ATankCommanderSeat::PitchRate' has a wrong offset!");
static_assert(offsetof(ATankCommanderSeat, YawRate) == 0x0009EC, "Member 'ATankCommanderSeat::YawRate' has a wrong offset!");

// Class HLL.EosNativeSession
// 0x0068 (0x0090 - 0x0028)
class UEosNativeSession final : public UObject
{
public:
	uint8                                         Pad_114F[0x68];                                    // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EosNativeSession">();
	}
	static class UEosNativeSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEosNativeSession>();
	}
};
static_assert(alignof(UEosNativeSession) == 0x000008, "Wrong alignment on UEosNativeSession");
static_assert(sizeof(UEosNativeSession) == 0x000090, "Wrong size on UEosNativeSession");

// Class HLL.EosPlatformSession
// 0x0068 (0x0090 - 0x0028)
class UEosPlatformSession final : public UObject
{
public:
	uint8                                         Pad_1150[0x68];                                    // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EosPlatformSession">();
	}
	static class UEosPlatformSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEosPlatformSession>();
	}
};
static_assert(alignof(UEosPlatformSession) == 0x000008, "Wrong alignment on UEosPlatformSession");
static_assert(sizeof(UEosPlatformSession) == 0x000090, "Wrong size on UEosPlatformSession");

// Class HLL.RCONServerInfoBannedWords
// 0x0000 (0x0028 - 0x0028)
class URCONServerInfoBannedWords final : public URCONServerInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerInfoBannedWords">();
	}
	static class URCONServerInfoBannedWords* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerInfoBannedWords>();
	}
};
static_assert(alignof(URCONServerInfoBannedWords) == 0x000008, "Wrong alignment on URCONServerInfoBannedWords");
static_assert(sizeof(URCONServerInfoBannedWords) == 0x000028, "Wrong size on URCONServerInfoBannedWords");

// Class HLL.EosUserSubsystem
// 0x0030 (0x0060 - 0x0030)
class UEosUserSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_1151[0x30];                                    // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EosUserSubsystem">();
	}
	static class UEosUserSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEosUserSubsystem>();
	}
};
static_assert(alignof(UEosUserSubsystem) == 0x000008, "Wrong alignment on UEosUserSubsystem");
static_assert(sizeof(UEosUserSubsystem) == 0x000060, "Wrong size on UEosUserSubsystem");

// Class HLL.ErrorReportingSubsystem
// 0x0010 (0x0040 - 0x0030)
class UErrorReportingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_1152[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ErrorReportingSubsystem">();
	}
	static class UErrorReportingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UErrorReportingSubsystem>();
	}
};
static_assert(alignof(UErrorReportingSubsystem) == 0x000008, "Wrong alignment on UErrorReportingSubsystem");
static_assert(sizeof(UErrorReportingSubsystem) == 0x000040, "Wrong size on UErrorReportingSubsystem");

// Class HLL.HLLNameplateIndicatorBase
// 0x0010 (0x02C0 - 0x02B0)
class UHLLNameplateIndicatorBase : public UHLLIndicatorBase
{
public:
	uint8                                         bLimitViewDistanceWhenLaserTagged : 1;             // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOnlyShowWhenLaserTagged : 1;                      // 0x02B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1153[0xF];                                     // 0x02B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLNameplateIndicatorBase">();
	}
	static class UHLLNameplateIndicatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLNameplateIndicatorBase>();
	}
};
static_assert(alignof(UHLLNameplateIndicatorBase) == 0x000008, "Wrong alignment on UHLLNameplateIndicatorBase");
static_assert(sizeof(UHLLNameplateIndicatorBase) == 0x0002C0, "Wrong size on UHLLNameplateIndicatorBase");

// Class HLL.HLLDismantleDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLDismantleDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDismantleDamage">();
	}
	static class UHLLDismantleDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDismantleDamage>();
	}
};
static_assert(alignof(UHLLDismantleDamage) == 0x000008, "Wrong alignment on UHLLDismantleDamage");
static_assert(sizeof(UHLLDismantleDamage) == 0x0001E8, "Wrong size on UHLLDismantleDamage");

// Class HLL.HLLDialogBox
// 0x00F0 (0x0320 - 0x0230)
class UHLLDialogBox : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OptionSelected;                                    // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1154[0x18];                                    // 0x0240(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         CurrentPriority;                                   // 0x0258(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1155[0x4];                                     // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             TitleText;                                         // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             BodyText;                                          // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           CustomContent;                                     // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ButtonsPerRow;                                     // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1156[0x4];                                     // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLDialogButton*>               Buttons;                                           // 0x0280(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUniformGridPanel*                      ButtonPanel;                                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1157[0x18];                                    // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UInputComponent*                        PopupInput;                                        // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockGameInput;                                   // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceSetFocusWhenBlockingInput;                   // 0x02B9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1158[0x2];                                     // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   OptionOneInputAction;                              // 0x02BC(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OptionTwoInputAction;                              // 0x02C4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OptionThreeInputAction;                            // 0x02CC(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1159[0x4];                                     // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_115A[0x40];                                    // 0x02E0(0x0040)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UHLLDialogBox* CreateDialogBox(class ULocalPlayer* ContextPlayer, const class FText& InTitle, const class FText& InBodyText, const TArray<class FText>& Options, int32 DialogPriority, bool bAddToViewport);
	static class UHLLDialogBox* GetActiveDialogBox();

	void Close(bool bClearDialogResponses);
	void DialogResponse__DelegateSignature(const int32 SelectedOption);
	class UUniformGridPanel* GetButtonPanel();
	void InputChanged(bool NewValue);
	void OnOptionSelected(const int32 Option);
	void OnUpdatePrompts();
	void OptionOnePressed();
	void OptionThreePressed();
	void OptionTwoPressed();
	void SetForceFocusWhenBlockingInput(bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDialogBox">();
	}
	static class UHLLDialogBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDialogBox>();
	}
};
static_assert(alignof(UHLLDialogBox) == 0x000008, "Wrong alignment on UHLLDialogBox");
static_assert(sizeof(UHLLDialogBox) == 0x000320, "Wrong size on UHLLDialogBox");
static_assert(offsetof(UHLLDialogBox, OptionSelected) == 0x000230, "Member 'UHLLDialogBox::OptionSelected' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, CurrentPriority) == 0x000258, "Member 'UHLLDialogBox::CurrentPriority' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, TitleText) == 0x000260, "Member 'UHLLDialogBox::TitleText' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, BodyText) == 0x000268, "Member 'UHLLDialogBox::BodyText' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, CustomContent) == 0x000270, "Member 'UHLLDialogBox::CustomContent' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, ButtonsPerRow) == 0x000278, "Member 'UHLLDialogBox::ButtonsPerRow' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, Buttons) == 0x000280, "Member 'UHLLDialogBox::Buttons' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, ButtonPanel) == 0x000290, "Member 'UHLLDialogBox::ButtonPanel' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, PopupInput) == 0x0002B0, "Member 'UHLLDialogBox::PopupInput' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, bBlockGameInput) == 0x0002B8, "Member 'UHLLDialogBox::bBlockGameInput' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, bForceSetFocusWhenBlockingInput) == 0x0002B9, "Member 'UHLLDialogBox::bForceSetFocusWhenBlockingInput' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, OptionOneInputAction) == 0x0002BC, "Member 'UHLLDialogBox::OptionOneInputAction' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, OptionTwoInputAction) == 0x0002C4, "Member 'UHLLDialogBox::OptionTwoInputAction' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, OptionThreeInputAction) == 0x0002CC, "Member 'UHLLDialogBox::OptionThreeInputAction' has a wrong offset!");
static_assert(offsetof(UHLLDialogBox, ViewportClient) == 0x0002D8, "Member 'UHLLDialogBox::ViewportClient' has a wrong offset!");

// Class HLL.HLLCharacterCapsule
// 0x0000 (0x0420 - 0x0420)
class UHLLCharacterCapsule final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCharacterCapsule">();
	}
	static class UHLLCharacterCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCharacterCapsule>();
	}
};
static_assert(alignof(UHLLCharacterCapsule) == 0x000010, "Wrong alignment on UHLLCharacterCapsule");
static_assert(sizeof(UHLLCharacterCapsule) == 0x000420, "Wrong size on UHLLCharacterCapsule");

// Class HLL.EULAWidget
// 0x0008 (0x0328 - 0x0320)
class UEULAWidget : public UHLLDialogBox
{
public:
	int32                                         M_Version;                                         // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_115C[0x4];                                     // 0x0324(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EULAWidget">();
	}
	static class UEULAWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEULAWidget>();
	}
};
static_assert(alignof(UEULAWidget) == 0x000008, "Wrong alignment on UEULAWidget");
static_assert(sizeof(UEULAWidget) == 0x000328, "Wrong size on UEULAWidget");
static_assert(offsetof(UEULAWidget, M_Version) == 0x000320, "Member 'UEULAWidget::M_Version' has a wrong offset!");

// Class HLL.SeedingControlPointHUD
// 0x0028 (0x0258 - 0x0230)
class USeedingControlPointHUD : public UUserWidget
{
public:
	class ASeedingControlPoint*                   ControlPoint;                                      // 0x0230(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ControlPointName;                                  // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           FriendlyCaptureProgress;                           // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           EnemyCaptureProgress;                              // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundColour;                                  // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleControlPointEnter();
	void HandleControlPointExit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeedingControlPointHUD">();
	}
	static class USeedingControlPointHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeedingControlPointHUD>();
	}
};
static_assert(alignof(USeedingControlPointHUD) == 0x000008, "Wrong alignment on USeedingControlPointHUD");
static_assert(sizeof(USeedingControlPointHUD) == 0x000258, "Wrong size on USeedingControlPointHUD");
static_assert(offsetof(USeedingControlPointHUD, ControlPoint) == 0x000230, "Member 'USeedingControlPointHUD::ControlPoint' has a wrong offset!");
static_assert(offsetof(USeedingControlPointHUD, ControlPointName) == 0x000238, "Member 'USeedingControlPointHUD::ControlPointName' has a wrong offset!");
static_assert(offsetof(USeedingControlPointHUD, FriendlyCaptureProgress) == 0x000240, "Member 'USeedingControlPointHUD::FriendlyCaptureProgress' has a wrong offset!");
static_assert(offsetof(USeedingControlPointHUD, EnemyCaptureProgress) == 0x000248, "Member 'USeedingControlPointHUD::EnemyCaptureProgress' has a wrong offset!");
static_assert(offsetof(USeedingControlPointHUD, BackgroundColour) == 0x000250, "Member 'USeedingControlPointHUD::BackgroundColour' has a wrong offset!");

// Class HLL.ExplorerMapButtonWidget
// 0x0090 (0x02C0 - 0x0230)
class UExplorerMapButtonWidget : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnExplorerButtonClicked;                           // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExplorerButtonHovered;                           // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExplorerButtonUnhovered;                         // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTextBlock*                             MapNameText;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMapExplorerData                       MapExplorerData;                                   // 0x0268(0x0058)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnButtonClickedBroadcast() const;
	void OnButtonHoveredBroadcast() const;
	void OnButtonUnhoveredBroadcast() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplorerMapButtonWidget">();
	}
	static class UExplorerMapButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplorerMapButtonWidget>();
	}
};
static_assert(alignof(UExplorerMapButtonWidget) == 0x000008, "Wrong alignment on UExplorerMapButtonWidget");
static_assert(sizeof(UExplorerMapButtonWidget) == 0x0002C0, "Wrong size on UExplorerMapButtonWidget");
static_assert(offsetof(UExplorerMapButtonWidget, OnExplorerButtonClicked) == 0x000230, "Member 'UExplorerMapButtonWidget::OnExplorerButtonClicked' has a wrong offset!");
static_assert(offsetof(UExplorerMapButtonWidget, OnExplorerButtonHovered) == 0x000240, "Member 'UExplorerMapButtonWidget::OnExplorerButtonHovered' has a wrong offset!");
static_assert(offsetof(UExplorerMapButtonWidget, OnExplorerButtonUnhovered) == 0x000250, "Member 'UExplorerMapButtonWidget::OnExplorerButtonUnhovered' has a wrong offset!");
static_assert(offsetof(UExplorerMapButtonWidget, MapNameText) == 0x000260, "Member 'UExplorerMapButtonWidget::MapNameText' has a wrong offset!");
static_assert(offsetof(UExplorerMapButtonWidget, MapExplorerData) == 0x000268, "Member 'UExplorerMapButtonWidget::MapExplorerData' has a wrong offset!");

// Class HLL.ExplorerMenuUIWidget
// 0x0088 (0x02B8 - 0x0230)
class UExplorerMenuUIWidget : public UUserWidget
{
public:
	int32                                         MaxGridColumns;                                    // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_115D[0x4];                                     // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UExplorerMapButtonWidget>   ExplorerMapButtonClass;                            // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      ExplorerMapGridPanel;                              // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MapNameTextBlock;                                  // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ExplorerInfoImage;                                 // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        ExplorerDetailsSwitcher;                           // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMapExplorerData                       SelectedMapData;                                   // 0x0260(0x0058)(NativeAccessSpecifierPrivate)

public:
	void OnExplorerMapButtonClicked(const struct FMapExplorerData& ExplorerData);
	void OnExplorerMapButtonHovered(const struct FMapExplorerData& ExplorerData);
	void OnExplorerMapButtonUnhovered(const struct FMapExplorerData& ExplorerData);

	class UWidget* GetFirstGridChild() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplorerMenuUIWidget">();
	}
	static class UExplorerMenuUIWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplorerMenuUIWidget>();
	}
};
static_assert(alignof(UExplorerMenuUIWidget) == 0x000008, "Wrong alignment on UExplorerMenuUIWidget");
static_assert(sizeof(UExplorerMenuUIWidget) == 0x0002B8, "Wrong size on UExplorerMenuUIWidget");
static_assert(offsetof(UExplorerMenuUIWidget, MaxGridColumns) == 0x000230, "Member 'UExplorerMenuUIWidget::MaxGridColumns' has a wrong offset!");
static_assert(offsetof(UExplorerMenuUIWidget, ExplorerMapButtonClass) == 0x000238, "Member 'UExplorerMenuUIWidget::ExplorerMapButtonClass' has a wrong offset!");
static_assert(offsetof(UExplorerMenuUIWidget, ExplorerMapGridPanel) == 0x000240, "Member 'UExplorerMenuUIWidget::ExplorerMapGridPanel' has a wrong offset!");
static_assert(offsetof(UExplorerMenuUIWidget, MapNameTextBlock) == 0x000248, "Member 'UExplorerMenuUIWidget::MapNameTextBlock' has a wrong offset!");
static_assert(offsetof(UExplorerMenuUIWidget, ExplorerInfoImage) == 0x000250, "Member 'UExplorerMenuUIWidget::ExplorerInfoImage' has a wrong offset!");
static_assert(offsetof(UExplorerMenuUIWidget, ExplorerDetailsSwitcher) == 0x000258, "Member 'UExplorerMenuUIWidget::ExplorerDetailsSwitcher' has a wrong offset!");
static_assert(offsetof(UExplorerMenuUIWidget, SelectedMapData) == 0x000260, "Member 'UExplorerMenuUIWidget::SelectedMapData' has a wrong offset!");

// Class HLL.HLLInGameMenu
// 0x0030 (0x0260 - 0x0230)
class UHLLInGameMenu : public UUserWidget
{
public:
	uint8                                         Pad_115E[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetAnimation*                       OpenAnim;                                          // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CloseAnim;                                         // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        OptionSwitcher;                                    // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLOptionScreenBase*                   OptionsScreen;                                     // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InputChanged(bool NewValue);
	void OnCancel();
	void OnClose();
	void OnFieldManual(bool bWantsVisible);
	void OnOpen();
	void OnOptions(bool bWantsVisible);
	void OnPressBack();
	void OnPressLeaveServer();
	void OnPressQuitGame();
	void OnPressSuicide();
	void OnSuicideDialogConfirm(const int32 OptionIndex);
	void OnUpdatePrompts();

	bool IsSuicideEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLInGameMenu">();
	}
	static class UHLLInGameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLInGameMenu>();
	}
};
static_assert(alignof(UHLLInGameMenu) == 0x000008, "Wrong alignment on UHLLInGameMenu");
static_assert(sizeof(UHLLInGameMenu) == 0x000260, "Wrong size on UHLLInGameMenu");
static_assert(offsetof(UHLLInGameMenu, OpenAnim) == 0x000238, "Member 'UHLLInGameMenu::OpenAnim' has a wrong offset!");
static_assert(offsetof(UHLLInGameMenu, CloseAnim) == 0x000240, "Member 'UHLLInGameMenu::CloseAnim' has a wrong offset!");
static_assert(offsetof(UHLLInGameMenu, OptionSwitcher) == 0x000248, "Member 'UHLLInGameMenu::OptionSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLInGameMenu, OptionsScreen) == 0x000250, "Member 'UHLLInGameMenu::OptionsScreen' has a wrong offset!");
static_assert(offsetof(UHLLInGameMenu, ViewportClient) == 0x000258, "Member 'UHLLInGameMenu::ViewportClient' has a wrong offset!");

// Class HLL.ScenarioMetaDataAsset
// 0x0078 (0x00A8 - 0x0030)
class UScenarioMetaDataAsset final : public UDataAsset
{
public:
	class FString                                 ScenarioKey;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameModeMetaDataAsset*                 GameModeMetaDataAsset;                             // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapVariantMetaDataAsset*               VariantMetaDataAsset;                              // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLWeatherManagerData*                 WeatherManagerData;                                // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              MapScenarioAmbientSound;                           // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideMapId;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_115F[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 OverridenMapId;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideMapFriendlyName;                          // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1160[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   OverridenMapFriendlyName;                          // 0x0080(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideAchievementStat;                          // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLAchievementStat                           OverridenAchievementStat;                          // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideMapSpecificAchievements;                  // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1161[0x5];                                     // 0x009B(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UMapSpecificAchievements*               OverridenMapSpecificAchievements;                  // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioMetaDataAsset">();
	}
	static class UScenarioMetaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioMetaDataAsset>();
	}
};
static_assert(alignof(UScenarioMetaDataAsset) == 0x000008, "Wrong alignment on UScenarioMetaDataAsset");
static_assert(sizeof(UScenarioMetaDataAsset) == 0x0000A8, "Wrong size on UScenarioMetaDataAsset");
static_assert(offsetof(UScenarioMetaDataAsset, ScenarioKey) == 0x000030, "Member 'UScenarioMetaDataAsset::ScenarioKey' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, GameModeMetaDataAsset) == 0x000040, "Member 'UScenarioMetaDataAsset::GameModeMetaDataAsset' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, VariantMetaDataAsset) == 0x000048, "Member 'UScenarioMetaDataAsset::VariantMetaDataAsset' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, WeatherManagerData) == 0x000050, "Member 'UScenarioMetaDataAsset::WeatherManagerData' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, MapScenarioAmbientSound) == 0x000058, "Member 'UScenarioMetaDataAsset::MapScenarioAmbientSound' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, bOverrideMapId) == 0x000060, "Member 'UScenarioMetaDataAsset::bOverrideMapId' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, OverridenMapId) == 0x000068, "Member 'UScenarioMetaDataAsset::OverridenMapId' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, bOverrideMapFriendlyName) == 0x000078, "Member 'UScenarioMetaDataAsset::bOverrideMapFriendlyName' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, OverridenMapFriendlyName) == 0x000080, "Member 'UScenarioMetaDataAsset::OverridenMapFriendlyName' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, bOverrideAchievementStat) == 0x000098, "Member 'UScenarioMetaDataAsset::bOverrideAchievementStat' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, OverridenAchievementStat) == 0x000099, "Member 'UScenarioMetaDataAsset::OverridenAchievementStat' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, bOverrideMapSpecificAchievements) == 0x00009A, "Member 'UScenarioMetaDataAsset::bOverrideMapSpecificAchievements' has a wrong offset!");
static_assert(offsetof(UScenarioMetaDataAsset, OverridenMapSpecificAchievements) == 0x0000A0, "Member 'UScenarioMetaDataAsset::OverridenMapSpecificAchievements' has a wrong offset!");

// Class HLL.FaceAnimComponent
// 0x0030 (0x00E0 - 0x00B0)
class UFaceAnimComponent final : public UActorComponent
{
public:
	float                                         DelayAnimEnabling;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         LookAtPlayerDuration;                              // 0x00B4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         LookAwayPlayerDuration;                            // 0x00BC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1162[0x1C];                                    // 0x00C4(0x001C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaceAnimComponent">();
	}
	static class UFaceAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFaceAnimComponent>();
	}
};
static_assert(alignof(UFaceAnimComponent) == 0x000008, "Wrong alignment on UFaceAnimComponent");
static_assert(sizeof(UFaceAnimComponent) == 0x0000E0, "Wrong size on UFaceAnimComponent");
static_assert(offsetof(UFaceAnimComponent, DelayAnimEnabling) == 0x0000B0, "Member 'UFaceAnimComponent::DelayAnimEnabling' has a wrong offset!");
static_assert(offsetof(UFaceAnimComponent, LookAtPlayerDuration) == 0x0000B4, "Member 'UFaceAnimComponent::LookAtPlayerDuration' has a wrong offset!");
static_assert(offsetof(UFaceAnimComponent, LookAwayPlayerDuration) == 0x0000BC, "Member 'UFaceAnimComponent::LookAwayPlayerDuration' has a wrong offset!");

// Class HLL.HLLBallisticsComponent
// 0x00E0 (0x0190 - 0x00B0)
class UHLLBallisticsComponent : public UActorComponent
{
public:
	class UHLLProjectile*                         ProjectileClass;                                   // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ProjectileParticleInterval;                        // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1163[0x87];                                    // 0x00B9(0x0087)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bPendingNulls;                                     // 0x0140(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPendingHits;                                      // 0x0141(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1164[0x6];                                     // 0x0142(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FBallisticBatchedNulls                 PendingBatchedNulls;                               // 0x0148(0x0010)(Transient, NativeAccessSpecifierPrivate)
	struct FBallisticBatchedHits                  PendingBatchedHits;                                // 0x0158(0x0020)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1165[0x18];                                    // 0x0178(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBallisticsComponent">();
	}
	static class UHLLBallisticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLBallisticsComponent>();
	}
};
static_assert(alignof(UHLLBallisticsComponent) == 0x000008, "Wrong alignment on UHLLBallisticsComponent");
static_assert(sizeof(UHLLBallisticsComponent) == 0x000190, "Wrong size on UHLLBallisticsComponent");
static_assert(offsetof(UHLLBallisticsComponent, ProjectileClass) == 0x0000B0, "Member 'UHLLBallisticsComponent::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UHLLBallisticsComponent, ProjectileParticleInterval) == 0x0000B8, "Member 'UHLLBallisticsComponent::ProjectileParticleInterval' has a wrong offset!");
static_assert(offsetof(UHLLBallisticsComponent, bPendingNulls) == 0x000140, "Member 'UHLLBallisticsComponent::bPendingNulls' has a wrong offset!");
static_assert(offsetof(UHLLBallisticsComponent, bPendingHits) == 0x000141, "Member 'UHLLBallisticsComponent::bPendingHits' has a wrong offset!");
static_assert(offsetof(UHLLBallisticsComponent, PendingBatchedNulls) == 0x000148, "Member 'UHLLBallisticsComponent::PendingBatchedNulls' has a wrong offset!");
static_assert(offsetof(UHLLBallisticsComponent, PendingBatchedHits) == 0x000158, "Member 'UHLLBallisticsComponent::PendingBatchedHits' has a wrong offset!");

// Class HLL.HLLBallisticsComponent_Character
// 0x0000 (0x0190 - 0x0190)
class UHLLBallisticsComponent_Character final : public UHLLBallisticsComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBallisticsComponent_Character">();
	}
	static class UHLLBallisticsComponent_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLBallisticsComponent_Character>();
	}
};
static_assert(alignof(UHLLBallisticsComponent_Character) == 0x000008, "Wrong alignment on UHLLBallisticsComponent_Character");
static_assert(sizeof(UHLLBallisticsComponent_Character) == 0x000190, "Wrong size on UHLLBallisticsComponent_Character");

// Class HLL.FireGrenadeFragment
// 0x0030 (0x0250 - 0x0220)
class AFireGrenadeFragment final : public AActor
{
public:
	float                                         FadingDuration;                                    // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialDelay;                                      // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AFireSpot>                  FireSpotClass;                                     // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       VolumeComponent;                                   // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1166[0x10];                                    // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireGrenadeFragment">();
	}
	static class AFireGrenadeFragment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFireGrenadeFragment>();
	}
};
static_assert(alignof(AFireGrenadeFragment) == 0x000008, "Wrong alignment on AFireGrenadeFragment");
static_assert(sizeof(AFireGrenadeFragment) == 0x000250, "Wrong size on AFireGrenadeFragment");
static_assert(offsetof(AFireGrenadeFragment, FadingDuration) == 0x000220, "Member 'AFireGrenadeFragment::FadingDuration' has a wrong offset!");
static_assert(offsetof(AFireGrenadeFragment, InitialDelay) == 0x000224, "Member 'AFireGrenadeFragment::InitialDelay' has a wrong offset!");
static_assert(offsetof(AFireGrenadeFragment, FireSpotClass) == 0x000228, "Member 'AFireGrenadeFragment::FireSpotClass' has a wrong offset!");
static_assert(offsetof(AFireGrenadeFragment, VolumeComponent) == 0x000230, "Member 'AFireGrenadeFragment::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AFireGrenadeFragment, ParticleSystemComponent) == 0x000238, "Member 'AFireGrenadeFragment::ParticleSystemComponent' has a wrong offset!");

// Class HLL.HLLKilledBySeatDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLKilledBySeatDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLKilledBySeatDamage">();
	}
	static class UHLLKilledBySeatDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLKilledBySeatDamage>();
	}
};
static_assert(alignof(UHLLKilledBySeatDamage) == 0x000008, "Wrong alignment on UHLLKilledBySeatDamage");
static_assert(sizeof(UHLLKilledBySeatDamage) == 0x0001E8, "Wrong size on UHLLKilledBySeatDamage");

// Class HLL.GrenadeProjectile
// 0x00B8 (0x02D8 - 0x0220)
class AGrenadeProjectile : public AActor
{
public:
	uint8                                         Pad_1167[0x10];                                    // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        Audio;                                             // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       ExplosionEffectClass;                              // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       BounceEffectClass;                                 // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactMinVeloc;                                    // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenImpactFX;                            // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplodeWithCollision;                             // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1168[0x3];                                     // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ExplosionDelay;                                    // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExplosionDamage;                                   // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionFalloff;                                  // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionRadius;                                   // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionSuppression;                              // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionSuppressionRadius;                        // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionSuppressionFalloff;                       // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeSpanAfterExplosion;                            // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowStopServerTick;                              // 0x0284(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartAudioOnRelease;                              // 0x0285(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DisableGrenadeCollisionOnRelease;                  // 0x0286(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1169[0x9];                                     // 0x0287(0x0009)(Fixing Size After Last Property [ Dumper-69 ])
	class AController*                            ExplosionInstigator;                               // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_116A[0x9];                                     // 0x0298(0x0009)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bExploded : 1;                                     // 0x02A1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_116B[0x2];                                     // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                ReleaseLocation;                                   // 0x02A4(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116C[0x10];                                    // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	ETeam                                         OwningTeam;                                        // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_116D[0x7];                                     // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 DamageSourceName;                                  // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMeshImpact(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_Exploded();
	void OnRep_ReleaseLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeProjectile">();
	}
	static class AGrenadeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenadeProjectile>();
	}
};
static_assert(alignof(AGrenadeProjectile) == 0x000008, "Wrong alignment on AGrenadeProjectile");
static_assert(sizeof(AGrenadeProjectile) == 0x0002D8, "Wrong size on AGrenadeProjectile");
static_assert(offsetof(AGrenadeProjectile, Mesh) == 0x000230, "Member 'AGrenadeProjectile::Mesh' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, Audio) == 0x000238, "Member 'AGrenadeProjectile::Audio' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionEffectClass) == 0x000240, "Member 'AGrenadeProjectile::ExplosionEffectClass' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, BounceEffectClass) == 0x000248, "Member 'AGrenadeProjectile::BounceEffectClass' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ImpactMinVeloc) == 0x000250, "Member 'AGrenadeProjectile::ImpactMinVeloc' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, MinTimeBetweenImpactFX) == 0x000254, "Member 'AGrenadeProjectile::MinTimeBetweenImpactFX' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, bExplodeWithCollision) == 0x000258, "Member 'AGrenadeProjectile::bExplodeWithCollision' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionDelay) == 0x00025C, "Member 'AGrenadeProjectile::ExplosionDelay' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionDamage) == 0x000260, "Member 'AGrenadeProjectile::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionFalloff) == 0x000264, "Member 'AGrenadeProjectile::ExplosionFalloff' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionRadius) == 0x000268, "Member 'AGrenadeProjectile::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionSuppression) == 0x00026C, "Member 'AGrenadeProjectile::ExplosionSuppression' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionSuppressionRadius) == 0x000270, "Member 'AGrenadeProjectile::ExplosionSuppressionRadius' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionSuppressionFalloff) == 0x000274, "Member 'AGrenadeProjectile::ExplosionSuppressionFalloff' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DamageType) == 0x000278, "Member 'AGrenadeProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, LifeSpanAfterExplosion) == 0x000280, "Member 'AGrenadeProjectile::LifeSpanAfterExplosion' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, bAllowStopServerTick) == 0x000284, "Member 'AGrenadeProjectile::bAllowStopServerTick' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, bStartAudioOnRelease) == 0x000285, "Member 'AGrenadeProjectile::bStartAudioOnRelease' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DisableGrenadeCollisionOnRelease) == 0x000286, "Member 'AGrenadeProjectile::DisableGrenadeCollisionOnRelease' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ExplosionInstigator) == 0x000290, "Member 'AGrenadeProjectile::ExplosionInstigator' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ReleaseLocation) == 0x0002A4, "Member 'AGrenadeProjectile::ReleaseLocation' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, OwningTeam) == 0x0002C0, "Member 'AGrenadeProjectile::OwningTeam' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DamageSourceName) == 0x0002C8, "Member 'AGrenadeProjectile::DamageSourceName' has a wrong offset!");

// Class HLL.FireGrenadeProjectile
// 0x0040 (0x0318 - 0x02D8)
class AFireGrenadeProjectile final : public AGrenadeProjectile
{
public:
	int32                                         FragmentsCount;                                    // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FragmentsSpreadAngle;                              // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceSphereRadius;                                 // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceSphereOffset;                                 // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EObjectTypeQuery>                      FlameQueryChannels;                                // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AFireGrenadeFragment>       FragmentClass;                                     // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AFireSpot>                  FireSpotClass;                                     // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UShooterDamageType>         DirectHitDamageClass;                              // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectHitDamageAmount;                             // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116F[0x4];                                     // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireGrenadeProjectile">();
	}
	static class AFireGrenadeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFireGrenadeProjectile>();
	}
};
static_assert(alignof(AFireGrenadeProjectile) == 0x000008, "Wrong alignment on AFireGrenadeProjectile");
static_assert(sizeof(AFireGrenadeProjectile) == 0x000318, "Wrong size on AFireGrenadeProjectile");
static_assert(offsetof(AFireGrenadeProjectile, FragmentsCount) == 0x0002D8, "Member 'AFireGrenadeProjectile::FragmentsCount' has a wrong offset!");
static_assert(offsetof(AFireGrenadeProjectile, FragmentsSpreadAngle) == 0x0002DC, "Member 'AFireGrenadeProjectile::FragmentsSpreadAngle' has a wrong offset!");
static_assert(offsetof(AFireGrenadeProjectile, TraceSphereRadius) == 0x0002E0, "Member 'AFireGrenadeProjectile::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(AFireGrenadeProjectile, TraceSphereOffset) == 0x0002E4, "Member 'AFireGrenadeProjectile::TraceSphereOffset' has a wrong offset!");
static_assert(offsetof(AFireGrenadeProjectile, FlameQueryChannels) == 0x0002E8, "Member 'AFireGrenadeProjectile::FlameQueryChannels' has a wrong offset!");
static_assert(offsetof(AFireGrenadeProjectile, FragmentClass) == 0x0002F8, "Member 'AFireGrenadeProjectile::FragmentClass' has a wrong offset!");
static_assert(offsetof(AFireGrenadeProjectile, FireSpotClass) == 0x000300, "Member 'AFireGrenadeProjectile::FireSpotClass' has a wrong offset!");
static_assert(offsetof(AFireGrenadeProjectile, DirectHitDamageClass) == 0x000308, "Member 'AFireGrenadeProjectile::DirectHitDamageClass' has a wrong offset!");
static_assert(offsetof(AFireGrenadeProjectile, DirectHitDamageAmount) == 0x000310, "Member 'AFireGrenadeProjectile::DirectHitDamageAmount' has a wrong offset!");

// Class HLL.ShooterGameModePlatformComponent
// 0x0000 (0x00B0 - 0x00B0)
class UShooterGameModePlatformComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameModePlatformComponent">();
	}
	static class UShooterGameModePlatformComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameModePlatformComponent>();
	}
};
static_assert(alignof(UShooterGameModePlatformComponent) == 0x000008, "Wrong alignment on UShooterGameModePlatformComponent");
static_assert(sizeof(UShooterGameModePlatformComponent) == 0x0000B0, "Wrong size on UShooterGameModePlatformComponent");

// Class HLL.FireSpot
// 0x00B0 (0x02D0 - 0x0220)
class AFireSpot : public AActor
{
public:
	uint8                                         Pad_1170[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class USphereComponent*                       VolumeComponent;                                   // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParticleSystem;                                    // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        BurnDecal;                                         // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FireSpotDuration;                                  // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRate;                                        // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UShooterDamageType>         DamageTypeClass;                                   // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1171[0x8];                                     // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<class UBurningComponent*>                OverlappedBurners;                                 // 0x0268(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FString                                 DefaultDamageSourceName;                           // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x02C8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1172[0x7];                                     // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void IgniteFireSpot_Multicast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireSpot">();
	}
	static class AFireSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFireSpot>();
	}
};
static_assert(alignof(AFireSpot) == 0x000008, "Wrong alignment on AFireSpot");
static_assert(sizeof(AFireSpot) == 0x0002D0, "Wrong size on AFireSpot");
static_assert(offsetof(AFireSpot, VolumeComponent) == 0x000238, "Member 'AFireSpot::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AFireSpot, ParticleSystem) == 0x000240, "Member 'AFireSpot::ParticleSystem' has a wrong offset!");
static_assert(offsetof(AFireSpot, BurnDecal) == 0x000248, "Member 'AFireSpot::BurnDecal' has a wrong offset!");
static_assert(offsetof(AFireSpot, FireSpotDuration) == 0x000250, "Member 'AFireSpot::FireSpotDuration' has a wrong offset!");
static_assert(offsetof(AFireSpot, DamageRate) == 0x000254, "Member 'AFireSpot::DamageRate' has a wrong offset!");
static_assert(offsetof(AFireSpot, DamageTypeClass) == 0x000258, "Member 'AFireSpot::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(AFireSpot, OverlappedBurners) == 0x000268, "Member 'AFireSpot::OverlappedBurners' has a wrong offset!");
static_assert(offsetof(AFireSpot, DefaultDamageSourceName) == 0x0002B8, "Member 'AFireSpot::DefaultDamageSourceName' has a wrong offset!");
static_assert(offsetof(AFireSpot, Team) == 0x0002C8, "Member 'AFireSpot::Team' has a wrong offset!");

// Class HLL.HLLConsoleUIManager
// 0x0158 (0x0180 - 0x0028)
class UHLLConsoleUIManager : public UObject
{
public:
	uint8                                         Pad_1173[0x108];                                   // 0x0028(0x0108)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UEULAWidget>                EulaDialogueWidgetClass;                           // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHLLSplashScreen>           WelcomeScreenWidgetClass;                          // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEULAWidget*                            EULAWidget;                                        // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSplashScreen*                       WelcomeScreenWidget;                               // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNotificationWidget>        NotificationWidgetClass;                           // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHLLUI_NetworkNotifications> NetworkNotificationsClass;                         // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNotificationWidget*                    NotificationWidget;                                // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLUI_NetworkNotifications*            NetworkNotificationsWidget;                        // 0x0168(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFriendsWidget>             FriendsWidgetClass;                                // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFriendsWidget*                         FriendsWidget;                                     // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLConsoleUIManager">();
	}
	static class UHLLConsoleUIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLConsoleUIManager>();
	}
};
static_assert(alignof(UHLLConsoleUIManager) == 0x000008, "Wrong alignment on UHLLConsoleUIManager");
static_assert(sizeof(UHLLConsoleUIManager) == 0x000180, "Wrong size on UHLLConsoleUIManager");
static_assert(offsetof(UHLLConsoleUIManager, EulaDialogueWidgetClass) == 0x000130, "Member 'UHLLConsoleUIManager::EulaDialogueWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, WelcomeScreenWidgetClass) == 0x000138, "Member 'UHLLConsoleUIManager::WelcomeScreenWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, EULAWidget) == 0x000140, "Member 'UHLLConsoleUIManager::EULAWidget' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, WelcomeScreenWidget) == 0x000148, "Member 'UHLLConsoleUIManager::WelcomeScreenWidget' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, NotificationWidgetClass) == 0x000150, "Member 'UHLLConsoleUIManager::NotificationWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, NetworkNotificationsClass) == 0x000158, "Member 'UHLLConsoleUIManager::NetworkNotificationsClass' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, NotificationWidget) == 0x000160, "Member 'UHLLConsoleUIManager::NotificationWidget' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, NetworkNotificationsWidget) == 0x000168, "Member 'UHLLConsoleUIManager::NetworkNotificationsWidget' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, FriendsWidgetClass) == 0x000170, "Member 'UHLLConsoleUIManager::FriendsWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLConsoleUIManager, FriendsWidget) == 0x000178, "Member 'UHLLConsoleUIManager::FriendsWidget' has a wrong offset!");

// Class HLL.FlameJetComponent
// 0x00A0 (0x0150 - 0x00B0)
class UFlameJetComponent final : public UActorComponent
{
public:
	float                                         Gravity;                                           // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirResistance;                                     // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadiusSpeed;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeTime;                                          // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartVelocity;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialRadius;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AFireSpot>                  FireSpotClass;                                     // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceBetweenFireSpots;                       // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1174[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<EObjectTypeQuery>                      JetQueryChannels;                                  // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             FlameBlockerChannel;                               // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1175[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DamagePerSecond;                                   // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UShooterDamageType>         DamageTypeClass;                                   // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionAmount;                                 // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionRadius;                                 // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionFalloff;                                // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1176[0xC];                                     // 0x0104(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UFlameJetModel*>                 Jets;                                              // 0x0110(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1177[0x30];                                    // 0x0120(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameJetComponent">();
	}
	static class UFlameJetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameJetComponent>();
	}
};
static_assert(alignof(UFlameJetComponent) == 0x000008, "Wrong alignment on UFlameJetComponent");
static_assert(sizeof(UFlameJetComponent) == 0x000150, "Wrong size on UFlameJetComponent");
static_assert(offsetof(UFlameJetComponent, Gravity) == 0x0000B0, "Member 'UFlameJetComponent::Gravity' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, AirResistance) == 0x0000B4, "Member 'UFlameJetComponent::AirResistance' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, RadiusSpeed) == 0x0000B8, "Member 'UFlameJetComponent::RadiusSpeed' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, LifeTime) == 0x0000BC, "Member 'UFlameJetComponent::LifeTime' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, StartVelocity) == 0x0000C0, "Member 'UFlameJetComponent::StartVelocity' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, InitialRadius) == 0x0000C4, "Member 'UFlameJetComponent::InitialRadius' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, FireSpotClass) == 0x0000C8, "Member 'UFlameJetComponent::FireSpotClass' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, MinDistanceBetweenFireSpots) == 0x0000D0, "Member 'UFlameJetComponent::MinDistanceBetweenFireSpots' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, JetQueryChannels) == 0x0000D8, "Member 'UFlameJetComponent::JetQueryChannels' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, FlameBlockerChannel) == 0x0000E8, "Member 'UFlameJetComponent::FlameBlockerChannel' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, DamagePerSecond) == 0x0000EC, "Member 'UFlameJetComponent::DamagePerSecond' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, DamageTypeClass) == 0x0000F0, "Member 'UFlameJetComponent::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, SuppressionAmount) == 0x0000F8, "Member 'UFlameJetComponent::SuppressionAmount' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, SuppressionRadius) == 0x0000FC, "Member 'UFlameJetComponent::SuppressionRadius' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, SuppressionFalloff) == 0x000100, "Member 'UFlameJetComponent::SuppressionFalloff' has a wrong offset!");
static_assert(offsetof(UFlameJetComponent, Jets) == 0x000110, "Member 'UFlameJetComponent::Jets' has a wrong offset!");

// Class HLL.RCONCommandRemovePermanentBan
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemovePermanentBan final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemovePermanentBan">();
	}
	static class URCONCommandRemovePermanentBan* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemovePermanentBan>();
	}
};
static_assert(alignof(URCONCommandRemovePermanentBan) == 0x000008, "Wrong alignment on URCONCommandRemovePermanentBan");
static_assert(sizeof(URCONCommandRemovePermanentBan) == 0x000028, "Wrong size on URCONCommandRemovePermanentBan");

// Class HLL.FlameJetModel
// 0x0038 (0x0060 - 0x0028)
class UFlameJetModel final : public UObject
{
public:
	uint8                                         Pad_1178[0x38];                                    // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameJetModel">();
	}
	static class UFlameJetModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameJetModel>();
	}
};
static_assert(alignof(UFlameJetModel) == 0x000008, "Wrong alignment on UFlameJetModel");
static_assert(sizeof(UFlameJetModel) == 0x000060, "Wrong size on UFlameJetModel");

// Class HLL.FlamethrowerComponent
// 0x0050 (0x0240 - 0x01F0)
class UFlamethrowerComponent final : public USceneComponent
{
public:
	TSubclassOf<class AFlamethrowerBurningSpot>   GroundBurningFX;                                   // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFlamethrowerBurningCharacter> CharacterBurningFX;                                // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1179[0x40];                                    // 0x0200(0x0040)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetFiring(bool bFiring);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamethrowerComponent">();
	}
	static class UFlamethrowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlamethrowerComponent>();
	}
};
static_assert(alignof(UFlamethrowerComponent) == 0x000010, "Wrong alignment on UFlamethrowerComponent");
static_assert(sizeof(UFlamethrowerComponent) == 0x000240, "Wrong size on UFlamethrowerComponent");
static_assert(offsetof(UFlamethrowerComponent, GroundBurningFX) == 0x0001F0, "Member 'UFlamethrowerComponent::GroundBurningFX' has a wrong offset!");
static_assert(offsetof(UFlamethrowerComponent, CharacterBurningFX) == 0x0001F8, "Member 'UFlamethrowerComponent::CharacterBurningFX' has a wrong offset!");

// Class HLL.HLLTeamLoadouts
// 0x00E8 (0x0118 - 0x0030)
class UHLLTeamLoadouts final : public UDataAsset
{
public:
	EFaction                                      Faction;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_117A[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FLoadout>                       Rifleman;                                          // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       Assault;                                           // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       AutomaticRifleman;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       Medic;                                             // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       Spotter;                                           // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       Support;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       MachineGunner;                                     // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       AntiTank;                                          // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       Engineer;                                          // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       Officer;                                           // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       Sniper;                                            // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       Crewman;                                           // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       TankCommander;                                     // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoadout>                       ArmyCommander;                                     // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLTeamLoadouts">();
	}
	static class UHLLTeamLoadouts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLTeamLoadouts>();
	}
};
static_assert(alignof(UHLLTeamLoadouts) == 0x000008, "Wrong alignment on UHLLTeamLoadouts");
static_assert(sizeof(UHLLTeamLoadouts) == 0x000118, "Wrong size on UHLLTeamLoadouts");
static_assert(offsetof(UHLLTeamLoadouts, Faction) == 0x000030, "Member 'UHLLTeamLoadouts::Faction' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Rifleman) == 0x000038, "Member 'UHLLTeamLoadouts::Rifleman' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Assault) == 0x000048, "Member 'UHLLTeamLoadouts::Assault' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, AutomaticRifleman) == 0x000058, "Member 'UHLLTeamLoadouts::AutomaticRifleman' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Medic) == 0x000068, "Member 'UHLLTeamLoadouts::Medic' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Spotter) == 0x000078, "Member 'UHLLTeamLoadouts::Spotter' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Support) == 0x000088, "Member 'UHLLTeamLoadouts::Support' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, MachineGunner) == 0x000098, "Member 'UHLLTeamLoadouts::MachineGunner' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, AntiTank) == 0x0000A8, "Member 'UHLLTeamLoadouts::AntiTank' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Engineer) == 0x0000B8, "Member 'UHLLTeamLoadouts::Engineer' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Officer) == 0x0000C8, "Member 'UHLLTeamLoadouts::Officer' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Sniper) == 0x0000D8, "Member 'UHLLTeamLoadouts::Sniper' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, Crewman) == 0x0000E8, "Member 'UHLLTeamLoadouts::Crewman' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, TankCommander) == 0x0000F8, "Member 'UHLLTeamLoadouts::TankCommander' has a wrong offset!");
static_assert(offsetof(UHLLTeamLoadouts, ArmyCommander) == 0x000108, "Member 'UHLLTeamLoadouts::ArmyCommander' has a wrong offset!");

// Class HLL.SeedingGameModeHUD
// 0x0020 (0x0250 - 0x0230)
class USeedingGameModeHUD : public UUserWidget
{
public:
	class UHorizontalBox*                         ControlPoints;                                     // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USeedingControlPointHUD>    SeedingControlPointHUDClass;                       // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USeedingControlPointHUD*>        ControlPointHUDList;                               // 0x0240(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetupObjective();
	void UpdateControlPoints();

	void TriggerEnterOnControlPointUI(const class ASeedingControlPoint* SeedingControlPoint) const;
	void TriggerExitOnControlPointUI(const class ASeedingControlPoint* SeedingControlPoint) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeedingGameModeHUD">();
	}
	static class USeedingGameModeHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeedingGameModeHUD>();
	}
};
static_assert(alignof(USeedingGameModeHUD) == 0x000008, "Wrong alignment on USeedingGameModeHUD");
static_assert(sizeof(USeedingGameModeHUD) == 0x000250, "Wrong size on USeedingGameModeHUD");
static_assert(offsetof(USeedingGameModeHUD, ControlPoints) == 0x000230, "Member 'USeedingGameModeHUD::ControlPoints' has a wrong offset!");
static_assert(offsetof(USeedingGameModeHUD, SeedingControlPointHUDClass) == 0x000238, "Member 'USeedingGameModeHUD::SeedingControlPointHUDClass' has a wrong offset!");
static_assert(offsetof(USeedingGameModeHUD, ControlPointHUDList) == 0x000240, "Member 'USeedingGameModeHUD::ControlPointHUDList' has a wrong offset!");

// Class HLL.FlamethrowerBurningCharacter
// 0x0008 (0x0228 - 0x0220)
class AFlamethrowerBurningCharacter final : public AActor
{
public:
	class ACharacter*                             BurningCharacter;                                  // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamethrowerBurningCharacter">();
	}
	static class AFlamethrowerBurningCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlamethrowerBurningCharacter>();
	}
};
static_assert(alignof(AFlamethrowerBurningCharacter) == 0x000008, "Wrong alignment on AFlamethrowerBurningCharacter");
static_assert(sizeof(AFlamethrowerBurningCharacter) == 0x000228, "Wrong size on AFlamethrowerBurningCharacter");
static_assert(offsetof(AFlamethrowerBurningCharacter, BurningCharacter) == 0x000220, "Member 'AFlamethrowerBurningCharacter::BurningCharacter' has a wrong offset!");

// Class HLL.HLLScopeWidget
// 0x0020 (0x0250 - 0x0230)
class UHLLScopeWidget : public UUserWidget
{
public:
	class AShooterWeapon*                         AssignedWeapon;                                    // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRotateWithLean : 1;                               // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScopeParallax : 1;                                // 0x0238(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_117B[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLScopeImage*                         ScopeImage;                                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ZoomText;                                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLScopeWidget">();
	}
	static class UHLLScopeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLScopeWidget>();
	}
};
static_assert(alignof(UHLLScopeWidget) == 0x000008, "Wrong alignment on UHLLScopeWidget");
static_assert(sizeof(UHLLScopeWidget) == 0x000250, "Wrong size on UHLLScopeWidget");
static_assert(offsetof(UHLLScopeWidget, AssignedWeapon) == 0x000230, "Member 'UHLLScopeWidget::AssignedWeapon' has a wrong offset!");
static_assert(offsetof(UHLLScopeWidget, ScopeImage) == 0x000240, "Member 'UHLLScopeWidget::ScopeImage' has a wrong offset!");
static_assert(offsetof(UHLLScopeWidget, ZoomText) == 0x000248, "Member 'UHLLScopeWidget::ZoomText' has a wrong offset!");

// Class HLL.HLLBinoWidget
// 0x0008 (0x0258 - 0x0250)
class UHLLBinoWidget final : public UHLLScopeWidget
{
public:
	class UWidgetAnimation*                       RangeAnim;                                         // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBinoWidget">();
	}
	static class UHLLBinoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLBinoWidget>();
	}
};
static_assert(alignof(UHLLBinoWidget) == 0x000008, "Wrong alignment on UHLLBinoWidget");
static_assert(sizeof(UHLLBinoWidget) == 0x000258, "Wrong size on UHLLBinoWidget");
static_assert(offsetof(UHLLBinoWidget, RangeAnim) == 0x000250, "Member 'UHLLBinoWidget::RangeAnim' has a wrong offset!");

// Class HLL.FlamethrowerBurningSpot
// 0x0008 (0x0228 - 0x0220)
class AFlamethrowerBurningSpot final : public AActor
{
public:
	float                                         Power;                                             // 0x0220(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_117C[0x4];                                     // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnLifeSpanUpdated(float NewLifeSpan);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamethrowerBurningSpot">();
	}
	static class AFlamethrowerBurningSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlamethrowerBurningSpot>();
	}
};
static_assert(alignof(AFlamethrowerBurningSpot) == 0x000008, "Wrong alignment on AFlamethrowerBurningSpot");
static_assert(sizeof(AFlamethrowerBurningSpot) == 0x000228, "Wrong size on AFlamethrowerBurningSpot");
static_assert(offsetof(AFlamethrowerBurningSpot, Power) == 0x000220, "Member 'AFlamethrowerBurningSpot::Power' has a wrong offset!");

// Class HLL.PendingPlayerDeployment
// 0x0020 (0x0048 - 0x0028)
class UPendingPlayerDeployment final : public UObject
{
public:
	uint8                                         Pad_117D[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TScriptInterface<class IDynamicSpawnInterface> Spawn;                                             // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AShooterPlayerController*               Player;                                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PendingPlayerDeployment">();
	}
	static class UPendingPlayerDeployment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPendingPlayerDeployment>();
	}
};
static_assert(alignof(UPendingPlayerDeployment) == 0x000008, "Wrong alignment on UPendingPlayerDeployment");
static_assert(sizeof(UPendingPlayerDeployment) == 0x000048, "Wrong size on UPendingPlayerDeployment");
static_assert(offsetof(UPendingPlayerDeployment, Spawn) == 0x000030, "Member 'UPendingPlayerDeployment::Spawn' has a wrong offset!");
static_assert(offsetof(UPendingPlayerDeployment, Player) == 0x000040, "Member 'UPendingPlayerDeployment::Player' has a wrong offset!");

// Class HLL.PlayerDownedAchievement
// 0x0000 (0x0030 - 0x0030)
class UPlayerDownedAchievement : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDownedAchievement">();
	}
	static class UPlayerDownedAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDownedAchievement>();
	}
};
static_assert(alignof(UPlayerDownedAchievement) == 0x000008, "Wrong alignment on UPlayerDownedAchievement");
static_assert(sizeof(UPlayerDownedAchievement) == 0x000030, "Wrong size on UPlayerDownedAchievement");

// Class HLL.FlamethrowerKillWhileInjuredAchievement
// 0x0018 (0x0048 - 0x0030)
class UFlamethrowerKillWhileInjuredAchievement final : public UPlayerDownedAchievement
{
public:
	EHLLAchievement                               UnlockAchievement;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_117E[0x17];                                    // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamethrowerKillWhileInjuredAchievement">();
	}
	static class UFlamethrowerKillWhileInjuredAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlamethrowerKillWhileInjuredAchievement>();
	}
};
static_assert(alignof(UFlamethrowerKillWhileInjuredAchievement) == 0x000008, "Wrong alignment on UFlamethrowerKillWhileInjuredAchievement");
static_assert(sizeof(UFlamethrowerKillWhileInjuredAchievement) == 0x000048, "Wrong size on UFlamethrowerKillWhileInjuredAchievement");
static_assert(offsetof(UFlamethrowerKillWhileInjuredAchievement, UnlockAchievement) == 0x000030, "Member 'UFlamethrowerKillWhileInjuredAchievement::UnlockAchievement' has a wrong offset!");

// Class HLL.HLLDeployment_TeamSelectItem
// 0x0038 (0x0268 - 0x0230)
class UHLLDeployment_TeamSelectItem : public UUserWidget
{
public:
	class UHLLDeployment_TeamSelect*              OwningTeamPanel;                                   // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         AssignedTeam;                                      // 0x0238(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFaction                                      AssignedFaction;                                   // 0x0239(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsAvailable : 1;                                  // 0x023A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_117F[0x5];                                     // 0x023B(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidget*                                EnabledStateWidget;                                // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerCount;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FactionName;                                       // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FactionIcon;                                       // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SelectButton;                                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDeployment_TeamSelectItem">();
	}
	static class UHLLDeployment_TeamSelectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDeployment_TeamSelectItem>();
	}
};
static_assert(alignof(UHLLDeployment_TeamSelectItem) == 0x000008, "Wrong alignment on UHLLDeployment_TeamSelectItem");
static_assert(sizeof(UHLLDeployment_TeamSelectItem) == 0x000268, "Wrong size on UHLLDeployment_TeamSelectItem");
static_assert(offsetof(UHLLDeployment_TeamSelectItem, OwningTeamPanel) == 0x000230, "Member 'UHLLDeployment_TeamSelectItem::OwningTeamPanel' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelectItem, AssignedTeam) == 0x000238, "Member 'UHLLDeployment_TeamSelectItem::AssignedTeam' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelectItem, AssignedFaction) == 0x000239, "Member 'UHLLDeployment_TeamSelectItem::AssignedFaction' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelectItem, EnabledStateWidget) == 0x000240, "Member 'UHLLDeployment_TeamSelectItem::EnabledStateWidget' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelectItem, PlayerCount) == 0x000248, "Member 'UHLLDeployment_TeamSelectItem::PlayerCount' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelectItem, FactionName) == 0x000250, "Member 'UHLLDeployment_TeamSelectItem::FactionName' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelectItem, FactionIcon) == 0x000258, "Member 'UHLLDeployment_TeamSelectItem::FactionIcon' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelectItem, SelectButton) == 0x000260, "Member 'UHLLDeployment_TeamSelectItem::SelectButton' has a wrong offset!");

// Class HLL.SectorCompassIndicator
// 0x0008 (0x0258 - 0x0250)
class USectorCompassIndicator : public UBaseCompassIndicator
{
public:
	int32                                         SectorIndex;                                       // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1180[0x4];                                     // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SectorCompassIndicator">();
	}
	static class USectorCompassIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<USectorCompassIndicator>();
	}
};
static_assert(alignof(USectorCompassIndicator) == 0x000008, "Wrong alignment on USectorCompassIndicator");
static_assert(sizeof(USectorCompassIndicator) == 0x000258, "Wrong size on USectorCompassIndicator");
static_assert(offsetof(USectorCompassIndicator, SectorIndex) == 0x000250, "Member 'USectorCompassIndicator::SectorIndex' has a wrong offset!");

// Class HLL.ShooterProjectile
// 0x0250 (0x0470 - 0x0220)
class AShooterProjectile : public AActor
{
public:
	uint8                                         Pad_1181[0x30];                                    // 0x0220(0x0030)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLProjectileMovement*                 MovementComp;                                      // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       CollisionComp;                                     // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParticleComp;                                      // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ProjectileMesh;                                    // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       ExplosionTemplate;                                 // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       PenetrationTemplate;                               // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       RicochetTemplate;                                  // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           MyPlayerState;                                     // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x0290(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1182[0x3];                                     // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ProjectileLife;                                    // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExplosionDamage;                                   // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionRadius;                                   // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionFalloff;                                  // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1183[0x4];                                     // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UShooterDamageType>         DamageType;                                        // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostExplodeLifespan;                               // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bExplodeAtEndOfLife : 1;                           // 0x02B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1184[0x3];                                     // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 DamageSourceName;                                  // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bExploded : 1;                                     // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPenetrated : 1;                                   // 0x02C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDidRicochet : 1;                                  // 0x02C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAwaitingDestroy : 1;                              // 0x02C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1185[0x7];                                     // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FProjectileHitData                     HitData;                                           // 0x02D0(0x0140)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FVector                                RicochetLocationWS;                                // 0x0410(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionRadius;                                 // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionAmount_Flyby;                           // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bApplyFlybySuppressionToAllTeams : 1;              // 0x0424(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ESuppressionType                              FlybySuppressionType;                              // 0x0425(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1186[0x2];                                     // 0x0426(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SuppressionAmount_Explode;                         // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionFalloff_Explode;                        // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionRadius_Explode;                         // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bApplyExplodeSuppressionToAllTeams : 1;            // 0x0434(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ESuppressionType                              ExplosionSuppressionType;                          // 0x0435(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1187[0xE];                                     // 0x0436(0x000E)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bUseBulletCrackSound : 1;                          // 0x0444(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1188[0x3];                                     // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         BulletCrackRadius;                                 // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1189[0x4];                                     // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             BulletCrackSound;                                  // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    SpawnLocation;                                     // 0x0458(0x000C)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118A[0xC];                                     // 0x0464(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnBounce(const struct FHitResult& HitResult, const struct FVector& BounceVelocity);
	void OnImpact(const struct FHitResult& HitResult);
	void OnRep_HitData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterProjectile">();
	}
	static class AShooterProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterProjectile>();
	}
};
static_assert(alignof(AShooterProjectile) == 0x000008, "Wrong alignment on AShooterProjectile");
static_assert(sizeof(AShooterProjectile) == 0x000470, "Wrong size on AShooterProjectile");
static_assert(offsetof(AShooterProjectile, MovementComp) == 0x000250, "Member 'AShooterProjectile::MovementComp' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, CollisionComp) == 0x000258, "Member 'AShooterProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ParticleComp) == 0x000260, "Member 'AShooterProjectile::ParticleComp' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ProjectileMesh) == 0x000268, "Member 'AShooterProjectile::ProjectileMesh' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ExplosionTemplate) == 0x000270, "Member 'AShooterProjectile::ExplosionTemplate' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, PenetrationTemplate) == 0x000278, "Member 'AShooterProjectile::PenetrationTemplate' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, RicochetTemplate) == 0x000280, "Member 'AShooterProjectile::RicochetTemplate' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, MyPlayerState) == 0x000288, "Member 'AShooterProjectile::MyPlayerState' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, Team) == 0x000290, "Member 'AShooterProjectile::Team' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ProjectileLife) == 0x000294, "Member 'AShooterProjectile::ProjectileLife' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ExplosionDamage) == 0x000298, "Member 'AShooterProjectile::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ExplosionRadius) == 0x00029C, "Member 'AShooterProjectile::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ExplosionFalloff) == 0x0002A0, "Member 'AShooterProjectile::ExplosionFalloff' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, DamageType) == 0x0002A8, "Member 'AShooterProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, PostExplodeLifespan) == 0x0002B0, "Member 'AShooterProjectile::PostExplodeLifespan' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, DamageSourceName) == 0x0002B8, "Member 'AShooterProjectile::DamageSourceName' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, HitData) == 0x0002D0, "Member 'AShooterProjectile::HitData' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, RicochetLocationWS) == 0x000410, "Member 'AShooterProjectile::RicochetLocationWS' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, SuppressionRadius) == 0x00041C, "Member 'AShooterProjectile::SuppressionRadius' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, SuppressionAmount_Flyby) == 0x000420, "Member 'AShooterProjectile::SuppressionAmount_Flyby' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, FlybySuppressionType) == 0x000425, "Member 'AShooterProjectile::FlybySuppressionType' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, SuppressionAmount_Explode) == 0x000428, "Member 'AShooterProjectile::SuppressionAmount_Explode' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, SuppressionFalloff_Explode) == 0x00042C, "Member 'AShooterProjectile::SuppressionFalloff_Explode' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, SuppressionRadius_Explode) == 0x000430, "Member 'AShooterProjectile::SuppressionRadius_Explode' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, ExplosionSuppressionType) == 0x000435, "Member 'AShooterProjectile::ExplosionSuppressionType' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, BulletCrackRadius) == 0x000448, "Member 'AShooterProjectile::BulletCrackRadius' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, BulletCrackSound) == 0x000450, "Member 'AShooterProjectile::BulletCrackSound' has a wrong offset!");
static_assert(offsetof(AShooterProjectile, SpawnLocation) == 0x000458, "Member 'AShooterProjectile::SpawnLocation' has a wrong offset!");

// Class HLL.HLLDamageFilterInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLDamageFilterInterface final : public IInterface
{
public:
	EHLLDamageFilterType GetFilterType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDamageFilterInterface">();
	}
	static class IHLLDamageFilterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLDamageFilterInterface>();
	}
};
static_assert(alignof(IHLLDamageFilterInterface) == 0x000008, "Wrong alignment on IHLLDamageFilterInterface");
static_assert(sizeof(IHLLDamageFilterInterface) == 0x000028, "Wrong size on IHLLDamageFilterInterface");

// Class HLL.FlareProjectile
// 0x00D8 (0x0548 - 0x0470)
class AFlareProjectile : public AShooterProjectile
{
public:
	class UHLLMapComponent*                       MapComponent;                                      // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               IgnitionParticle;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        FlightAudio;                                       // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        IgnitionAudio;                                     // 0x0488(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118B[0x18];                                    // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ScanRadius;                                        // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanAdditionalHeight;                              // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanPeriod;                                        // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinIgnitionAltitude;                               // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeedAfterIgnition;                             // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityScaleAfterIgnition;                         // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLifespanAfterIgnition;                          // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseIgnitionDelay : 1;                             // 0x04C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_118C[0x3];                                     // 0x04C5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         IgnitionDelay;                                     // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118D[0x4];                                     // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterImpactEffect>       IgnitionTemplate;                                  // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLOSCheck : 1;                                     // 0x04D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_118E[0x7];                                     // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<EObjectTypeQuery>                      ScanObjectTypes;                                   // 0x04E0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             LOSChannel;                                        // 0x04F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIgnited : 1;                                      // 0x04F1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_118F[0x56];                                    // 0x04F2(0x0056)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_Ignited();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlareProjectile">();
	}
	static class AFlareProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlareProjectile>();
	}
};
static_assert(alignof(AFlareProjectile) == 0x000008, "Wrong alignment on AFlareProjectile");
static_assert(sizeof(AFlareProjectile) == 0x000548, "Wrong size on AFlareProjectile");
static_assert(offsetof(AFlareProjectile, MapComponent) == 0x000470, "Member 'AFlareProjectile::MapComponent' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, IgnitionParticle) == 0x000478, "Member 'AFlareProjectile::IgnitionParticle' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, FlightAudio) == 0x000480, "Member 'AFlareProjectile::FlightAudio' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, IgnitionAudio) == 0x000488, "Member 'AFlareProjectile::IgnitionAudio' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, ScanRadius) == 0x0004A8, "Member 'AFlareProjectile::ScanRadius' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, ScanAdditionalHeight) == 0x0004AC, "Member 'AFlareProjectile::ScanAdditionalHeight' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, ScanPeriod) == 0x0004B0, "Member 'AFlareProjectile::ScanPeriod' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, MinIgnitionAltitude) == 0x0004B4, "Member 'AFlareProjectile::MinIgnitionAltitude' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, MaxSpeedAfterIgnition) == 0x0004B8, "Member 'AFlareProjectile::MaxSpeedAfterIgnition' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, GravityScaleAfterIgnition) == 0x0004BC, "Member 'AFlareProjectile::GravityScaleAfterIgnition' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, MaxLifespanAfterIgnition) == 0x0004C0, "Member 'AFlareProjectile::MaxLifespanAfterIgnition' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, IgnitionDelay) == 0x0004C8, "Member 'AFlareProjectile::IgnitionDelay' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, IgnitionTemplate) == 0x0004D0, "Member 'AFlareProjectile::IgnitionTemplate' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, ScanObjectTypes) == 0x0004E0, "Member 'AFlareProjectile::ScanObjectTypes' has a wrong offset!");
static_assert(offsetof(AFlareProjectile, LOSChannel) == 0x0004F0, "Member 'AFlareProjectile::LOSChannel' has a wrong offset!");

// Class HLL.Garrison
// 0x0008 (0x0410 - 0x0408)
class AGarrison : public ADynamicSpawn
{
public:
	bool                                          bStrongInLockedSectors;                            // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1190[0x3];                                     // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         StrongDismantleTime;                               // 0x040C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Garrison">();
	}
	static class AGarrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGarrison>();
	}
};
static_assert(alignof(AGarrison) == 0x000008, "Wrong alignment on AGarrison");
static_assert(sizeof(AGarrison) == 0x000410, "Wrong size on AGarrison");
static_assert(offsetof(AGarrison, bStrongInLockedSectors) == 0x000408, "Member 'AGarrison::bStrongInLockedSectors' has a wrong offset!");
static_assert(offsetof(AGarrison, StrongDismantleTime) == 0x00040C, "Member 'AGarrison::StrongDismantleTime' has a wrong offset!");

// Class HLL.VehicleTickAchievement
// 0x0000 (0x0030 - 0x0030)
class UVehicleTickAchievement : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleTickAchievement">();
	}
	static class UVehicleTickAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleTickAchievement>();
	}
};
static_assert(alignof(UVehicleTickAchievement) == 0x000008, "Wrong alignment on UVehicleTickAchievement");
static_assert(sizeof(UVehicleTickAchievement) == 0x000030, "Wrong size on UVehicleTickAchievement");

// Class HLL.VehicleTimerProgressiveAchievement
// 0x0008 (0x0038 - 0x0030)
class UVehicleTimerProgressiveAchievement final : public UVehicleTickAchievement
{
public:
	EHLLAchievementStat                           AchievementStat;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1191[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleTimerProgressiveAchievement">();
	}
	static class UVehicleTimerProgressiveAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleTimerProgressiveAchievement>();
	}
};
static_assert(alignof(UVehicleTimerProgressiveAchievement) == 0x000008, "Wrong alignment on UVehicleTimerProgressiveAchievement");
static_assert(sizeof(UVehicleTimerProgressiveAchievement) == 0x000038, "Wrong size on UVehicleTimerProgressiveAchievement");
static_assert(offsetof(UVehicleTimerProgressiveAchievement, AchievementStat) == 0x000030, "Member 'UVehicleTimerProgressiveAchievement::AchievementStat' has a wrong offset!");

// Class HLL.ForwardPosition
// 0x0000 (0x0410 - 0x0410)
class AForwardPosition : public AGarrison
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForwardPosition">();
	}
	static class AForwardPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AForwardPosition>();
	}
};
static_assert(alignof(AForwardPosition) == 0x000008, "Wrong alignment on AForwardPosition");
static_assert(sizeof(AForwardPosition) == 0x000410, "Wrong size on AForwardPosition");

// Class HLL.HLLDispenseInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLDispenseInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenseInterface">();
	}
	static class IHLLDispenseInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLDispenseInterface>();
	}
};
static_assert(alignof(IHLLDispenseInterface) == 0x000008, "Wrong alignment on IHLLDispenseInterface");
static_assert(sizeof(IHLLDispenseInterface) == 0x000028, "Wrong size on IHLLDispenseInterface");

// Class HLL.FpsSkeletalMeshComponent
// 0x0000 (0x0AC0 - 0x0AC0)
class UFpsSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FpsSkeletalMeshComponent">();
	}
	static class UFpsSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFpsSkeletalMeshComponent>();
	}
};
static_assert(alignof(UFpsSkeletalMeshComponent) == 0x000010, "Wrong alignment on UFpsSkeletalMeshComponent");
static_assert(sizeof(UFpsSkeletalMeshComponent) == 0x000AC0, "Wrong size on UFpsSkeletalMeshComponent");

// Class HLL.VehicleExitLocationComponent
// 0x0000 (0x0420 - 0x0420)
class UVehicleExitLocationComponent final : public UCapsuleComponent
{
public:
	int32                                         Priority;                                          // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreBlockers;                                   // 0x041C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1192[0x3];                                     // 0x041D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleExitLocationComponent">();
	}
	static class UVehicleExitLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleExitLocationComponent>();
	}
};
static_assert(alignof(UVehicleExitLocationComponent) == 0x000010, "Wrong alignment on UVehicleExitLocationComponent");
static_assert(sizeof(UVehicleExitLocationComponent) == 0x000420, "Wrong size on UVehicleExitLocationComponent");
static_assert(offsetof(UVehicleExitLocationComponent, Priority) == 0x000418, "Member 'UVehicleExitLocationComponent::Priority' has a wrong offset!");
static_assert(offsetof(UVehicleExitLocationComponent, bIgnoreBlockers) == 0x00041C, "Member 'UVehicleExitLocationComponent::bIgnoreBlockers' has a wrong offset!");

// Class HLL.FpsStaticMeshComponent
// 0x0000 (0x0490 - 0x0490)
class UFpsStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FpsStaticMeshComponent">();
	}
	static class UFpsStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFpsStaticMeshComponent>();
	}
};
static_assert(alignof(UFpsStaticMeshComponent) == 0x000010, "Wrong alignment on UFpsStaticMeshComponent");
static_assert(sizeof(UFpsStaticMeshComponent) == 0x000490, "Wrong size on UFpsStaticMeshComponent");

// Class HLL.HalftrackAnimInstance
// 0x0760 (0x10E0 - 0x0980)
class UHalftrackAnimInstance : public UVehicleAnimInstance
{
public:
	uint8                                         Pad_1193[0x768];                                   // 0x0978(0x0768)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HalftrackAnimInstance">();
	}
	static class UHalftrackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHalftrackAnimInstance>();
	}
};
static_assert(alignof(UHalftrackAnimInstance) == 0x000010, "Wrong alignment on UHalftrackAnimInstance");
static_assert(sizeof(UHalftrackAnimInstance) == 0x0010E0, "Wrong size on UHalftrackAnimInstance");

// Class HLL.SdKfz251HalftrackAnimInstance
// 0x0770 (0x1850 - 0x10E0)
class USdKfz251HalftrackAnimInstance final : public UHalftrackAnimInstance
{
public:
	uint8                                         Pad_1194[0x770];                                   // 0x10E0(0x0770)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SdKfz251HalftrackAnimInstance">();
	}
	static class USdKfz251HalftrackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USdKfz251HalftrackAnimInstance>();
	}
};
static_assert(alignof(USdKfz251HalftrackAnimInstance) == 0x000010, "Wrong alignment on USdKfz251HalftrackAnimInstance");
static_assert(sizeof(USdKfz251HalftrackAnimInstance) == 0x001850, "Wrong size on USdKfz251HalftrackAnimInstance");

// Class HLL.FrameTimeAverager
// 0x0020 (0x0240 - 0x0220)
class AFrameTimeAverager final : public AActor
{
public:
	int32                                         NumSamples;                                        // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1195[0x1C];                                    // 0x0224(0x001C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrameTimeAverager">();
	}
	static class AFrameTimeAverager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFrameTimeAverager>();
	}
};
static_assert(alignof(AFrameTimeAverager) == 0x000008, "Wrong alignment on AFrameTimeAverager");
static_assert(sizeof(AFrameTimeAverager) == 0x000240, "Wrong size on AFrameTimeAverager");
static_assert(offsetof(AFrameTimeAverager, NumSamples) == 0x000220, "Member 'AFrameTimeAverager::NumSamples' has a wrong offset!");

// Class HLL.FriendsWidget
// 0x01A0 (0x03D0 - 0x0230)
class UFriendsWidget : public UUserWidget
{
public:
	float                                         M_ForcePlatformFriendListCooldown;                 // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_ForceT17FriendListCooldown;                      // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1196[0x190];                                   // 0x0238(0x0190)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bEnterAnimationIsFinished;                         // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1197[0x7];                                     // 0x03C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ChangeT17DisplayName(const class FString& NewDisplayName, TDelegate<void(const class FString& NewDisplayNameShort, const class FString& NewDisplayNameFull, bool Success, ENameChangeFailureReason FailReason)> OnChangeDisplayNameCompleted);
	void ForceFriendListUpdate(const EFriendsType FriendsTypeToUpdate);
	bool GetIsForceUpdateCooldownReady(const EFriendsType FriendsTypeToCheck);
	int32 GetNumUnreadNotifications();
	bool IsAT17Friend(const class FString& GlobalPlayerId);
	bool IsPlayerInGame(const class FString& GlobalPlayerId);
	void OnBlockListUpdated(const TArray<struct FT17PlayerQuery>& ChangedBlockedPlayers, const TArray<EFriendStatusChangedEvent>& ReasonsOfChanges);
	void OnChangeNameDialogOpen();
	void OnMenuClosed();
	void OnMenuOpened(const EFriendsTab& InTab);
	void OnNumUnreadNotificationsChangedEvent(int32 NumUnreadNotifications);
	void OnPlatformFriendsListUpdated(const TArray<struct FPlatformFriendInfo>& ChangedFriends, const TArray<EFriendStatusChangedEvent>& ReasonsOfChanges);
	void OnT17FriendInviteListUpdated(const TArray<struct FT17PlayerQuery>& ChangedInvites, const TArray<EFriendStatusChangedEvent>& ReasonsOfChanges);
	void OnT17FriendsListUpdated(const TArray<struct FT17FriendInfo>& ChangedFriends, const TArray<EFriendStatusChangedEvent>& ReasonsOfChanges);
	void OnT17FriendStatusChanged(const struct FT17FriendInfo& ChangedFriend, const EFriendStatusChangedEvent& StatusChangedEvent);
	void OnT17SessionInviteListUpdated(const TArray<struct FT17InvitedPlayer>& ChangedInvites, const TArray<EFriendStatusChangedEvent>& ReasonsOfChanges);
	void ProcessFriendButtonAction(EFriendsTab CurrentTab, EFriendManagementAction ButtonAction, const class FString& FriendUniqueID, const class FString& FriendPlatformID, TDelegate<void(bool Success)> OnFriendActionCompleted);
	void ResetNumUnreadNotifications();
	void SendLocalNotification(const EPopupNotificationType& NotificationType, const class FString& PlayerName);
	void SendT17FriendInvite(const class FString& ShareablePlayerID, TDelegate<void(bool Success)> OnFriendActionCompleted);

	const struct FPlayerQueryList GetBlockedPlayerList() const;
	const struct FPlayerQueryList GetNotificationsList() const;
	const struct FPlatformFriendListInfo GetPlatformFriendsList(EFriendListType TypeToRetrieve) const;
	const struct FInvitedPlayerList GetSessionInviteList() const;
	const struct FT17FriendListInfo GetT17FriendsList(EFriendListType TypeToRetrieve) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsWidget">();
	}
	static class UFriendsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsWidget>();
	}
};
static_assert(alignof(UFriendsWidget) == 0x000008, "Wrong alignment on UFriendsWidget");
static_assert(sizeof(UFriendsWidget) == 0x0003D0, "Wrong size on UFriendsWidget");
static_assert(offsetof(UFriendsWidget, M_ForcePlatformFriendListCooldown) == 0x000230, "Member 'UFriendsWidget::M_ForcePlatformFriendListCooldown' has a wrong offset!");
static_assert(offsetof(UFriendsWidget, M_ForceT17FriendListCooldown) == 0x000234, "Member 'UFriendsWidget::M_ForceT17FriendListCooldown' has a wrong offset!");
static_assert(offsetof(UFriendsWidget, bEnterAnimationIsFinished) == 0x0003C8, "Member 'UFriendsWidget::bEnterAnimationIsFinished' has a wrong offset!");

// Class HLL.HLLDispenserItem_DynamicSpawnGhost
// 0x0028 (0x0580 - 0x0558)
class AHLLDispenserItem_DynamicSpawnGhost : public AHLLDispenserItem_StructureAdv
{
public:
	EHLLAchievement                               OnDispensedAchievement;                            // 0x0558(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119F[0x3];                                     // 0x0559(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         PlacementCooldownInSeconds;                        // 0x055C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDispenserCooldownCategory                    CooldownType;                                      // 0x0560(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A0[0x1C];                                    // 0x0564(0x001C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_DynamicSpawnGhost">();
	}
	static class AHLLDispenserItem_DynamicSpawnGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_DynamicSpawnGhost>();
	}
};
static_assert(alignof(AHLLDispenserItem_DynamicSpawnGhost) == 0x000008, "Wrong alignment on AHLLDispenserItem_DynamicSpawnGhost");
static_assert(sizeof(AHLLDispenserItem_DynamicSpawnGhost) == 0x000580, "Wrong size on AHLLDispenserItem_DynamicSpawnGhost");
static_assert(offsetof(AHLLDispenserItem_DynamicSpawnGhost, OnDispensedAchievement) == 0x000558, "Member 'AHLLDispenserItem_DynamicSpawnGhost::OnDispensedAchievement' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_DynamicSpawnGhost, PlacementCooldownInSeconds) == 0x00055C, "Member 'AHLLDispenserItem_DynamicSpawnGhost::PlacementCooldownInSeconds' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_DynamicSpawnGhost, CooldownType) == 0x000560, "Member 'AHLLDispenserItem_DynamicSpawnGhost::CooldownType' has a wrong offset!");

// Class HLL.ServerBrowserMapFilterData
// 0x0048 (0x0080 - 0x0038)
class UServerBrowserMapFilterData final : public UServerBrowserFilterDataAsset
{
public:
	class FText                                   FilterDisplayName;                                 // 0x0038(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              FilterThumbnail;                                   // 0x0050(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFaction                                      TeamOneFaction;                                    // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFaction                                      TeamTwoFaction;                                    // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A1[0x6];                                     // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class FText GetFilterDisplayName() const;
	TSoftObjectPtr<class UTexture2D> GetFilterThumbnail() const;
	EFaction GetTeamOneFaction() const;
	EFaction GetTeamTwoFaction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerBrowserMapFilterData">();
	}
	static class UServerBrowserMapFilterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerBrowserMapFilterData>();
	}
};
static_assert(alignof(UServerBrowserMapFilterData) == 0x000008, "Wrong alignment on UServerBrowserMapFilterData");
static_assert(sizeof(UServerBrowserMapFilterData) == 0x000080, "Wrong size on UServerBrowserMapFilterData");
static_assert(offsetof(UServerBrowserMapFilterData, FilterDisplayName) == 0x000038, "Member 'UServerBrowserMapFilterData::FilterDisplayName' has a wrong offset!");
static_assert(offsetof(UServerBrowserMapFilterData, FilterThumbnail) == 0x000050, "Member 'UServerBrowserMapFilterData::FilterThumbnail' has a wrong offset!");
static_assert(offsetof(UServerBrowserMapFilterData, TeamOneFaction) == 0x000078, "Member 'UServerBrowserMapFilterData::TeamOneFaction' has a wrong offset!");
static_assert(offsetof(UServerBrowserMapFilterData, TeamTwoFaction) == 0x000079, "Member 'UServerBrowserMapFilterData::TeamTwoFaction' has a wrong offset!");

// Class HLL.GameFeaturesBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameFeaturesBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesClientSupportMatchmaking();
	static bool IsEpicAccountLoggedIn();
	static bool ShouldShowQuitOnMainMenu();
	static bool ShouldUseConsoleFlow();
	static bool ShouldUseConsoleTextStyle();
	static bool ShouldUseSearchParamsToFindSessions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeaturesBlueprintFunctionLibrary">();
	}
	static class UGameFeaturesBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeaturesBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UGameFeaturesBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UGameFeaturesBlueprintFunctionLibrary");
static_assert(sizeof(UGameFeaturesBlueprintFunctionLibrary) == 0x000028, "Wrong size on UGameFeaturesBlueprintFunctionLibrary");

// Class HLL.HLLRadialMenu_ChatSegment
// 0x0010 (0x0288 - 0x0278)
class UHLLRadialMenu_ChatSegment : public UHLLRadialMenu_Segment
{
public:
	EHLLChat                                      ChatType;                                          // 0x0278(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A2[0x7];                                     // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 ChatIcon;                                          // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_InitChategment(const struct FChatMetaData& ChatMeta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_ChatSegment">();
	}
	static class UHLLRadialMenu_ChatSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_ChatSegment>();
	}
};
static_assert(alignof(UHLLRadialMenu_ChatSegment) == 0x000008, "Wrong alignment on UHLLRadialMenu_ChatSegment");
static_assert(sizeof(UHLLRadialMenu_ChatSegment) == 0x000288, "Wrong size on UHLLRadialMenu_ChatSegment");
static_assert(offsetof(UHLLRadialMenu_ChatSegment, ChatType) == 0x000278, "Member 'UHLLRadialMenu_ChatSegment::ChatType' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_ChatSegment, ChatIcon) == 0x000280, "Member 'UHLLRadialMenu_ChatSegment::ChatIcon' has a wrong offset!");

// Class HLL.HLLDeploymentScreen
// 0x0000 (0x0230 - 0x0230)
class UHLLDeploymentScreen : public UUserWidget
{
public:
	void ForceCancelDeploy();
	bool HasValidParty();
	void OnRoleSelectionEnabledChange(const bool bEnabled);
	void OnSpawnPointNotAvailable();
	bool TriggerDeployFailedMessage(const class FText& Message);

	class FText GetCommanderNameText() const;
	class UHLLDeploymentMap* GetDeploymentMap() const;
	ETeam GetPracticeRangeTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDeploymentScreen">();
	}
	static class UHLLDeploymentScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDeploymentScreen>();
	}
};
static_assert(alignof(UHLLDeploymentScreen) == 0x000008, "Wrong alignment on UHLLDeploymentScreen");
static_assert(sizeof(UHLLDeploymentScreen) == 0x000230, "Wrong size on UHLLDeploymentScreen");

// Class HLL.GameInstanceUserEngagementSS
// 0x0018 (0x0048 - 0x0030)
class UGameInstanceUserEngagementSS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_11A4[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInstanceUserEngagementSS">();
	}
	static class UGameInstanceUserEngagementSS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInstanceUserEngagementSS>();
	}
};
static_assert(alignof(UGameInstanceUserEngagementSS) == 0x000008, "Wrong alignment on UGameInstanceUserEngagementSS");
static_assert(sizeof(UGameInstanceUserEngagementSS) == 0x000048, "Wrong size on UGameInstanceUserEngagementSS");

// Class HLL.GameModeMetaDataAsset
// 0x00F0 (0x0120 - 0x0030)
class UGameModeMetaDataAsset final : public UDataAsset
{
public:
	TSubclassOf<class ABaseShooterGameMode>       GameMode;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         AttackingTeam;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         PracticeRangeTeam;                                 // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A5[0x6];                                     // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<TSoftObjectPtr<class UWorld>>          LevelsToLoad;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapLayoutMetaDataAsset*                LayoutMetaDataAsset;                               // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHLLSectorDefinition>           SectorDefinitions;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EDivision>                             CosmeticDivisions;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapAbilityData*                     AxisAbilityData;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapAbilityData*                     AlliesAbilityData;                                 // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLWeatherManagerData*                 WeatherManagerData;                                // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseConquestRuleset;                               // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A6[0x1];                                     // 0x0091(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	uint16                                        InitialConquestTickets;                            // 0x0092(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverridePlatoonData;                              // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A7[0x3];                                     // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UPlatoonOverrideData*                   PlatoonOverride;                                   // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlliesOverrideLoadoutData;                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A8[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UWeaponOverrideData*                    AlliesLoadoutOverride;                             // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAxisOverrideLoadoutData;                          // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A9[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UWeaponOverrideData*                    AxisLoadoutOverride;                               // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAlliesCommanderData;                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AA[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UCommanderOverrideData*                 AlliesCommanderOverrideData;                       // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAxisCommanderData;                        // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AB[0x7];                                     // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UCommanderOverrideData*                 AxisCommanderOverrideData;                         // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAlliesResourceData;                       // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AC[0x7];                                     // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UResourceOverrideData*                  AlliesResourceOverrideData;                        // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAxisResourceData;                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AD[0x7];                                     // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UResourceOverrideData*                  AxisResourceOverrideData;                          // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAlliesStatsData;                          // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AE[0x7];                                     // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UPersonalStatsListDataAsset*            AlliesStatsOverrideData;                           // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAxisStatsData;                            // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AF[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UPersonalStatsListDataAsset*            AxisStatsOverrideData;                             // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeMetaDataAsset">();
	}
	static class UGameModeMetaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameModeMetaDataAsset>();
	}
};
static_assert(alignof(UGameModeMetaDataAsset) == 0x000008, "Wrong alignment on UGameModeMetaDataAsset");
static_assert(sizeof(UGameModeMetaDataAsset) == 0x000120, "Wrong size on UGameModeMetaDataAsset");
static_assert(offsetof(UGameModeMetaDataAsset, GameMode) == 0x000030, "Member 'UGameModeMetaDataAsset::GameMode' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AttackingTeam) == 0x000038, "Member 'UGameModeMetaDataAsset::AttackingTeam' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, PracticeRangeTeam) == 0x000039, "Member 'UGameModeMetaDataAsset::PracticeRangeTeam' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, LevelsToLoad) == 0x000040, "Member 'UGameModeMetaDataAsset::LevelsToLoad' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, LayoutMetaDataAsset) == 0x000050, "Member 'UGameModeMetaDataAsset::LayoutMetaDataAsset' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, SectorDefinitions) == 0x000058, "Member 'UGameModeMetaDataAsset::SectorDefinitions' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, CosmeticDivisions) == 0x000068, "Member 'UGameModeMetaDataAsset::CosmeticDivisions' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AxisAbilityData) == 0x000078, "Member 'UGameModeMetaDataAsset::AxisAbilityData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AlliesAbilityData) == 0x000080, "Member 'UGameModeMetaDataAsset::AlliesAbilityData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, WeatherManagerData) == 0x000088, "Member 'UGameModeMetaDataAsset::WeatherManagerData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bUseConquestRuleset) == 0x000090, "Member 'UGameModeMetaDataAsset::bUseConquestRuleset' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, InitialConquestTickets) == 0x000092, "Member 'UGameModeMetaDataAsset::InitialConquestTickets' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bOverridePlatoonData) == 0x000094, "Member 'UGameModeMetaDataAsset::bOverridePlatoonData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, PlatoonOverride) == 0x000098, "Member 'UGameModeMetaDataAsset::PlatoonOverride' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bAlliesOverrideLoadoutData) == 0x0000A0, "Member 'UGameModeMetaDataAsset::bAlliesOverrideLoadoutData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AlliesLoadoutOverride) == 0x0000A8, "Member 'UGameModeMetaDataAsset::AlliesLoadoutOverride' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bAxisOverrideLoadoutData) == 0x0000B0, "Member 'UGameModeMetaDataAsset::bAxisOverrideLoadoutData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AxisLoadoutOverride) == 0x0000B8, "Member 'UGameModeMetaDataAsset::AxisLoadoutOverride' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bOverrideAlliesCommanderData) == 0x0000C0, "Member 'UGameModeMetaDataAsset::bOverrideAlliesCommanderData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AlliesCommanderOverrideData) == 0x0000C8, "Member 'UGameModeMetaDataAsset::AlliesCommanderOverrideData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bOverrideAxisCommanderData) == 0x0000D0, "Member 'UGameModeMetaDataAsset::bOverrideAxisCommanderData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AxisCommanderOverrideData) == 0x0000D8, "Member 'UGameModeMetaDataAsset::AxisCommanderOverrideData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bOverrideAlliesResourceData) == 0x0000E0, "Member 'UGameModeMetaDataAsset::bOverrideAlliesResourceData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AlliesResourceOverrideData) == 0x0000E8, "Member 'UGameModeMetaDataAsset::AlliesResourceOverrideData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bOverrideAxisResourceData) == 0x0000F0, "Member 'UGameModeMetaDataAsset::bOverrideAxisResourceData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AxisResourceOverrideData) == 0x0000F8, "Member 'UGameModeMetaDataAsset::AxisResourceOverrideData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bOverrideAlliesStatsData) == 0x000100, "Member 'UGameModeMetaDataAsset::bOverrideAlliesStatsData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AlliesStatsOverrideData) == 0x000108, "Member 'UGameModeMetaDataAsset::AlliesStatsOverrideData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, bOverrideAxisStatsData) == 0x000110, "Member 'UGameModeMetaDataAsset::bOverrideAxisStatsData' has a wrong offset!");
static_assert(offsetof(UGameModeMetaDataAsset, AxisStatsOverrideData) == 0x000118, "Member 'UGameModeMetaDataAsset::AxisStatsOverrideData' has a wrong offset!");

// Class HLL.VolumeResponsesTool
// 0x0000 (0x0228 - 0x0228)
class AVolumeResponsesTool final : public ACollisionToolBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VolumeResponsesTool">();
	}
	static class AVolumeResponsesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVolumeResponsesTool>();
	}
};
static_assert(alignof(AVolumeResponsesTool) == 0x000008, "Wrong alignment on AVolumeResponsesTool");
static_assert(sizeof(AVolumeResponsesTool) == 0x000228, "Wrong size on AVolumeResponsesTool");

// Class HLL.GameModeObjectivesData
// 0x0008 (0x0038 - 0x0030)
class UGameModeObjectivesData final : public UDataAsset
{
public:
	EHLLWinState                                  ObjectivesCompletedCondition;                      // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHLLWinState                                  MatchTimeoutCondition;                             // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B0[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeObjectivesData">();
	}
	static class UGameModeObjectivesData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameModeObjectivesData>();
	}
};
static_assert(alignof(UGameModeObjectivesData) == 0x000008, "Wrong alignment on UGameModeObjectivesData");
static_assert(sizeof(UGameModeObjectivesData) == 0x000038, "Wrong size on UGameModeObjectivesData");
static_assert(offsetof(UGameModeObjectivesData, ObjectivesCompletedCondition) == 0x000030, "Member 'UGameModeObjectivesData::ObjectivesCompletedCondition' has a wrong offset!");
static_assert(offsetof(UGameModeObjectivesData, MatchTimeoutCondition) == 0x000031, "Member 'UGameModeObjectivesData::MatchTimeoutCondition' has a wrong offset!");

// Class HLL.HLLDispenserItem_Garrison
// 0x0008 (0x0588 - 0x0580)
class AHLLDispenserItem_Garrison : public AHLLDispenserItem_DynamicSpawnGhost
{
public:
	uint8                                         bAutoDestroyGarrisonsPlacedByOtherOfficers : 1;    // 0x0580(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11B1[0x7];                                     // 0x0581(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_Garrison">();
	}
	static class AHLLDispenserItem_Garrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_Garrison>();
	}
};
static_assert(alignof(AHLLDispenserItem_Garrison) == 0x000008, "Wrong alignment on AHLLDispenserItem_Garrison");
static_assert(sizeof(AHLLDispenserItem_Garrison) == 0x000588, "Wrong size on AHLLDispenserItem_Garrison");

// Class HLL.HLLDispenserItem_ForwardPosition
// 0x0000 (0x0588 - 0x0588)
class AHLLDispenserItem_ForwardPosition : public AHLLDispenserItem_Garrison
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_ForwardPosition">();
	}
	static class AHLLDispenserItem_ForwardPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_ForwardPosition>();
	}
};
static_assert(alignof(AHLLDispenserItem_ForwardPosition) == 0x000008, "Wrong alignment on AHLLDispenserItem_ForwardPosition");
static_assert(sizeof(AHLLDispenserItem_ForwardPosition) == 0x000588, "Wrong size on AHLLDispenserItem_ForwardPosition");

// Class HLL.GameObjectiveBase
// 0x0018 (0x0238 - 0x0220)
class AGameObjectiveBase : public AActor
{
public:
	TArray<int32>                                 LinkedSectorsTerritories;                          // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ObjectivePhaseID;                                  // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ObjectiveActive;                                   // 0x0234(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ActiveForMatch;                                    // 0x0235(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B2[0x2];                                     // 0x0236(0x0002)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool GetIsActiveForMatch() const;
	bool IsObjectiveActive() const;
	bool ObjectiveCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjectiveBase">();
	}
	static class AGameObjectiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjectiveBase>();
	}
};
static_assert(alignof(AGameObjectiveBase) == 0x000008, "Wrong alignment on AGameObjectiveBase");
static_assert(sizeof(AGameObjectiveBase) == 0x000238, "Wrong size on AGameObjectiveBase");
static_assert(offsetof(AGameObjectiveBase, LinkedSectorsTerritories) == 0x000220, "Member 'AGameObjectiveBase::LinkedSectorsTerritories' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, ObjectivePhaseID) == 0x000230, "Member 'AGameObjectiveBase::ObjectivePhaseID' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, ObjectiveActive) == 0x000234, "Member 'AGameObjectiveBase::ObjectiveActive' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, ActiveForMatch) == 0x000235, "Member 'AGameObjectiveBase::ActiveForMatch' has a wrong offset!");

// Class HLL.HLLRadialMenu_WeaponSegment
// 0x0058 (0x02D0 - 0x0278)
class UHLLRadialMenu_WeaponSegment : public UHLLRadialMenu_Segment
{
public:
	uint8                                         Pad_11B3[0x4C];                                    // 0x0278(0x004C)(Fixing Size After Last Property [ Dumper-69 ])
	EWeaponType                                   WeaponType;                                        // 0x02C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11B4[0x3];                                     // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 WeaponIcon;                                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_WeaponSegment">();
	}
	static class UHLLRadialMenu_WeaponSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_WeaponSegment>();
	}
};
static_assert(alignof(UHLLRadialMenu_WeaponSegment) == 0x000008, "Wrong alignment on UHLLRadialMenu_WeaponSegment");
static_assert(sizeof(UHLLRadialMenu_WeaponSegment) == 0x0002D0, "Wrong size on UHLLRadialMenu_WeaponSegment");
static_assert(offsetof(UHLLRadialMenu_WeaponSegment, WeaponType) == 0x0002C4, "Member 'UHLLRadialMenu_WeaponSegment::WeaponType' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_WeaponSegment, WeaponIcon) == 0x0002C8, "Member 'UHLLRadialMenu_WeaponSegment::WeaponIcon' has a wrong offset!");

// Class HLL.HLLCosmeticCharacter
// 0x0150 (0x0370 - 0x0220)
class AHLLCosmeticCharacter : public AActor
{
public:
	TMap<EFaction, class FName>                   DefaultFactionUniformID;                           // 0x0220(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EFaction, class FName>                   DefaultFactionHelmetID;                            // 0x0270(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EFaction, class FName>                   DefaultFactionHeadID;                              // 0x02C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         YawLimit;                                          // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawInterpSpeed;                                    // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowRotation;                                    // 0x0318(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11B5[0xF];                                     // 0x0319(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        DummyRoot;                                         // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 UniformMesh;                                       // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 HeadMesh;                                          // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HelmetMesh;                                        // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   AccessoryMesh;                                     // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MeshHideMaterial;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CachedBackpackMaterial;                            // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11B6[0x8];                                     // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnTeamChanged();
	void SetEnableRotation(const bool bNewValue);
	void SetYawTarget(const float InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCosmeticCharacter">();
	}
	static class AHLLCosmeticCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCosmeticCharacter>();
	}
};
static_assert(alignof(AHLLCosmeticCharacter) == 0x000008, "Wrong alignment on AHLLCosmeticCharacter");
static_assert(sizeof(AHLLCosmeticCharacter) == 0x000370, "Wrong size on AHLLCosmeticCharacter");
static_assert(offsetof(AHLLCosmeticCharacter, DefaultFactionUniformID) == 0x000220, "Member 'AHLLCosmeticCharacter::DefaultFactionUniformID' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, DefaultFactionHelmetID) == 0x000270, "Member 'AHLLCosmeticCharacter::DefaultFactionHelmetID' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, DefaultFactionHeadID) == 0x0002C0, "Member 'AHLLCosmeticCharacter::DefaultFactionHeadID' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, YawLimit) == 0x000310, "Member 'AHLLCosmeticCharacter::YawLimit' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, YawInterpSpeed) == 0x000314, "Member 'AHLLCosmeticCharacter::YawInterpSpeed' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, bAllowRotation) == 0x000318, "Member 'AHLLCosmeticCharacter::bAllowRotation' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, DummyRoot) == 0x000328, "Member 'AHLLCosmeticCharacter::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, UniformMesh) == 0x000330, "Member 'AHLLCosmeticCharacter::UniformMesh' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, HeadMesh) == 0x000338, "Member 'AHLLCosmeticCharacter::HeadMesh' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, HelmetMesh) == 0x000340, "Member 'AHLLCosmeticCharacter::HelmetMesh' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, AccessoryMesh) == 0x000348, "Member 'AHLLCosmeticCharacter::AccessoryMesh' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, WeaponMesh) == 0x000350, "Member 'AHLLCosmeticCharacter::WeaponMesh' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, MeshHideMaterial) == 0x000358, "Member 'AHLLCosmeticCharacter::MeshHideMaterial' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacter, CachedBackpackMaterial) == 0x000360, "Member 'AHLLCosmeticCharacter::CachedBackpackMaterial' has a wrong offset!");

// Class HLL.HLLCosmeticCharacterRenderer
// 0x0010 (0x0380 - 0x0370)
class AHLLCosmeticCharacterRenderer : public AHLLCosmeticCharacter
{
public:
	class UCineCameraComponent*                   ViewCamera;                                        // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BackgroundMesh;                                    // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCosmeticCharacterRenderer">();
	}
	static class AHLLCosmeticCharacterRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCosmeticCharacterRenderer>();
	}
};
static_assert(alignof(AHLLCosmeticCharacterRenderer) == 0x000008, "Wrong alignment on AHLLCosmeticCharacterRenderer");
static_assert(sizeof(AHLLCosmeticCharacterRenderer) == 0x000380, "Wrong size on AHLLCosmeticCharacterRenderer");
static_assert(offsetof(AHLLCosmeticCharacterRenderer, ViewCamera) == 0x000370, "Member 'AHLLCosmeticCharacterRenderer::ViewCamera' has a wrong offset!");
static_assert(offsetof(AHLLCosmeticCharacterRenderer, BackgroundMesh) == 0x000378, "Member 'AHLLCosmeticCharacterRenderer::BackgroundMesh' has a wrong offset!");

// Class HLL.GameObjectivePhaseContainer
// 0x00C8 (0x02E8 - 0x0220)
class AGameObjectivePhaseContainer final : public AActor
{
public:
	class FText                                   DefaultTitle;                                      // 0x0220(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   DefaultDescription;                                // 0x0238(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAlliesTitle;                              // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B7[0x7];                                     // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   AlliesTitle;                                       // 0x0258(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAxisTitle;                                // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B8[0x7];                                     // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   AxisTitle;                                         // 0x0278(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAlliesDescription;                        // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B9[0x7];                                     // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   AlliesDescription;                                 // 0x0298(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAxisDescription;                          // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11BA[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   AxisDescription;                                   // 0x02B8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint32                                        PhaseID;                                           // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         DefensiveTeam;                                     // 0x02D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          PreventPhaseTransition;                            // 0x02D5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPhaseTimeoutState                            PhaseTimeoutCondition;                             // 0x02D6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnabledRandomObjective;                            // 0x02D7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGameObjectiveBase*>             GameObjectives;                                    // 0x02D8(0x0010)(Edit, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MultiSetGameObjectiveActive(const bool IsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjectivePhaseContainer">();
	}
	static class AGameObjectivePhaseContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjectivePhaseContainer>();
	}
};
static_assert(alignof(AGameObjectivePhaseContainer) == 0x000008, "Wrong alignment on AGameObjectivePhaseContainer");
static_assert(sizeof(AGameObjectivePhaseContainer) == 0x0002E8, "Wrong size on AGameObjectivePhaseContainer");
static_assert(offsetof(AGameObjectivePhaseContainer, DefaultTitle) == 0x000220, "Member 'AGameObjectivePhaseContainer::DefaultTitle' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, DefaultDescription) == 0x000238, "Member 'AGameObjectivePhaseContainer::DefaultDescription' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, bOverrideAlliesTitle) == 0x000250, "Member 'AGameObjectivePhaseContainer::bOverrideAlliesTitle' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, AlliesTitle) == 0x000258, "Member 'AGameObjectivePhaseContainer::AlliesTitle' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, bOverrideAxisTitle) == 0x000270, "Member 'AGameObjectivePhaseContainer::bOverrideAxisTitle' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, AxisTitle) == 0x000278, "Member 'AGameObjectivePhaseContainer::AxisTitle' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, bOverrideAlliesDescription) == 0x000290, "Member 'AGameObjectivePhaseContainer::bOverrideAlliesDescription' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, AlliesDescription) == 0x000298, "Member 'AGameObjectivePhaseContainer::AlliesDescription' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, bOverrideAxisDescription) == 0x0002B0, "Member 'AGameObjectivePhaseContainer::bOverrideAxisDescription' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, AxisDescription) == 0x0002B8, "Member 'AGameObjectivePhaseContainer::AxisDescription' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, PhaseID) == 0x0002D0, "Member 'AGameObjectivePhaseContainer::PhaseID' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, DefensiveTeam) == 0x0002D4, "Member 'AGameObjectivePhaseContainer::DefensiveTeam' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, PreventPhaseTransition) == 0x0002D5, "Member 'AGameObjectivePhaseContainer::PreventPhaseTransition' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, PhaseTimeoutCondition) == 0x0002D6, "Member 'AGameObjectivePhaseContainer::PhaseTimeoutCondition' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, EnabledRandomObjective) == 0x0002D7, "Member 'AGameObjectivePhaseContainer::EnabledRandomObjective' has a wrong offset!");
static_assert(offsetof(AGameObjectivePhaseContainer, GameObjectives) == 0x0002D8, "Member 'AGameObjectivePhaseContainer::GameObjectives' has a wrong offset!");

// Class HLL.RCONCommandServerMessage
// 0x0000 (0x0028 - 0x0028)
class URCONCommandServerMessage final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandServerMessage">();
	}
	static class URCONCommandServerMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandServerMessage>();
	}
};
static_assert(alignof(URCONCommandServerMessage) == 0x000008, "Wrong alignment on URCONCommandServerMessage");
static_assert(sizeof(URCONCommandServerMessage) == 0x000028, "Wrong size on URCONCommandServerMessage");

// Class HLL.GamepadRTBImageDecorator
// 0x0028 (0x0058 - 0x0030)
class UGamepadRTBImageDecorator : public URichTextBlockImageDecorator
{
public:
	TSoftObjectPtr<class UDataTable>              ControllerButtonIcons;                             // 0x0030(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadRTBImageDecorator">();
	}
	static class UGamepadRTBImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadRTBImageDecorator>();
	}
};
static_assert(alignof(UGamepadRTBImageDecorator) == 0x000008, "Wrong alignment on UGamepadRTBImageDecorator");
static_assert(sizeof(UGamepadRTBImageDecorator) == 0x000058, "Wrong size on UGamepadRTBImageDecorator");
static_assert(offsetof(UGamepadRTBImageDecorator, ControllerButtonIcons) == 0x000030, "Member 'UGamepadRTBImageDecorator::ControllerButtonIcons' has a wrong offset!");

// Class HLL.GameTimerWidget
// 0x0020 (0x0250 - 0x0230)
class UGameTimerWidget : public UUserWidget
{
public:
	class UTextBlock*                             Text;                                              // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UContentWidget*                         ManpowerIconPanel;                                 // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ResetToNormalState;                                // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OverTime;                                          // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetText(const class FText& TimerText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameTimerWidget">();
	}
	static class UGameTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameTimerWidget>();
	}
};
static_assert(alignof(UGameTimerWidget) == 0x000008, "Wrong alignment on UGameTimerWidget");
static_assert(sizeof(UGameTimerWidget) == 0x000250, "Wrong size on UGameTimerWidget");
static_assert(offsetof(UGameTimerWidget, Text) == 0x000230, "Member 'UGameTimerWidget::Text' has a wrong offset!");
static_assert(offsetof(UGameTimerWidget, ManpowerIconPanel) == 0x000238, "Member 'UGameTimerWidget::ManpowerIconPanel' has a wrong offset!");
static_assert(offsetof(UGameTimerWidget, ResetToNormalState) == 0x000240, "Member 'UGameTimerWidget::ResetToNormalState' has a wrong offset!");
static_assert(offsetof(UGameTimerWidget, OverTime) == 0x000248, "Member 'UGameTimerWidget::OverTime' has a wrong offset!");

// Class HLL.GarrisonDestroyedBySatchelAchievement
// 0x0008 (0x0038 - 0x0030)
class UGarrisonDestroyedBySatchelAchievement final : public UObjectDestroyedAchievement
{
public:
	EHLLAchievement                               UnlockAchievement;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11BB[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GarrisonDestroyedBySatchelAchievement">();
	}
	static class UGarrisonDestroyedBySatchelAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGarrisonDestroyedBySatchelAchievement>();
	}
};
static_assert(alignof(UGarrisonDestroyedBySatchelAchievement) == 0x000008, "Wrong alignment on UGarrisonDestroyedBySatchelAchievement");
static_assert(sizeof(UGarrisonDestroyedBySatchelAchievement) == 0x000038, "Wrong size on UGarrisonDestroyedBySatchelAchievement");
static_assert(offsetof(UGarrisonDestroyedBySatchelAchievement, UnlockAchievement) == 0x000030, "Member 'UGarrisonDestroyedBySatchelAchievement::UnlockAchievement' has a wrong offset!");

// Class HLL.Greyhound
// 0x0000 (0x05C0 - 0x05C0)
class AGreyhound final : public ABaseReconVehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Greyhound">();
	}
	static class AGreyhound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGreyhound>();
	}
};
static_assert(alignof(AGreyhound) == 0x000008, "Wrong alignment on AGreyhound");
static_assert(sizeof(AGreyhound) == 0x0005C0, "Wrong size on AGreyhound");

// Class HLL.HLLDamageVolumeComponent
// 0x0030 (0x0450 - 0x0420)
class UHLLDamageVolumeComponent final : public UBoxComponent
{
public:
	TArray<struct FDamageVolumeTracker>           DamageTracker;                                     // 0x0420(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UShooterDamageType>         DamageType;                                        // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageInterval;                                    // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialDamageDelay;                                // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bConsiderAsSelfInflicted : 1;                      // 0x0444(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsePawnEyeLocation : 1;                           // 0x0444(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11BC[0x3];                                     // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         EyeVerticalOffset;                                 // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11BD[0x4];                                     // 0x044C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDamageVolumeComponent">();
	}
	static class UHLLDamageVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDamageVolumeComponent>();
	}
};
static_assert(alignof(UHLLDamageVolumeComponent) == 0x000010, "Wrong alignment on UHLLDamageVolumeComponent");
static_assert(sizeof(UHLLDamageVolumeComponent) == 0x000450, "Wrong size on UHLLDamageVolumeComponent");
static_assert(offsetof(UHLLDamageVolumeComponent, DamageTracker) == 0x000420, "Member 'UHLLDamageVolumeComponent::DamageTracker' has a wrong offset!");
static_assert(offsetof(UHLLDamageVolumeComponent, DamageType) == 0x000430, "Member 'UHLLDamageVolumeComponent::DamageType' has a wrong offset!");
static_assert(offsetof(UHLLDamageVolumeComponent, Damage) == 0x000438, "Member 'UHLLDamageVolumeComponent::Damage' has a wrong offset!");
static_assert(offsetof(UHLLDamageVolumeComponent, DamageInterval) == 0x00043C, "Member 'UHLLDamageVolumeComponent::DamageInterval' has a wrong offset!");
static_assert(offsetof(UHLLDamageVolumeComponent, InitialDamageDelay) == 0x000440, "Member 'UHLLDamageVolumeComponent::InitialDamageDelay' has a wrong offset!");
static_assert(offsetof(UHLLDamageVolumeComponent, EyeVerticalOffset) == 0x000448, "Member 'UHLLDamageVolumeComponent::EyeVerticalOffset' has a wrong offset!");

// Class HLL.RCONCommandResetVoteKickThreshold
// 0x0000 (0x0028 - 0x0028)
class URCONCommandResetVoteKickThreshold final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandResetVoteKickThreshold">();
	}
	static class URCONCommandResetVoteKickThreshold* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandResetVoteKickThreshold>();
	}
};
static_assert(alignof(URCONCommandResetVoteKickThreshold) == 0x000008, "Wrong alignment on URCONCommandResetVoteKickThreshold");
static_assert(sizeof(URCONCommandResetVoteKickThreshold) == 0x000028, "Wrong size on URCONCommandResetVoteKickThreshold");

// Class HLL.VehicleDriverSeatUI
// 0x0060 (0x02D0 - 0x0270)
class UVehicleDriverSeatUI : public UHLLSeatWidgetBase
{
public:
	float                                         RPMSmoothingAlpha;                                 // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleRPM;                                           // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11BE[0x8];                                     // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SpeedSmoothingAlpha;                               // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11BF[0x4];                                     // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLDial_Speedometer*                   Speedometer;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHLLDial_Tachometer*                    Tachometer;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           EngineProgressPanel;                               // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        EngineProgressTextSwitcher;                        // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             Starting;                                          // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             Stopping;                                          // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 EngineProgressWheel;                               // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextBlock*                         EngineKeyText;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextBlock*                         GearKeyText;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleDriverSeatUI">();
	}
	static class UVehicleDriverSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleDriverSeatUI>();
	}
};
static_assert(alignof(UVehicleDriverSeatUI) == 0x000008, "Wrong alignment on UVehicleDriverSeatUI");
static_assert(sizeof(UVehicleDriverSeatUI) == 0x0002D0, "Wrong size on UVehicleDriverSeatUI");
static_assert(offsetof(UVehicleDriverSeatUI, RPMSmoothingAlpha) == 0x000270, "Member 'UVehicleDriverSeatUI::RPMSmoothingAlpha' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, IdleRPM) == 0x000274, "Member 'UVehicleDriverSeatUI::IdleRPM' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, SpeedSmoothingAlpha) == 0x000280, "Member 'UVehicleDriverSeatUI::SpeedSmoothingAlpha' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, Speedometer) == 0x000288, "Member 'UVehicleDriverSeatUI::Speedometer' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, Tachometer) == 0x000290, "Member 'UVehicleDriverSeatUI::Tachometer' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, EngineProgressPanel) == 0x000298, "Member 'UVehicleDriverSeatUI::EngineProgressPanel' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, EngineProgressTextSwitcher) == 0x0002A0, "Member 'UVehicleDriverSeatUI::EngineProgressTextSwitcher' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, Starting) == 0x0002A8, "Member 'UVehicleDriverSeatUI::Starting' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, Stopping) == 0x0002B0, "Member 'UVehicleDriverSeatUI::Stopping' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, EngineProgressWheel) == 0x0002B8, "Member 'UVehicleDriverSeatUI::EngineProgressWheel' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, EngineKeyText) == 0x0002C0, "Member 'UVehicleDriverSeatUI::EngineKeyText' has a wrong offset!");
static_assert(offsetof(UVehicleDriverSeatUI, GearKeyText) == 0x0002C8, "Member 'UVehicleDriverSeatUI::GearKeyText' has a wrong offset!");

// Class HLL.TruckDriverSeatUI
// 0x0040 (0x0310 - 0x02D0)
class UTruckDriverSeatUI : public UVehicleDriverSeatUI
{
public:
	class UPanelWidget*                           DropsPanel;                                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             DropCount;                                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           DropActionPanel;                                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 DropProgressWheel;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        DropsStatusSwitcher;                               // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           DropBlockedPanel;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           DropInProgressPanel;                               // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextBlock*                         SuppliesKeyHint;                                   // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSuppliesAdded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TruckDriverSeatUI">();
	}
	static class UTruckDriverSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTruckDriverSeatUI>();
	}
};
static_assert(alignof(UTruckDriverSeatUI) == 0x000008, "Wrong alignment on UTruckDriverSeatUI");
static_assert(sizeof(UTruckDriverSeatUI) == 0x000310, "Wrong size on UTruckDriverSeatUI");
static_assert(offsetof(UTruckDriverSeatUI, DropsPanel) == 0x0002D0, "Member 'UTruckDriverSeatUI::DropsPanel' has a wrong offset!");
static_assert(offsetof(UTruckDriverSeatUI, DropCount) == 0x0002D8, "Member 'UTruckDriverSeatUI::DropCount' has a wrong offset!");
static_assert(offsetof(UTruckDriverSeatUI, DropActionPanel) == 0x0002E0, "Member 'UTruckDriverSeatUI::DropActionPanel' has a wrong offset!");
static_assert(offsetof(UTruckDriverSeatUI, DropProgressWheel) == 0x0002E8, "Member 'UTruckDriverSeatUI::DropProgressWheel' has a wrong offset!");
static_assert(offsetof(UTruckDriverSeatUI, DropsStatusSwitcher) == 0x0002F0, "Member 'UTruckDriverSeatUI::DropsStatusSwitcher' has a wrong offset!");
static_assert(offsetof(UTruckDriverSeatUI, DropBlockedPanel) == 0x0002F8, "Member 'UTruckDriverSeatUI::DropBlockedPanel' has a wrong offset!");
static_assert(offsetof(UTruckDriverSeatUI, DropInProgressPanel) == 0x000300, "Member 'UTruckDriverSeatUI::DropInProgressPanel' has a wrong offset!");
static_assert(offsetof(UTruckDriverSeatUI, SuppliesKeyHint) == 0x000308, "Member 'UTruckDriverSeatUI::SuppliesKeyHint' has a wrong offset!");

// Class HLL.HLLAudioVolumeComponent
// 0x0050 (0x0470 - 0x0420)
class UHLLAudioVolumeComponent final : public UBoxComponent
{
public:
	float                                         Priority;                                          // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C0[0x4];                                     // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FReverbSettings                        ReverbSettings;                                    // 0x0428(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FInteriorSettings                      InteriorSettings;                                  // 0x0448(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EAudioVolumeType                              VolumeType;                                        // 0x046C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C1[0x3];                                     // 0x046D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAudioVolumeComponent">();
	}
	static class UHLLAudioVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAudioVolumeComponent>();
	}
};
static_assert(alignof(UHLLAudioVolumeComponent) == 0x000010, "Wrong alignment on UHLLAudioVolumeComponent");
static_assert(sizeof(UHLLAudioVolumeComponent) == 0x000470, "Wrong size on UHLLAudioVolumeComponent");
static_assert(offsetof(UHLLAudioVolumeComponent, Priority) == 0x000420, "Member 'UHLLAudioVolumeComponent::Priority' has a wrong offset!");
static_assert(offsetof(UHLLAudioVolumeComponent, ReverbSettings) == 0x000428, "Member 'UHLLAudioVolumeComponent::ReverbSettings' has a wrong offset!");
static_assert(offsetof(UHLLAudioVolumeComponent, InteriorSettings) == 0x000448, "Member 'UHLLAudioVolumeComponent::InteriorSettings' has a wrong offset!");
static_assert(offsetof(UHLLAudioVolumeComponent, VolumeType) == 0x00046C, "Member 'UHLLAudioVolumeComponent::VolumeType' has a wrong offset!");

// Class HLL.RCONCommandSetMatchTimer
// 0x0018 (0x0040 - 0x0028)
class URCONCommandSetMatchTimer final : public URCONCommand
{
public:
	uint8                                         Pad_11C2[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetMatchTimer">();
	}
	static class URCONCommandSetMatchTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetMatchTimer>();
	}
};
static_assert(alignof(URCONCommandSetMatchTimer) == 0x000008, "Wrong alignment on URCONCommandSetMatchTimer");
static_assert(sizeof(URCONCommandSetMatchTimer) == 0x000040, "Wrong size on URCONCommandSetMatchTimer");

// Class HLL.HalftrackDriverSeatUI
// 0x0010 (0x0320 - 0x0310)
class UHalftrackDriverSeatUI final : public UTruckDriverSeatUI
{
public:
	class UTextBlock*                             DeploymentAvailability;                            // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           DeploymentAvailabilityPanel;                       // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HalftrackDriverSeatUI">();
	}
	static class UHalftrackDriverSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHalftrackDriverSeatUI>();
	}
};
static_assert(alignof(UHalftrackDriverSeatUI) == 0x000008, "Wrong alignment on UHalftrackDriverSeatUI");
static_assert(sizeof(UHalftrackDriverSeatUI) == 0x000320, "Wrong size on UHalftrackDriverSeatUI");
static_assert(offsetof(UHalftrackDriverSeatUI, DeploymentAvailability) == 0x000310, "Member 'UHalftrackDriverSeatUI::DeploymentAvailability' has a wrong offset!");
static_assert(offsetof(UHalftrackDriverSeatUI, DeploymentAvailabilityPanel) == 0x000318, "Member 'UHalftrackDriverSeatUI::DeploymentAvailabilityPanel' has a wrong offset!");

// Class HLL.HLLDispenserItem_ResourceNode
// 0x0038 (0x0590 - 0x0558)
class AHLLDispenserItem_ResourceNode : public AHLLDispenserItem_StructureAdv
{
public:
	class FText                                   InvalidPlacement_BaseSector;                       // 0x0558(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlacement_NoFrontline;                      // 0x0570(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C3[0x8];                                     // 0x0588(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_ResourceNode">();
	}
	static class AHLLDispenserItem_ResourceNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_ResourceNode>();
	}
};
static_assert(alignof(AHLLDispenserItem_ResourceNode) == 0x000008, "Wrong alignment on AHLLDispenserItem_ResourceNode");
static_assert(sizeof(AHLLDispenserItem_ResourceNode) == 0x000590, "Wrong size on AHLLDispenserItem_ResourceNode");
static_assert(offsetof(AHLLDispenserItem_ResourceNode, InvalidPlacement_BaseSector) == 0x000558, "Member 'AHLLDispenserItem_ResourceNode::InvalidPlacement_BaseSector' has a wrong offset!");
static_assert(offsetof(AHLLDispenserItem_ResourceNode, InvalidPlacement_NoFrontline) == 0x000570, "Member 'AHLLDispenserItem_ResourceNode::InvalidPlacement_NoFrontline' has a wrong offset!");

// Class HLL.RCONServerInfoPlayers
// 0x0000 (0x0028 - 0x0028)
class URCONServerInfoPlayers final : public URCONServerInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerInfoPlayers">();
	}
	static class URCONServerInfoPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerInfoPlayers>();
	}
};
static_assert(alignof(URCONServerInfoPlayers) == 0x000008, "Wrong alignment on URCONServerInfoPlayers");
static_assert(sizeof(URCONServerInfoPlayers) == 0x000028, "Wrong size on URCONServerInfoPlayers");

// Class HLL.HalfTrackGunnerSeat
// 0x0020 (0x09F0 - 0x09D0)
class AHalfTrackGunnerSeat final : public AVehicleSeatBase
{
public:
	uint8                                         Pad_11C4[0x10];                                    // 0x09C8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UVehicleMGController*                   MGController;                                      // 0x09D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C5[0x10];                                    // 0x09E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Server_UpdateMGRotation(const uint16 PackedRotation);
	void Server_UpdateTurretRotation(const struct FPitchYawControllerTargetRotationValues& TargetRotation);

	struct FRotator GetMGRotation() const;
	struct FRotator GetTurretRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HalfTrackGunnerSeat">();
	}
	static class AHalfTrackGunnerSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHalfTrackGunnerSeat>();
	}
};
static_assert(alignof(AHalfTrackGunnerSeat) == 0x000010, "Wrong alignment on AHalfTrackGunnerSeat");
static_assert(sizeof(AHalfTrackGunnerSeat) == 0x0009F0, "Wrong size on AHalfTrackGunnerSeat");
static_assert(offsetof(AHalfTrackGunnerSeat, MGController) == 0x0009D8, "Member 'AHalfTrackGunnerSeat::MGController' has a wrong offset!");

// Class HLL.HLLBallisticsDebugger
// 0x0000 (0x0220 - 0x0220)
class AHLLBallisticsDebugger final : public AActor
{
public:
	void DrawHit(const struct FVector& Hit);
	void DrawHitVerify(const bool bSuccess, const struct FVector& Location, const struct FVector& LineB, const struct FVector& LineT);
	void DrawLatentHitVerify(const bool bSuccess, const struct FVector& Location, const struct FVector& LineB, const struct FVector& LineT, const struct FVector& OriginalLocation);
	void DrawSample(const struct FNetRewindSample& Sample, const struct FColor& Color, const struct FColor& ControlColour);
	void DrawSamples(const TArray<struct FNetRewindSample>& Samples, const struct FColor& Color, const struct FColor& ControlColour);
	void DrawShot(const struct FVector& StartLoc, const struct FVector& StartDir);
	void DrawVerifyInfo(const struct FVector& LineB, const struct FVector& LineT, const struct FVector& HeadLoc, const struct FVector& HitTest, const struct FVector& Closest, const uint8 TryType, const uint8 VerifiedType, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBallisticsDebugger">();
	}
	static class AHLLBallisticsDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLBallisticsDebugger>();
	}
};
static_assert(alignof(AHLLBallisticsDebugger) == 0x000008, "Wrong alignment on AHLLBallisticsDebugger");
static_assert(sizeof(AHLLBallisticsDebugger) == 0x000220, "Wrong size on AHLLBallisticsDebugger");

// Class HLL.HalftrackGunnerSeatUI
// 0x0028 (0x0298 - 0x0270)
class UHalftrackGunnerSeatUI final : public UHLLSeatWidgetBase
{
public:
	class UHLLArmourWeaponUI*                     WeaponInfo;                                        // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         FireKeyText;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         ZoomKeyText;                                       // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RotateKeyText;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C9[0x8];                                     // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HalftrackGunnerSeatUI">();
	}
	static class UHalftrackGunnerSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHalftrackGunnerSeatUI>();
	}
};
static_assert(alignof(UHalftrackGunnerSeatUI) == 0x000008, "Wrong alignment on UHalftrackGunnerSeatUI");
static_assert(sizeof(UHalftrackGunnerSeatUI) == 0x000298, "Wrong size on UHalftrackGunnerSeatUI");
static_assert(offsetof(UHalftrackGunnerSeatUI, WeaponInfo) == 0x000270, "Member 'UHalftrackGunnerSeatUI::WeaponInfo' has a wrong offset!");
static_assert(offsetof(UHalftrackGunnerSeatUI, FireKeyText) == 0x000278, "Member 'UHalftrackGunnerSeatUI::FireKeyText' has a wrong offset!");
static_assert(offsetof(UHalftrackGunnerSeatUI, ZoomKeyText) == 0x000280, "Member 'UHalftrackGunnerSeatUI::ZoomKeyText' has a wrong offset!");
static_assert(offsetof(UHalftrackGunnerSeatUI, RotateKeyText) == 0x000288, "Member 'UHalftrackGunnerSeatUI::RotateKeyText' has a wrong offset!");

// Class HLL.HLLDialogButton
// 0x0038 (0x0268 - 0x0230)
class UHLLDialogButton : public UUserWidget
{
public:
	class UButton*                                RootButton;                                        // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ButtonText;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Index_HLLDialogButton;                             // 0x0240(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11CA[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnPressed;                                         // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnReleased;                                        // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void HandlePressed();
	void HandleReleased();
	bool IsUsingGamepad();
	void OnButtonInit(int32 ButtonIndex);
	void OnDialogPressed__DelegateSignature(const int32 Param_Index);
	void OnDialogReleased__DelegateSignature(const int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDialogButton">();
	}
	static class UHLLDialogButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDialogButton>();
	}
};
static_assert(alignof(UHLLDialogButton) == 0x000008, "Wrong alignment on UHLLDialogButton");
static_assert(sizeof(UHLLDialogButton) == 0x000268, "Wrong size on UHLLDialogButton");
static_assert(offsetof(UHLLDialogButton, RootButton) == 0x000230, "Member 'UHLLDialogButton::RootButton' has a wrong offset!");
static_assert(offsetof(UHLLDialogButton, ButtonText) == 0x000238, "Member 'UHLLDialogButton::ButtonText' has a wrong offset!");
static_assert(offsetof(UHLLDialogButton, Index_HLLDialogButton) == 0x000240, "Member 'UHLLDialogButton::Index_HLLDialogButton' has a wrong offset!");
static_assert(offsetof(UHLLDialogButton, OnPressed) == 0x000248, "Member 'UHLLDialogButton::OnPressed' has a wrong offset!");
static_assert(offsetof(UHLLDialogButton, OnReleased) == 0x000258, "Member 'UHLLDialogButton::OnReleased' has a wrong offset!");

// Class HLL.HalfTrackTurretController
// 0x0028 (0x04D0 - 0x04A8)
class UHalfTrackTurretController final : public UPitchYawControllerComponent
{
public:
	class FName                                   YawBoneName;                                       // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTurretRotationScale;                            // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11CB[0x4];                                     // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AHalfTrackGunnerSeat*                   GunnerSeat;                                        // 0x04B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              YawVibrationController;                            // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              PitchVibrationController;                          // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HalfTrackTurretController">();
	}
	static class UHalfTrackTurretController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHalfTrackTurretController>();
	}
};
static_assert(alignof(UHalfTrackTurretController) == 0x000008, "Wrong alignment on UHalfTrackTurretController");
static_assert(sizeof(UHalfTrackTurretController) == 0x0004D0, "Wrong size on UHalfTrackTurretController");
static_assert(offsetof(UHalfTrackTurretController, YawBoneName) == 0x0004A8, "Member 'UHalfTrackTurretController::YawBoneName' has a wrong offset!");
static_assert(offsetof(UHalfTrackTurretController, MinTurretRotationScale) == 0x0004B0, "Member 'UHalfTrackTurretController::MinTurretRotationScale' has a wrong offset!");
static_assert(offsetof(UHalfTrackTurretController, GunnerSeat) == 0x0004B8, "Member 'UHalfTrackTurretController::GunnerSeat' has a wrong offset!");
static_assert(offsetof(UHalfTrackTurretController, YawVibrationController) == 0x0004C0, "Member 'UHalfTrackTurretController::YawVibrationController' has a wrong offset!");
static_assert(offsetof(UHalfTrackTurretController, PitchVibrationController) == 0x0004C8, "Member 'UHalfTrackTurretController::PitchVibrationController' has a wrong offset!");

// Class HLL.RCONCommandSetKickIdleTime
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetKickIdleTime final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetKickIdleTime">();
	}
	static class URCONCommandSetKickIdleTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetKickIdleTime>();
	}
};
static_assert(alignof(URCONCommandSetKickIdleTime) == 0x000008, "Wrong alignment on URCONCommandSetKickIdleTime");
static_assert(sizeof(URCONCommandSetKickIdleTime) == 0x000028, "Wrong size on URCONCommandSetKickIdleTime");

// Class HLL.HalftrackWheelsComponent
// 0x0050 (0x0100 - 0x00B0)
class UHalftrackWheelsComponent final : public UActorComponent
{
public:
	float                                         DefaultAnimatedWheelRadius;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CC[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FAnimatedTrackedVehicleWheelSetup> AnimatedWheelSetups;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUpdateWheelLocations : 1;                         // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11CD[0x17];                                    // 0x00C9(0x0017)(Fixing Size After Last Property [ Dumper-69 ])
	class UVehicleWheel*                          LeftReferenceRotationPhysicsWheel;                 // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVehicleWheel*                          RightReferenceRotationPhysicsWheel;                // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11CE[0x10];                                    // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HalftrackWheelsComponent">();
	}
	static class UHalftrackWheelsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHalftrackWheelsComponent>();
	}
};
static_assert(alignof(UHalftrackWheelsComponent) == 0x000008, "Wrong alignment on UHalftrackWheelsComponent");
static_assert(sizeof(UHalftrackWheelsComponent) == 0x000100, "Wrong size on UHalftrackWheelsComponent");
static_assert(offsetof(UHalftrackWheelsComponent, DefaultAnimatedWheelRadius) == 0x0000B0, "Member 'UHalftrackWheelsComponent::DefaultAnimatedWheelRadius' has a wrong offset!");
static_assert(offsetof(UHalftrackWheelsComponent, AnimatedWheelSetups) == 0x0000B8, "Member 'UHalftrackWheelsComponent::AnimatedWheelSetups' has a wrong offset!");
static_assert(offsetof(UHalftrackWheelsComponent, LeftReferenceRotationPhysicsWheel) == 0x0000E0, "Member 'UHalftrackWheelsComponent::LeftReferenceRotationPhysicsWheel' has a wrong offset!");
static_assert(offsetof(UHalftrackWheelsComponent, RightReferenceRotationPhysicsWheel) == 0x0000E8, "Member 'UHalftrackWheelsComponent::RightReferenceRotationPhysicsWheel' has a wrong offset!");

// Class HLL.HintsAndTips
// 0x0058 (0x0080 - 0x0028)
class UHintsAndTips final : public UObject
{
public:
	TSoftObjectPtr<class UDataTable>              HintDataTable;                                     // 0x0028(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDisplayTimeToComplete;                          // 0x0050(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHint                                         CurrentHint;                                       // 0x0054(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11CF[0x3];                                     // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         CurrentHintPriority;                               // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D0[0x14];                                    // 0x005C(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	class UDataTable*                             HintTable;                                         // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D1[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintsAndTips">();
	}
	static class UHintsAndTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintsAndTips>();
	}
};
static_assert(alignof(UHintsAndTips) == 0x000008, "Wrong alignment on UHintsAndTips");
static_assert(sizeof(UHintsAndTips) == 0x000080, "Wrong size on UHintsAndTips");
static_assert(offsetof(UHintsAndTips, HintDataTable) == 0x000028, "Member 'UHintsAndTips::HintDataTable' has a wrong offset!");
static_assert(offsetof(UHintsAndTips, MinDisplayTimeToComplete) == 0x000050, "Member 'UHintsAndTips::MinDisplayTimeToComplete' has a wrong offset!");
static_assert(offsetof(UHintsAndTips, CurrentHint) == 0x000054, "Member 'UHintsAndTips::CurrentHint' has a wrong offset!");
static_assert(offsetof(UHintsAndTips, CurrentHintPriority) == 0x000058, "Member 'UHintsAndTips::CurrentHintPriority' has a wrong offset!");
static_assert(offsetof(UHintsAndTips, HintTable) == 0x000070, "Member 'UHintsAndTips::HintTable' has a wrong offset!");

// Class HLL.ShooterImpactEffect
// 0x0650 (0x0870 - 0x0220)
class AShooterImpactEffect : public AActor
{
public:
	uint8                                         bHitSurfaceSet : 1;                                // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11D2[0x3];                                     // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHitResult                             HitSurface;                                        // 0x0224(0x0088)(Transient, DuplicateTransient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         DecalProjectionDepth;                              // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SurfaceSearchDepth;                                // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bFindComplexSurface : 1;                           // 0x02B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOrientToSurface : 1;                              // 0x02B4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSearchInWorldSpace : 1;                           // 0x02B4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EAxis                                         SurfaceSearchAxis;                                 // 0x02B5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAttachDecals : 1;                                 // 0x02B6(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDecalsUseRelevancy : 1;                           // 0x02B6(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11D3[0x1];                                     // 0x02B7(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DecalRelevancyDistance;                            // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeScreenSize;                               // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAttachFX;                                   // 0x02C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D4[0x7];                                     // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSurfaceVFX                            SurfaceEffects;                                    // 0x02C8(0x0160)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSurfaceSounds                         SurfaceSounds;                                     // 0x0428(0x0160)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSurfaceDecals                         SurfaceDecals;                                     // 0x0588(0x02C8)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D5[0x8];                                     // 0x0850(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystemComponent*               SpawnedPC;                                         // 0x0858(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        SpawnedAC;                                         // 0x0860(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        SpawnedDC;                                         // 0x0868(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterImpactEffect">();
	}
	static class AShooterImpactEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterImpactEffect>();
	}
};
static_assert(alignof(AShooterImpactEffect) == 0x000008, "Wrong alignment on AShooterImpactEffect");
static_assert(sizeof(AShooterImpactEffect) == 0x000870, "Wrong size on AShooterImpactEffect");
static_assert(offsetof(AShooterImpactEffect, HitSurface) == 0x000224, "Member 'AShooterImpactEffect::HitSurface' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, DecalProjectionDepth) == 0x0002AC, "Member 'AShooterImpactEffect::DecalProjectionDepth' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SurfaceSearchDepth) == 0x0002B0, "Member 'AShooterImpactEffect::SurfaceSearchDepth' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SurfaceSearchAxis) == 0x0002B5, "Member 'AShooterImpactEffect::SurfaceSearchAxis' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, DecalRelevancyDistance) == 0x0002B8, "Member 'AShooterImpactEffect::DecalRelevancyDistance' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, DecalFadeScreenSize) == 0x0002BC, "Member 'AShooterImpactEffect::DecalFadeScreenSize' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, bShouldAttachFX) == 0x0002C0, "Member 'AShooterImpactEffect::bShouldAttachFX' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SurfaceEffects) == 0x0002C8, "Member 'AShooterImpactEffect::SurfaceEffects' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SurfaceSounds) == 0x000428, "Member 'AShooterImpactEffect::SurfaceSounds' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SurfaceDecals) == 0x000588, "Member 'AShooterImpactEffect::SurfaceDecals' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SpawnedPC) == 0x000858, "Member 'AShooterImpactEffect::SpawnedPC' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SpawnedAC) == 0x000860, "Member 'AShooterImpactEffect::SpawnedAC' has a wrong offset!");
static_assert(offsetof(AShooterImpactEffect, SpawnedDC) == 0x000868, "Member 'AShooterImpactEffect::SpawnedDC' has a wrong offset!");

// Class HLL.HLLAbilityDropInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLAbilityDropInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbilityDropInterface">();
	}
	static class IHLLAbilityDropInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLAbilityDropInterface>();
	}
};
static_assert(alignof(IHLLAbilityDropInterface) == 0x000008, "Wrong alignment on IHLLAbilityDropInterface");
static_assert(sizeof(IHLLAbilityDropInterface) == 0x000028, "Wrong size on IHLLAbilityDropInterface");

// Class HLL.HLLVibrationData
// 0x0000 (0x0030 - 0x0030)
class UHLLVibrationData : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVibrationData">();
	}
	static class UHLLVibrationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVibrationData>();
	}
};
static_assert(alignof(UHLLVibrationData) == 0x000008, "Wrong alignment on UHLLVibrationData");
static_assert(sizeof(UHLLVibrationData) == 0x000030, "Wrong size on UHLLVibrationData");

// Class HLL.HLLVehicleVibrationData
// 0x0008 (0x0038 - 0x0030)
class UHLLVehicleVibrationData : public UHLLVibrationData
{
public:
	float                                         EngineHapticMinScale;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineHapticMaxScale;                              // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UVibrationEventController* CreateEffect2D(class UObject* WorldContextObject, EVehicleVibrationEventType Type, bool AutoDestroy);
	class UVibrationEventController* CreateEffect3D(EVehicleVibrationEventType Type, const bool bDoAttach, const bool AutoDestroy, class USkeletalMeshComponent* ReferenceComp, class FName SocketName, bool bDisableAttenuation, bool AutoPlay);
	void PlayEffect2D(class UObject* WorldContextObject, EVehicleVibrationEventType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleVibrationData">();
	}
	static class UHLLVehicleVibrationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVehicleVibrationData>();
	}
};
static_assert(alignof(UHLLVehicleVibrationData) == 0x000008, "Wrong alignment on UHLLVehicleVibrationData");
static_assert(sizeof(UHLLVehicleVibrationData) == 0x000038, "Wrong size on UHLLVehicleVibrationData");
static_assert(offsetof(UHLLVehicleVibrationData, EngineHapticMinScale) == 0x000030, "Member 'UHLLVehicleVibrationData::EngineHapticMinScale' has a wrong offset!");
static_assert(offsetof(UHLLVehicleVibrationData, EngineHapticMaxScale) == 0x000034, "Member 'UHLLVehicleVibrationData::EngineHapticMaxScale' has a wrong offset!");

// Class HLL.HLLAbilityDrop_ParachuteBase
// 0x00B8 (0x02D8 - 0x0220)
class AHLLAbilityDrop_ParachuteBase : public AActor
{
public:
	uint8                                         Pad_11DA[0x20];                                    // 0x0220(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bParachuteIsOpen : 1;                              // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11DB[0x3];                                     // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ParachuteDamping;                                  // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreefallDamping;                                   // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DC[0x4];                                     // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimMontage*                           ParachuteClose;                                    // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  LandedCollisionProfile;                            // 0x0258(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RandImpulseOnHit;                                  // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DD[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UStaticMeshComponent*                   ObjectMesh;                                        // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 ParachuteMesh;                                     // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSimpleHealthComponent*              HealthComponent;                                   // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDismantlingComponent*                  DismantlingComponent;                              // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanDismantle;                                     // 0x0291(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DE[0x2];                                     // 0x0292(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DismantleTime;                                     // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0298(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       ImpactEffectClass;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactMinVeloc;                                    // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenImpactFX;                            // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DF[0x7];                                     // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerState*                    DroppedBy;                                         // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E0[0x8];                                     // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnObjectHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_ParachuteIsOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbilityDrop_ParachuteBase">();
	}
	static class AHLLAbilityDrop_ParachuteBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbilityDrop_ParachuteBase>();
	}
};
static_assert(alignof(AHLLAbilityDrop_ParachuteBase) == 0x000008, "Wrong alignment on AHLLAbilityDrop_ParachuteBase");
static_assert(sizeof(AHLLAbilityDrop_ParachuteBase) == 0x0002D8, "Wrong size on AHLLAbilityDrop_ParachuteBase");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, ParachuteDamping) == 0x000244, "Member 'AHLLAbilityDrop_ParachuteBase::ParachuteDamping' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, FreefallDamping) == 0x000248, "Member 'AHLLAbilityDrop_ParachuteBase::FreefallDamping' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, ParachuteClose) == 0x000250, "Member 'AHLLAbilityDrop_ParachuteBase::ParachuteClose' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, LandedCollisionProfile) == 0x000258, "Member 'AHLLAbilityDrop_ParachuteBase::LandedCollisionProfile' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, RandImpulseOnHit) == 0x000260, "Member 'AHLLAbilityDrop_ParachuteBase::RandImpulseOnHit' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, ObjectMesh) == 0x000268, "Member 'AHLLAbilityDrop_ParachuteBase::ObjectMesh' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, ParachuteMesh) == 0x000270, "Member 'AHLLAbilityDrop_ParachuteBase::ParachuteMesh' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, MapComponent) == 0x000278, "Member 'AHLLAbilityDrop_ParachuteBase::MapComponent' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, HealthComponent) == 0x000280, "Member 'AHLLAbilityDrop_ParachuteBase::HealthComponent' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, DismantlingComponent) == 0x000288, "Member 'AHLLAbilityDrop_ParachuteBase::DismantlingComponent' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, DamageFilterType) == 0x000290, "Member 'AHLLAbilityDrop_ParachuteBase::DamageFilterType' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, bCanDismantle) == 0x000291, "Member 'AHLLAbilityDrop_ParachuteBase::bCanDismantle' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, DismantleTime) == 0x000294, "Member 'AHLLAbilityDrop_ParachuteBase::DismantleTime' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, DisplayName) == 0x000298, "Member 'AHLLAbilityDrop_ParachuteBase::DisplayName' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, ImpactEffectClass) == 0x0002B0, "Member 'AHLLAbilityDrop_ParachuteBase::ImpactEffectClass' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, ImpactMinVeloc) == 0x0002B8, "Member 'AHLLAbilityDrop_ParachuteBase::ImpactMinVeloc' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, MinTimeBetweenImpactFX) == 0x0002BC, "Member 'AHLLAbilityDrop_ParachuteBase::MinTimeBetweenImpactFX' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, Team) == 0x0002C0, "Member 'AHLLAbilityDrop_ParachuteBase::Team' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_ParachuteBase, DroppedBy) == 0x0002C8, "Member 'AHLLAbilityDrop_ParachuteBase::DroppedBy' has a wrong offset!");

// Class HLL.HLLMeleeAttackDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLMeleeAttackDamage : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMeleeAttackDamage">();
	}
	static class UHLLMeleeAttackDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMeleeAttackDamage>();
	}
};
static_assert(alignof(UHLLMeleeAttackDamage) == 0x000008, "Wrong alignment on UHLLMeleeAttackDamage");
static_assert(sizeof(UHLLMeleeAttackDamage) == 0x0001E8, "Wrong size on UHLLMeleeAttackDamage");

// Class HLL.HLLAbilityDrop_AmmoCrate
// 0x0018 (0x02F0 - 0x02D8)
class AHLLAbilityDrop_AmmoCrate final : public AHLLAbilityDrop_ParachuteBase
{
public:
	uint8                                         Pad_11E2[0x8];                                     // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLAmmoComponent*                      AmmoComponent;                                     // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbilityDrop_AmmoCrate">();
	}
	static class AHLLAbilityDrop_AmmoCrate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbilityDrop_AmmoCrate>();
	}
};
static_assert(alignof(AHLLAbilityDrop_AmmoCrate) == 0x000008, "Wrong alignment on AHLLAbilityDrop_AmmoCrate");
static_assert(sizeof(AHLLAbilityDrop_AmmoCrate) == 0x0002F0, "Wrong size on AHLLAbilityDrop_AmmoCrate");
static_assert(offsetof(AHLLAbilityDrop_AmmoCrate, AmmoComponent) == 0x0002E0, "Member 'AHLLAbilityDrop_AmmoCrate::AmmoComponent' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_AmmoCrate, IndicatorComponent) == 0x0002E8, "Member 'AHLLAbilityDrop_AmmoCrate::IndicatorComponent' has a wrong offset!");

// Class HLL.HLLAbilityDrop_BombingRun
// 0x0048 (0x0268 - 0x0220)
class AHLLAbilityDrop_BombingRun final : public AActor
{
public:
	uint8                                         Pad_11E3[0x10];                                    // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FBombingRunDrop>                Drops;                                             // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLHowitzerShell>          ShellClass;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         MyTeam;                                            // 0x0248(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E4[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        DummyRoot;                                         // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterPlayerState*                    DroppedBy;                                         // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLCommanderAbility*                   SourceAbility;                                     // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbilityDrop_BombingRun">();
	}
	static class AHLLAbilityDrop_BombingRun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbilityDrop_BombingRun>();
	}
};
static_assert(alignof(AHLLAbilityDrop_BombingRun) == 0x000008, "Wrong alignment on AHLLAbilityDrop_BombingRun");
static_assert(sizeof(AHLLAbilityDrop_BombingRun) == 0x000268, "Wrong size on AHLLAbilityDrop_BombingRun");
static_assert(offsetof(AHLLAbilityDrop_BombingRun, Drops) == 0x000230, "Member 'AHLLAbilityDrop_BombingRun::Drops' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_BombingRun, ShellClass) == 0x000240, "Member 'AHLLAbilityDrop_BombingRun::ShellClass' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_BombingRun, MyTeam) == 0x000248, "Member 'AHLLAbilityDrop_BombingRun::MyTeam' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_BombingRun, DummyRoot) == 0x000250, "Member 'AHLLAbilityDrop_BombingRun::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_BombingRun, DroppedBy) == 0x000258, "Member 'AHLLAbilityDrop_BombingRun::DroppedBy' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_BombingRun, SourceAbility) == 0x000260, "Member 'AHLLAbilityDrop_BombingRun::SourceAbility' has a wrong offset!");

// Class HLL.HLLGunnerUI_HowitzerRangeItem
// 0x0010 (0x0240 - 0x0230)
class UHLLGunnerUI_HowitzerRangeItem final : public UUserWidget
{
public:
	class UTextBlock*                             RangeText;                                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ElevationText;                                     // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGunnerUI_HowitzerRangeItem">();
	}
	static class UHLLGunnerUI_HowitzerRangeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLGunnerUI_HowitzerRangeItem>();
	}
};
static_assert(alignof(UHLLGunnerUI_HowitzerRangeItem) == 0x000008, "Wrong alignment on UHLLGunnerUI_HowitzerRangeItem");
static_assert(sizeof(UHLLGunnerUI_HowitzerRangeItem) == 0x000240, "Wrong size on UHLLGunnerUI_HowitzerRangeItem");
static_assert(offsetof(UHLLGunnerUI_HowitzerRangeItem, RangeText) == 0x000230, "Member 'UHLLGunnerUI_HowitzerRangeItem::RangeText' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_HowitzerRangeItem, ElevationText) == 0x000238, "Member 'UHLLGunnerUI_HowitzerRangeItem::ElevationText' has a wrong offset!");

// Class HLL.HLLAdminPunishmentDamage
// 0x0010 (0x01F8 - 0x01E8)
class UHLLAdminPunishmentDamage final : public UShooterDamageType
{
public:
	uint8                                         Pad_11E5[0x10];                                    // 0x01E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAdminPunishmentDamage">();
	}
	static class UHLLAdminPunishmentDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAdminPunishmentDamage>();
	}
};
static_assert(alignof(UHLLAdminPunishmentDamage) == 0x000008, "Wrong alignment on UHLLAdminPunishmentDamage");
static_assert(sizeof(UHLLAdminPunishmentDamage) == 0x0001F8, "Wrong size on UHLLAdminPunishmentDamage");

// Class HLL.HLLAbilityDrop_Spawn
// 0x0030 (0x0438 - 0x0408)
class AHLLAbilityDrop_Spawn final : public ADynamicSpawn
{
public:
	uint8                                         Pad_11E6[0x8];                                     // 0x0408(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLParachuteMeshComponent*             Parachute;                                         // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DescentSpeed;                                      // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxWaves;                                          // 0x041C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E7[0x3];                                     // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDropSpawnInfo                         ReplicatedDropInfo;                                // 0x0420(0x000C)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         NumExecutedWaves;                                  // 0x042C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E8[0xB];                                     // 0x042D(0x000B)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_DropSpawnInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbilityDrop_Spawn">();
	}
	static class AHLLAbilityDrop_Spawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbilityDrop_Spawn>();
	}
};
static_assert(alignof(AHLLAbilityDrop_Spawn) == 0x000008, "Wrong alignment on AHLLAbilityDrop_Spawn");
static_assert(sizeof(AHLLAbilityDrop_Spawn) == 0x000438, "Wrong size on AHLLAbilityDrop_Spawn");
static_assert(offsetof(AHLLAbilityDrop_Spawn, Parachute) == 0x000410, "Member 'AHLLAbilityDrop_Spawn::Parachute' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_Spawn, DescentSpeed) == 0x000418, "Member 'AHLLAbilityDrop_Spawn::DescentSpeed' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_Spawn, MaxWaves) == 0x00041C, "Member 'AHLLAbilityDrop_Spawn::MaxWaves' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_Spawn, ReplicatedDropInfo) == 0x000420, "Member 'AHLLAbilityDrop_Spawn::ReplicatedDropInfo' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_Spawn, NumExecutedWaves) == 0x00042C, "Member 'AHLLAbilityDrop_Spawn::NumExecutedWaves' has a wrong offset!");

// Class HLL.HLLMapData_Marker
// 0x0038 (0x0270 - 0x0238)
class AHLLMapData_Marker : public AHLLMapDataBase
{
public:
	EHLLMarker                                    MarkerType;                                        // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MarkerSubIndex;                                    // 0x0239(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E9[0x2];                                     // 0x023A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class AShooterPlayerState>     OwningPlayer;                                      // 0x023C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11EA[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnMovedOrPlacedDelegate;                           // 0x0248(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bWantsDisplayed;                                   // 0x0258(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11EB[0x3];                                     // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DisplayToggleOnTime;                               // 0x025C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisplayToggleOffTime;                              // 0x0260(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11EC[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLIndicatorComponent_Marker*          IndicatorComponent;                                // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Marker">();
	}
	static class AHLLMapData_Marker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Marker>();
	}
};
static_assert(alignof(AHLLMapData_Marker) == 0x000008, "Wrong alignment on AHLLMapData_Marker");
static_assert(sizeof(AHLLMapData_Marker) == 0x000270, "Wrong size on AHLLMapData_Marker");
static_assert(offsetof(AHLLMapData_Marker, MarkerType) == 0x000238, "Member 'AHLLMapData_Marker::MarkerType' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Marker, MarkerSubIndex) == 0x000239, "Member 'AHLLMapData_Marker::MarkerSubIndex' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Marker, OwningPlayer) == 0x00023C, "Member 'AHLLMapData_Marker::OwningPlayer' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Marker, OnMovedOrPlacedDelegate) == 0x000248, "Member 'AHLLMapData_Marker::OnMovedOrPlacedDelegate' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Marker, bWantsDisplayed) == 0x000258, "Member 'AHLLMapData_Marker::bWantsDisplayed' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Marker, DisplayToggleOnTime) == 0x00025C, "Member 'AHLLMapData_Marker::DisplayToggleOnTime' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Marker, DisplayToggleOffTime) == 0x000260, "Member 'AHLLMapData_Marker::DisplayToggleOffTime' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Marker, IndicatorComponent) == 0x000268, "Member 'AHLLMapData_Marker::IndicatorComponent' has a wrong offset!");

// Class HLL.HLLAbilityDrop_Supplies
// 0x0018 (0x02F0 - 0x02D8)
class AHLLAbilityDrop_Supplies final : public AHLLAbilityDrop_ParachuteBase
{
public:
	uint8                                         Pad_11ED[0x8];                                     // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLSupplyComponent*                    SupplyComponent;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbilityDrop_Supplies">();
	}
	static class AHLLAbilityDrop_Supplies* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbilityDrop_Supplies>();
	}
};
static_assert(alignof(AHLLAbilityDrop_Supplies) == 0x000008, "Wrong alignment on AHLLAbilityDrop_Supplies");
static_assert(sizeof(AHLLAbilityDrop_Supplies) == 0x0002F0, "Wrong size on AHLLAbilityDrop_Supplies");
static_assert(offsetof(AHLLAbilityDrop_Supplies, SupplyComponent) == 0x0002E0, "Member 'AHLLAbilityDrop_Supplies::SupplyComponent' has a wrong offset!");
static_assert(offsetof(AHLLAbilityDrop_Supplies, IndicatorComponent) == 0x0002E8, "Member 'AHLLAbilityDrop_Supplies::IndicatorComponent' has a wrong offset!");

// Class HLL.ShooterPlayerController_Base
// 0x0040 (0x05C0 - 0x0580)
class AShooterPlayerController_Base : public APlayerController
{
public:
	uint8                                         Pad_11EE[0x28];                                    // 0x0580(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnChangeNameDialogToggled;                         // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11EF[0x8];                                     // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ToggleChangeNameDialog();
	void ToggleFriendsMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerController_Base">();
	}
	static class AShooterPlayerController_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerController_Base>();
	}
};
static_assert(alignof(AShooterPlayerController_Base) == 0x000008, "Wrong alignment on AShooterPlayerController_Base");
static_assert(sizeof(AShooterPlayerController_Base) == 0x0005C0, "Wrong size on AShooterPlayerController_Base");
static_assert(offsetof(AShooterPlayerController_Base, OnChangeNameDialogToggled) == 0x0005A8, "Member 'AShooterPlayerController_Base::OnChangeNameDialogToggled' has a wrong offset!");

// Class HLL.HLLCommanderAbility_Placeable
// 0x0020 (0x0380 - 0x0360)
class AHLLCommanderAbility_Placeable : public AHLLCommanderAbility
{
public:
	struct FRepAbilityPlacement                   PlacementData;                                     // 0x0360(0x000C)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bChatMessageNameSector : 1;                        // 0x036C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowPlacementOutOfBounds : 1;                    // 0x036C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupportRotation : 1;                              // 0x036C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTickPlacementChecks : 1;                          // 0x036C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ECollisionChannel                             PlacementChannelName;                              // 0x036D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bFixedBaseRotation : 1;                            // 0x036E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11F0[0x1];                                     // 0x036F(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMapComponent*                       MapComponent;                                      // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bTransformValid : 1;                               // 0x0378(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPlacementValid : 1;                             // 0x0378(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHideIconForThisActivation : 1;                    // 0x0378(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11F1[0x7];                                     // 0x0379(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ServerPlace(const struct FVector2D& InPosition);
	void ServerRotate(bool bIncrement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_Placeable">();
	}
	static class AHLLCommanderAbility_Placeable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_Placeable>();
	}
};
static_assert(alignof(AHLLCommanderAbility_Placeable) == 0x000008, "Wrong alignment on AHLLCommanderAbility_Placeable");
static_assert(sizeof(AHLLCommanderAbility_Placeable) == 0x000380, "Wrong size on AHLLCommanderAbility_Placeable");
static_assert(offsetof(AHLLCommanderAbility_Placeable, PlacementData) == 0x000360, "Member 'AHLLCommanderAbility_Placeable::PlacementData' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_Placeable, PlacementChannelName) == 0x00036D, "Member 'AHLLCommanderAbility_Placeable::PlacementChannelName' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_Placeable, MapComponent) == 0x000370, "Member 'AHLLCommanderAbility_Placeable::MapComponent' has a wrong offset!");

// Class HLL.HLLGunnerUI_SPAHowitzerRangeItem
// 0x0010 (0x0240 - 0x0230)
class UHLLGunnerUI_SPAHowitzerRangeItem final : public UUserWidget
{
public:
	class UTextBlock*                             RangeText;                                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ElevationText;                                     // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGunnerUI_SPAHowitzerRangeItem">();
	}
	static class UHLLGunnerUI_SPAHowitzerRangeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLGunnerUI_SPAHowitzerRangeItem>();
	}
};
static_assert(alignof(UHLLGunnerUI_SPAHowitzerRangeItem) == 0x000008, "Wrong alignment on UHLLGunnerUI_SPAHowitzerRangeItem");
static_assert(sizeof(UHLLGunnerUI_SPAHowitzerRangeItem) == 0x000240, "Wrong size on UHLLGunnerUI_SPAHowitzerRangeItem");
static_assert(offsetof(UHLLGunnerUI_SPAHowitzerRangeItem, RangeText) == 0x000230, "Member 'UHLLGunnerUI_SPAHowitzerRangeItem::RangeText' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_SPAHowitzerRangeItem, ElevationText) == 0x000238, "Member 'UHLLGunnerUI_SPAHowitzerRangeItem::ElevationText' has a wrong offset!");

// Class HLL.HLLVehicleHitDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLVehicleHitDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleHitDamage">();
	}
	static class UHLLVehicleHitDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVehicleHitDamage>();
	}
};
static_assert(alignof(UHLLVehicleHitDamage) == 0x000008, "Wrong alignment on UHLLVehicleHitDamage");
static_assert(sizeof(UHLLVehicleHitDamage) == 0x0001E8, "Wrong size on UHLLVehicleHitDamage");

// Class HLL.HLLCommanderAbility_SplineFollower
// 0x0020 (0x03A0 - 0x0380)
class AHLLCommanderAbility_SplineFollower : public AHLLCommanderAbility_Placeable
{
public:
	TArray<struct FSplineFollower>                SplineFollowers;                                   // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       PlaneSpline;                                       // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PlaneMesh;                                         // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_SplineFollower">();
	}
	static class AHLLCommanderAbility_SplineFollower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_SplineFollower>();
	}
};
static_assert(alignof(AHLLCommanderAbility_SplineFollower) == 0x000008, "Wrong alignment on AHLLCommanderAbility_SplineFollower");
static_assert(sizeof(AHLLCommanderAbility_SplineFollower) == 0x0003A0, "Wrong size on AHLLCommanderAbility_SplineFollower");
static_assert(offsetof(AHLLCommanderAbility_SplineFollower, SplineFollowers) == 0x000380, "Member 'AHLLCommanderAbility_SplineFollower::SplineFollowers' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_SplineFollower, PlaneSpline) == 0x000390, "Member 'AHLLCommanderAbility_SplineFollower::PlaneSpline' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_SplineFollower, PlaneMesh) == 0x000398, "Member 'AHLLCommanderAbility_SplineFollower::PlaneMesh' has a wrong offset!");

// Class HLL.HLLGoreComponent
// 0x0100 (0x01B0 - 0x00B0)
class UHLLGoreComponent final : public UActorComponent
{
public:
	class UHLLDismemberData*                      DismembermentData;                                 // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F2[0x10];                                    // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UDataTable*                             DecalSets;                                         // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F3[0x50];                                    // 0x00D0(0x0050)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DecalRelevancyDistance;                            // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplatterRadius;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllBodiesGenerateGibs : 1;                        // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11F4[0x3];                                     // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         LargeGibMassThreshold;                             // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GibImpact_SmallThreshold;                          // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GibImpact_LargeThreshold;                          // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyTrailCheckRate;                                // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyTrailSpawnDist2D;                              // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyTrailTraceDistance;                            // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F5[0x4];                                     // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystem*                        BleedEmitter;                                      // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UParticleSystemComponent> PSC_BleedEmitter;                                  // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinMaxBleedDecalSpawnRate;                         // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BleedDecalRandomOffset;                            // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplatterTraceDistanceModifier;                     // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactTraceDistance;                               // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BloodPoolMaxScale;                                 // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BloodPoolScaleSpeed;                               // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenDamageResponse;                      // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLGoreTrailType                             CurrentTrailMode;                                  // 0x0178(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F6[0x37];                                    // 0x0179(0x0037)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static bool GetDismembermentDisabledForRegion();
	static bool IsDismembermentEnabled();

	void OnGibImpact(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnJointSevered(const struct FVector& JointPosition, const struct FVector& Impulse, const struct FHLLBreakableJointData& InData, class USkeletalMeshComponent* MeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGoreComponent">();
	}
	static class UHLLGoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLGoreComponent>();
	}
};
static_assert(alignof(UHLLGoreComponent) == 0x000008, "Wrong alignment on UHLLGoreComponent");
static_assert(sizeof(UHLLGoreComponent) == 0x0001B0, "Wrong size on UHLLGoreComponent");
static_assert(offsetof(UHLLGoreComponent, DismembermentData) == 0x0000B0, "Member 'UHLLGoreComponent::DismembermentData' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, DecalSets) == 0x0000C8, "Member 'UHLLGoreComponent::DecalSets' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, DecalRelevancyDistance) == 0x000120, "Member 'UHLLGoreComponent::DecalRelevancyDistance' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, SplatterRadius) == 0x000124, "Member 'UHLLGoreComponent::SplatterRadius' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, LargeGibMassThreshold) == 0x00012C, "Member 'UHLLGoreComponent::LargeGibMassThreshold' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, GibImpact_SmallThreshold) == 0x000130, "Member 'UHLLGoreComponent::GibImpact_SmallThreshold' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, GibImpact_LargeThreshold) == 0x000134, "Member 'UHLLGoreComponent::GibImpact_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, BodyTrailCheckRate) == 0x000138, "Member 'UHLLGoreComponent::BodyTrailCheckRate' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, BodyTrailSpawnDist2D) == 0x00013C, "Member 'UHLLGoreComponent::BodyTrailSpawnDist2D' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, BodyTrailTraceDistance) == 0x000140, "Member 'UHLLGoreComponent::BodyTrailTraceDistance' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, BleedEmitter) == 0x000148, "Member 'UHLLGoreComponent::BleedEmitter' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, PSC_BleedEmitter) == 0x000150, "Member 'UHLLGoreComponent::PSC_BleedEmitter' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, MinMaxBleedDecalSpawnRate) == 0x000158, "Member 'UHLLGoreComponent::MinMaxBleedDecalSpawnRate' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, BleedDecalRandomOffset) == 0x000160, "Member 'UHLLGoreComponent::BleedDecalRandomOffset' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, SplatterTraceDistanceModifier) == 0x000164, "Member 'UHLLGoreComponent::SplatterTraceDistanceModifier' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, ImpactTraceDistance) == 0x000168, "Member 'UHLLGoreComponent::ImpactTraceDistance' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, BloodPoolMaxScale) == 0x00016C, "Member 'UHLLGoreComponent::BloodPoolMaxScale' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, BloodPoolScaleSpeed) == 0x000170, "Member 'UHLLGoreComponent::BloodPoolScaleSpeed' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, MinTimeBetweenDamageResponse) == 0x000174, "Member 'UHLLGoreComponent::MinTimeBetweenDamageResponse' has a wrong offset!");
static_assert(offsetof(UHLLGoreComponent, CurrentTrailMode) == 0x000178, "Member 'UHLLGoreComponent::CurrentTrailMode' has a wrong offset!");

// Class HLL.HLLCommanderAbility_DiveBomber
// 0x0050 (0x03F0 - 0x03A0)
class AHLLCommanderAbility_DiveBomber final : public AHLLCommanderAbility_SplineFollower
{
public:
	TMap<class FName, struct FDiveBomber>         DiveBombers;                                       // 0x03A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_DiveBomber">();
	}
	static class AHLLCommanderAbility_DiveBomber* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_DiveBomber>();
	}
};
static_assert(alignof(AHLLCommanderAbility_DiveBomber) == 0x000008, "Wrong alignment on AHLLCommanderAbility_DiveBomber");
static_assert(sizeof(AHLLCommanderAbility_DiveBomber) == 0x0003F0, "Wrong size on AHLLCommanderAbility_DiveBomber");
static_assert(offsetof(AHLLCommanderAbility_DiveBomber, DiveBombers) == 0x0003A0, "Member 'AHLLCommanderAbility_DiveBomber::DiveBombers' has a wrong offset!");

// Class HLL.ShooterGameStateActivityComponent
// 0x0018 (0x00C8 - 0x00B0)
class UShooterGameStateActivityComponent final : public UActorComponent
{
public:
	class FString                                 M_ActivityMatchID;                                 // 0x00B0(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         M_NumActivityAgents;                               // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11F8[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_ActivityMatchID(const class FString& OldInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameStateActivityComponent">();
	}
	static class UShooterGameStateActivityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameStateActivityComponent>();
	}
};
static_assert(alignof(UShooterGameStateActivityComponent) == 0x000008, "Wrong alignment on UShooterGameStateActivityComponent");
static_assert(sizeof(UShooterGameStateActivityComponent) == 0x0000C8, "Wrong size on UShooterGameStateActivityComponent");
static_assert(offsetof(UShooterGameStateActivityComponent, M_ActivityMatchID) == 0x0000B0, "Member 'UShooterGameStateActivityComponent::M_ActivityMatchID' has a wrong offset!");
static_assert(offsetof(UShooterGameStateActivityComponent, M_NumActivityAgents) == 0x0000C0, "Member 'UShooterGameStateActivityComponent::M_NumActivityAgents' has a wrong offset!");

// Class HLL.HLLCommanderAbility_PlaneBase
// 0x0048 (0x03C8 - 0x0380)
class AHLLCommanderAbility_PlaneBase : public AHLLCommanderAbility_Placeable
{
public:
	struct FVector                                CoverageInfo;                                      // 0x0380(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F9[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UStaticMeshComponent*                   PlaneMesh;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PlaneAudio;                                        // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PlaneFlybyAudio;                                   // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               PlaneParticles;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlightTime;                                        // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlaneSpeed;                                        // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlaneAltitude;                                     // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnOffset;                                       // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DespawnOffset;                                     // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FA[0x4];                                     // 0x03C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_PlaneBase">();
	}
	static class AHLLCommanderAbility_PlaneBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_PlaneBase>();
	}
};
static_assert(alignof(AHLLCommanderAbility_PlaneBase) == 0x000008, "Wrong alignment on AHLLCommanderAbility_PlaneBase");
static_assert(sizeof(AHLLCommanderAbility_PlaneBase) == 0x0003C8, "Wrong size on AHLLCommanderAbility_PlaneBase");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, CoverageInfo) == 0x000380, "Member 'AHLLCommanderAbility_PlaneBase::CoverageInfo' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, PlaneMesh) == 0x000390, "Member 'AHLLCommanderAbility_PlaneBase::PlaneMesh' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, PlaneAudio) == 0x000398, "Member 'AHLLCommanderAbility_PlaneBase::PlaneAudio' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, PlaneFlybyAudio) == 0x0003A0, "Member 'AHLLCommanderAbility_PlaneBase::PlaneFlybyAudio' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, PlaneParticles) == 0x0003A8, "Member 'AHLLCommanderAbility_PlaneBase::PlaneParticles' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, FlightTime) == 0x0003B0, "Member 'AHLLCommanderAbility_PlaneBase::FlightTime' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, PlaneSpeed) == 0x0003B4, "Member 'AHLLCommanderAbility_PlaneBase::PlaneSpeed' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, PlaneAltitude) == 0x0003B8, "Member 'AHLLCommanderAbility_PlaneBase::PlaneAltitude' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, SpawnOffset) == 0x0003BC, "Member 'AHLLCommanderAbility_PlaneBase::SpawnOffset' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_PlaneBase, DespawnOffset) == 0x0003C0, "Member 'AHLLCommanderAbility_PlaneBase::DespawnOffset' has a wrong offset!");

// Class HLL.HLLCommanderAbility_DropperPlane
// 0x0028 (0x03F0 - 0x03C8)
class AHLLCommanderAbility_DropperPlane : public AHLLCommanderAbility_PlaneBase
{
public:
	uint8                                         Pad_11FB[0x8];                                     // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AActor>                     SpawnClass;                                        // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnAltitude;                                     // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDidDrop : 1;                                      // 0x03DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11FC[0x3];                                     // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DropDelayTime;                                     // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FD[0xC];                                     // 0x03E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_DropperPlane">();
	}
	static class AHLLCommanderAbility_DropperPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_DropperPlane>();
	}
};
static_assert(alignof(AHLLCommanderAbility_DropperPlane) == 0x000008, "Wrong alignment on AHLLCommanderAbility_DropperPlane");
static_assert(sizeof(AHLLCommanderAbility_DropperPlane) == 0x0003F0, "Wrong size on AHLLCommanderAbility_DropperPlane");
static_assert(offsetof(AHLLCommanderAbility_DropperPlane, SpawnClass) == 0x0003D0, "Member 'AHLLCommanderAbility_DropperPlane::SpawnClass' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_DropperPlane, SpawnAltitude) == 0x0003D8, "Member 'AHLLCommanderAbility_DropperPlane::SpawnAltitude' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_DropperPlane, DropDelayTime) == 0x0003E0, "Member 'AHLLCommanderAbility_DropperPlane::DropDelayTime' has a wrong offset!");

// Class HLL.HLLHintWidget
// 0x0000 (0x0230 - 0x0230)
class UHLLHintWidget : public UUserWidget
{
public:
	void OnHideHint();
	void OnShowHint(const struct FHint& HintToShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLHintWidget">();
	}
	static class UHLLHintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLHintWidget>();
	}
};
static_assert(alignof(UHLLHintWidget) == 0x000008, "Wrong alignment on UHLLHintWidget");
static_assert(sizeof(UHLLHintWidget) == 0x000230, "Wrong size on UHLLHintWidget");

// Class HLL.ShooterEngine
// 0x0008 (0x0E38 - 0x0E30)
class UShooterEngine final : public UGameEngine
{
public:
	uint8                                         Pad_11FE[0x8];                                     // 0x0E30(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterEngine">();
	}
	static class UShooterEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterEngine>();
	}
};
static_assert(alignof(UShooterEngine) == 0x000008, "Wrong alignment on UShooterEngine");
static_assert(sizeof(UShooterEngine) == 0x000E38, "Wrong size on UShooterEngine");

// Class HLL.HLLCommanderAbility_GhostPlane
// 0x01B0 (0x05A0 - 0x03F0)
class AHLLCommanderAbility_GhostPlane final : public AHLLCommanderAbility_DropperPlane
{
public:
	uint8                                         Pad_11FF[0x8];                                     // 0x03F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDispenserData                         DispenserData;                                     // 0x03F8(0x0190)(Edit, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLGhostAbilitySafezone>   SafezoneClass;                                     // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLDispenserItem_Base*                 GhostInstance;                                     // 0x0590(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLGhostAbilitySafezone*               SafezoneInstance;                                  // 0x0598(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDispenseCompleted(class AActor* Item, const bool bWasSuccessful);
	void OnDispenseDestroyed(class AActor* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_GhostPlane">();
	}
	static class AHLLCommanderAbility_GhostPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_GhostPlane>();
	}
};
static_assert(alignof(AHLLCommanderAbility_GhostPlane) == 0x000008, "Wrong alignment on AHLLCommanderAbility_GhostPlane");
static_assert(sizeof(AHLLCommanderAbility_GhostPlane) == 0x0005A0, "Wrong size on AHLLCommanderAbility_GhostPlane");
static_assert(offsetof(AHLLCommanderAbility_GhostPlane, DispenserData) == 0x0003F8, "Member 'AHLLCommanderAbility_GhostPlane::DispenserData' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_GhostPlane, SafezoneClass) == 0x000588, "Member 'AHLLCommanderAbility_GhostPlane::SafezoneClass' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_GhostPlane, GhostInstance) == 0x000590, "Member 'AHLLCommanderAbility_GhostPlane::GhostInstance' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_GhostPlane, SafezoneInstance) == 0x000598, "Member 'AHLLCommanderAbility_GhostPlane::SafezoneInstance' has a wrong offset!");

// Class HLL.HLLFootstepData
// 0x23D8 (0x2408 - 0x0030)
class UHLLFootstepData final : public UDataAsset
{
public:
	uint8                                         bCullFootstepSFX : 1;                              // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCullFootstepFX : 1;                               // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCullFootstepDecals : 1;                           // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCullWaterSFX : 1;                                 // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCullWaterFX : 1;                                  // 0x0030(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1201[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CullDistanceSound;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CullDistanceEffects;                               // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CullDistanceDecals;                                // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterCullDistanceSound;                            // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterCullDistanceEffects;                          // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     HeelToeDelay[0x3];                                 // 0x0048(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFootstepFX                            FootstepsFPP[0x3];                                 // 0x01E0(0x0588)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFootstepFX                            FootstepsTPP[0x3];                                 // 0x1278(0x0588)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FootstepDecalProjectionDistance;                   // 0x2310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1202[0x4];                                     // 0x2314(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FWadeFX                                WadeFPP[0x3];                                      // 0x2318(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWadeFX                                WadeTPP[0x3];                                      // 0x2360(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSplashFX                              Splashes[0x3];                                     // 0x23A8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSplashFX                              JumpOuts[0x3];                                     // 0x23D8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLFootstepData">();
	}
	static class UHLLFootstepData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLFootstepData>();
	}
};
static_assert(alignof(UHLLFootstepData) == 0x000008, "Wrong alignment on UHLLFootstepData");
static_assert(sizeof(UHLLFootstepData) == 0x002408, "Wrong size on UHLLFootstepData");
static_assert(offsetof(UHLLFootstepData, CullDistanceSound) == 0x000034, "Member 'UHLLFootstepData::CullDistanceSound' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, CullDistanceEffects) == 0x000038, "Member 'UHLLFootstepData::CullDistanceEffects' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, CullDistanceDecals) == 0x00003C, "Member 'UHLLFootstepData::CullDistanceDecals' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, WaterCullDistanceSound) == 0x000040, "Member 'UHLLFootstepData::WaterCullDistanceSound' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, WaterCullDistanceEffects) == 0x000044, "Member 'UHLLFootstepData::WaterCullDistanceEffects' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, HeelToeDelay) == 0x000048, "Member 'UHLLFootstepData::HeelToeDelay' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, FootstepsFPP) == 0x0001E0, "Member 'UHLLFootstepData::FootstepsFPP' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, FootstepsTPP) == 0x001278, "Member 'UHLLFootstepData::FootstepsTPP' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, FootstepDecalProjectionDistance) == 0x002310, "Member 'UHLLFootstepData::FootstepDecalProjectionDistance' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, WadeFPP) == 0x002318, "Member 'UHLLFootstepData::WadeFPP' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, WadeTPP) == 0x002360, "Member 'UHLLFootstepData::WadeTPP' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, Splashes) == 0x0023A8, "Member 'UHLLFootstepData::Splashes' has a wrong offset!");
static_assert(offsetof(UHLLFootstepData, JumpOuts) == 0x0023D8, "Member 'UHLLFootstepData::JumpOuts' has a wrong offset!");

// Class HLL.HLLAbility_ProjectileStrike
// 0x0078 (0x03F8 - 0x0380)
class AHLLAbility_ProjectileStrike final : public AHLLCommanderAbility_Placeable
{
public:
	uint8                                         Pad_1203[0x8];                                     // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterProjectile>         ProjectileClass;                                   // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumProjectiles;                                    // 0x0390(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1204[0x3];                                     // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         StrikeZoneRadius;                                  // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenProjectiles;                           // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialLaunchDelay;                                // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileStartDistance;                           // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileLaunchZOffset;                           // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileArcFactor;                               // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1205[0x4];                                     // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             LaunchSound;                                       // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bProjectilesStartedFiring;                         // 0x03B8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1206[0x3F];                                    // 0x03B9(0x003F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_ProjectileStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbility_ProjectileStrike">();
	}
	static class AHLLAbility_ProjectileStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbility_ProjectileStrike>();
	}
};
static_assert(alignof(AHLLAbility_ProjectileStrike) == 0x000008, "Wrong alignment on AHLLAbility_ProjectileStrike");
static_assert(sizeof(AHLLAbility_ProjectileStrike) == 0x0003F8, "Wrong size on AHLLAbility_ProjectileStrike");
static_assert(offsetof(AHLLAbility_ProjectileStrike, ProjectileClass) == 0x000388, "Member 'AHLLAbility_ProjectileStrike::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, NumProjectiles) == 0x000390, "Member 'AHLLAbility_ProjectileStrike::NumProjectiles' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, StrikeZoneRadius) == 0x000394, "Member 'AHLLAbility_ProjectileStrike::StrikeZoneRadius' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, DelayBetweenProjectiles) == 0x000398, "Member 'AHLLAbility_ProjectileStrike::DelayBetweenProjectiles' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, InitialLaunchDelay) == 0x00039C, "Member 'AHLLAbility_ProjectileStrike::InitialLaunchDelay' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, ProjectileStartDistance) == 0x0003A0, "Member 'AHLLAbility_ProjectileStrike::ProjectileStartDistance' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, ProjectileLaunchZOffset) == 0x0003A4, "Member 'AHLLAbility_ProjectileStrike::ProjectileLaunchZOffset' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, ProjectileArcFactor) == 0x0003A8, "Member 'AHLLAbility_ProjectileStrike::ProjectileArcFactor' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, LaunchSound) == 0x0003B0, "Member 'AHLLAbility_ProjectileStrike::LaunchSound' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ProjectileStrike, bProjectilesStartedFiring) == 0x0003B8, "Member 'AHLLAbility_ProjectileStrike::bProjectilesStartedFiring' has a wrong offset!");

// Class HLL.HLLSuicideDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLSuicideDamage : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSuicideDamage">();
	}
	static class UHLLSuicideDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSuicideDamage>();
	}
};
static_assert(alignof(UHLLSuicideDamage) == 0x000008, "Wrong alignment on UHLLSuicideDamage");
static_assert(sizeof(UHLLSuicideDamage) == 0x0001E8, "Wrong size on UHLLSuicideDamage");

// Class HLL.HLLCommanderAbility_ReconPlane
// 0x0090 (0x0458 - 0x03C8)
class AHLLCommanderAbility_ReconPlane final : public AHLLCommanderAbility_PlaneBase
{
public:
	uint8                                         bLOSCheck : 1;                                     // 0x03C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1207[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<EObjectTypeQuery>                      ScanObjectTypes;                                   // 0x03D0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             LOSChannel;                                        // 0x03E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1208[0x7];                                     // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystemComponent*               FlareParticleComponent;                            // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenScans;                              // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanRadius;                                        // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1209[0x60];                                    // 0x03F8(0x0060)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_ReconPlane">();
	}
	static class AHLLCommanderAbility_ReconPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_ReconPlane>();
	}
};
static_assert(alignof(AHLLCommanderAbility_ReconPlane) == 0x000008, "Wrong alignment on AHLLCommanderAbility_ReconPlane");
static_assert(sizeof(AHLLCommanderAbility_ReconPlane) == 0x000458, "Wrong size on AHLLCommanderAbility_ReconPlane");
static_assert(offsetof(AHLLCommanderAbility_ReconPlane, ScanObjectTypes) == 0x0003D0, "Member 'AHLLCommanderAbility_ReconPlane::ScanObjectTypes' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_ReconPlane, LOSChannel) == 0x0003E0, "Member 'AHLLCommanderAbility_ReconPlane::LOSChannel' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_ReconPlane, FlareParticleComponent) == 0x0003E8, "Member 'AHLLCommanderAbility_ReconPlane::FlareParticleComponent' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_ReconPlane, DistanceBetweenScans) == 0x0003F0, "Member 'AHLLCommanderAbility_ReconPlane::DistanceBetweenScans' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_ReconPlane, ScanRadius) == 0x0003F4, "Member 'AHLLCommanderAbility_ReconPlane::ScanRadius' has a wrong offset!");

// Class HLL.HLLAbility_Reinforce
// 0x0010 (0x0390 - 0x0380)
class AHLLAbility_Reinforce final : public AHLLCommanderAbility_Placeable
{
public:
	float                                         AbilityTime;                                       // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ManpowerMultiplier;                                // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120A[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbility_Reinforce">();
	}
	static class AHLLAbility_Reinforce* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbility_Reinforce>();
	}
};
static_assert(alignof(AHLLAbility_Reinforce) == 0x000008, "Wrong alignment on AHLLAbility_Reinforce");
static_assert(sizeof(AHLLAbility_Reinforce) == 0x000390, "Wrong size on AHLLAbility_Reinforce");
static_assert(offsetof(AHLLAbility_Reinforce, AbilityTime) == 0x000380, "Member 'AHLLAbility_Reinforce::AbilityTime' has a wrong offset!");
static_assert(offsetof(AHLLAbility_Reinforce, ManpowerMultiplier) == 0x000384, "Member 'AHLLAbility_Reinforce::ManpowerMultiplier' has a wrong offset!");

// Class HLL.HLLMapStateComponent
// 0x0068 (0x0118 - 0x00B0)
class UHLLMapStateComponent final : public UActorComponent
{
public:
	TArray<class AHLLMapDataBase*>                MapDataObjects;                                    // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPlayerMarkers>                 PlayerMarkers;                                     // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTeamRecon>                     TeamReconData;                                     // 0x00D0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMapDataRegistered_Delegate;                      // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMapDataUnRegistered_Delegate;                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLMapData_Sector>         DataClass_Sector;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLMapData_Marker>         DataClass_MapMarker;                               // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLMapData_ReconItem>      DataClass_ReconItem;                               // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapStateComponent">();
	}
	static class UHLLMapStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapStateComponent>();
	}
};
static_assert(alignof(UHLLMapStateComponent) == 0x000008, "Wrong alignment on UHLLMapStateComponent");
static_assert(sizeof(UHLLMapStateComponent) == 0x000118, "Wrong size on UHLLMapStateComponent");
static_assert(offsetof(UHLLMapStateComponent, MapDataObjects) == 0x0000B0, "Member 'UHLLMapStateComponent::MapDataObjects' has a wrong offset!");
static_assert(offsetof(UHLLMapStateComponent, PlayerMarkers) == 0x0000C0, "Member 'UHLLMapStateComponent::PlayerMarkers' has a wrong offset!");
static_assert(offsetof(UHLLMapStateComponent, TeamReconData) == 0x0000D0, "Member 'UHLLMapStateComponent::TeamReconData' has a wrong offset!");
static_assert(offsetof(UHLLMapStateComponent, OnMapDataRegistered_Delegate) == 0x0000E0, "Member 'UHLLMapStateComponent::OnMapDataRegistered_Delegate' has a wrong offset!");
static_assert(offsetof(UHLLMapStateComponent, OnMapDataUnRegistered_Delegate) == 0x0000F0, "Member 'UHLLMapStateComponent::OnMapDataUnRegistered_Delegate' has a wrong offset!");
static_assert(offsetof(UHLLMapStateComponent, DataClass_Sector) == 0x000100, "Member 'UHLLMapStateComponent::DataClass_Sector' has a wrong offset!");
static_assert(offsetof(UHLLMapStateComponent, DataClass_MapMarker) == 0x000108, "Member 'UHLLMapStateComponent::DataClass_MapMarker' has a wrong offset!");
static_assert(offsetof(UHLLMapStateComponent, DataClass_ReconItem) == 0x000110, "Member 'UHLLMapStateComponent::DataClass_ReconItem' has a wrong offset!");

// Class HLL.SoundNodeVolumeType
// 0x0008 (0x0050 - 0x0048)
class USoundNodeVolumeType final : public USoundNode
{
public:
	uint8                                         bUseListenerVolume : 1;                            // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFallbackToDefault : 1;                            // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bContinuousUpdate : 1;                             // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRestartOnSwap : 1;                                // 0x0048(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_120B[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeVolumeType">();
	}
	static class USoundNodeVolumeType* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeVolumeType>();
	}
};
static_assert(alignof(USoundNodeVolumeType) == 0x000008, "Wrong alignment on USoundNodeVolumeType");
static_assert(sizeof(USoundNodeVolumeType) == 0x000050, "Wrong size on USoundNodeVolumeType");

// Class HLL.HLLCommanderAbility_Selection
// 0x0028 (0x0388 - 0x0360)
class AHLLCommanderAbility_Selection : public AHLLCommanderAbility
{
public:
	TArray<TSubclassOf<class AHLLMapDataBase>>    SelectableDataTypes;                               // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAbilitySelection                      RepSelection;                                      // 0x0370(0x0018)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_Selection();
	void OnSelectionDestroyed(class AActor* Destroyed);
	void ServerSelect(class AActor* InSelection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_Selection">();
	}
	static class AHLLCommanderAbility_Selection* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_Selection>();
	}
};
static_assert(alignof(AHLLCommanderAbility_Selection) == 0x000008, "Wrong alignment on AHLLCommanderAbility_Selection");
static_assert(sizeof(AHLLCommanderAbility_Selection) == 0x000388, "Wrong size on AHLLCommanderAbility_Selection");
static_assert(offsetof(AHLLCommanderAbility_Selection, SelectableDataTypes) == 0x000360, "Member 'AHLLCommanderAbility_Selection::SelectableDataTypes' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_Selection, RepSelection) == 0x000370, "Member 'AHLLCommanderAbility_Selection::RepSelection' has a wrong offset!");

// Class HLL.HLLAbility_RemoveGarrison
// 0x0000 (0x0388 - 0x0388)
class AHLLAbility_RemoveGarrison final : public AHLLCommanderAbility_Selection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbility_RemoveGarrison">();
	}
	static class AHLLAbility_RemoveGarrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbility_RemoveGarrison>();
	}
};
static_assert(alignof(AHLLAbility_RemoveGarrison) == 0x000008, "Wrong alignment on AHLLAbility_RemoveGarrison");
static_assert(sizeof(AHLLAbility_RemoveGarrison) == 0x000388, "Wrong size on AHLLAbility_RemoveGarrison");

// Class HLL.ShooterHUD
// 0x0490 (0x07A0 - 0x0310)
class AShooterHUD : public AHUD
{
public:
	uint8                                         Pad_120C[0x18];                                    // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   RemainingTimeText;                                 // 0x0328(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_120D[0x2];                                     // 0x0340(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          RoleSelectionEnabledOnDeploymentScreen;            // 0x0342(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120E[0x5];                                     // 0x0343(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLHUDBase>                HUDWidgetClass;                                    // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HUDWidgetZOrder;                                   // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120F[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLHintWidget>             HintWidgetClass;                                   // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HintWidgetZOrder;                                  // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DeploymentWidgetZOrder;                            // 0x0364(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UChatOverlay>               ChatOverlayWidgetClass;                            // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChatOverlayWidgetZOrder;                           // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChatOverlayVisibilityTimeout;                      // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLHUDBase*                            M_hudWidget;                                       // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLHintWidget*                         M_HintWidget;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatOverlay*                           M_chatOverlay;                                     // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1210[0x10];                                    // 0x0390(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLDeploymentScreen*                   M_deploymentScreen;                                // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1211[0x5C];                                    // 0x03A8(0x005C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MaxTeammateNameVisibilityDistance;                 // 0x0404(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPlatoonMemberNameVisibilityDistance;            // 0x0408(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1212[0x4];                                     // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnShowDeploymentScreenRequested;                   // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHideDeploymentScreenRequested;                   // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnRoundSummaryVisibilityChanged;                   // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         OverviewMapZOrder;                                 // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1213[0x4];                                     // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLOverviewMapWrapper*                 M_OverviewMap;                                     // 0x0448(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RconConsoleZOrder;                                 // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1214[0x4];                                     // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLRconCommandWindow>      RconConsoleClass;                                  // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLRconCommandWindow*                  M_RconConsole;                                     // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUseContextContainer>    UseContextWidgetClass;                             // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchors                               UseContextAnchors;                                 // 0x0470(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         UseContextZOrder;                                  // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UseContextAlignment;                               // 0x0484(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1215[0x4];                                     // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLUseContextContainer*                M_UseContextWidget;                                // 0x0490(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ScopeWidgetZOrder;                                 // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1216[0x4];                                     // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLScopeWidget*                        ActiveScopeWidget;                                 // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1217[0x8];                                     // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLInGameMenu*                         ActiveGameMenu;                                    // 0x04B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GameMenuZOrder;                                    // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1218[0x4];                                     // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLRoundSummary*                       ActiveRoundSummary;                                // 0x04C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1219[0x4];                                     // 0x04C8(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         RoundSummaryZOrder;                                // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLRoundSummary>           RoundSummaryClass;                                 // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DeathScreenZOrder;                                 // 0x04D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121A[0x4];                                     // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLDeathScreen*                        ActiveDeathScreen;                                 // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121B[0x4];                                     // 0x04E8(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSectorCaptureProgressWheelColor       YourSectorProgressColors;                          // 0x04EC(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSectorCaptureProgressWheelColor       EnemySectorProgressColors;                         // 0x050C(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSectorCaptureProgressWheelColor       ContestedSectorProgressColors;                     // 0x052C(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         SeatWidgetZOrder;                                  // 0x054C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLSeatWidgetBase*                     M_ActiveSeatUI;                                    // 0x0550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_RconSayDuration;                                 // 0x0558(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121C[0x14];                                    // 0x055C(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLDamageIndicator*                    DamageIndicator;                                   // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLDamageIndicator>        DamageIndicatorClass;                              // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageIndicatorZOrder;                             // 0x0580(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121D[0x4];                                     // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USpeakingPlayersList*                   SpeakingPlayers;                                   // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USpeakingPlayersList>       SpeakingPlayersClass;                              // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpeakingPlayersZOrder;                             // 0x0598(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnchors                               SpeakingPlayersAnchors;                            // 0x059C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              SpeakingPlayersAlignment;                          // 0x05AC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                SpeakingPlayersOffsets;                            // 0x05B4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_121E[0x4];                                     // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UUserWidget*                            StatsTestWidget;                                   // 0x05C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                StatsTestWidgetClass;                              // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlatoonInvitationDialogZOrder;                     // 0x05D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121F[0xC];                                     // 0x05DC(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UPlatoonManagementStack>    PlatoonManagementStackWidget;                      // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlatoonManagementStackZOrder;                      // 0x05F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1220[0x24];                                    // 0x05F4(0x0024)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLRadialMenu_MarkersBase*             ActiveMarkerMenu;                                  // 0x0618(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MarkerMenuZOrder;                                  // 0x0620(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1221[0x4];                                     // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLRadialMenu_MarkersBase> MarkerMenuClass;                                   // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnchors                               MarkerMenuAnchors;                                 // 0x0630(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              MarkerMenuAlignment;                               // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                MarkerMenuOffsets;                                 // 0x0648(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1222[0x8];                                     // 0x0658(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLRadialMenu_ChatBase*                ActiveChatMenu;                                    // 0x0660(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChatMenuZOrder;                                    // 0x0668(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1223[0x4];                                     // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLRadialMenu_ChatBase>    ChatMenuClass;                                     // 0x0670(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnchors                               ChatMenuAnchors;                                   // 0x0678(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              ChatMenuAlignment;                                 // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                ChatMenuOffsets;                                   // 0x0690(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UHLLRadialMenu_WeaponBase*              WeaponRadialMenu;                                  // 0x06A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHLLRadialMenu_WeaponBase>  EquipmentRadialMenuClass;                          // 0x06A8(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1224[0x4];                                     // 0x06B0(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DefaultFadeSpeed;                                  // 0x06B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastFadeSpeed;                                     // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHUDDisplayState                       SecondaryDisplayState;                             // 0x06BC(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1225[0x4];                                     // 0x06CC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLVoteWidget*                         VoteWidget;                                        // 0x06D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLVoteWidget>             VoteWidgetClass;                                   // 0x06D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VoteWidgetZOrder;                                  // 0x06E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnchors                               VoteWidgetAnchors;                                 // 0x06E4(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              VoteWidgetAlignment;                               // 0x06F4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                VoteWidgetOffsets;                                 // 0x06FC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1226[0x4];                                     // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLAdminCamUI*                         AdminCamWidget;                                    // 0x0710(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLAdminCamUI>             AdminCamWidgetClass;                               // 0x0718(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AdminCamWidgetZOrder;                              // 0x0720(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnchors                               AdminCamWidgetAnchors;                             // 0x0724(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              AdminCamWidgetAlignment;                           // 0x0734(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                AdminCamWidgetOffsets;                             // 0x073C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1227[0x4];                                     // 0x074C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUserWidget>                AimDebugWidgetClass;                               // 0x0750(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            AimDebugWidget;                                    // 0x0758(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1228[0x40];                                    // 0x0760(0x0040)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddAbilityUseLine(const class FText& String);
	void AddChatLine(EChatChannel Channel, EPlayerRole PlayerRole, const class FText& SenderName, const class FText& ChatString, bool bWantFocus, const class FString& SenderUniqueId);
	void DeathScreenCompleted();
	void DebugHideHUDUI(const bool bUIHidden);
	void HideDeploymentScreen();
	void HideHUDUI(const bool bUIHidden);
	bool IsDeploymentMapOpen();
	void OnCancel();
	void OnCancelDeploy();
	void OnChatPromptVisibilityChanged(bool bVisible);
	void OnHideDeploymentScreenRequested__DelegateSignature();
	void OnHideOverviewMap(const bool bInstant);
	void OnInputChanged(bool NewValue);
	void OnNewRconSayMessage(class AHLLRconState* Sender, const class FString& Message);
	void OnPostRconSayTimerFinished();
	void OnRconStateCreated(class AHLLRconState* RconInstance);
	void OnSecondaryDisplayKeyPress();
	void OnShowDeploymentScreenRequested__DelegateSignature();
	void OnShowOverviewMap(const bool bInstant);
	void OnSummaryVisibilityChanged__DelegateSignature(bool bVisible);
	void RequestFirstTimeShowRconSay();
	void SetChatWantsFocus(const bool bWantsFocus);
	void ShowDeploymentScreen();
	void ShowLeaveOrQuit(const bool bQuitting);
	void ShowPlatoonInvitationDialog(class UUserWidget* InWidgetFrom);
	void ShowReturnToMainMenu();
	void ShowReturnToWarRoom();
	void ToggleSecondaryDisplay(const bool bWantsVisible, const bool bFromKeyPress, const bool bFast);
	void ToggleStatsDebug(const bool bWantsVisible);
	void UpdateFocusAndMouse();
	void UpdatePlatoon();

	class UChatOverlay* GetChatOverlay() const;
	void GetOverheatDataFromCurrentWeapon(float* OutHeatRatio, bool* OutOverheatLocked) const;
	TArray<struct FDisplayedSectorState> GetTugOfWar() const;
	bool IsGameMenuOpen() const;
	bool IsOverviewMapOpen() const;
	bool IsRoundSummaryVisible() const;
	bool IsShowingAdminCameraWidget() const;
	bool IsShowingPlatoonManagementRequest() const;
	bool WantsChatFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterHUD">();
	}
	static class AShooterHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterHUD>();
	}
};
static_assert(alignof(AShooterHUD) == 0x000008, "Wrong alignment on AShooterHUD");
static_assert(sizeof(AShooterHUD) == 0x0007A0, "Wrong size on AShooterHUD");
static_assert(offsetof(AShooterHUD, RemainingTimeText) == 0x000328, "Member 'AShooterHUD::RemainingTimeText' has a wrong offset!");
static_assert(offsetof(AShooterHUD, RoleSelectionEnabledOnDeploymentScreen) == 0x000342, "Member 'AShooterHUD::RoleSelectionEnabledOnDeploymentScreen' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HUDWidgetClass) == 0x000348, "Member 'AShooterHUD::HUDWidgetClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HUDWidgetZOrder) == 0x000350, "Member 'AShooterHUD::HUDWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HintWidgetClass) == 0x000358, "Member 'AShooterHUD::HintWidgetClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, HintWidgetZOrder) == 0x000360, "Member 'AShooterHUD::HintWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, DeploymentWidgetZOrder) == 0x000364, "Member 'AShooterHUD::DeploymentWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ChatOverlayWidgetClass) == 0x000368, "Member 'AShooterHUD::ChatOverlayWidgetClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ChatOverlayWidgetZOrder) == 0x000370, "Member 'AShooterHUD::ChatOverlayWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ChatOverlayVisibilityTimeout) == 0x000374, "Member 'AShooterHUD::ChatOverlayVisibilityTimeout' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_hudWidget) == 0x000378, "Member 'AShooterHUD::M_hudWidget' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_HintWidget) == 0x000380, "Member 'AShooterHUD::M_HintWidget' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_chatOverlay) == 0x000388, "Member 'AShooterHUD::M_chatOverlay' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_deploymentScreen) == 0x0003A0, "Member 'AShooterHUD::M_deploymentScreen' has a wrong offset!");
static_assert(offsetof(AShooterHUD, MaxTeammateNameVisibilityDistance) == 0x000404, "Member 'AShooterHUD::MaxTeammateNameVisibilityDistance' has a wrong offset!");
static_assert(offsetof(AShooterHUD, MaxPlatoonMemberNameVisibilityDistance) == 0x000408, "Member 'AShooterHUD::MaxPlatoonMemberNameVisibilityDistance' has a wrong offset!");
static_assert(offsetof(AShooterHUD, OnShowDeploymentScreenRequested) == 0x000410, "Member 'AShooterHUD::OnShowDeploymentScreenRequested' has a wrong offset!");
static_assert(offsetof(AShooterHUD, OnHideDeploymentScreenRequested) == 0x000420, "Member 'AShooterHUD::OnHideDeploymentScreenRequested' has a wrong offset!");
static_assert(offsetof(AShooterHUD, OnRoundSummaryVisibilityChanged) == 0x000430, "Member 'AShooterHUD::OnRoundSummaryVisibilityChanged' has a wrong offset!");
static_assert(offsetof(AShooterHUD, OverviewMapZOrder) == 0x000440, "Member 'AShooterHUD::OverviewMapZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_OverviewMap) == 0x000448, "Member 'AShooterHUD::M_OverviewMap' has a wrong offset!");
static_assert(offsetof(AShooterHUD, RconConsoleZOrder) == 0x000450, "Member 'AShooterHUD::RconConsoleZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, RconConsoleClass) == 0x000458, "Member 'AShooterHUD::RconConsoleClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_RconConsole) == 0x000460, "Member 'AShooterHUD::M_RconConsole' has a wrong offset!");
static_assert(offsetof(AShooterHUD, UseContextWidgetClass) == 0x000468, "Member 'AShooterHUD::UseContextWidgetClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, UseContextAnchors) == 0x000470, "Member 'AShooterHUD::UseContextAnchors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, UseContextZOrder) == 0x000480, "Member 'AShooterHUD::UseContextZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, UseContextAlignment) == 0x000484, "Member 'AShooterHUD::UseContextAlignment' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_UseContextWidget) == 0x000490, "Member 'AShooterHUD::M_UseContextWidget' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ScopeWidgetZOrder) == 0x000498, "Member 'AShooterHUD::ScopeWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ActiveScopeWidget) == 0x0004A0, "Member 'AShooterHUD::ActiveScopeWidget' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ActiveGameMenu) == 0x0004B0, "Member 'AShooterHUD::ActiveGameMenu' has a wrong offset!");
static_assert(offsetof(AShooterHUD, GameMenuZOrder) == 0x0004B8, "Member 'AShooterHUD::GameMenuZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ActiveRoundSummary) == 0x0004C0, "Member 'AShooterHUD::ActiveRoundSummary' has a wrong offset!");
static_assert(offsetof(AShooterHUD, RoundSummaryZOrder) == 0x0004CC, "Member 'AShooterHUD::RoundSummaryZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, RoundSummaryClass) == 0x0004D0, "Member 'AShooterHUD::RoundSummaryClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, DeathScreenZOrder) == 0x0004D8, "Member 'AShooterHUD::DeathScreenZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ActiveDeathScreen) == 0x0004E0, "Member 'AShooterHUD::ActiveDeathScreen' has a wrong offset!");
static_assert(offsetof(AShooterHUD, YourSectorProgressColors) == 0x0004EC, "Member 'AShooterHUD::YourSectorProgressColors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, EnemySectorProgressColors) == 0x00050C, "Member 'AShooterHUD::EnemySectorProgressColors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ContestedSectorProgressColors) == 0x00052C, "Member 'AShooterHUD::ContestedSectorProgressColors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SeatWidgetZOrder) == 0x00054C, "Member 'AShooterHUD::SeatWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_ActiveSeatUI) == 0x000550, "Member 'AShooterHUD::M_ActiveSeatUI' has a wrong offset!");
static_assert(offsetof(AShooterHUD, M_RconSayDuration) == 0x000558, "Member 'AShooterHUD::M_RconSayDuration' has a wrong offset!");
static_assert(offsetof(AShooterHUD, DamageIndicator) == 0x000570, "Member 'AShooterHUD::DamageIndicator' has a wrong offset!");
static_assert(offsetof(AShooterHUD, DamageIndicatorClass) == 0x000578, "Member 'AShooterHUD::DamageIndicatorClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, DamageIndicatorZOrder) == 0x000580, "Member 'AShooterHUD::DamageIndicatorZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SpeakingPlayers) == 0x000588, "Member 'AShooterHUD::SpeakingPlayers' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SpeakingPlayersClass) == 0x000590, "Member 'AShooterHUD::SpeakingPlayersClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SpeakingPlayersZOrder) == 0x000598, "Member 'AShooterHUD::SpeakingPlayersZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SpeakingPlayersAnchors) == 0x00059C, "Member 'AShooterHUD::SpeakingPlayersAnchors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SpeakingPlayersAlignment) == 0x0005AC, "Member 'AShooterHUD::SpeakingPlayersAlignment' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SpeakingPlayersOffsets) == 0x0005B4, "Member 'AShooterHUD::SpeakingPlayersOffsets' has a wrong offset!");
static_assert(offsetof(AShooterHUD, StatsTestWidget) == 0x0005C8, "Member 'AShooterHUD::StatsTestWidget' has a wrong offset!");
static_assert(offsetof(AShooterHUD, StatsTestWidgetClass) == 0x0005D0, "Member 'AShooterHUD::StatsTestWidgetClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, PlatoonInvitationDialogZOrder) == 0x0005D8, "Member 'AShooterHUD::PlatoonInvitationDialogZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, PlatoonManagementStackWidget) == 0x0005E8, "Member 'AShooterHUD::PlatoonManagementStackWidget' has a wrong offset!");
static_assert(offsetof(AShooterHUD, PlatoonManagementStackZOrder) == 0x0005F0, "Member 'AShooterHUD::PlatoonManagementStackZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ActiveMarkerMenu) == 0x000618, "Member 'AShooterHUD::ActiveMarkerMenu' has a wrong offset!");
static_assert(offsetof(AShooterHUD, MarkerMenuZOrder) == 0x000620, "Member 'AShooterHUD::MarkerMenuZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, MarkerMenuClass) == 0x000628, "Member 'AShooterHUD::MarkerMenuClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, MarkerMenuAnchors) == 0x000630, "Member 'AShooterHUD::MarkerMenuAnchors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, MarkerMenuAlignment) == 0x000640, "Member 'AShooterHUD::MarkerMenuAlignment' has a wrong offset!");
static_assert(offsetof(AShooterHUD, MarkerMenuOffsets) == 0x000648, "Member 'AShooterHUD::MarkerMenuOffsets' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ActiveChatMenu) == 0x000660, "Member 'AShooterHUD::ActiveChatMenu' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ChatMenuZOrder) == 0x000668, "Member 'AShooterHUD::ChatMenuZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ChatMenuClass) == 0x000670, "Member 'AShooterHUD::ChatMenuClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ChatMenuAnchors) == 0x000678, "Member 'AShooterHUD::ChatMenuAnchors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ChatMenuAlignment) == 0x000688, "Member 'AShooterHUD::ChatMenuAlignment' has a wrong offset!");
static_assert(offsetof(AShooterHUD, ChatMenuOffsets) == 0x000690, "Member 'AShooterHUD::ChatMenuOffsets' has a wrong offset!");
static_assert(offsetof(AShooterHUD, WeaponRadialMenu) == 0x0006A0, "Member 'AShooterHUD::WeaponRadialMenu' has a wrong offset!");
static_assert(offsetof(AShooterHUD, EquipmentRadialMenuClass) == 0x0006A8, "Member 'AShooterHUD::EquipmentRadialMenuClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, DefaultFadeSpeed) == 0x0006B4, "Member 'AShooterHUD::DefaultFadeSpeed' has a wrong offset!");
static_assert(offsetof(AShooterHUD, FastFadeSpeed) == 0x0006B8, "Member 'AShooterHUD::FastFadeSpeed' has a wrong offset!");
static_assert(offsetof(AShooterHUD, SecondaryDisplayState) == 0x0006BC, "Member 'AShooterHUD::SecondaryDisplayState' has a wrong offset!");
static_assert(offsetof(AShooterHUD, VoteWidget) == 0x0006D0, "Member 'AShooterHUD::VoteWidget' has a wrong offset!");
static_assert(offsetof(AShooterHUD, VoteWidgetClass) == 0x0006D8, "Member 'AShooterHUD::VoteWidgetClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, VoteWidgetZOrder) == 0x0006E0, "Member 'AShooterHUD::VoteWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, VoteWidgetAnchors) == 0x0006E4, "Member 'AShooterHUD::VoteWidgetAnchors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, VoteWidgetAlignment) == 0x0006F4, "Member 'AShooterHUD::VoteWidgetAlignment' has a wrong offset!");
static_assert(offsetof(AShooterHUD, VoteWidgetOffsets) == 0x0006FC, "Member 'AShooterHUD::VoteWidgetOffsets' has a wrong offset!");
static_assert(offsetof(AShooterHUD, AdminCamWidget) == 0x000710, "Member 'AShooterHUD::AdminCamWidget' has a wrong offset!");
static_assert(offsetof(AShooterHUD, AdminCamWidgetClass) == 0x000718, "Member 'AShooterHUD::AdminCamWidgetClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, AdminCamWidgetZOrder) == 0x000720, "Member 'AShooterHUD::AdminCamWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AShooterHUD, AdminCamWidgetAnchors) == 0x000724, "Member 'AShooterHUD::AdminCamWidgetAnchors' has a wrong offset!");
static_assert(offsetof(AShooterHUD, AdminCamWidgetAlignment) == 0x000734, "Member 'AShooterHUD::AdminCamWidgetAlignment' has a wrong offset!");
static_assert(offsetof(AShooterHUD, AdminCamWidgetOffsets) == 0x00073C, "Member 'AShooterHUD::AdminCamWidgetOffsets' has a wrong offset!");
static_assert(offsetof(AShooterHUD, AimDebugWidgetClass) == 0x000750, "Member 'AShooterHUD::AimDebugWidgetClass' has a wrong offset!");
static_assert(offsetof(AShooterHUD, AimDebugWidget) == 0x000758, "Member 'AShooterHUD::AimDebugWidget' has a wrong offset!");

// Class HLL.HLLAbility_ResourceConversion
// 0x0008 (0x0368 - 0x0360)
class AHLLAbility_ResourceConversion final : public AHLLCommanderAbility
{
public:
	EGameResource                                 GeneratedResource;                                 // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122C[0x3];                                     // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         GeneratedAmount;                                   // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbility_ResourceConversion">();
	}
	static class AHLLAbility_ResourceConversion* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbility_ResourceConversion>();
	}
};
static_assert(alignof(AHLLAbility_ResourceConversion) == 0x000008, "Wrong alignment on AHLLAbility_ResourceConversion");
static_assert(sizeof(AHLLAbility_ResourceConversion) == 0x000368, "Wrong size on AHLLAbility_ResourceConversion");
static_assert(offsetof(AHLLAbility_ResourceConversion, GeneratedResource) == 0x000360, "Member 'AHLLAbility_ResourceConversion::GeneratedResource' has a wrong offset!");
static_assert(offsetof(AHLLAbility_ResourceConversion, GeneratedAmount) == 0x000364, "Member 'AHLLAbility_ResourceConversion::GeneratedAmount' has a wrong offset!");

// Class HLL.HLLAbility_SpawnVehicle
// 0x0010 (0x0390 - 0x0380)
class AHLLAbility_SpawnVehicle final : public AHLLCommanderAbility_Placeable
{
public:
	TSubclassOf<class AActor>                     VehicleClass;                                      // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLimitTotalCountPerTeam : 1;                       // 0x0388(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         MaxTotalCountPerTeam;                              // 0x0389(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122D[0x6];                                     // 0x038A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbility_SpawnVehicle">();
	}
	static class AHLLAbility_SpawnVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbility_SpawnVehicle>();
	}
};
static_assert(alignof(AHLLAbility_SpawnVehicle) == 0x000008, "Wrong alignment on AHLLAbility_SpawnVehicle");
static_assert(sizeof(AHLLAbility_SpawnVehicle) == 0x000390, "Wrong size on AHLLAbility_SpawnVehicle");
static_assert(offsetof(AHLLAbility_SpawnVehicle, VehicleClass) == 0x000380, "Member 'AHLLAbility_SpawnVehicle::VehicleClass' has a wrong offset!");
static_assert(offsetof(AHLLAbility_SpawnVehicle, MaxTotalCountPerTeam) == 0x000389, "Member 'AHLLAbility_SpawnVehicle::MaxTotalCountPerTeam' has a wrong offset!");

// Class HLL.HLLMapTooltip_ResourceNode
// 0x0018 (0x0278 - 0x0260)
class UHLLMapTooltip_ResourceNode : public UHLLTooltipBase
{
public:
	class UImage*                                 ResourceTypeImage;                                 // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ResourceTypeText;                                  // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ResourceGenValue;                                  // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapTooltip_ResourceNode">();
	}
	static class UHLLMapTooltip_ResourceNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapTooltip_ResourceNode>();
	}
};
static_assert(alignof(UHLLMapTooltip_ResourceNode) == 0x000008, "Wrong alignment on UHLLMapTooltip_ResourceNode");
static_assert(sizeof(UHLLMapTooltip_ResourceNode) == 0x000278, "Wrong size on UHLLMapTooltip_ResourceNode");
static_assert(offsetof(UHLLMapTooltip_ResourceNode, ResourceTypeImage) == 0x000260, "Member 'UHLLMapTooltip_ResourceNode::ResourceTypeImage' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_ResourceNode, ResourceTypeText) == 0x000268, "Member 'UHLLMapTooltip_ResourceNode::ResourceTypeText' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_ResourceNode, ResourceGenValue) == 0x000270, "Member 'UHLLMapTooltip_ResourceNode::ResourceGenValue' has a wrong offset!");

// Class HLL.ShooterGameUserSettings
// 0x0328 (0x0448 - 0x0120)
class UShooterGameUserSettings final : public UGameUserSettings
{
public:
	uint8                                         Pad_122E[0x8];                                     // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnRendererChangeReverted;                          // 0x0128(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_122F[0x4];                                     // 0x0138(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         HLL_GlobalQualityLevel;                            // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HLL_SSAOQualityLevel;                              // 0x0140(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TeamNameplateDistIndex;                            // 0x0144(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UnitNameplateDistIndex;                            // 0x0148(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SeatNameplateDistIndex;                            // 0x014C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NameplateSwitchRatio;                              // 0x0150(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerNameplateOpacity;                            // 0x0154(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseNameplateOcclusion;                            // 0x0158(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseNameplateOcclusionUnit;                        // 0x0159(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1230[0x2];                                     // 0x015A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   SelectedGamepadLayout;                             // 0x015C(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HLL_ResolutionScale;                               // 0x0164(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         HLLSettingsVersion;                                // 0x0168(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1231[0x1];                                     // 0x0169(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bIsLanMatch;                                       // 0x016A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1232[0x1];                                     // 0x016B(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Brightness;                                        // 0x016C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHLLGraphicsRHISetting                        RendererAPI;                                       // 0x0170(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MotionBlur;                                        // 0x0171(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1233[0x2];                                     // 0x0172(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MouseSensitivity;                                  // 0x0174(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ADSMouseSensitivity;                               // 0x0178(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeLookMouseSensitivity;                          // 0x017C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertMouseVehicle;                                // 0x0180(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertMouseFirstPerson;                            // 0x0181(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1234[0x2];                                     // 0x0182(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         GamepadSensitivity;                                // 0x0184(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadSensitivityY;                               // 0x0188(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ADSGamepadSensitivity;                             // 0x018C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ADSGamepadSensitivityY;                            // 0x0190(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeLookGamepadSensitivityX;                       // 0x0194(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeLookGamepadSensitivityY;                       // 0x0198(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScopedGamepadSensitivity;                          // 0x019C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadCursorSensitivity;                          // 0x01A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadMovementDeadZone;                           // 0x01A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadLookDeadZone;                               // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHLLAimAssistLevel                            GamepadAimAssist;                                  // 0x01AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertAnalogVehicleYAxis;                          // 0x01AD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertAnalogVehicleXAxis;                          // 0x01AE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertAnalogFirstPersonYAxis;                      // 0x01AF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertAnalogFirstPersonXAxis;                      // 0x01B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ToggleSteadyAim;                                   // 0x01B1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ToggleCrouch;                                      // 0x01B2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ToggleADS;                                         // 0x01B3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ToggleSprint;                                      // 0x01B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ToggleLean;                                        // 0x01B5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideKickVoteRequests;                              // 0x01B6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1235[0x1];                                     // 0x01B7(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MasterVolume;                                      // 0x01B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MusicVolume;                                       // 0x01BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SfxVolume;                                         // 0x01C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VoiceVolume;                                       // 0x01C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProximityVoiceVolume;                              // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UnitVoiceVolume;                                   // 0x01CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeadershipVoiceVolume;                             // 0x01D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PartyVoiceVolume;                                  // 0x01D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MicVolume;                                         // 0x01D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UIVolume_3D;                                       // 0x01DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UIVolume_2D;                                       // 0x01E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1236[0x4];                                     // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 LastAudioInputDevice;                              // 0x01E8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LastAudioOutputDevice;                             // 0x01F8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bManualBolting;                                    // 0x0208(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGoreDisabled;                                     // 0x0209(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1237[0x2];                                     // 0x020A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         FOV;                                               // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDedicatedServer;                                // 0x0210(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseCrossplayServers;                              // 0x0211(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldLogInEpicAccount;                           // 0x0212(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1238[0x1];                                     // 0x0213(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         LastSeenEULAVersion;                               // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            MasterAudioClass;                                  // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            SFXAudioClass;                                     // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            MusicAudioClass;                                   // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            UIAudioClass_3D;                                   // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            UIAudioClass_2D;                                   // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHLLPlayerFlags                        PlayerFlags;                                       // 0x0240(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 M_LastMatchID;                                     // 0x0248(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHLLPlayerPreferences                  PlayerPreferences;                                 // 0x0258(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FScalabilityLevelsSnapshot             ScalabilityLevelsSnapshot;                         // 0x0270(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1239[0x10];                                    // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FServerBrowserFilters                  ServerBrowserFilters;                              // 0x02A0(0x0058)(Config, NativeAccessSpecifierPrivate)
	TArray<struct FServerBrowserFavouriteServerData> FavouriteServers;                                  // 0x02F8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FServerBrowserHistoryServerData> HistoryServers;                                    // 0x0308(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeadBodyDespawnDelay;                              // 0x0318(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bProfanityFilterEnabled;                           // 0x031C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowChatOnNewMessage;                             // 0x031D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_123A[0x2];                                     // 0x031E(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FHLLSavedCharacterCosmetics>    SavedCosmetics;                                    // 0x0320(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         HLLCosmeticsVersion;                               // 0x0330(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_123B[0x7];                                     // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<uint8>                                 ActiveCosmeticIndices;                             // 0x0338(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFaction                                      FavDisplayFaction;                                 // 0x0348(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerRole                                   FavDisplayRole;                                    // 0x0349(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_123C[0x6];                                     // 0x034A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FHLLSavedCharacterLoadout>      SavedLoadouts;                                     // 0x0350(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLAntiAliasingMethod                        AntiAliasingMethod;                                // 0x0360(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_123D[0x7];                                     // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<bool>                                  CompletedHints;                                    // 0x0368(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HintsVersion;                                      // 0x0378(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHintsEnabled;                                     // 0x037C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_123E[0x3];                                     // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 Hints;                                             // 0x0380(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_123F[0x1];                                     // 0x0390(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bLinkMarkersToHUD;                                 // 0x0391(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1240[0x2];                                     // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MarkerFadeScale;                                   // 0x0394(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         POIFadeScale;                                      // 0x0398(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasShownDisclaimer;                               // 0x039C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1241[0x3];                                     // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         HUDFadeTimeScale;                                  // 0x03A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHUDMode                                      HUDMode;                                           // 0x03A4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisableFPPBullets : 1;                            // 0x03A5(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1242[0x2];                                     // 0x03A6(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnResolutionChangeReverted;                        // 0x03A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1243[0x28];                                    // 0x03B8(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 ClanTag;                                           // 0x03E0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1244[0x1];                                     // 0x03F0(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	EAspectRatioAxisConstraint                    AspectRatioAxisConstraint;                         // 0x03F1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FStreamerModeSettings                  StreamModeSettings;                                // 0x03F2(0x0004)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowCommandMessages;                              // 0x03F6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VibrationEnabled;                                  // 0x03F7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLVibrationIntensityLevel                   VibrationLevel;                                    // 0x03F8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AdaptiveTriggersEnabled;                           // 0x03F9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLAdaptiveTriggerIntensityLevel             AdaptiveTriggersLevel;                             // 0x03FA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1245[0x1];                                     // 0x03FB(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ControllerAccelerationXValue;                      // 0x03FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ControllerAccelerationYValue;                      // 0x0400(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1246[0x1C];                                    // 0x0404(0x001C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MapIconScale;                                      // 0x0420(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1247[0x1C];                                    // 0x0424(0x001C)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bMapPingRepeating;                                 // 0x0440(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1248[0x7];                                     // 0x0441(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static bool GamepadLayoutAOrB();
	static class UShooterGameUserSettings* Get_ReadWrite();

	void ApplyAudioSettings();
	void ApplyLevelSpecificSettingsOverrides();
	void ClearPendingDisclaimer();
	void MarkHintCompleted(const EHint InHint);
	void OnRendererChangeReverted__DelegateSignature();
	void OnResolutionChangeReverted__DelegateSignature();
	void ResetAudioOptionsToDefaults();
	void ResetControllerLayoutToDefault();
	void ResetControlsOptionsToDefaults();
	void ResetGameplayOptionsToDefault();
	void ResetHints(bool bDoSaveGame);
	void ResetVideoOptionsToDefaults();
	void RestoreSnapshot();
	void SaveSnapshot();
	bool SetActiveCharacterCosmeticIndex(const EPlayerRole ForRole, const EFaction ForFaction, const uint8 Param_Index);
	void SetAdaptiveTriggersLevel(const EHLLAdaptiveTriggerIntensityLevel bSetting);
	void SetADSGamepadSensitivityX(float Value);
	void SetADSGamepadSensitivityY(float Value);
	void SetADSMouseSensitivity(float Value);
	void SetAntiAliasingMethod(EHLLAntiAliasingMethod Method);
	void SetAspectRatioAxisConstraint(const EAspectRatioAxisConstraint NewValue);
	void SetBrightness(float Value);
	bool SetCharacterCosmetics(const EPlayerRole ForRole, const EFaction ForFaction, const uint8 ForIndex, const struct FCharacterCosmeticProfile& CosmeticProfile);
	bool SetCharacterLoadoutID(const EPlayerRole ForRole, const EFaction Faction, const uint8 LoadoutID);
	void SetClanTag(const class UObject* WorldContextObject, const class FString& Tag);
	void SetControllerAccelerationValue(const bool bIsX, const float Value);
	void SetDeadBodyDespawnDelay(float Value);
	void SetDisableFPPBullets(const bool bDisabled);
	bool SetFavouriteCosmetics(const EFaction Faction, const EPlayerRole Role);
	void SetFOV(float Value);
	void SetFreeLookGamepadSensitivityX(float Value);
	void SetFreeLookGamepadSensitivityY(float Value);
	void SetFreeLookMouseSensitivity(float Value);
	void SetGamepadAimAssist(const EHLLAimAssistLevel InGamepadAimAssist);
	void SetGamepadCursorSensitivity(float Value);
	void SetGamepadLookDeadZone(float Value);
	void SetGamepadMovementDeadZone(float Value);
	void SetGamepadSensitivityX(float Value);
	void SetGamepadSensitivityY(float Value);
	void SetGoreDisabled(bool Value);
	void SetHideKickVoteRequests(bool Value);
	void SetHintsEnabled(const bool bNewEnabled);
	void SetHLLResolutionScale(const float InValue);
	void SetHUDFadeTimeScale(const float NewScale);
	void SetHUDMode(const EHUDMode NewMode);
	void SetInvertAnalog(bool Value);
	void SetInvertFirstPersonAnalogXAxis(bool Value);
	void SetInvertFirstPersonAnalogYAxis(bool Value);
	void SetInvertFirstPersonMouse(bool Value);
	void SetInvertVehicleAnalogXAxis(bool Value);
	void SetInvertVehicleAnalogYAxis(bool Value);
	void SetInvertVehicleMouse(bool Value);
	void SetLastAudioInputDevice(const class FString& Value);
	void SetLastAudioOutputDevice(const class FString& Value);
	void SetLeadershipVoiceVolume(const float Value);
	void SetLinkMarkersToHUD(const bool bNewEnabled);
	void SetLocalSeenCrossplayDialog(bool bLocalSeenCrossplayDialog);
	void SetLocalSeenEULAVersion(int32 LocalSeenEULAVersion);
	void SetManualBolting(bool Value);
	void SetMapIconScale(const float Value);
	void SetMapPingRepeating(const bool Value);
	void SetMarkerFadeScale(const float NewScale);
	void SetMasterVolume(const float Value);
	void SetMicVolume(const float Value);
	void SetMotionBlur(bool Enabled);
	void SetMouseSensitivity(float Value);
	void SetMusicVolume(const float Value);
	void SetNameplateSwitchRatio(const float InAlpha);
	void SetPartyVoiceVolume(const float Value);
	void SetPlayerNameplateOpacity(const float InAlpha);
	void SetPOIFadeScale(const float NewScale);
	void SetProfanityFilterEnabled(bool Enabled);
	void SetProximityVoiceVolume(const float Value);
	void SetScopedGamepadSensitivity(float Value);
	void SetScreenResolutionExplicit(const struct FIntPoint& Resolution);
	void SetSeatNameplateIndex(const float InAlpha);
	void SetSfxVolume(const float Value);
	void SetShouldLoginEpicAccount(bool Value);
	void SetShouldShowChatWhenNewMessageArrives(bool Should);
	void SetShowCommandMessages(const bool bSetting);
	void SetSmoothMouse(bool Value);
	void SetSSAOQualityLevel(const int32 NewQuality);
	void SetStreamModeSettings(const struct FStreamerModeSettings& InSettings);
	void SetTeamNameplateIndex(const float InAlpha);
	void SetToggleADS(bool Value);
	void SetToggleCrouch(bool Value);
	void SetToggleLean(bool Value);
	void SetToggleSprint(bool Value);
	void SetToggleSteadyAim(bool Value);
	void SetUIVolume_2D(const float Value);
	void SetUIVolume_3D(const float Value);
	void SetUnitNameplateIndex(const float InAlpha);
	void SetUnitVoiceVolume(const float Value);
	void SetUseCrossplayServers(bool Value);
	void SetUseNameplateOcclusionTeam(const bool bUse);
	void SetUseNameplateOcclusionUnit(const bool bUse);
	void SetVibrationLevel(const EHLLVibrationIntensityLevel bSetting);
	void SetVoiceVolume(const float Value);

	bool AreFavouritesValid() const;
	bool AreHintsEnabled() const;
	bool AreMarkersLinkedToHUD() const;
	uint8 GetActiveCharacterCosmeticIndex(const EPlayerRole ForRole, const EFaction ForFaction) const;
	EHLLAdaptiveTriggerIntensityLevel GetAdaptiveTriggersLevel() const;
	float GetADSGamepadSensitivityX() const;
	float GetADSGamepadSensitivityY() const;
	float GetADSMouseSensitivity() const;
	EHLLAntiAliasingMethod GetAntiAliasingMethod() const;
	EAspectRatioAxisConstraint GetAspectRatioAxisConstraint() const;
	float GetBrightness() const;
	struct FCharacterCosmeticProfile GetCharacterCosmetics(const EPlayerRole ForRole, const EFaction ForFaction, const uint8 ForIndex, const bool bMakeSafe) const;
	uint8 GetCharacterLoadoutID(const EPlayerRole ForRole, const EFaction Faction) const;
	class FString GetClanTag() const;
	struct FVector2D GetConsoleFOVRange() const;
	float GetControllerAccelerationXValue() const;
	float GetControllerAccelerationYValue() const;
	EHLLGraphicsRHISetting GetCurrentRendererAPI() const;
	float GetDeadBodyDespawnDelay() const;
	struct FVector2D GetDeadBodyDespawnDelayRange() const;
	bool GetDisableFPPBullets() const;
	EFaction GetFavouriteCosmeticFaction() const;
	EPlayerRole GetFavouriteCosmeticRole() const;
	class FText GetFormattedClanTag() const;
	float GetFOV() const;
	struct FVector2D GetFOVRange() const;
	float GetFreeLookGamepadSensitivityX() const;
	float GetFreeLookGamepadSensitivityY() const;
	float GetFreeLookMouseSensitivity() const;
	EHLLAimAssistLevel GetGamepadAimAssist() const;
	float GetGamepadCursorSensitivity() const;
	float GetGamepadLookDeadZone() const;
	float GetGamepadMovementDeadZone() const;
	float GetGamepadSensitivityX() const;
	float GetGamepadSensitivityY() const;
	bool GetGoreDisabled() const;
	bool GetHideKickVoteRequests() const;
	int32 GetHLLOverallScalabilityLevel() const;
	float GetHUDFadeTime() const;
	float GetHUDFadeTimeScale() const;
	EHUDMode GetHUDMode() const;
	bool GetInvertAnalog() const;
	bool GetInvertFirstPersonAnalogXAxis() const;
	bool GetInvertFirstPersonAnalogYAxis() const;
	bool GetInvertFirstPersonMouse() const;
	bool GetInvertVehicleAnalogXAxis() const;
	bool GetInvertVehicleAnalogYAxis() const;
	bool GetInvertVehicleMouse() const;
	class FString GetLastAudioInputDevice() const;
	class FString GetLastAudioOutputDevice() const;
	int32 GetLastSeenEULAVersion() const;
	float GetLeadershipVoiceVolume() const;
	bool GetLocalCrossplaySetting() const;
	bool GetLocalPrivateLobbySetting() const;
	class FString GetLocalRegionKeySetting() const;
	bool GetManualBolting() const;
	float GetMapIconScale() const;
	bool GetMapPingRepeating() const;
	float GetMarkerDisplayTime() const;
	float GetMarkerFadeScale() const;
	float GetMasterVolume() const;
	float GetMaxResolutionScale() const;
	float GetMicVolume() const;
	bool GetMotionBlur() const;
	float GetMouseSensitivity() const;
	float GetMusicVolume() const;
	float GetNameplateSwitchRatio() const;
	float GetPartyVoiceVolume() const;
	float GetPlayerNameplateOpacity() const;
	float GetPOIDisplayTime() const;
	float GetPOIFadeScale() const;
	float GetProximityVoiceVolume() const;
	float GetScopedGamepadSensitivity() const;
	int32 GetSeatNameplateIndex() const;
	bool GetSeenCrossplayDialog() const;
	float GetSfxVolume() const;
	bool GetShouldLoginEpicAccount() const;
	bool GetShowCommandMessages() const;
	bool GetSmoothMouse() const;
	int32 GetSSAOQualityLevel() const;
	struct FStreamerModeSettings GetStreamModeSettings() const;
	int32 GetTeamNameplateIndex() const;
	bool GetToggleADS() const;
	bool GetToggleCrouch() const;
	bool GetToggleLean() const;
	bool GetToggleSprint() const;
	bool GetToggleSteadyAim() const;
	float GetUIVolume_2D() const;
	float GetUIVolume_3D() const;
	int32 GetUnitNameplateIndex() const;
	float GetUnitVoiceVolume() const;
	bool GetUseCrossplayServers() const;
	bool GetUseNameplateOcclusionTeam() const;
	bool GetUseNameplateOcclusionUnit() const;
	EHLLVibrationIntensityLevel GetVibrationLevel() const;
	float GetVoiceVolume() const;
	bool HasCompletedHint(const EHint InHint) const;
	bool HasPendingDisclaimer() const;
	bool IsProfanityFilterEnabled() const;
	int32 NameplateIndexToDistance(const int32 InIndex) const;
	float NameplateIndexToSlider(const int32 InIndex) const;
	bool ShouldShowChatWhenNewMessageArrives() const;
	int32 SliderToNameplateIndex(const float InAlpha) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameUserSettings">();
	}
	static class UShooterGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameUserSettings>();
	}
};
static_assert(alignof(UShooterGameUserSettings) == 0x000008, "Wrong alignment on UShooterGameUserSettings");
static_assert(sizeof(UShooterGameUserSettings) == 0x000448, "Wrong size on UShooterGameUserSettings");
static_assert(offsetof(UShooterGameUserSettings, OnRendererChangeReverted) == 0x000128, "Member 'UShooterGameUserSettings::OnRendererChangeReverted' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HLL_GlobalQualityLevel) == 0x00013C, "Member 'UShooterGameUserSettings::HLL_GlobalQualityLevel' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HLL_SSAOQualityLevel) == 0x000140, "Member 'UShooterGameUserSettings::HLL_SSAOQualityLevel' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, TeamNameplateDistIndex) == 0x000144, "Member 'UShooterGameUserSettings::TeamNameplateDistIndex' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, UnitNameplateDistIndex) == 0x000148, "Member 'UShooterGameUserSettings::UnitNameplateDistIndex' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, SeatNameplateDistIndex) == 0x00014C, "Member 'UShooterGameUserSettings::SeatNameplateDistIndex' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, NameplateSwitchRatio) == 0x000150, "Member 'UShooterGameUserSettings::NameplateSwitchRatio' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, PlayerNameplateOpacity) == 0x000154, "Member 'UShooterGameUserSettings::PlayerNameplateOpacity' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bUseNameplateOcclusion) == 0x000158, "Member 'UShooterGameUserSettings::bUseNameplateOcclusion' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bUseNameplateOcclusionUnit) == 0x000159, "Member 'UShooterGameUserSettings::bUseNameplateOcclusionUnit' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, SelectedGamepadLayout) == 0x00015C, "Member 'UShooterGameUserSettings::SelectedGamepadLayout' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HLL_ResolutionScale) == 0x000164, "Member 'UShooterGameUserSettings::HLL_ResolutionScale' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HLLSettingsVersion) == 0x000168, "Member 'UShooterGameUserSettings::HLLSettingsVersion' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bIsLanMatch) == 0x00016A, "Member 'UShooterGameUserSettings::bIsLanMatch' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, Brightness) == 0x00016C, "Member 'UShooterGameUserSettings::Brightness' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, RendererAPI) == 0x000170, "Member 'UShooterGameUserSettings::RendererAPI' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MotionBlur) == 0x000171, "Member 'UShooterGameUserSettings::MotionBlur' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MouseSensitivity) == 0x000174, "Member 'UShooterGameUserSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ADSMouseSensitivity) == 0x000178, "Member 'UShooterGameUserSettings::ADSMouseSensitivity' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, FreeLookMouseSensitivity) == 0x00017C, "Member 'UShooterGameUserSettings::FreeLookMouseSensitivity' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, InvertMouseVehicle) == 0x000180, "Member 'UShooterGameUserSettings::InvertMouseVehicle' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, InvertMouseFirstPerson) == 0x000181, "Member 'UShooterGameUserSettings::InvertMouseFirstPerson' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, GamepadSensitivity) == 0x000184, "Member 'UShooterGameUserSettings::GamepadSensitivity' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, GamepadSensitivityY) == 0x000188, "Member 'UShooterGameUserSettings::GamepadSensitivityY' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ADSGamepadSensitivity) == 0x00018C, "Member 'UShooterGameUserSettings::ADSGamepadSensitivity' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ADSGamepadSensitivityY) == 0x000190, "Member 'UShooterGameUserSettings::ADSGamepadSensitivityY' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, FreeLookGamepadSensitivityX) == 0x000194, "Member 'UShooterGameUserSettings::FreeLookGamepadSensitivityX' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, FreeLookGamepadSensitivityY) == 0x000198, "Member 'UShooterGameUserSettings::FreeLookGamepadSensitivityY' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ScopedGamepadSensitivity) == 0x00019C, "Member 'UShooterGameUserSettings::ScopedGamepadSensitivity' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, GamepadCursorSensitivity) == 0x0001A0, "Member 'UShooterGameUserSettings::GamepadCursorSensitivity' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, GamepadMovementDeadZone) == 0x0001A4, "Member 'UShooterGameUserSettings::GamepadMovementDeadZone' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, GamepadLookDeadZone) == 0x0001A8, "Member 'UShooterGameUserSettings::GamepadLookDeadZone' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, GamepadAimAssist) == 0x0001AC, "Member 'UShooterGameUserSettings::GamepadAimAssist' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, InvertAnalogVehicleYAxis) == 0x0001AD, "Member 'UShooterGameUserSettings::InvertAnalogVehicleYAxis' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, InvertAnalogVehicleXAxis) == 0x0001AE, "Member 'UShooterGameUserSettings::InvertAnalogVehicleXAxis' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, InvertAnalogFirstPersonYAxis) == 0x0001AF, "Member 'UShooterGameUserSettings::InvertAnalogFirstPersonYAxis' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, InvertAnalogFirstPersonXAxis) == 0x0001B0, "Member 'UShooterGameUserSettings::InvertAnalogFirstPersonXAxis' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ToggleSteadyAim) == 0x0001B1, "Member 'UShooterGameUserSettings::ToggleSteadyAim' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ToggleCrouch) == 0x0001B2, "Member 'UShooterGameUserSettings::ToggleCrouch' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ToggleADS) == 0x0001B3, "Member 'UShooterGameUserSettings::ToggleADS' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ToggleSprint) == 0x0001B4, "Member 'UShooterGameUserSettings::ToggleSprint' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ToggleLean) == 0x0001B5, "Member 'UShooterGameUserSettings::ToggleLean' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HideKickVoteRequests) == 0x0001B6, "Member 'UShooterGameUserSettings::HideKickVoteRequests' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MasterVolume) == 0x0001B8, "Member 'UShooterGameUserSettings::MasterVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MusicVolume) == 0x0001BC, "Member 'UShooterGameUserSettings::MusicVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, SfxVolume) == 0x0001C0, "Member 'UShooterGameUserSettings::SfxVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, VoiceVolume) == 0x0001C4, "Member 'UShooterGameUserSettings::VoiceVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ProximityVoiceVolume) == 0x0001C8, "Member 'UShooterGameUserSettings::ProximityVoiceVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, UnitVoiceVolume) == 0x0001CC, "Member 'UShooterGameUserSettings::UnitVoiceVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, LeadershipVoiceVolume) == 0x0001D0, "Member 'UShooterGameUserSettings::LeadershipVoiceVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, PartyVoiceVolume) == 0x0001D4, "Member 'UShooterGameUserSettings::PartyVoiceVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MicVolume) == 0x0001D8, "Member 'UShooterGameUserSettings::MicVolume' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, UIVolume_3D) == 0x0001DC, "Member 'UShooterGameUserSettings::UIVolume_3D' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, UIVolume_2D) == 0x0001E0, "Member 'UShooterGameUserSettings::UIVolume_2D' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, LastAudioInputDevice) == 0x0001E8, "Member 'UShooterGameUserSettings::LastAudioInputDevice' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, LastAudioOutputDevice) == 0x0001F8, "Member 'UShooterGameUserSettings::LastAudioOutputDevice' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bManualBolting) == 0x000208, "Member 'UShooterGameUserSettings::bManualBolting' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bGoreDisabled) == 0x000209, "Member 'UShooterGameUserSettings::bGoreDisabled' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, FOV) == 0x00020C, "Member 'UShooterGameUserSettings::FOV' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bIsDedicatedServer) == 0x000210, "Member 'UShooterGameUserSettings::bIsDedicatedServer' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bUseCrossplayServers) == 0x000211, "Member 'UShooterGameUserSettings::bUseCrossplayServers' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bShouldLogInEpicAccount) == 0x000212, "Member 'UShooterGameUserSettings::bShouldLogInEpicAccount' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, LastSeenEULAVersion) == 0x000214, "Member 'UShooterGameUserSettings::LastSeenEULAVersion' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MasterAudioClass) == 0x000218, "Member 'UShooterGameUserSettings::MasterAudioClass' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, SFXAudioClass) == 0x000220, "Member 'UShooterGameUserSettings::SFXAudioClass' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MusicAudioClass) == 0x000228, "Member 'UShooterGameUserSettings::MusicAudioClass' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, UIAudioClass_3D) == 0x000230, "Member 'UShooterGameUserSettings::UIAudioClass_3D' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, UIAudioClass_2D) == 0x000238, "Member 'UShooterGameUserSettings::UIAudioClass_2D' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, PlayerFlags) == 0x000240, "Member 'UShooterGameUserSettings::PlayerFlags' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, M_LastMatchID) == 0x000248, "Member 'UShooterGameUserSettings::M_LastMatchID' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, PlayerPreferences) == 0x000258, "Member 'UShooterGameUserSettings::PlayerPreferences' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ScalabilityLevelsSnapshot) == 0x000270, "Member 'UShooterGameUserSettings::ScalabilityLevelsSnapshot' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ServerBrowserFilters) == 0x0002A0, "Member 'UShooterGameUserSettings::ServerBrowserFilters' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, FavouriteServers) == 0x0002F8, "Member 'UShooterGameUserSettings::FavouriteServers' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HistoryServers) == 0x000308, "Member 'UShooterGameUserSettings::HistoryServers' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, DeadBodyDespawnDelay) == 0x000318, "Member 'UShooterGameUserSettings::DeadBodyDespawnDelay' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bProfanityFilterEnabled) == 0x00031C, "Member 'UShooterGameUserSettings::bProfanityFilterEnabled' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bShowChatOnNewMessage) == 0x00031D, "Member 'UShooterGameUserSettings::bShowChatOnNewMessage' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, SavedCosmetics) == 0x000320, "Member 'UShooterGameUserSettings::SavedCosmetics' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HLLCosmeticsVersion) == 0x000330, "Member 'UShooterGameUserSettings::HLLCosmeticsVersion' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ActiveCosmeticIndices) == 0x000338, "Member 'UShooterGameUserSettings::ActiveCosmeticIndices' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, FavDisplayFaction) == 0x000348, "Member 'UShooterGameUserSettings::FavDisplayFaction' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, FavDisplayRole) == 0x000349, "Member 'UShooterGameUserSettings::FavDisplayRole' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, SavedLoadouts) == 0x000350, "Member 'UShooterGameUserSettings::SavedLoadouts' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, AntiAliasingMethod) == 0x000360, "Member 'UShooterGameUserSettings::AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, CompletedHints) == 0x000368, "Member 'UShooterGameUserSettings::CompletedHints' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HintsVersion) == 0x000378, "Member 'UShooterGameUserSettings::HintsVersion' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bHintsEnabled) == 0x00037C, "Member 'UShooterGameUserSettings::bHintsEnabled' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, Hints) == 0x000380, "Member 'UShooterGameUserSettings::Hints' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bLinkMarkersToHUD) == 0x000391, "Member 'UShooterGameUserSettings::bLinkMarkersToHUD' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MarkerFadeScale) == 0x000394, "Member 'UShooterGameUserSettings::MarkerFadeScale' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, POIFadeScale) == 0x000398, "Member 'UShooterGameUserSettings::POIFadeScale' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bHasShownDisclaimer) == 0x00039C, "Member 'UShooterGameUserSettings::bHasShownDisclaimer' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HUDFadeTimeScale) == 0x0003A0, "Member 'UShooterGameUserSettings::HUDFadeTimeScale' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, HUDMode) == 0x0003A4, "Member 'UShooterGameUserSettings::HUDMode' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, OnResolutionChangeReverted) == 0x0003A8, "Member 'UShooterGameUserSettings::OnResolutionChangeReverted' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ClanTag) == 0x0003E0, "Member 'UShooterGameUserSettings::ClanTag' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, AspectRatioAxisConstraint) == 0x0003F1, "Member 'UShooterGameUserSettings::AspectRatioAxisConstraint' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, StreamModeSettings) == 0x0003F2, "Member 'UShooterGameUserSettings::StreamModeSettings' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bShowCommandMessages) == 0x0003F6, "Member 'UShooterGameUserSettings::bShowCommandMessages' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, VibrationEnabled) == 0x0003F7, "Member 'UShooterGameUserSettings::VibrationEnabled' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, VibrationLevel) == 0x0003F8, "Member 'UShooterGameUserSettings::VibrationLevel' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, AdaptiveTriggersEnabled) == 0x0003F9, "Member 'UShooterGameUserSettings::AdaptiveTriggersEnabled' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, AdaptiveTriggersLevel) == 0x0003FA, "Member 'UShooterGameUserSettings::AdaptiveTriggersLevel' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ControllerAccelerationXValue) == 0x0003FC, "Member 'UShooterGameUserSettings::ControllerAccelerationXValue' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, ControllerAccelerationYValue) == 0x000400, "Member 'UShooterGameUserSettings::ControllerAccelerationYValue' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, MapIconScale) == 0x000420, "Member 'UShooterGameUserSettings::MapIconScale' has a wrong offset!");
static_assert(offsetof(UShooterGameUserSettings, bMapPingRepeating) == 0x000440, "Member 'UShooterGameUserSettings::bMapPingRepeating' has a wrong offset!");

// Class HLL.HLLAccountAuthSubsystem
// 0x0050 (0x0080 - 0x0030)
class UHLLAccountAuthSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_124C[0x50];                                    // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAccountAuthSubsystem">();
	}
	static class UHLLAccountAuthSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAccountAuthSubsystem>();
	}
};
static_assert(alignof(UHLLAccountAuthSubsystem) == 0x000008, "Wrong alignment on UHLLAccountAuthSubsystem");
static_assert(sizeof(UHLLAccountAuthSubsystem) == 0x000080, "Wrong size on UHLLAccountAuthSubsystem");

// Class HLL.HLLFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UHLLFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CalculateSkeletalMeshReferencePoseAABB(struct FBox* AABB, const class USkeletalMesh* Mesh);
	static bool CanSeeReconData(const EPlayerRole PlayerRole, const EReconSourceType SourceType);
	static bool CheckCommanderReqs(const class AShooterPlayerState* Player);
	static class FText ClampTextLength(bool* bWasClamped, const class FText& InText, int32 Length);
	static class FName Conv_CollisionProfileToName(const struct FCollisionProfileName& InProfile);
	static float DegreesToMils(const float InDegrees);
	static TArray<class AActor*> FindPawnsInProximity(const class UObject* WorldContextObject, const struct FVector& Location, const float Radius);
	static class FText GameModeToText(const EGameModeType& Mode, const bool bAllCaps);
	static class FText GetActionBindingGamepadKeyName(const class FName& InAction);
	static class FText GetActionBindingKeyName(const class FName InAction);
	static bool GetAllowedChatTypes(TArray<EHLLChat>& AllowedChats, const class AShooterPlayerState* ForPlayer);
	static bool GetAllowedMarkerTypes(TArray<EHLLMarker>& AllowedMarkers, const class AShooterPlayerState* ForPlayer);
	static class FText GetAxisBindingGamepadKeyName(const class FName& InAxisName, const float AxisValue);
	static class FText GetAxisBindingKeyName(const class FName InAxisName, const float AxisValue);
	static TArray<EPlatoonType> GetBlacklistedPlatoonTypes(const class UObject* WorldContextObject);
	static class UMapMeta* GetCurrentMapMeta(const class UObject* WorldContextObject);
	static struct FVector GetLocalViewLocation(const class UObject* WorldContextObject);
	static float GetPlatoonSuppressionScale(const class AShooterCharacter* TargetCharacter);
	static int32 GetRolloverArrayIndex(const int32 InArraySize, const int32 InArrayIndex);
	static bool GetSectorResourceBrush(const class UObject* WorldContextObject, const int32 SectorIndex, struct FSlateBrush* ReturnBrush);
	static int32 GetSessionMaxPlayers();
	static class FText GetUIFormattedCooldown(const int32 TimeSeconds);
	static class FText GetUIFormattedMatchTime(const int32 TimeSeconds);
	static bool HLLRadialDamage(const class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, const float Radius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel);
	static class FText IndexToCharacter(const int32 Param_Index);
	static class FText IndexToPhonetic(const int32 Param_Index, const ETeam InTeam);
	static bool IsKeyForAction(const class FName InAction, const struct FKeyEvent& InKeyEvent);
	static bool IsOfficerRole(EPlayerRole PlayerRole);
	static class FText MakePlayerNameText(const class APlayerState* PlayerState);
	static class FText MakePlayerNameTextFromString(const class FString& PlayerName);
	static int32 MaxPlatoonMembersCount(EPlatoonType Type);
	static float MilsToDegrees(const float InMils);
	static int32 NumAllowedMarkerTypes(const class AShooterPlayerState* ForPlayer);
	static void OpenURLInPlatformBrowser(class UWorld* World, const class FString& InURL);
	static class FText PlatoonToCharacter(const int32 Param_Index, const bool bCommander);
	static class FText PlatoonTypeToText(const EPlatoonType InType, const bool bAllCaps);
	static class FText PlayerRoleToText(const EPlayerRole InRole, const bool bAllCaps);
	static class UAudioComponent* PlayInstantWeaponBulletSound(const class UObject* WorldContextObject, class USoundBase* InSound, const struct FVector& ShotOrigin, const struct FVector& ShotEnd, const float MaxSoundRadius, const bool bCapOrigin, const bool bCapEnd, const float OriginCapDist, const float EndCapDist);
	static class FText ReplaceInputActionsWithGamepadKeyNames(const class FText& RichText, bool bAddKeybindTag);
	static class FText ReplaceInputActionsWithKeyNames(const class FText& RichText, bool bAddKeybindTag);
	static class FText RoleLevelToText(const int32 Level);
	static EPlatoonType RoleToPlatoonType(const EPlayerRole Role);
	static void ScorePlayerAction(class AShooterPlayerState* Player, const class FName& ActionName, const float Modifier);
	static bool ShouldCheckCommanderReqs(const class AShooterGameState* GameState);
	static class UParticleSystemComponent* SpawnBulletTracer(const class UObject* WorldContextObject, const struct FVector& MuzzleLocation, const struct FVector& Direction, const float Distance, const struct FHLLTracerProperties& TracerProperties);
	static class FText TeamToText(const ETeam InTeam, const bool bAllCaps);
	static class FText Widen(const class FText& Text);
	static bool WithinCullDistance(const class UObject* WorldContextObject, const struct FVector& TargetLocation, const float CullDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLFunctionLibrary">();
	}
	static class UHLLFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLFunctionLibrary>();
	}
};
static_assert(alignof(UHLLFunctionLibrary) == 0x000008, "Wrong alignment on UHLLFunctionLibrary");
static_assert(sizeof(UHLLFunctionLibrary) == 0x000028, "Wrong size on UHLLFunctionLibrary");

// Class HLL.HLLAdminCamera
// 0x31C0 (0x3440 - 0x0280)
class AHLLAdminCamera : public APawn
{
public:
	FMulticastInlineDelegateProperty_             InputTypeChanged;                                  // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AShooterCharacter*                      TargetPOVPawn;                                     // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1270[0xC];                                     // 0x0298(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         SpeedSliderIndex;                                  // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ControllerSliderDampener;                          // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1271[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USphereComponent*                       CollisionSphere;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLAdminCameraMovement*                AdminCameraMovement;                               // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLAdminCameraSpringArm*               CameraArm;                                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       Camera;                                            // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPostProcessSettings>           PostProcessSettings;                               // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PostProcessingDataTable;                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPostProcessCameraEffect               ActivePostProcessEffect;                           // 0x02F0(0x0560)(Edit, BlueprintVisible, EditConst, Protected, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x0850(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               AimLaser;                                          // 0x0858(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetScanDistance;                                // 0x0860(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetScanRadius;                                  // 0x0864(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomSpeed;                                         // 0x0868(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1272[0x4];                                     // 0x086C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     PostProcessMaterial;                               // 0x0870(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FOVZoomMin;                                        // 0x0878(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFollowCamSettings                     VehicleSettings;                                   // 0x087C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFollowCamSettings                     CharacterSettings;                                 // 0x089C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1273[0x4];                                     // 0x08BC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInstanceDynamic*               PostProcessMID;                                    // 0x08C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetArmRatio;                                    // 0x08C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentArmRatio;                                   // 0x08CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinArmLength;                                      // 0x08D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxArmLength;                                      // 0x08D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetZoomRatio;                                   // 0x08D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentZoomRatio;                                  // 0x08DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAdminCamTarget                        ReticleTarget;                                     // 0x08E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAdminCamTarget                        LockedTarget;                                      // 0x08F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1274[0x2B30];                                  // 0x0900(0x2B30)(Fixing Size After Last Property [ Dumper-69 ])
	EAdminCamMode                                 CurrentMode;                                       // 0x3430(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAdminHighlightMode                           HighlightMode;                                     // 0x3431(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAdminUIMode                                  UIMode;                                            // 0x3432(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAdminControllerMode                          ControllerMode;                                    // 0x3433(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLaserEnabled : 1;                                 // 0x3434(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         PermissionsMask;                                   // 0x3435(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1275[0xA];                                     // 0x3436(0x000A)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BanPlayer(class AShooterPlayerState* Player, const class FString& Reason, const bool bPermanent);
	void CycleControllerMode();
	void CycleHighlightMode();
	void CyclePostProcessThemes();
	void KickPlayer(class AShooterPlayerState* Player, const class FString& Reason);
	void LockToTargetOrPlayer(class AActor* Target);
	void OnRep_LockedTarget(const struct FAdminCamTarget& PreviousValue);
	void OnTargetActorDestroyed(class AActor* DestroyedActor);
	void OnToggleMap();
	void ResetUI();
	void ServerClearTarget();
	void ServerLockToTargetOrPlayer(class AActor* Target);
	void ServerUpdatePovMode(bool bEnteredPov);
	bool SetCameraMode(const EAdminCamMode RequestedMode, const bool bReset);
	void ToggleAimLaser();
	void ToggleClipping();
	void TogglePlayerSearch();
	void TogglePostProcessing();
	void TogglePOVMode();
	void ToggleTargetLock();
	void ToggleTargetMode();
	void ToggleUI();

	class UHLLAdminCamUI* GetAdminCameraUI() const;
	EAdminSliderMode GetAffectSliderMode() const;
	bool GetAutoMoveStatus() const;
	bool GetAutoOrbitStatus() const;
	bool GetAutoRotateStatus() const;
	bool GetDisplayTarget(struct FAdminCamTarget* Target) const;
	bool HasPermission(const EAdminCamPermissions Item) const;
	bool IsCameraModeAllowed(const EAdminCamMode Mode) const;
	bool IsLockedToTarget() const;
	bool IsValidTarget(const class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAdminCamera">();
	}
	static class AHLLAdminCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAdminCamera>();
	}
};
static_assert(alignof(AHLLAdminCamera) == 0x000010, "Wrong alignment on AHLLAdminCamera");
static_assert(sizeof(AHLLAdminCamera) == 0x003440, "Wrong size on AHLLAdminCamera");
static_assert(offsetof(AHLLAdminCamera, InputTypeChanged) == 0x000280, "Member 'AHLLAdminCamera::InputTypeChanged' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, TargetPOVPawn) == 0x000290, "Member 'AHLLAdminCamera::TargetPOVPawn' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, SpeedSliderIndex) == 0x0002A4, "Member 'AHLLAdminCamera::SpeedSliderIndex' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, ControllerSliderDampener) == 0x0002A8, "Member 'AHLLAdminCamera::ControllerSliderDampener' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, CollisionSphere) == 0x0002B0, "Member 'AHLLAdminCamera::CollisionSphere' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, AdminCameraMovement) == 0x0002B8, "Member 'AHLLAdminCamera::AdminCameraMovement' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, CameraArm) == 0x0002C0, "Member 'AHLLAdminCamera::CameraArm' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, Camera) == 0x0002C8, "Member 'AHLLAdminCamera::Camera' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, PostProcessComponent) == 0x0002D0, "Member 'AHLLAdminCamera::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, PostProcessSettings) == 0x0002D8, "Member 'AHLLAdminCamera::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, PostProcessingDataTable) == 0x0002E8, "Member 'AHLLAdminCamera::PostProcessingDataTable' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, ActivePostProcessEffect) == 0x0002F0, "Member 'AHLLAdminCamera::ActivePostProcessEffect' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, MapComponent) == 0x000850, "Member 'AHLLAdminCamera::MapComponent' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, AimLaser) == 0x000858, "Member 'AHLLAdminCamera::AimLaser' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, TargetScanDistance) == 0x000860, "Member 'AHLLAdminCamera::TargetScanDistance' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, TargetScanRadius) == 0x000864, "Member 'AHLLAdminCamera::TargetScanRadius' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, ZoomSpeed) == 0x000868, "Member 'AHLLAdminCamera::ZoomSpeed' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, PostProcessMaterial) == 0x000870, "Member 'AHLLAdminCamera::PostProcessMaterial' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, FOVZoomMin) == 0x000878, "Member 'AHLLAdminCamera::FOVZoomMin' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, VehicleSettings) == 0x00087C, "Member 'AHLLAdminCamera::VehicleSettings' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, CharacterSettings) == 0x00089C, "Member 'AHLLAdminCamera::CharacterSettings' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, PostProcessMID) == 0x0008C0, "Member 'AHLLAdminCamera::PostProcessMID' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, TargetArmRatio) == 0x0008C8, "Member 'AHLLAdminCamera::TargetArmRatio' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, CurrentArmRatio) == 0x0008CC, "Member 'AHLLAdminCamera::CurrentArmRatio' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, MinArmLength) == 0x0008D0, "Member 'AHLLAdminCamera::MinArmLength' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, MaxArmLength) == 0x0008D4, "Member 'AHLLAdminCamera::MaxArmLength' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, TargetZoomRatio) == 0x0008D8, "Member 'AHLLAdminCamera::TargetZoomRatio' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, CurrentZoomRatio) == 0x0008DC, "Member 'AHLLAdminCamera::CurrentZoomRatio' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, ReticleTarget) == 0x0008E0, "Member 'AHLLAdminCamera::ReticleTarget' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, LockedTarget) == 0x0008F0, "Member 'AHLLAdminCamera::LockedTarget' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, CurrentMode) == 0x003430, "Member 'AHLLAdminCamera::CurrentMode' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, HighlightMode) == 0x003431, "Member 'AHLLAdminCamera::HighlightMode' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, UIMode) == 0x003432, "Member 'AHLLAdminCamera::UIMode' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, ControllerMode) == 0x003433, "Member 'AHLLAdminCamera::ControllerMode' has a wrong offset!");
static_assert(offsetof(AHLLAdminCamera, PermissionsMask) == 0x003435, "Member 'AHLLAdminCamera::PermissionsMask' has a wrong offset!");

// Class HLL.HLLTurnBackVolume
// 0x0008 (0x0260 - 0x0258)
class AHLLTurnBackVolume final : public AVolume
{
public:
	int32                                         AffectedTeams;                                     // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1279[0x4];                                     // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLTurnBackVolume">();
	}
	static class AHLLTurnBackVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLTurnBackVolume>();
	}
};
static_assert(alignof(AHLLTurnBackVolume) == 0x000008, "Wrong alignment on AHLLTurnBackVolume");
static_assert(sizeof(AHLLTurnBackVolume) == 0x000260, "Wrong size on AHLLTurnBackVolume");
static_assert(offsetof(AHLLTurnBackVolume, AffectedTeams) == 0x000258, "Member 'AHLLTurnBackVolume::AffectedTeams' has a wrong offset!");

// Class HLL.HLLAdminCameraMovement
// 0x0030 (0x0180 - 0x0150)
class UHLLAdminCameraMovement final : public UFloatingPawnMovement
{
public:
	float                                         MinDeceleration;                                   // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeceleration;                                   // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeed;                                          // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_127A[0x24];                                    // 0x015C(0x0024)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Server_UpdatePosition(const struct FVector_NetQuantize& Location);

	class AHLLAdminCamera* GetOwningAdminCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAdminCameraMovement">();
	}
	static class UHLLAdminCameraMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAdminCameraMovement>();
	}
};
static_assert(alignof(UHLLAdminCameraMovement) == 0x000008, "Wrong alignment on UHLLAdminCameraMovement");
static_assert(sizeof(UHLLAdminCameraMovement) == 0x000180, "Wrong size on UHLLAdminCameraMovement");
static_assert(offsetof(UHLLAdminCameraMovement, MinDeceleration) == 0x000150, "Member 'UHLLAdminCameraMovement::MinDeceleration' has a wrong offset!");
static_assert(offsetof(UHLLAdminCameraMovement, MaxDeceleration) == 0x000154, "Member 'UHLLAdminCameraMovement::MaxDeceleration' has a wrong offset!");
static_assert(offsetof(UHLLAdminCameraMovement, MinSpeed) == 0x000158, "Member 'UHLLAdminCameraMovement::MinSpeed' has a wrong offset!");

// Class HLL.HLLMarkerIndicator
// 0x0038 (0x02E8 - 0x02B0)
class UHLLMarkerIndicator : public UHLLIndicatorBase
{
public:
	float                                         FadeTime;                                          // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectionEdgePadding;                             // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       MovedOrPlacedAnim;                                 // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MarkerIcon;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerText;                                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OwnerText;                                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DistanceText;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalOffsetWhenFollowingPlayer;                 // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_127B[0x4];                                     // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void K2_PostInitMarker(const EHLLMarker Type, const struct FMarkerMetaData& MarkerMeta);
	void K2_UpdateMarker(const EHLLMarker Type, const struct FMarkerMetaData& MarkerMeta, const class AShooterPlayerState* Viewer, const class AShooterPlayerState* Owner);
	void OnMovedOrPlaced();
	void UpdateOwnerIcon(EMarkerOwnerIconType OwnerIconToShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMarkerIndicator">();
	}
	static class UHLLMarkerIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMarkerIndicator>();
	}
};
static_assert(alignof(UHLLMarkerIndicator) == 0x000008, "Wrong alignment on UHLLMarkerIndicator");
static_assert(sizeof(UHLLMarkerIndicator) == 0x0002E8, "Wrong size on UHLLMarkerIndicator");
static_assert(offsetof(UHLLMarkerIndicator, FadeTime) == 0x0002B0, "Member 'UHLLMarkerIndicator::FadeTime' has a wrong offset!");
static_assert(offsetof(UHLLMarkerIndicator, ProjectionEdgePadding) == 0x0002B4, "Member 'UHLLMarkerIndicator::ProjectionEdgePadding' has a wrong offset!");
static_assert(offsetof(UHLLMarkerIndicator, MovedOrPlacedAnim) == 0x0002B8, "Member 'UHLLMarkerIndicator::MovedOrPlacedAnim' has a wrong offset!");
static_assert(offsetof(UHLLMarkerIndicator, MarkerIcon) == 0x0002C0, "Member 'UHLLMarkerIndicator::MarkerIcon' has a wrong offset!");
static_assert(offsetof(UHLLMarkerIndicator, MarkerText) == 0x0002C8, "Member 'UHLLMarkerIndicator::MarkerText' has a wrong offset!");
static_assert(offsetof(UHLLMarkerIndicator, OwnerText) == 0x0002D0, "Member 'UHLLMarkerIndicator::OwnerText' has a wrong offset!");
static_assert(offsetof(UHLLMarkerIndicator, DistanceText) == 0x0002D8, "Member 'UHLLMarkerIndicator::DistanceText' has a wrong offset!");
static_assert(offsetof(UHLLMarkerIndicator, VerticalOffsetWhenFollowingPlayer) == 0x0002E0, "Member 'UHLLMarkerIndicator::VerticalOffsetWhenFollowingPlayer' has a wrong offset!");

// Class HLL.HLLHowitzerShell
// 0x00B8 (0x02D8 - 0x0220)
class AHLLHowitzerShell final : public AActor
{
public:
	uint8                                         Pad_127E[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         IncomingDelay;                                     // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_127F[0xC];                                     // 0x023C(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ExplodeDelay;                                      // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1280[0xC];                                     // 0x024C(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         PostExplodeLifespan;                               // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1281[0x4];                                     // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             IncomingSound;                                     // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                IncomingSoundOffset;                               // 0x0268(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1282[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<TSubclassOf<class AShooterImpactEffect>> ExplosionTemplates;                                // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRadius;                                      // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageFalloff;                                     // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1283[0x4];                                     // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UShooterDamageType>         DamageType;                                        // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreDamageOcclusion : 1;                        // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1284[0x7];                                     // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 DamageSourceName;                                  // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Suppression;                                       // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionRadius;                                 // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         ShellTeam;                                         // 0x02C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bExploded : 1;                                     // 0x02C1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIncoming : 1;                                     // 0x02C1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1285[0x2];                                     // 0x02C2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector_NetQuantize                    ShotOrigin;                                        // 0x02C4(0x000C)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             FireSound;                                         // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Exploded(const bool bOldValue);
	void OnRep_Incoming(const bool bOldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLHowitzerShell">();
	}
	static class AHLLHowitzerShell* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLHowitzerShell>();
	}
};
static_assert(alignof(AHLLHowitzerShell) == 0x000008, "Wrong alignment on AHLLHowitzerShell");
static_assert(sizeof(AHLLHowitzerShell) == 0x0002D8, "Wrong size on AHLLHowitzerShell");
static_assert(offsetof(AHLLHowitzerShell, IncomingDelay) == 0x000238, "Member 'AHLLHowitzerShell::IncomingDelay' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, ExplodeDelay) == 0x000248, "Member 'AHLLHowitzerShell::ExplodeDelay' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, PostExplodeLifespan) == 0x000258, "Member 'AHLLHowitzerShell::PostExplodeLifespan' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, IncomingSound) == 0x000260, "Member 'AHLLHowitzerShell::IncomingSound' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, IncomingSoundOffset) == 0x000268, "Member 'AHLLHowitzerShell::IncomingSoundOffset' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, ExplosionTemplates) == 0x000278, "Member 'AHLLHowitzerShell::ExplosionTemplates' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, Damage) == 0x000288, "Member 'AHLLHowitzerShell::Damage' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, DamageRadius) == 0x00028C, "Member 'AHLLHowitzerShell::DamageRadius' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, DamageFalloff) == 0x000290, "Member 'AHLLHowitzerShell::DamageFalloff' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, DamageType) == 0x000298, "Member 'AHLLHowitzerShell::DamageType' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, DamageSourceName) == 0x0002A8, "Member 'AHLLHowitzerShell::DamageSourceName' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, Suppression) == 0x0002B8, "Member 'AHLLHowitzerShell::Suppression' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, SuppressionRadius) == 0x0002BC, "Member 'AHLLHowitzerShell::SuppressionRadius' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, ShellTeam) == 0x0002C0, "Member 'AHLLHowitzerShell::ShellTeam' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, ShotOrigin) == 0x0002C4, "Member 'AHLLHowitzerShell::ShotOrigin' has a wrong offset!");
static_assert(offsetof(AHLLHowitzerShell, FireSound) == 0x0002D0, "Member 'AHLLHowitzerShell::FireSound' has a wrong offset!");

// Class HLL.HLLAdminCameraSpringArm
// 0x0010 (0x0290 - 0x0280)
class UHLLAdminCameraSpringArm final : public USpringArmComponent
{
public:
	class AActor*                                 TraceIgnoreActor;                                  // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1286[0x8];                                     // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAdminCameraSpringArm">();
	}
	static class UHLLAdminCameraSpringArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAdminCameraSpringArm>();
	}
};
static_assert(alignof(UHLLAdminCameraSpringArm) == 0x000010, "Wrong alignment on UHLLAdminCameraSpringArm");
static_assert(sizeof(UHLLAdminCameraSpringArm) == 0x000290, "Wrong size on UHLLAdminCameraSpringArm");
static_assert(offsetof(UHLLAdminCameraSpringArm, TraceIgnoreActor) == 0x000280, "Member 'UHLLAdminCameraSpringArm::TraceIgnoreActor' has a wrong offset!");

// Class HLL.HLLUI_CreditsCategory_RoleAndMembers
// 0x0010 (0x0240 - 0x0230)
class UHLLUI_CreditsCategory_RoleAndMembers : public UUserWidget
{
public:
	class UTextBlock*                             TitleText;                                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MemberText;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_CreditsCategory_RoleAndMembers">();
	}
	static class UHLLUI_CreditsCategory_RoleAndMembers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_CreditsCategory_RoleAndMembers>();
	}
};
static_assert(alignof(UHLLUI_CreditsCategory_RoleAndMembers) == 0x000008, "Wrong alignment on UHLLUI_CreditsCategory_RoleAndMembers");
static_assert(sizeof(UHLLUI_CreditsCategory_RoleAndMembers) == 0x000240, "Wrong size on UHLLUI_CreditsCategory_RoleAndMembers");
static_assert(offsetof(UHLLUI_CreditsCategory_RoleAndMembers, TitleText) == 0x000230, "Member 'UHLLUI_CreditsCategory_RoleAndMembers::TitleText' has a wrong offset!");
static_assert(offsetof(UHLLUI_CreditsCategory_RoleAndMembers, MemberText) == 0x000238, "Member 'UHLLUI_CreditsCategory_RoleAndMembers::MemberText' has a wrong offset!");

// Class HLL.HLLAdminCamInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLAdminCamInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAdminCamInterface">();
	}
	static class IHLLAdminCamInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLAdminCamInterface>();
	}
};
static_assert(alignof(IHLLAdminCamInterface) == 0x000008, "Wrong alignment on IHLLAdminCamInterface");
static_assert(sizeof(IHLLAdminCamInterface) == 0x000028, "Wrong size on IHLLAdminCamInterface");

// Class HLL.HLLAdminCamUI
// 0x0068 (0x0298 - 0x0230)
class UHLLAdminCamUI : public UUserWidget
{
public:
	bool                                          bIsExploreMode;                                    // 0x0230(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1287[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidget*                                PlayerSearchPanel;                                 // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                KickBanPanel;                                      // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                HotkeyPanel;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             PlayerSearchEntryBox;                              // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       PlayerNameFilter;                                  // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       KickBanReasonEntry;                                // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           SpeedBar;                                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NumPlayersText;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLAdminCamPlayerEntry>    PlayerEntryWidget;                                 // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLAdminCamPlayerEntry*>        PlayerWidgets;                                     // 0x0280(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterPlayerState*                    SelectedPlayer;                                    // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearSelection();
	void OnCameraModeChanged(const EAdminCamMode Mode);
	void OnMoveSliderChanged();
	void OnPlayersChanged(const TArray<class APlayerState*>& InPlayers);
	void OnTargetsChanged();
	void OnToggleKickBanPanel(bool bEnabled);
	void OnToggleSearchPanel(const bool bEnabled);
	void SelectPlayer(class AShooterPlayerState* InPlayer);
	void SetFilterText(const class FText& NewValue);

	bool CopyNameToClipboard(const class AShooterPlayerState* InPlayer) const;
	bool CopyNetworkIDToClipboard(const class AShooterPlayerState* InPlayer) const;
	class AHLLAdminCamera* GetOwningPlayerAdminCamera() const;
	class AShooterHUD* GetOwningPlayerHUD() const;
	bool IsValidPlayer(const class APlayerState* Player) const;
	bool ShowingKickBanPanel() const;
	bool ShowingSearchPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAdminCamUI">();
	}
	static class UHLLAdminCamUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAdminCamUI>();
	}
};
static_assert(alignof(UHLLAdminCamUI) == 0x000008, "Wrong alignment on UHLLAdminCamUI");
static_assert(sizeof(UHLLAdminCamUI) == 0x000298, "Wrong size on UHLLAdminCamUI");
static_assert(offsetof(UHLLAdminCamUI, bIsExploreMode) == 0x000230, "Member 'UHLLAdminCamUI::bIsExploreMode' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, PlayerSearchPanel) == 0x000238, "Member 'UHLLAdminCamUI::PlayerSearchPanel' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, KickBanPanel) == 0x000240, "Member 'UHLLAdminCamUI::KickBanPanel' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, HotkeyPanel) == 0x000248, "Member 'UHLLAdminCamUI::HotkeyPanel' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, PlayerSearchEntryBox) == 0x000250, "Member 'UHLLAdminCamUI::PlayerSearchEntryBox' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, PlayerNameFilter) == 0x000258, "Member 'UHLLAdminCamUI::PlayerNameFilter' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, KickBanReasonEntry) == 0x000260, "Member 'UHLLAdminCamUI::KickBanReasonEntry' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, SpeedBar) == 0x000268, "Member 'UHLLAdminCamUI::SpeedBar' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, NumPlayersText) == 0x000270, "Member 'UHLLAdminCamUI::NumPlayersText' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, PlayerEntryWidget) == 0x000278, "Member 'UHLLAdminCamUI::PlayerEntryWidget' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, PlayerWidgets) == 0x000280, "Member 'UHLLAdminCamUI::PlayerWidgets' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamUI, SelectedPlayer) == 0x000290, "Member 'UHLLAdminCamUI::SelectedPlayer' has a wrong offset!");

// Class HLL.HLLMaterialManager
// 0x0018 (0x0040 - 0x0028)
class UHLLMaterialManager : public UObject
{
public:
	TArray<class UMaterialParameterCollection*>   FoliageParamCollections;                           // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParamNameFootLocation;                             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMaterialManager">();
	}
	static class UHLLMaterialManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMaterialManager>();
	}
};
static_assert(alignof(UHLLMaterialManager) == 0x000008, "Wrong alignment on UHLLMaterialManager");
static_assert(sizeof(UHLLMaterialManager) == 0x000040, "Wrong size on UHLLMaterialManager");
static_assert(offsetof(UHLLMaterialManager, FoliageParamCollections) == 0x000028, "Member 'UHLLMaterialManager::FoliageParamCollections' has a wrong offset!");
static_assert(offsetof(UHLLMaterialManager, ParamNameFootLocation) == 0x000038, "Member 'UHLLMaterialManager::ParamNameFootLocation' has a wrong offset!");

// Class HLL.ShooterOnlineSessionClient
// 0x0030 (0x0210 - 0x01E0)
class UShooterOnlineSessionClient final : public UOnlineSessionClient
{
public:
	uint8                                         Pad_128B[0x30];                                    // 0x01E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterOnlineSessionClient">();
	}
	static class UShooterOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterOnlineSessionClient>();
	}
};
static_assert(alignof(UShooterOnlineSessionClient) == 0x000008, "Wrong alignment on UShooterOnlineSessionClient");
static_assert(sizeof(UShooterOnlineSessionClient) == 0x000210, "Wrong size on UShooterOnlineSessionClient");

// Class HLL.HLLAdminCamPlayerEntry
// 0x0038 (0x0268 - 0x0230)
class UHLLAdminCamPlayerEntry : public UUserWidget
{
public:
	class AShooterPlayerState*                    AssignedPlayer;                                    // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsSelected : 1;                                   // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHiddenByFilter : 1;                               // 0x0238(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_128C[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             PlayerRole;                                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerLevel;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerName;                                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerId;                                          // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLAdminCamUI*                         OwningUI;                                          // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSelectionChanged(const bool bSelected);
	void Select(const bool bClearIfSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAdminCamPlayerEntry">();
	}
	static class UHLLAdminCamPlayerEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAdminCamPlayerEntry>();
	}
};
static_assert(alignof(UHLLAdminCamPlayerEntry) == 0x000008, "Wrong alignment on UHLLAdminCamPlayerEntry");
static_assert(sizeof(UHLLAdminCamPlayerEntry) == 0x000268, "Wrong size on UHLLAdminCamPlayerEntry");
static_assert(offsetof(UHLLAdminCamPlayerEntry, AssignedPlayer) == 0x000230, "Member 'UHLLAdminCamPlayerEntry::AssignedPlayer' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamPlayerEntry, PlayerRole) == 0x000240, "Member 'UHLLAdminCamPlayerEntry::PlayerRole' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamPlayerEntry, PlayerLevel) == 0x000248, "Member 'UHLLAdminCamPlayerEntry::PlayerLevel' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamPlayerEntry, PlayerName) == 0x000250, "Member 'UHLLAdminCamPlayerEntry::PlayerName' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamPlayerEntry, PlayerId) == 0x000258, "Member 'UHLLAdminCamPlayerEntry::PlayerId' has a wrong offset!");
static_assert(offsetof(UHLLAdminCamPlayerEntry, OwningUI) == 0x000260, "Member 'UHLLAdminCamPlayerEntry::OwningUI' has a wrong offset!");

// Class HLL.HLLGunnerUI_AntiTank
// 0x0040 (0x02B0 - 0x0270)
class UHLLGunnerUI_AntiTank : public UHLLSeatWidgetBase
{
public:
	class UHLLArmourWeaponUI*                     ArtilleryWeaponInfo;                               // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TraverseValue;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ElevationValue;                                    // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         ZoomKeyText;                                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         PrecisionKeyText;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                MuzzleOcclusion;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128D[0x10];                                    // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGunnerUI_AntiTank">();
	}
	static class UHLLGunnerUI_AntiTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLGunnerUI_AntiTank>();
	}
};
static_assert(alignof(UHLLGunnerUI_AntiTank) == 0x000008, "Wrong alignment on UHLLGunnerUI_AntiTank");
static_assert(sizeof(UHLLGunnerUI_AntiTank) == 0x0002B0, "Wrong size on UHLLGunnerUI_AntiTank");
static_assert(offsetof(UHLLGunnerUI_AntiTank, ArtilleryWeaponInfo) == 0x000270, "Member 'UHLLGunnerUI_AntiTank::ArtilleryWeaponInfo' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_AntiTank, TraverseValue) == 0x000278, "Member 'UHLLGunnerUI_AntiTank::TraverseValue' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_AntiTank, ElevationValue) == 0x000280, "Member 'UHLLGunnerUI_AntiTank::ElevationValue' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_AntiTank, ZoomKeyText) == 0x000288, "Member 'UHLLGunnerUI_AntiTank::ZoomKeyText' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_AntiTank, PrecisionKeyText) == 0x000290, "Member 'UHLLGunnerUI_AntiTank::PrecisionKeyText' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_AntiTank, MuzzleOcclusion) == 0x000298, "Member 'UHLLGunnerUI_AntiTank::MuzzleOcclusion' has a wrong offset!");

// Class HLL.HLLAimAssistManager
// 0x00C0 (0x00F0 - 0x0030)
class UHLLAimAssistManager final : public UWorldSubsystem
{
public:
	class UHLLAimAssistSettingsDataAsset*         AimAssistSettingsAsset;                            // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128E[0xB8];                                    // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAimAssistManager">();
	}
	static class UHLLAimAssistManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAimAssistManager>();
	}
};
static_assert(alignof(UHLLAimAssistManager) == 0x000008, "Wrong alignment on UHLLAimAssistManager");
static_assert(sizeof(UHLLAimAssistManager) == 0x0000F0, "Wrong size on UHLLAimAssistManager");
static_assert(offsetof(UHLLAimAssistManager, AimAssistSettingsAsset) == 0x000030, "Member 'UHLLAimAssistManager::AimAssistSettingsAsset' has a wrong offset!");

// Class HLL.HLLTeamInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLTeamInterface final : public IInterface
{
public:
	void SetTeam(const ETeam NewTeam);

	ETeam GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLTeamInterface">();
	}
	static class IHLLTeamInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLTeamInterface>();
	}
};
static_assert(alignof(IHLLTeamInterface) == 0x000008, "Wrong alignment on IHLLTeamInterface");
static_assert(sizeof(IHLLTeamInterface) == 0x000028, "Wrong size on IHLLTeamInterface");

// Class HLL.StressTestPlayerControllerComponent
// 0x0020 (0x00D0 - 0x00B0)
class UStressTestPlayerControllerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128F[0x8];                                     // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterCharacter>          StressTestPawnClass;                               // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPathFollowingComponent*                PathFollowing;                                     // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bSimulationStopped : 1;                            // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1290[0x7];                                     // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ServerForceCrouch();
	void ServerForceProne();
	void ServerForceStand();
	void ServerReduceStressTestNPCs(int32 NewNumNPCs);
	void ServerSpawnStressTestNPCs(int32 NumNPCs);
	void ServerStartProfiling();
	void ServerStopProfiling();
	void ServerTeleportToStartingLocation();
	void ServerToggleSprint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StressTestPlayerControllerComponent">();
	}
	static class UStressTestPlayerControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStressTestPlayerControllerComponent>();
	}
};
static_assert(alignof(UStressTestPlayerControllerComponent) == 0x000008, "Wrong alignment on UStressTestPlayerControllerComponent");
static_assert(sizeof(UStressTestPlayerControllerComponent) == 0x0000D0, "Wrong size on UStressTestPlayerControllerComponent");
static_assert(offsetof(UStressTestPlayerControllerComponent, StressTestPawnClass) == 0x0000B8, "Member 'UStressTestPlayerControllerComponent::StressTestPawnClass' has a wrong offset!");
static_assert(offsetof(UStressTestPlayerControllerComponent, PathFollowing) == 0x0000C0, "Member 'UStressTestPlayerControllerComponent::PathFollowing' has a wrong offset!");

// Class HLL.HLLAimAssistSettings
// 0x0028 (0x0060 - 0x0038)
class UHLLAimAssistSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UHLLAimAssistSettingsDataAsset> AimAssistSettingsDataAsset;                        // 0x0038(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAimAssistSettings">();
	}
	static class UHLLAimAssistSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAimAssistSettings>();
	}
};
static_assert(alignof(UHLLAimAssistSettings) == 0x000008, "Wrong alignment on UHLLAimAssistSettings");
static_assert(sizeof(UHLLAimAssistSettings) == 0x000060, "Wrong size on UHLLAimAssistSettings");
static_assert(offsetof(UHLLAimAssistSettings, AimAssistSettingsDataAsset) == 0x000038, "Member 'UHLLAimAssistSettings::AimAssistSettingsDataAsset' has a wrong offset!");

// Class HLL.HLLAimAssistSettingsDataAsset
// 0x0028 (0x0058 - 0x0030)
class UHLLAimAssistSettingsDataAsset final : public UDataAsset
{
public:
	float                                         AimAssistActiveFOVAngle;                           // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistActiveFOVAngleRadians;                    // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistActiveFOVAngleCosValue;                   // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateForUnprotectedVehicleOccupants;           // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1291[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         LastRenderTimeThreshhold;                          // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             LineOfSightChannel;                                // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1292[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FHLLAimAssistDistanceSettings>  AimAssistDistanceSettings;                         // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAimAssistSettingsDataAsset">();
	}
	static class UHLLAimAssistSettingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAimAssistSettingsDataAsset>();
	}
};
static_assert(alignof(UHLLAimAssistSettingsDataAsset) == 0x000008, "Wrong alignment on UHLLAimAssistSettingsDataAsset");
static_assert(sizeof(UHLLAimAssistSettingsDataAsset) == 0x000058, "Wrong size on UHLLAimAssistSettingsDataAsset");
static_assert(offsetof(UHLLAimAssistSettingsDataAsset, AimAssistActiveFOVAngle) == 0x000030, "Member 'UHLLAimAssistSettingsDataAsset::AimAssistActiveFOVAngle' has a wrong offset!");
static_assert(offsetof(UHLLAimAssistSettingsDataAsset, AimAssistActiveFOVAngleRadians) == 0x000034, "Member 'UHLLAimAssistSettingsDataAsset::AimAssistActiveFOVAngleRadians' has a wrong offset!");
static_assert(offsetof(UHLLAimAssistSettingsDataAsset, AimAssistActiveFOVAngleCosValue) == 0x000038, "Member 'UHLLAimAssistSettingsDataAsset::AimAssistActiveFOVAngleCosValue' has a wrong offset!");
static_assert(offsetof(UHLLAimAssistSettingsDataAsset, bActivateForUnprotectedVehicleOccupants) == 0x00003C, "Member 'UHLLAimAssistSettingsDataAsset::bActivateForUnprotectedVehicleOccupants' has a wrong offset!");
static_assert(offsetof(UHLLAimAssistSettingsDataAsset, LastRenderTimeThreshhold) == 0x000040, "Member 'UHLLAimAssistSettingsDataAsset::LastRenderTimeThreshhold' has a wrong offset!");
static_assert(offsetof(UHLLAimAssistSettingsDataAsset, LineOfSightChannel) == 0x000044, "Member 'UHLLAimAssistSettingsDataAsset::LineOfSightChannel' has a wrong offset!");
static_assert(offsetof(UHLLAimAssistSettingsDataAsset, AimAssistDistanceSettings) == 0x000048, "Member 'UHLLAimAssistSettingsDataAsset::AimAssistDistanceSettings' has a wrong offset!");

// Class HLL.ShooterGame_Menu
// 0x0008 (0x02C8 - 0x02C0)
class AShooterGame_Menu : public AGameModeBase
{
public:
	uint8                                         Pad_1293[0x8];                                     // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGame_Menu">();
	}
	static class AShooterGame_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGame_Menu>();
	}
};
static_assert(alignof(AShooterGame_Menu) == 0x000008, "Wrong alignment on AShooterGame_Menu");
static_assert(sizeof(AShooterGame_Menu) == 0x0002C8, "Wrong size on AShooterGame_Menu");

// Class HLL.HLLAmmoComponent
// 0x0040 (0x00F0 - 0x00B0)
class UHLLAmmoComponent final : public UActorComponent
{
public:
	TArray<TWeakObjectPtr<class AShooterCharacter>> ResuppliedPlayers;                                 // 0x00B0(0x0010)(Net, ZeroConstructor, Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ResupplySound;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSameTeamOnly;                                     // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AmmoTypes;                                         // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInfiniteResupplies;                               // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnlimitedReuses;                                  // 0x00CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxResupplies;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResupplyTime;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1294[0x1C];                                    // 0x00D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	EHLLAmmoType GetPrimaryAmmoType() const;
	float GetResupplyTime(const class AShooterCharacter* InCharacter) const;
	bool IsMultiSupply() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAmmoComponent">();
	}
	static class UHLLAmmoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAmmoComponent>();
	}
};
static_assert(alignof(UHLLAmmoComponent) == 0x000008, "Wrong alignment on UHLLAmmoComponent");
static_assert(sizeof(UHLLAmmoComponent) == 0x0000F0, "Wrong size on UHLLAmmoComponent");
static_assert(offsetof(UHLLAmmoComponent, ResuppliedPlayers) == 0x0000B0, "Member 'UHLLAmmoComponent::ResuppliedPlayers' has a wrong offset!");
static_assert(offsetof(UHLLAmmoComponent, ResupplySound) == 0x0000C0, "Member 'UHLLAmmoComponent::ResupplySound' has a wrong offset!");
static_assert(offsetof(UHLLAmmoComponent, bSameTeamOnly) == 0x0000C8, "Member 'UHLLAmmoComponent::bSameTeamOnly' has a wrong offset!");
static_assert(offsetof(UHLLAmmoComponent, AmmoTypes) == 0x0000C9, "Member 'UHLLAmmoComponent::AmmoTypes' has a wrong offset!");
static_assert(offsetof(UHLLAmmoComponent, bInfiniteResupplies) == 0x0000CA, "Member 'UHLLAmmoComponent::bInfiniteResupplies' has a wrong offset!");
static_assert(offsetof(UHLLAmmoComponent, bUnlimitedReuses) == 0x0000CB, "Member 'UHLLAmmoComponent::bUnlimitedReuses' has a wrong offset!");
static_assert(offsetof(UHLLAmmoComponent, MaxResupplies) == 0x0000CC, "Member 'UHLLAmmoComponent::MaxResupplies' has a wrong offset!");
static_assert(offsetof(UHLLAmmoComponent, ResupplyTime) == 0x0000D0, "Member 'UHLLAmmoComponent::ResupplyTime' has a wrong offset!");

// Class HLL.HLLRcon
// 0x0058 (0x0278 - 0x0220)
class AHLLRcon : public AActor
{
public:
	uint8                                         Pad_1296[0x30];                                    // 0x0220(0x0030)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<uint8>                                 XORKey;                                            // 0x0250(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ResponseID;                                        // 0x0260(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  AuthenticationToken;                               // 0x0264(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          V2ServerConfigEnabled;                             // 0x0274(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UsingV2Connection;                                 // 0x0275(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1297[0x2];                                     // 0x0276(0x0002)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnDestroyedCleanup(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRcon">();
	}
	static class AHLLRcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLRcon>();
	}
};
static_assert(alignof(AHLLRcon) == 0x000008, "Wrong alignment on AHLLRcon");
static_assert(sizeof(AHLLRcon) == 0x000278, "Wrong size on AHLLRcon");
static_assert(offsetof(AHLLRcon, XORKey) == 0x000250, "Member 'AHLLRcon::XORKey' has a wrong offset!");
static_assert(offsetof(AHLLRcon, ResponseID) == 0x000260, "Member 'AHLLRcon::ResponseID' has a wrong offset!");
static_assert(offsetof(AHLLRcon, AuthenticationToken) == 0x000264, "Member 'AHLLRcon::AuthenticationToken' has a wrong offset!");
static_assert(offsetof(AHLLRcon, V2ServerConfigEnabled) == 0x000274, "Member 'AHLLRcon::V2ServerConfigEnabled' has a wrong offset!");
static_assert(offsetof(AHLLRcon, UsingV2Connection) == 0x000275, "Member 'AHLLRcon::UsingV2Connection' has a wrong offset!");

// Class HLL.HLLIngameRcon
// 0x0048 (0x02C0 - 0x0278)
class AHLLIngameRcon final : public AHLLRcon
{
public:
	uint8                                         Pad_1298[0x48];                                    // 0x0278(0x0048)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void RPC_Client_ReceiveReply(const class FString& MessageFromServer);
	void RPC_Server_ProcessCommand(const class FString& Command);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLIngameRcon">();
	}
	static class AHLLIngameRcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLIngameRcon>();
	}
};
static_assert(alignof(AHLLIngameRcon) == 0x000008, "Wrong alignment on AHLLIngameRcon");
static_assert(sizeof(AHLLIngameRcon) == 0x0002C0, "Wrong size on AHLLIngameRcon");

// Class HLL.HLLDispenseStructure
// 0x0160 (0x0380 - 0x0220)
class AHLLDispenseStructure : public AActor
{
public:
	uint8                                         Pad_1299[0x68];                                    // 0x0220(0x0068)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        DummyRoot;                                         // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSimpleHealthComponent*              HealthComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSnapComponent*                      SnapsComponent;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDismantlingComponent*                  DismantlingComponent;                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanBeDismantled : 1;                              // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanDismantleWhenPlacedInWorld : 1;                // 0x02B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_129A[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DismantleTime;                                     // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x02B8(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   ScoreOnEnemyDismantled;                            // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DismantleDistance;                                 // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x02DC(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x02DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129B[0x2];                                     // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLUpgradeInfo                        UpgradeData;                                       // 0x02E0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Net, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UHLLUpgradeGhostComponent*              UpgradeGhostComponent;                             // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRegisterWithTeamActors : 1;                       // 0x0370(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EActorCountClass                              TeamActorCountClass;                               // 0x0371(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129C[0x6];                                     // 0x0372(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerState*                    SpawnedByPlayer;                                   // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnKilled(class UHLLSimpleHealthComponent* Component);
	void OnRep_UpgradeData(const struct FHLLUpgradeInfo& OldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenseStructure">();
	}
	static class AHLLDispenseStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenseStructure>();
	}
};
static_assert(alignof(AHLLDispenseStructure) == 0x000008, "Wrong alignment on AHLLDispenseStructure");
static_assert(sizeof(AHLLDispenseStructure) == 0x000380, "Wrong size on AHLLDispenseStructure");
static_assert(offsetof(AHLLDispenseStructure, DummyRoot) == 0x000288, "Member 'AHLLDispenseStructure::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, Mesh) == 0x000290, "Member 'AHLLDispenseStructure::Mesh' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, HealthComponent) == 0x000298, "Member 'AHLLDispenseStructure::HealthComponent' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, SnapsComponent) == 0x0002A0, "Member 'AHLLDispenseStructure::SnapsComponent' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, DismantlingComponent) == 0x0002A8, "Member 'AHLLDispenseStructure::DismantlingComponent' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, DismantleTime) == 0x0002B4, "Member 'AHLLDispenseStructure::DismantleTime' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, DisplayName) == 0x0002B8, "Member 'AHLLDispenseStructure::DisplayName' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, ScoreOnEnemyDismantled) == 0x0002D0, "Member 'AHLLDispenseStructure::ScoreOnEnemyDismantled' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, DismantleDistance) == 0x0002D8, "Member 'AHLLDispenseStructure::DismantleDistance' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, Team) == 0x0002DC, "Member 'AHLLDispenseStructure::Team' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, DamageFilterType) == 0x0002DD, "Member 'AHLLDispenseStructure::DamageFilterType' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, UpgradeData) == 0x0002E0, "Member 'AHLLDispenseStructure::UpgradeData' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, UpgradeGhostComponent) == 0x000368, "Member 'AHLLDispenseStructure::UpgradeGhostComponent' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, TeamActorCountClass) == 0x000371, "Member 'AHLLDispenseStructure::TeamActorCountClass' has a wrong offset!");
static_assert(offsetof(AHLLDispenseStructure, SpawnedByPlayer) == 0x000378, "Member 'AHLLDispenseStructure::SpawnedByPlayer' has a wrong offset!");

// Class HLL.RCONCommandSetAutoBalance
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetAutoBalance final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetAutoBalance">();
	}
	static class URCONCommandSetAutoBalance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetAutoBalance>();
	}
};
static_assert(alignof(URCONCommandSetAutoBalance) == 0x000008, "Wrong alignment on URCONCommandSetAutoBalance");
static_assert(sizeof(URCONCommandSetAutoBalance) == 0x000028, "Wrong size on URCONCommandSetAutoBalance");

// Class HLL.HLLAmmoDepot
// 0x0040 (0x03C0 - 0x0380)
class AHLLAmmoDepot final : public AHLLDispenseStructure
{
public:
	int32                                         ReplenishRate;                                     // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplenishRadius;                                   // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ReplenishingSound;                                 // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129D[0x8];                                     // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bIsReplenishing : 1;                               // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_129E[0x7];                                     // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystemComponent*               ReplenishParticle;                                 // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         ReplenishAC;                                       // 0x03A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Replenishing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAmmoDepot">();
	}
	static class AHLLAmmoDepot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAmmoDepot>();
	}
};
static_assert(alignof(AHLLAmmoDepot) == 0x000008, "Wrong alignment on AHLLAmmoDepot");
static_assert(sizeof(AHLLAmmoDepot) == 0x0003C0, "Wrong size on AHLLAmmoDepot");
static_assert(offsetof(AHLLAmmoDepot, ReplenishRate) == 0x000380, "Member 'AHLLAmmoDepot::ReplenishRate' has a wrong offset!");
static_assert(offsetof(AHLLAmmoDepot, ReplenishRadius) == 0x000384, "Member 'AHLLAmmoDepot::ReplenishRadius' has a wrong offset!");
static_assert(offsetof(AHLLAmmoDepot, ReplenishingSound) == 0x000388, "Member 'AHLLAmmoDepot::ReplenishingSound' has a wrong offset!");
static_assert(offsetof(AHLLAmmoDepot, ReplenishParticle) == 0x0003A0, "Member 'AHLLAmmoDepot::ReplenishParticle' has a wrong offset!");
static_assert(offsetof(AHLLAmmoDepot, ReplenishAC) == 0x0003A8, "Member 'AHLLAmmoDepot::ReplenishAC' has a wrong offset!");
static_assert(offsetof(AHLLAmmoDepot, MapComponent) == 0x0003B0, "Member 'AHLLAmmoDepot::MapComponent' has a wrong offset!");
static_assert(offsetof(AHLLAmmoDepot, IndicatorComponent) == 0x0003B8, "Member 'AHLLAmmoDepot::IndicatorComponent' has a wrong offset!");

// Class HLL.HLLMapData_AdminCamera
// 0x0008 (0x0240 - 0x0238)
class AHLLMapData_AdminCamera : public AHLLMapDataBase
{
public:
	class AHLLAdminCamera*                        AdminCam;                                          // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_AdminCamera">();
	}
	static class AHLLMapData_AdminCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_AdminCamera>();
	}
};
static_assert(alignof(AHLLMapData_AdminCamera) == 0x000008, "Wrong alignment on AHLLMapData_AdminCamera");
static_assert(sizeof(AHLLMapData_AdminCamera) == 0x000240, "Wrong size on AHLLMapData_AdminCamera");
static_assert(offsetof(AHLLMapData_AdminCamera, AdminCam) == 0x000238, "Member 'AHLLMapData_AdminCamera::AdminCam' has a wrong offset!");

// Class HLL.RCONCommandRemoveVipPlayer
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveVipPlayer final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveVipPlayer">();
	}
	static class URCONCommandRemoveVipPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveVipPlayer>();
	}
};
static_assert(alignof(URCONCommandRemoveVipPlayer) == 0x000008, "Wrong alignment on URCONCommandRemoveVipPlayer");
static_assert(sizeof(URCONCommandRemoveVipPlayer) == 0x000028, "Wrong size on URCONCommandRemoveVipPlayer");

// Class HLL.HLLAmmoDepotIndicator
// 0x0008 (0x02B8 - 0x02B0)
class UHLLAmmoDepotIndicator final : public UHLLIndicatorBase
{
public:
	class UBorder*                                ReplenishBorder;                                   // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAmmoDepotIndicator">();
	}
	static class UHLLAmmoDepotIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAmmoDepotIndicator>();
	}
};
static_assert(alignof(UHLLAmmoDepotIndicator) == 0x000008, "Wrong alignment on UHLLAmmoDepotIndicator");
static_assert(sizeof(UHLLAmmoDepotIndicator) == 0x0002B8, "Wrong size on UHLLAmmoDepotIndicator");
static_assert(offsetof(UHLLAmmoDepotIndicator, ReplenishBorder) == 0x0002B0, "Member 'UHLLAmmoDepotIndicator::ReplenishBorder' has a wrong offset!");

// Class HLL.HLLCommanderAbility_TradeMorale
// 0x0008 (0x0368 - 0x0360)
class AHLLCommanderAbility_TradeMorale final : public AHLLCommanderAbility
{
public:
	EGameResource                                 GeneratedResource;                                 // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129F[0x3];                                     // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         GeneratedAmount;                                   // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_TradeMorale">();
	}
	static class AHLLCommanderAbility_TradeMorale* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_TradeMorale>();
	}
};
static_assert(alignof(AHLLCommanderAbility_TradeMorale) == 0x000008, "Wrong alignment on AHLLCommanderAbility_TradeMorale");
static_assert(sizeof(AHLLCommanderAbility_TradeMorale) == 0x000368, "Wrong size on AHLLCommanderAbility_TradeMorale");
static_assert(offsetof(AHLLCommanderAbility_TradeMorale, GeneratedResource) == 0x000360, "Member 'AHLLCommanderAbility_TradeMorale::GeneratedResource' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_TradeMorale, GeneratedAmount) == 0x000364, "Member 'AHLLCommanderAbility_TradeMorale::GeneratedAmount' has a wrong offset!");

// Class HLL.HLLAnalyticsSubsystem
// 0x0158 (0x0188 - 0x0030)
class UHLLAnalyticsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_12A0[0x158];                                   // 0x0030(0x0158)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void HandleAppReactivated();
	void HandleAppWillDeactivate();
	void InitPublicIPFinder();
	void StoreItemDataUpdated(const struct FStoreItemData& StoreItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAnalyticsSubsystem">();
	}
	static class UHLLAnalyticsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAnalyticsSubsystem>();
	}
};
static_assert(alignof(UHLLAnalyticsSubsystem) == 0x000008, "Wrong alignment on UHLLAnalyticsSubsystem");
static_assert(sizeof(UHLLAnalyticsSubsystem) == 0x000188, "Wrong size on UHLLAnalyticsSubsystem");

// Class HLL.HLLAnimInstance_ArtilleryBase
// 0x0020 (0x0290 - 0x0270)
class UHLLAnimInstance_ArtilleryBase : public UAnimInstance
{
public:
	class AHLLArtilleryBase*                      ArtilleryPiece;                                    // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLArmourWeapon*                       ArtilleryWeapon;                                   // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurretYaw;                                         // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurretPitch;                                       // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoadingProgress;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLoading;                                        // 0x028C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A1[0x3];                                     // 0x028D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitArtillery(class AHLLArtilleryBase* InArtyPiece);
	void OnWeaponFired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAnimInstance_ArtilleryBase">();
	}
	static class UHLLAnimInstance_ArtilleryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAnimInstance_ArtilleryBase>();
	}
};
static_assert(alignof(UHLLAnimInstance_ArtilleryBase) == 0x000010, "Wrong alignment on UHLLAnimInstance_ArtilleryBase");
static_assert(sizeof(UHLLAnimInstance_ArtilleryBase) == 0x000290, "Wrong size on UHLLAnimInstance_ArtilleryBase");
static_assert(offsetof(UHLLAnimInstance_ArtilleryBase, ArtilleryPiece) == 0x000270, "Member 'UHLLAnimInstance_ArtilleryBase::ArtilleryPiece' has a wrong offset!");
static_assert(offsetof(UHLLAnimInstance_ArtilleryBase, ArtilleryWeapon) == 0x000278, "Member 'UHLLAnimInstance_ArtilleryBase::ArtilleryWeapon' has a wrong offset!");
static_assert(offsetof(UHLLAnimInstance_ArtilleryBase, TurretYaw) == 0x000280, "Member 'UHLLAnimInstance_ArtilleryBase::TurretYaw' has a wrong offset!");
static_assert(offsetof(UHLLAnimInstance_ArtilleryBase, TurretPitch) == 0x000284, "Member 'UHLLAnimInstance_ArtilleryBase::TurretPitch' has a wrong offset!");
static_assert(offsetof(UHLLAnimInstance_ArtilleryBase, LoadingProgress) == 0x000288, "Member 'UHLLAnimInstance_ArtilleryBase::LoadingProgress' has a wrong offset!");
static_assert(offsetof(UHLLAnimInstance_ArtilleryBase, bIsLoading) == 0x00028C, "Member 'UHLLAnimInstance_ArtilleryBase::bIsLoading' has a wrong offset!");

// Class HLL.HLLAnimNotify_BoltLock
// 0x0000 (0x0038 - 0x0038)
class UHLLAnimNotify_BoltLock final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAnimNotify_BoltLock">();
	}
	static class UHLLAnimNotify_BoltLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAnimNotify_BoltLock>();
	}
};
static_assert(alignof(UHLLAnimNotify_BoltLock) == 0x000008, "Wrong alignment on UHLLAnimNotify_BoltLock");
static_assert(sizeof(UHLLAnimNotify_BoltLock) == 0x000038, "Wrong size on UHLLAnimNotify_BoltLock");

// Class HLL.HLLMapData_DynamicSpawn
// 0x0000 (0x0248 - 0x0248)
class AHLLMapData_DynamicSpawn : public AHLLMapData_Basic
{
public:
	TScriptInterface<class IDynamicSpawnInterface> GetSpawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_DynamicSpawn">();
	}
	static class AHLLMapData_DynamicSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_DynamicSpawn>();
	}
};
static_assert(alignof(AHLLMapData_DynamicSpawn) == 0x000008, "Wrong alignment on AHLLMapData_DynamicSpawn");
static_assert(sizeof(AHLLMapData_DynamicSpawn) == 0x000248, "Wrong size on AHLLMapData_DynamicSpawn");

// Class HLL.ShooterPlayerCameraManager
// 0x0050 (0x2790 - 0x2740)
class AShooterPlayerCameraManager : public APlayerCameraManager
{
public:
	uint8                                         Pad_12A2[0x4];                                     // 0x2738(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ViewPitchMinWhenProne;                             // 0x273C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMaxWhenProne;                             // 0x2740(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A3[0x4];                                     // 0x2744(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class ACameraActor*                           MapStartCamera;                                    // 0x2748(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           WeaponFOVParameters;                               // 0x2750(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12A4[0x18];                                    // 0x2758(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bDebugLensFlame;                                   // 0x2770(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A5[0x7];                                     // 0x2771(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AEmitterCameraLensEffectBase> BurnCameraEffect;                                  // 0x2778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEmitterCameraLensEffectBase*           ActiveBurnEffect;                                  // 0x2780(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMountedBipodRotationComponent*         MountedBipodRotationComponent;                     // 0x2788(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerCameraManager">();
	}
	static class AShooterPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerCameraManager>();
	}
};
static_assert(alignof(AShooterPlayerCameraManager) == 0x000010, "Wrong alignment on AShooterPlayerCameraManager");
static_assert(sizeof(AShooterPlayerCameraManager) == 0x002790, "Wrong size on AShooterPlayerCameraManager");
static_assert(offsetof(AShooterPlayerCameraManager, ViewPitchMinWhenProne) == 0x00273C, "Member 'AShooterPlayerCameraManager::ViewPitchMinWhenProne' has a wrong offset!");
static_assert(offsetof(AShooterPlayerCameraManager, ViewPitchMaxWhenProne) == 0x002740, "Member 'AShooterPlayerCameraManager::ViewPitchMaxWhenProne' has a wrong offset!");
static_assert(offsetof(AShooterPlayerCameraManager, MapStartCamera) == 0x002748, "Member 'AShooterPlayerCameraManager::MapStartCamera' has a wrong offset!");
static_assert(offsetof(AShooterPlayerCameraManager, WeaponFOVParameters) == 0x002750, "Member 'AShooterPlayerCameraManager::WeaponFOVParameters' has a wrong offset!");
static_assert(offsetof(AShooterPlayerCameraManager, bDebugLensFlame) == 0x002770, "Member 'AShooterPlayerCameraManager::bDebugLensFlame' has a wrong offset!");
static_assert(offsetof(AShooterPlayerCameraManager, BurnCameraEffect) == 0x002778, "Member 'AShooterPlayerCameraManager::BurnCameraEffect' has a wrong offset!");
static_assert(offsetof(AShooterPlayerCameraManager, ActiveBurnEffect) == 0x002780, "Member 'AShooterPlayerCameraManager::ActiveBurnEffect' has a wrong offset!");
static_assert(offsetof(AShooterPlayerCameraManager, MountedBipodRotationComponent) == 0x002788, "Member 'AShooterPlayerCameraManager::MountedBipodRotationComponent' has a wrong offset!");

// Class HLL.HLLAnimNotify_CameraAnim
// 0x0018 (0x0050 - 0x0038)
class UHLLAnimNotify_CameraAnim final : public UAnimNotify
{
public:
	class UCameraAnim*                            AnimToPlay;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Scale;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlaySpeed;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendInTime;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendOutTime;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAnimNotify_CameraAnim">();
	}
	static class UHLLAnimNotify_CameraAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAnimNotify_CameraAnim>();
	}
};
static_assert(alignof(UHLLAnimNotify_CameraAnim) == 0x000008, "Wrong alignment on UHLLAnimNotify_CameraAnim");
static_assert(sizeof(UHLLAnimNotify_CameraAnim) == 0x000050, "Wrong size on UHLLAnimNotify_CameraAnim");
static_assert(offsetof(UHLLAnimNotify_CameraAnim, AnimToPlay) == 0x000038, "Member 'UHLLAnimNotify_CameraAnim::AnimToPlay' has a wrong offset!");
static_assert(offsetof(UHLLAnimNotify_CameraAnim, Scale) == 0x000040, "Member 'UHLLAnimNotify_CameraAnim::Scale' has a wrong offset!");
static_assert(offsetof(UHLLAnimNotify_CameraAnim, PlaySpeed) == 0x000044, "Member 'UHLLAnimNotify_CameraAnim::PlaySpeed' has a wrong offset!");
static_assert(offsetof(UHLLAnimNotify_CameraAnim, BlendInTime) == 0x000048, "Member 'UHLLAnimNotify_CameraAnim::BlendInTime' has a wrong offset!");
static_assert(offsetof(UHLLAnimNotify_CameraAnim, BlendOutTime) == 0x00004C, "Member 'UHLLAnimNotify_CameraAnim::BlendOutTime' has a wrong offset!");

// Class HLL.HLLMapAbilityData
// 0x0010 (0x0040 - 0x0030)
class UHLLMapAbilityData final : public UDataAsset
{
public:
	TArray<struct FAbilityDefinition>             Abilities;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapAbilityData">();
	}
	static class UHLLMapAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapAbilityData>();
	}
};
static_assert(alignof(UHLLMapAbilityData) == 0x000008, "Wrong alignment on UHLLMapAbilityData");
static_assert(sizeof(UHLLMapAbilityData) == 0x000040, "Wrong size on UHLLMapAbilityData");
static_assert(offsetof(UHLLMapAbilityData, Abilities) == 0x000030, "Member 'UHLLMapAbilityData::Abilities' has a wrong offset!");

// Class HLL.HLLAnimNotify_CasingEject
// 0x0008 (0x0040 - 0x0038)
class UHLLAnimNotify_CasingEject final : public UAnimNotify
{
public:
	uint8                                         NumToPlay;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A6[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAnimNotify_CasingEject">();
	}
	static class UHLLAnimNotify_CasingEject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAnimNotify_CasingEject>();
	}
};
static_assert(alignof(UHLLAnimNotify_CasingEject) == 0x000008, "Wrong alignment on UHLLAnimNotify_CasingEject");
static_assert(sizeof(UHLLAnimNotify_CasingEject) == 0x000040, "Wrong size on UHLLAnimNotify_CasingEject");
static_assert(offsetof(UHLLAnimNotify_CasingEject, NumToPlay) == 0x000038, "Member 'UHLLAnimNotify_CasingEject::NumToPlay' has a wrong offset!");

// Class HLL.RCONCommandSetSectorLayout
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetSectorLayout final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetSectorLayout">();
	}
	static class URCONCommandSetSectorLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetSectorLayout>();
	}
};
static_assert(alignof(URCONCommandSetSectorLayout) == 0x000008, "Wrong alignment on URCONCommandSetSectorLayout");
static_assert(sizeof(URCONCommandSetSectorLayout) == 0x000028, "Wrong size on URCONCommandSetSectorLayout");

// Class HLL.HLLAnimNotify_Footstep
// 0x0008 (0x0040 - 0x0038)
class UHLLAnimNotify_Footstep : public UAnimNotify
{
public:
	EFoot                                         Foot;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsFirstPerson : 1;                                // 0x0039(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12A7[0x6];                                     // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAnimNotify_Footstep">();
	}
	static class UHLLAnimNotify_Footstep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAnimNotify_Footstep>();
	}
};
static_assert(alignof(UHLLAnimNotify_Footstep) == 0x000008, "Wrong alignment on UHLLAnimNotify_Footstep");
static_assert(sizeof(UHLLAnimNotify_Footstep) == 0x000040, "Wrong size on UHLLAnimNotify_Footstep");
static_assert(offsetof(UHLLAnimNotify_Footstep, Foot) == 0x000038, "Member 'UHLLAnimNotify_Footstep::Foot' has a wrong offset!");

// Class HLL.HLLAnimNotify_ReloadLock
// 0x0000 (0x0038 - 0x0038)
class UHLLAnimNotify_ReloadLock final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAnimNotify_ReloadLock">();
	}
	static class UHLLAnimNotify_ReloadLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAnimNotify_ReloadLock>();
	}
};
static_assert(alignof(UHLLAnimNotify_ReloadLock) == 0x000008, "Wrong alignment on UHLLAnimNotify_ReloadLock");
static_assert(sizeof(UHLLAnimNotify_ReloadLock) == 0x000038, "Wrong size on UHLLAnimNotify_ReloadLock");

// Class HLL.HLLMapData_PlantObjective
// 0x0000 (0x0238 - 0x0238)
class AHLLMapData_PlantObjective final : public AHLLMapDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_PlantObjective">();
	}
	static class AHLLMapData_PlantObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_PlantObjective>();
	}
};
static_assert(alignof(AHLLMapData_PlantObjective) == 0x000008, "Wrong alignment on AHLLMapData_PlantObjective");
static_assert(sizeof(AHLLMapData_PlantObjective) == 0x000238, "Wrong size on AHLLMapData_PlantObjective");

// Class HLL.RCONCommandSetHighPingThreshold
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetHighPingThreshold final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetHighPingThreshold">();
	}
	static class URCONCommandSetHighPingThreshold* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetHighPingThreshold>();
	}
};
static_assert(alignof(URCONCommandSetHighPingThreshold) == 0x000008, "Wrong alignment on URCONCommandSetHighPingThreshold");
static_assert(sizeof(URCONCommandSetHighPingThreshold) == 0x000028, "Wrong size on URCONCommandSetHighPingThreshold");

// Class HLL.HLLAnimNotify_VibrationEvent
// 0x0030 (0x0068 - 0x0038)
class UHLLAnimNotify_VibrationEvent final : public UAnimNotify
{
public:
	uint8                                         Pad_12A8[0x10];                                    // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             Sound;                                             // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0050(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0054(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollow : 1;                                       // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12A9[0xF];                                     // 0x0059(0x000F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAnimNotify_VibrationEvent">();
	}
	static class UHLLAnimNotify_VibrationEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLAnimNotify_VibrationEvent>();
	}
};
static_assert(alignof(UHLLAnimNotify_VibrationEvent) == 0x000008, "Wrong alignment on UHLLAnimNotify_VibrationEvent");
static_assert(sizeof(UHLLAnimNotify_VibrationEvent) == 0x000068, "Wrong size on UHLLAnimNotify_VibrationEvent");
static_assert(offsetof(UHLLAnimNotify_VibrationEvent, Sound) == 0x000048, "Member 'UHLLAnimNotify_VibrationEvent::Sound' has a wrong offset!");
static_assert(offsetof(UHLLAnimNotify_VibrationEvent, VolumeMultiplier) == 0x000050, "Member 'UHLLAnimNotify_VibrationEvent::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UHLLAnimNotify_VibrationEvent, PitchMultiplier) == 0x000054, "Member 'UHLLAnimNotify_VibrationEvent::PitchMultiplier' has a wrong offset!");

// Class HLL.HLLIndicatorComponent
// 0x0010 (0x00C0 - 0x00B0)
class UHLLIndicatorComponent : public UActorComponent
{
public:
	TSubclassOf<class UHLLIndicatorBase>          IndicatorClass;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoCreate : 1;                                   // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWantsIndicator : 1;                               // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12AA[0x7];                                     // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLIndicatorComponent">();
	}
	static class UHLLIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLIndicatorComponent>();
	}
};
static_assert(alignof(UHLLIndicatorComponent) == 0x000008, "Wrong alignment on UHLLIndicatorComponent");
static_assert(sizeof(UHLLIndicatorComponent) == 0x0000C0, "Wrong size on UHLLIndicatorComponent");
static_assert(offsetof(UHLLIndicatorComponent, IndicatorClass) == 0x0000B0, "Member 'UHLLIndicatorComponent::IndicatorClass' has a wrong offset!");

// Class HLL.HLLIndicatorComponent_Sector
// 0x0008 (0x00C8 - 0x00C0)
class UHLLIndicatorComponent_Sector final : public UHLLIndicatorComponent
{
public:
	int32                                         SectorIndex;                                       // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12AB[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLIndicatorComponent_Sector">();
	}
	static class UHLLIndicatorComponent_Sector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLIndicatorComponent_Sector>();
	}
};
static_assert(alignof(UHLLIndicatorComponent_Sector) == 0x000008, "Wrong alignment on UHLLIndicatorComponent_Sector");
static_assert(sizeof(UHLLIndicatorComponent_Sector) == 0x0000C8, "Wrong size on UHLLIndicatorComponent_Sector");
static_assert(offsetof(UHLLIndicatorComponent_Sector, SectorIndex) == 0x0000C0, "Member 'UHLLIndicatorComponent_Sector::SectorIndex' has a wrong offset!");

// Class HLL.HLLArtilleryBase
// 0x0168 (0x0388 - 0x0220)
class AHLLArtilleryBase : public AActor
{
public:
	uint8                                         Pad_12AC[0x70];                                    // 0x0220(0x0070)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         YawRate;                                           // 0x0290(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxYawAngle;                                       // 0x0294(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchRate;                                         // 0x0298(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinPitchAngle;                                     // 0x029C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPitchAngle;                                     // 0x02A0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerUpdateTurretRate;                            // 0x02A4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArtyBarrelControllerComponent*         BarrelController;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArtyTurnControllerComponent*           TurnController;                                    // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PitchAudio;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        YawAudio;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        TurnAudio;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeed;                                         // 0x02D8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x02DC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12AD[0x3];                                     // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLArmourMetaData                     ArmourMetaData;                                    // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12AE[0x7];                                     // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USkeletalMeshComponent*                 ArtilleryMesh;                                     // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourHealthComponent*              ArmourHealth;                                      // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourInventory*                    ArmourInventory;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CharacterTurretGuard;                              // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      PlayerBlockerL;                                    // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      PlayerBlockerR;                                    // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLSeat_ArtilleryGunner>   GunnerSeatClass;                                   // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLSeat_ArtilleryLoader>   LoaderSeatClass;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLSeat_ArtilleryGunner*               GunnerSeat;                                        // 0x0358(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLSeat_ArtilleryLoader*               LoaderSeat;                                        // 0x0360(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterPlayerState*                    SpawnedByPlayer;                                   // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              PitchVibrationController;                          // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              YawVibrationController;                            // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              TurnVibrationController;                           // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Seat();

	float GetCurrentPitch() const;
	float GetCurrentYaw() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArtilleryBase">();
	}
	static class AHLLArtilleryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArtilleryBase>();
	}
};
static_assert(alignof(AHLLArtilleryBase) == 0x000008, "Wrong alignment on AHLLArtilleryBase");
static_assert(sizeof(AHLLArtilleryBase) == 0x000388, "Wrong size on AHLLArtilleryBase");
static_assert(offsetof(AHLLArtilleryBase, YawRate) == 0x000290, "Member 'AHLLArtilleryBase::YawRate' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, MaxYawAngle) == 0x000294, "Member 'AHLLArtilleryBase::MaxYawAngle' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, PitchRate) == 0x000298, "Member 'AHLLArtilleryBase::PitchRate' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, MinPitchAngle) == 0x00029C, "Member 'AHLLArtilleryBase::MinPitchAngle' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, MaxPitchAngle) == 0x0002A0, "Member 'AHLLArtilleryBase::MaxPitchAngle' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, ServerUpdateTurretRate) == 0x0002A4, "Member 'AHLLArtilleryBase::ServerUpdateTurretRate' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, BarrelController) == 0x0002A8, "Member 'AHLLArtilleryBase::BarrelController' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, TurnController) == 0x0002B0, "Member 'AHLLArtilleryBase::TurnController' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, PitchAudio) == 0x0002B8, "Member 'AHLLArtilleryBase::PitchAudio' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, YawAudio) == 0x0002C0, "Member 'AHLLArtilleryBase::YawAudio' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, TurnAudio) == 0x0002C8, "Member 'AHLLArtilleryBase::TurnAudio' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, MapComponent) == 0x0002D0, "Member 'AHLLArtilleryBase::MapComponent' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, TurnSpeed) == 0x0002D8, "Member 'AHLLArtilleryBase::TurnSpeed' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, Team) == 0x0002DC, "Member 'AHLLArtilleryBase::Team' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, ArmourMetaData) == 0x0002E0, "Member 'AHLLArtilleryBase::ArmourMetaData' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, DamageFilterType) == 0x000308, "Member 'AHLLArtilleryBase::DamageFilterType' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, ArtilleryMesh) == 0x000310, "Member 'AHLLArtilleryBase::ArtilleryMesh' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, ArmourHealth) == 0x000318, "Member 'AHLLArtilleryBase::ArmourHealth' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, ArmourInventory) == 0x000320, "Member 'AHLLArtilleryBase::ArmourInventory' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, IndicatorComponent) == 0x000328, "Member 'AHLLArtilleryBase::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, CharacterTurretGuard) == 0x000330, "Member 'AHLLArtilleryBase::CharacterTurretGuard' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, PlayerBlockerL) == 0x000338, "Member 'AHLLArtilleryBase::PlayerBlockerL' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, PlayerBlockerR) == 0x000340, "Member 'AHLLArtilleryBase::PlayerBlockerR' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, GunnerSeatClass) == 0x000348, "Member 'AHLLArtilleryBase::GunnerSeatClass' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, LoaderSeatClass) == 0x000350, "Member 'AHLLArtilleryBase::LoaderSeatClass' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, GunnerSeat) == 0x000358, "Member 'AHLLArtilleryBase::GunnerSeat' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, LoaderSeat) == 0x000360, "Member 'AHLLArtilleryBase::LoaderSeat' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, SpawnedByPlayer) == 0x000368, "Member 'AHLLArtilleryBase::SpawnedByPlayer' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, PitchVibrationController) == 0x000370, "Member 'AHLLArtilleryBase::PitchVibrationController' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, YawVibrationController) == 0x000378, "Member 'AHLLArtilleryBase::YawVibrationController' has a wrong offset!");
static_assert(offsetof(AHLLArtilleryBase, TurnVibrationController) == 0x000380, "Member 'AHLLArtilleryBase::TurnVibrationController' has a wrong offset!");

// Class HLL.ShooterPickup
// 0x0040 (0x0260 - 0x0220)
class AShooterPickup : public AActor
{
public:
	class UParticleSystemComponent*               PickupPSC;                                         // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        ActiveFX;                                          // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        RespawningFX;                                      // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PickupSound;                                       // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              RespawnSound;                                      // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnTime;                                       // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsActive : 1;                                     // 0x024C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12AF[0x3];                                     // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterCharacter*                      PickedUpBy;                                        // 0x0250(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12B0[0x8];                                     // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnPickedUpEvent();
	void OnRep_IsActive();
	void OnRespawnEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPickup">();
	}
	static class AShooterPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPickup>();
	}
};
static_assert(alignof(AShooterPickup) == 0x000008, "Wrong alignment on AShooterPickup");
static_assert(sizeof(AShooterPickup) == 0x000260, "Wrong size on AShooterPickup");
static_assert(offsetof(AShooterPickup, PickupPSC) == 0x000220, "Member 'AShooterPickup::PickupPSC' has a wrong offset!");
static_assert(offsetof(AShooterPickup, ActiveFX) == 0x000228, "Member 'AShooterPickup::ActiveFX' has a wrong offset!");
static_assert(offsetof(AShooterPickup, RespawningFX) == 0x000230, "Member 'AShooterPickup::RespawningFX' has a wrong offset!");
static_assert(offsetof(AShooterPickup, PickupSound) == 0x000238, "Member 'AShooterPickup::PickupSound' has a wrong offset!");
static_assert(offsetof(AShooterPickup, RespawnSound) == 0x000240, "Member 'AShooterPickup::RespawnSound' has a wrong offset!");
static_assert(offsetof(AShooterPickup, RespawnTime) == 0x000248, "Member 'AShooterPickup::RespawnTime' has a wrong offset!");
static_assert(offsetof(AShooterPickup, PickedUpBy) == 0x000250, "Member 'AShooterPickup::PickedUpBy' has a wrong offset!");

// Class HLL.ShooterPickup_Ammo
// 0x0010 (0x0270 - 0x0260)
class AShooterPickup_Ammo final : public AShooterPickup
{
public:
	int32                                         AmmoClips;                                         // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12B1[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterWeapon>             WeaponType;                                        // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPickup_Ammo">();
	}
	static class AShooterPickup_Ammo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPickup_Ammo>();
	}
};
static_assert(alignof(AShooterPickup_Ammo) == 0x000008, "Wrong alignment on AShooterPickup_Ammo");
static_assert(sizeof(AShooterPickup_Ammo) == 0x000270, "Wrong size on AShooterPickup_Ammo");
static_assert(offsetof(AShooterPickup_Ammo, AmmoClips) == 0x000260, "Member 'AShooterPickup_Ammo::AmmoClips' has a wrong offset!");
static_assert(offsetof(AShooterPickup_Ammo, WeaponType) == 0x000268, "Member 'AShooterPickup_Ammo::WeaponType' has a wrong offset!");

// Class HLL.HLLAntiTankGun
// 0x00F8 (0x0480 - 0x0388)
class AHLLAntiTankGun : public AHLLArtilleryBase
{
public:
	uint8                                         Pad_12B2[0x10];                                    // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DismantleTime;                                     // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DismantleScore;                                    // 0x039C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12B3[0x4];                                     // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterImpactEffect>       DismantleEffect;                                   // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             DismantleEffectTransform;                          // 0x03B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHLLUpgradeInfo                        UpgradeData;                                       // 0x03E0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UHLLUpgradeGhostComponent*              UpgradeGhostComponent;                             // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDismantlingComponent*                  DismantlingComponent;                              // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12B4[0x8];                                     // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Multi_OnDismantle();
	void OnRep_UpgradeData(const struct FHLLUpgradeInfo& OldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAntiTankGun">();
	}
	static class AHLLAntiTankGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAntiTankGun>();
	}
};
static_assert(alignof(AHLLAntiTankGun) == 0x000010, "Wrong alignment on AHLLAntiTankGun");
static_assert(sizeof(AHLLAntiTankGun) == 0x000480, "Wrong size on AHLLAntiTankGun");
static_assert(offsetof(AHLLAntiTankGun, DismantleTime) == 0x000398, "Member 'AHLLAntiTankGun::DismantleTime' has a wrong offset!");
static_assert(offsetof(AHLLAntiTankGun, DismantleScore) == 0x00039C, "Member 'AHLLAntiTankGun::DismantleScore' has a wrong offset!");
static_assert(offsetof(AHLLAntiTankGun, DismantleEffect) == 0x0003A8, "Member 'AHLLAntiTankGun::DismantleEffect' has a wrong offset!");
static_assert(offsetof(AHLLAntiTankGun, DismantleEffectTransform) == 0x0003B0, "Member 'AHLLAntiTankGun::DismantleEffectTransform' has a wrong offset!");
static_assert(offsetof(AHLLAntiTankGun, UpgradeData) == 0x0003E0, "Member 'AHLLAntiTankGun::UpgradeData' has a wrong offset!");
static_assert(offsetof(AHLLAntiTankGun, UpgradeGhostComponent) == 0x000468, "Member 'AHLLAntiTankGun::UpgradeGhostComponent' has a wrong offset!");
static_assert(offsetof(AHLLAntiTankGun, DismantlingComponent) == 0x000470, "Member 'AHLLAntiTankGun::DismantlingComponent' has a wrong offset!");

// Class HLL.HLLArmourCollisionMesh
// 0x0030 (0x04C0 - 0x0490)
class UHLLArmourCollisionMesh final : public UStaticMeshComponent
{
public:
	class FName                                   ArmourAttachSocket;                                // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> DebugMPC;                                          // 0x0490(0x0028)(Transient, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B5[0x8];                                     // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourCollisionMesh">();
	}
	static class UHLLArmourCollisionMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLArmourCollisionMesh>();
	}
};
static_assert(alignof(UHLLArmourCollisionMesh) == 0x000010, "Wrong alignment on UHLLArmourCollisionMesh");
static_assert(sizeof(UHLLArmourCollisionMesh) == 0x0004C0, "Wrong size on UHLLArmourCollisionMesh");
static_assert(offsetof(UHLLArmourCollisionMesh, ArmourAttachSocket) == 0x000488, "Member 'UHLLArmourCollisionMesh::ArmourAttachSocket' has a wrong offset!");
static_assert(offsetof(UHLLArmourCollisionMesh, DebugMPC) == 0x000490, "Member 'UHLLArmourCollisionMesh::DebugMPC' has a wrong offset!");

// Class HLL.ServerQueueBeaconHostObject
// 0x0000 (0x0248 - 0x0248)
class AServerQueueBeaconHostObject final : public AOnlineBeaconHostObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerQueueBeaconHostObject">();
	}
	static class AServerQueueBeaconHostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AServerQueueBeaconHostObject>();
	}
};
static_assert(alignof(AServerQueueBeaconHostObject) == 0x000008, "Wrong alignment on AServerQueueBeaconHostObject");
static_assert(sizeof(AServerQueueBeaconHostObject) == 0x000248, "Wrong size on AServerQueueBeaconHostObject");

// Class HLL.HLLArmourDebugger
// 0x0040 (0x0260 - 0x0220)
class AHLLArmourDebugger final : public AActor
{
public:
	class UBillboardComponent*                    RootBillboard;                                     // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        ArrowComponent;                                    // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DebugTarget;                                       // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Expansion;                                         // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumX;                                              // 0x023C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumY;                                              // 0x023D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumZ;                                              // 0x023E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12B6[0x1];                                     // 0x023F(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         WallSizeY;                                         // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallSizeZ;                                         // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallTraceLength;                                   // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRandomiseRot;                                  // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  TestProfile;                                       // 0x0250(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bVisualizeTraceVectors : 1;                        // 0x0258(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bVisualizeHits : 1;                                // 0x0258(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHitsByArmourBox : 1;                              // 0x0258(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHitsAngleRejection : 1;                           // 0x0258(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTraceComplex : 1;                                 // 0x0258(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12B7[0x7];                                     // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Flush();
	void QueryBox();
	void QueryWall();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourDebugger">();
	}
	static class AHLLArmourDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArmourDebugger>();
	}
};
static_assert(alignof(AHLLArmourDebugger) == 0x000008, "Wrong alignment on AHLLArmourDebugger");
static_assert(sizeof(AHLLArmourDebugger) == 0x000260, "Wrong size on AHLLArmourDebugger");
static_assert(offsetof(AHLLArmourDebugger, RootBillboard) == 0x000220, "Member 'AHLLArmourDebugger::RootBillboard' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, ArrowComponent) == 0x000228, "Member 'AHLLArmourDebugger::ArrowComponent' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, DebugTarget) == 0x000230, "Member 'AHLLArmourDebugger::DebugTarget' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, Expansion) == 0x000238, "Member 'AHLLArmourDebugger::Expansion' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, NumX) == 0x00023C, "Member 'AHLLArmourDebugger::NumX' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, NumY) == 0x00023D, "Member 'AHLLArmourDebugger::NumY' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, NumZ) == 0x00023E, "Member 'AHLLArmourDebugger::NumZ' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, WallSizeY) == 0x000240, "Member 'AHLLArmourDebugger::WallSizeY' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, WallSizeZ) == 0x000244, "Member 'AHLLArmourDebugger::WallSizeZ' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, WallTraceLength) == 0x000248, "Member 'AHLLArmourDebugger::WallTraceLength' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, WallRandomiseRot) == 0x00024C, "Member 'AHLLArmourDebugger::WallRandomiseRot' has a wrong offset!");
static_assert(offsetof(AHLLArmourDebugger, TestProfile) == 0x000250, "Member 'AHLLArmourDebugger::TestProfile' has a wrong offset!");

// Class HLL.HLLMapData_Artillery
// 0x0000 (0x0260 - 0x0260)
class AHLLMapData_Artillery : public AHLLMapData_SeatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Artillery">();
	}
	static class AHLLMapData_Artillery* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Artillery>();
	}
};
static_assert(alignof(AHLLMapData_Artillery) == 0x000008, "Wrong alignment on AHLLMapData_Artillery");
static_assert(sizeof(AHLLMapData_Artillery) == 0x000260, "Wrong size on AHLLMapData_Artillery");

// Class HLL.HLLArmourGlobals
// 0x0000 (0x0028 - 0x0028)
class UHLLArmourGlobals final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourGlobals">();
	}
	static class UHLLArmourGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLArmourGlobals>();
	}
};
static_assert(alignof(UHLLArmourGlobals) == 0x000008, "Wrong alignment on UHLLArmourGlobals");
static_assert(sizeof(UHLLArmourGlobals) == 0x000028, "Wrong size on UHLLArmourGlobals");

// Class HLL.RCONJsonWriter
// 0x0000 (0x0028 - 0x0028)
class URCONJsonWriter final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONJsonWriter">();
	}
	static class URCONJsonWriter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONJsonWriter>();
	}
};
static_assert(alignof(URCONJsonWriter) == 0x000008, "Wrong alignment on URCONJsonWriter");
static_assert(sizeof(URCONJsonWriter) == 0x000028, "Wrong size on URCONJsonWriter");

// Class HLL.HLLArmourHealthComponent
// 0x0248 (0x02F8 - 0x00B0)
class UHLLArmourHealthComponent final : public UActorComponent
{
public:
	uint8                                         Pad_12B8[0x18];                                    // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLArmourDeltaInfo                    ArmourInfo;                                        // 0x00C8(0x0130)(Edit, Net, DisableEditOnInstance, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         ExplodeDelay;                                      // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenRepairSounds;                        // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             RepairSound;                                       // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             RepairCompleteSound;                               // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12B9[0x10];                                    // 0x0210(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class AController*                            KilledInstigator;                                  // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLVehicleDamageFX*                    DamageEffectData;                                  // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLVehicleWreck>           WreckActor;                                        // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathExplosionDamage;                              // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathExplosionRadius;                              // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathExplosionSuppression;                         // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathExplosionSuppressionRadius;                   // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                ExplosionDamageType;                               // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       ExplosionEffect;                                   // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FHLLActiveDamageFX>  ActiveDamageFX;                                    // 0x0258(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    OverrideReferenceComponent;                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHLLArmourRating                              DefaultArmourRating;                               // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12BA[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DefaultResistance[0x5];                            // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FArmouredBody>                  ArmouredBodies;                                    // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FArmourBox>                     Compartments;                                      // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12BB[0x4];                                     // 0x02E8(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         EngineDamageWhenSubmerged;                         // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12BC[0x8];                                     // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_ArmourInfo(const struct FHLLArmourDeltaInfo& OldValue);

	bool CanBeRepaired() const;
	float GetAllCategoriesHealthRatio() const;
	EHLLArmourCategory GetBestRepairCategory() const;
	float GetCategoryRatio(const EHLLArmourCategory ForCategory) const;
	int32 GetCurrentHealth(const EHLLArmourCategory& ForCategory) const;
	int32 GetMaxHealth(const EHLLArmourCategory& ForCategory) const;
	bool IsAlive() const;
	bool IsCategoryEnabled(const EHLLArmourCategory Category, const float DisabledRatio) const;
	bool WasRecentlyRepaired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourHealthComponent">();
	}
	static class UHLLArmourHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLArmourHealthComponent>();
	}
};
static_assert(alignof(UHLLArmourHealthComponent) == 0x000008, "Wrong alignment on UHLLArmourHealthComponent");
static_assert(sizeof(UHLLArmourHealthComponent) == 0x0002F8, "Wrong size on UHLLArmourHealthComponent");
static_assert(offsetof(UHLLArmourHealthComponent, ArmourInfo) == 0x0000C8, "Member 'UHLLArmourHealthComponent::ArmourInfo' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, ExplodeDelay) == 0x0001F8, "Member 'UHLLArmourHealthComponent::ExplodeDelay' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, MinTimeBetweenRepairSounds) == 0x0001FC, "Member 'UHLLArmourHealthComponent::MinTimeBetweenRepairSounds' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, RepairSound) == 0x000200, "Member 'UHLLArmourHealthComponent::RepairSound' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, RepairCompleteSound) == 0x000208, "Member 'UHLLArmourHealthComponent::RepairCompleteSound' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, KilledInstigator) == 0x000220, "Member 'UHLLArmourHealthComponent::KilledInstigator' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, DamageEffectData) == 0x000228, "Member 'UHLLArmourHealthComponent::DamageEffectData' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, WreckActor) == 0x000230, "Member 'UHLLArmourHealthComponent::WreckActor' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, DeathExplosionDamage) == 0x000238, "Member 'UHLLArmourHealthComponent::DeathExplosionDamage' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, DeathExplosionRadius) == 0x00023C, "Member 'UHLLArmourHealthComponent::DeathExplosionRadius' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, DeathExplosionSuppression) == 0x000240, "Member 'UHLLArmourHealthComponent::DeathExplosionSuppression' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, DeathExplosionSuppressionRadius) == 0x000244, "Member 'UHLLArmourHealthComponent::DeathExplosionSuppressionRadius' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, ExplosionDamageType) == 0x000248, "Member 'UHLLArmourHealthComponent::ExplosionDamageType' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, ExplosionEffect) == 0x000250, "Member 'UHLLArmourHealthComponent::ExplosionEffect' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, ActiveDamageFX) == 0x000258, "Member 'UHLLArmourHealthComponent::ActiveDamageFX' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, OverrideReferenceComponent) == 0x0002A8, "Member 'UHLLArmourHealthComponent::OverrideReferenceComponent' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, DefaultArmourRating) == 0x0002B0, "Member 'UHLLArmourHealthComponent::DefaultArmourRating' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, DefaultResistance) == 0x0002B4, "Member 'UHLLArmourHealthComponent::DefaultResistance' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, ArmouredBodies) == 0x0002C8, "Member 'UHLLArmourHealthComponent::ArmouredBodies' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, Compartments) == 0x0002D8, "Member 'UHLLArmourHealthComponent::Compartments' has a wrong offset!");
static_assert(offsetof(UHLLArmourHealthComponent, EngineDamageWhenSubmerged) == 0x0002EC, "Member 'UHLLArmourHealthComponent::EngineDamageWhenSubmerged' has a wrong offset!");

// Class HLL.HLLArmourInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLArmourInterface final : public IInterface
{
public:
	class UHLLArmourHealthComponent* GetArmourHealthComponent() const;
	class UHLLArmourInventory* GetArmourInventoryComponent() const;
	struct FHLLArmourMetaData GetArmourMeta() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourInterface">();
	}
	static class IHLLArmourInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLArmourInterface>();
	}
};
static_assert(alignof(IHLLArmourInterface) == 0x000008, "Wrong alignment on IHLLArmourInterface");
static_assert(sizeof(IHLLArmourInterface) == 0x000028, "Wrong size on IHLLArmourInterface");

// Class HLL.HLLWeaponVibrationData
// 0x0000 (0x0030 - 0x0030)
class UHLLWeaponVibrationData : public UHLLVibrationData
{
public:
	class UVibrationEventController* CreateEffect2D(class UObject* WorldContextObject, EWeaponVibrationEventType Type, bool AutoDestroy);
	class UVibrationEventController* CreateEffect3D(EWeaponVibrationEventType Type, const bool bDoAttach, const bool AutoDestroy, class USkeletalMeshComponent* ReferenceComp, class FName SocketName);
	void PlayEffect2D(class UObject* WorldContextObject, EWeaponVibrationEventType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeaponVibrationData">();
	}
	static class UHLLWeaponVibrationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeaponVibrationData>();
	}
};
static_assert(alignof(UHLLWeaponVibrationData) == 0x000008, "Wrong alignment on UHLLWeaponVibrationData");
static_assert(sizeof(UHLLWeaponVibrationData) == 0x000030, "Wrong size on UHLLWeaponVibrationData");

// Class HLL.RCONCommandSetTeamSwitchCooldown
// 0x0008 (0x0030 - 0x0028)
class URCONCommandSetTeamSwitchCooldown final : public URCONCommand
{
public:
	int32                                         MaxCooldownTime;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C5[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetTeamSwitchCooldown">();
	}
	static class URCONCommandSetTeamSwitchCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetTeamSwitchCooldown>();
	}
};
static_assert(alignof(URCONCommandSetTeamSwitchCooldown) == 0x000008, "Wrong alignment on URCONCommandSetTeamSwitchCooldown");
static_assert(sizeof(URCONCommandSetTeamSwitchCooldown) == 0x000030, "Wrong size on URCONCommandSetTeamSwitchCooldown");
static_assert(offsetof(URCONCommandSetTeamSwitchCooldown, MaxCooldownTime) == 0x000028, "Member 'URCONCommandSetTeamSwitchCooldown::MaxCooldownTime' has a wrong offset!");

// Class HLL.HLLArmourInventory
// 0x0040 (0x00F0 - 0x00B0)
class UHLLArmourInventory final : public UActorComponent
{
public:
	TArray<struct FArmourWeaponSpec>              DefaultInventory;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHLLArmourWeapon*>               Inventory;                                         // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C6[0x20];                                    // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_Inventory();

	class AHLLArmourWeapon* GetWeapon(const uint8 Param_Index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourInventory">();
	}
	static class UHLLArmourInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLArmourInventory>();
	}
};
static_assert(alignof(UHLLArmourInventory) == 0x000008, "Wrong alignment on UHLLArmourInventory");
static_assert(sizeof(UHLLArmourInventory) == 0x0000F0, "Wrong size on UHLLArmourInventory");
static_assert(offsetof(UHLLArmourInventory, DefaultInventory) == 0x0000B0, "Member 'UHLLArmourInventory::DefaultInventory' has a wrong offset!");
static_assert(offsetof(UHLLArmourInventory, Inventory) == 0x0000C0, "Member 'UHLLArmourInventory::Inventory' has a wrong offset!");

// Class HLL.ServerQueue
// 0x00D0 (0x00F8 - 0x0028)
class UServerQueue final : public UObject
{
public:
	uint8                                         Pad_12C8[0xA0];                                    // 0x0028(0x00A0)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         MaxPlayersInQueue;                                 // 0x00C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumSlotsReservedForVIPPlayers;                     // 0x00CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         VIPPlayerNetworkIDs;                               // 0x00D0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVIPPlayerRecord>               VIPPlayerRecords;                                  // 0x00E0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C9[0x8];                                     // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerQueue">();
	}
	static class UServerQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerQueue>();
	}
};
static_assert(alignof(UServerQueue) == 0x000008, "Wrong alignment on UServerQueue");
static_assert(sizeof(UServerQueue) == 0x0000F8, "Wrong size on UServerQueue");
static_assert(offsetof(UServerQueue, MaxPlayersInQueue) == 0x0000C8, "Member 'UServerQueue::MaxPlayersInQueue' has a wrong offset!");
static_assert(offsetof(UServerQueue, NumSlotsReservedForVIPPlayers) == 0x0000CC, "Member 'UServerQueue::NumSlotsReservedForVIPPlayers' has a wrong offset!");
static_assert(offsetof(UServerQueue, VIPPlayerNetworkIDs) == 0x0000D0, "Member 'UServerQueue::VIPPlayerNetworkIDs' has a wrong offset!");
static_assert(offsetof(UServerQueue, VIPPlayerRecords) == 0x0000E0, "Member 'UServerQueue::VIPPlayerRecords' has a wrong offset!");

// Class HLL.HLLArmourMaterial
// 0x0028 (0x00A8 - 0x0080)
class UHLLArmourMaterial final : public UPhysicalMaterial
{
public:
	struct FHLLArmourSpec                         ArmourProperties;                                  // 0x0080(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12CA[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourMaterial">();
	}
	static class UHLLArmourMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLArmourMaterial>();
	}
};
static_assert(alignof(UHLLArmourMaterial) == 0x000008, "Wrong alignment on UHLLArmourMaterial");
static_assert(sizeof(UHLLArmourMaterial) == 0x0000A8, "Wrong size on UHLLArmourMaterial");
static_assert(offsetof(UHLLArmourMaterial, ArmourProperties) == 0x000080, "Member 'UHLLArmourMaterial::ArmourProperties' has a wrong offset!");

// Class HLL.HLLArmourWeapon
// 0x0340 (0x0560 - 0x0220)
class AHLLArmourWeapon : public AActor
{
public:
	uint8                                         Pad_12CB[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   CustomMeshAttachPoint;                             // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourInventory*                    OwningInventory;                                   // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLastOwnerWasLocalPlayer;                          // 0x0248(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12CC[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USkeletalMeshComponent*                 WeaponSourceMesh;                                  // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 WeaponOwnerMesh;                                   // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAmmoSourceContainer                   AmmoInfo;                                          // 0x0260(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         SelectedAmmoID;                                    // 0x0298(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHint                                         OutOfAmmoHint;                                     // 0x0299(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisableLoadingWhenWeaponDamaged : 1;              // 0x029A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoReload : 1;                                   // 0x029A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoReloadWhenEmpty : 1;                          // 0x029A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCancelReloadOnOccupancyChange : 1;                // 0x029A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12CD[0x1];                                     // 0x029B(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DisableLoadingHealthRatio;                         // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinLoadTime;                                       // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12CE[0x4];                                     // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             LoadSound;                                         // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             CancelLoadSound;                                   // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadMontage;                                     // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            ReloadBlendSpace;                                  // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   HapticsMontages;                                   // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12CF[0x8];                                     // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class UAudioComponent>         LoadAC;                                            // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12D0[0x38];                                    // 0x02E8(0x0038)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLWeaponBurstInfo                    BurstCounter;                                      // 0x0320(0x0004)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D1[0x4];                                     // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateBrush                            WeaponIcon;                                        // 0x0328(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   WeaponName;                                        // 0x03B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   WeaponHeader;                                      // 0x03C8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bDisableFiringWhenWeaponDamaged : 1;               // 0x03E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutomatic : 1;                                    // 0x03E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoSimulationLoop : 1;                           // 0x03E0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12D2[0x3];                                     // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DisableFiringHealthRatio;                          // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShotDelay;                                         // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShotVariance;                                      // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilImpulseMagnitude;                            // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleSocketName;                                  // 0x03F4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleSocketFlashName;                             // 0x03FC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D3[0x14];                                    // 0x0404(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnShotFired;                                       // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D4[0x10];                                    // 0x0428(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystem*                        MuzzleFlash;                                       // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        FireGroundSmoke;                                   // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponSoundMode                              FireSoundMode;                                     // 0x0448(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxTails;                                          // 0x0449(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxSingleFireSounds;                               // 0x044A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D5[0x5];                                     // 0x044B(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             FireSound;                                         // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             FireTailSound;                                     // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             FireStopSound;                                     // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               FireCameraShake;                                   // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeRadius;                                 // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLoopedGroundSmoke : 1;                            // 0x0474(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLoopedMuzzleFlash : 1;                            // 0x0474(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12D6[0x3];                                     // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimMontage*                           FireMontage;                                       // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        CasingFX;                                          // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CasingEjectPoint;                                  // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CasingScaleFPP;                                    // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UParticleSystemComponent> MuzzlePSC;                                         // 0x0494(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UParticleSystemComponent> GroundPSC;                                         // 0x049C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D7[0x4];                                     // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UAudioComponent*>                MuzzleAudio;                                       // 0x04A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAudioComponent*>                MuzzleAudioTails;                                  // 0x04B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D8[0x40];                                    // 0x04C8(0x0040)(Fixing Size After Last Property [ Dumper-69 ])
	struct FAdaptiveTriggerSetting                TriggerSetting;                                    // 0x0508(0x0014)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D9[0x4];                                     // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLWeaponVibrationData*                WeaponVibrationData;                               // 0x0520(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UVibrationEventController*>      FireVibrationEventControllers;                     // 0x0528(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              LoadVibrationComponent;                            // 0x0538(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12DA[0x8];                                     // 0x0540(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             FireSound_PADOVERRIDE;                             // 0x0548(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             LoadSound_PADOVERRIDE;                             // 0x0550(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLPlayerStat                                FireIncrementStat;                                 // 0x0558(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12DB[0x7];                                     // 0x0559(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void HLL_OnWeaponFire__DelegateSignature();
	void OnRep_AmmoInfo(const struct FAmmoSourceContainer& PrevInfo);
	void OnRep_BurstCounter(const struct FHLLWeaponBurstInfo& OldValue);
	void Server_LoadWeapon(const uint8 AmmoID);
	void Server_StopFire();

	bool CanBeReplenished() const;
	bool CanLoadWeapon(const uint8 AmmoID) const;
	uint8 GetCurrentClip() const;
	float GetLoadProgress() const;
	bool IsWeaponFiring() const;
	bool IsWeaponLoaded() const;
	bool IsWeaponLoading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeapon">();
	}
	static class AHLLArmourWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArmourWeapon>();
	}
};
static_assert(alignof(AHLLArmourWeapon) == 0x000008, "Wrong alignment on AHLLArmourWeapon");
static_assert(sizeof(AHLLArmourWeapon) == 0x000560, "Wrong size on AHLLArmourWeapon");
static_assert(offsetof(AHLLArmourWeapon, CustomMeshAttachPoint) == 0x000238, "Member 'AHLLArmourWeapon::CustomMeshAttachPoint' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, OwningInventory) == 0x000240, "Member 'AHLLArmourWeapon::OwningInventory' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, bLastOwnerWasLocalPlayer) == 0x000248, "Member 'AHLLArmourWeapon::bLastOwnerWasLocalPlayer' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, WeaponSourceMesh) == 0x000250, "Member 'AHLLArmourWeapon::WeaponSourceMesh' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, WeaponOwnerMesh) == 0x000258, "Member 'AHLLArmourWeapon::WeaponOwnerMesh' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, AmmoInfo) == 0x000260, "Member 'AHLLArmourWeapon::AmmoInfo' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, SelectedAmmoID) == 0x000298, "Member 'AHLLArmourWeapon::SelectedAmmoID' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, OutOfAmmoHint) == 0x000299, "Member 'AHLLArmourWeapon::OutOfAmmoHint' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, DisableLoadingHealthRatio) == 0x00029C, "Member 'AHLLArmourWeapon::DisableLoadingHealthRatio' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MinLoadTime) == 0x0002A0, "Member 'AHLLArmourWeapon::MinLoadTime' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, LoadSound) == 0x0002A8, "Member 'AHLLArmourWeapon::LoadSound' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, CancelLoadSound) == 0x0002B0, "Member 'AHLLArmourWeapon::CancelLoadSound' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, ReloadMontage) == 0x0002B8, "Member 'AHLLArmourWeapon::ReloadMontage' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, ReloadBlendSpace) == 0x0002C0, "Member 'AHLLArmourWeapon::ReloadBlendSpace' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, HapticsMontages) == 0x0002C8, "Member 'AHLLArmourWeapon::HapticsMontages' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, LoadAC) == 0x0002E0, "Member 'AHLLArmourWeapon::LoadAC' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, BurstCounter) == 0x000320, "Member 'AHLLArmourWeapon::BurstCounter' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, WeaponIcon) == 0x000328, "Member 'AHLLArmourWeapon::WeaponIcon' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, WeaponName) == 0x0003B0, "Member 'AHLLArmourWeapon::WeaponName' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, WeaponHeader) == 0x0003C8, "Member 'AHLLArmourWeapon::WeaponHeader' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, DisableFiringHealthRatio) == 0x0003E4, "Member 'AHLLArmourWeapon::DisableFiringHealthRatio' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, ShotDelay) == 0x0003E8, "Member 'AHLLArmourWeapon::ShotDelay' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, ShotVariance) == 0x0003EC, "Member 'AHLLArmourWeapon::ShotVariance' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, RecoilImpulseMagnitude) == 0x0003F0, "Member 'AHLLArmourWeapon::RecoilImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MuzzleSocketName) == 0x0003F4, "Member 'AHLLArmourWeapon::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MuzzleSocketFlashName) == 0x0003FC, "Member 'AHLLArmourWeapon::MuzzleSocketFlashName' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, OnShotFired) == 0x000418, "Member 'AHLLArmourWeapon::OnShotFired' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MuzzleFlash) == 0x000438, "Member 'AHLLArmourWeapon::MuzzleFlash' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireGroundSmoke) == 0x000440, "Member 'AHLLArmourWeapon::FireGroundSmoke' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireSoundMode) == 0x000448, "Member 'AHLLArmourWeapon::FireSoundMode' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MaxTails) == 0x000449, "Member 'AHLLArmourWeapon::MaxTails' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MaxSingleFireSounds) == 0x00044A, "Member 'AHLLArmourWeapon::MaxSingleFireSounds' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireSound) == 0x000450, "Member 'AHLLArmourWeapon::FireSound' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireTailSound) == 0x000458, "Member 'AHLLArmourWeapon::FireTailSound' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireStopSound) == 0x000460, "Member 'AHLLArmourWeapon::FireStopSound' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireCameraShake) == 0x000468, "Member 'AHLLArmourWeapon::FireCameraShake' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, CameraShakeRadius) == 0x000470, "Member 'AHLLArmourWeapon::CameraShakeRadius' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireMontage) == 0x000478, "Member 'AHLLArmourWeapon::FireMontage' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, CasingFX) == 0x000480, "Member 'AHLLArmourWeapon::CasingFX' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, CasingEjectPoint) == 0x000488, "Member 'AHLLArmourWeapon::CasingEjectPoint' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, CasingScaleFPP) == 0x000490, "Member 'AHLLArmourWeapon::CasingScaleFPP' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MuzzlePSC) == 0x000494, "Member 'AHLLArmourWeapon::MuzzlePSC' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, GroundPSC) == 0x00049C, "Member 'AHLLArmourWeapon::GroundPSC' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MuzzleAudio) == 0x0004A8, "Member 'AHLLArmourWeapon::MuzzleAudio' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, MuzzleAudioTails) == 0x0004B8, "Member 'AHLLArmourWeapon::MuzzleAudioTails' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, TriggerSetting) == 0x000508, "Member 'AHLLArmourWeapon::TriggerSetting' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, WeaponVibrationData) == 0x000520, "Member 'AHLLArmourWeapon::WeaponVibrationData' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireVibrationEventControllers) == 0x000528, "Member 'AHLLArmourWeapon::FireVibrationEventControllers' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, LoadVibrationComponent) == 0x000538, "Member 'AHLLArmourWeapon::LoadVibrationComponent' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireSound_PADOVERRIDE) == 0x000548, "Member 'AHLLArmourWeapon::FireSound_PADOVERRIDE' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, LoadSound_PADOVERRIDE) == 0x000550, "Member 'AHLLArmourWeapon::LoadSound_PADOVERRIDE' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon, FireIncrementStat) == 0x000558, "Member 'AHLLArmourWeapon::FireIncrementStat' has a wrong offset!");

// Class HLL.ShooterCharacter
// 0x0FC0 (0x1480 - 0x04C0)
class AShooterCharacter : public ACharacter
{
public:
	uint8                                         Pad_12DC[0x50];                                    // 0x04B8(0x0050)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         FreelookWeaponReturnInterpolationSpeed;            // 0x0508(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeLook_WeaponPitchRange;                         // 0x050C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeLook_MinWeaponPitchAngle;                      // 0x0510(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeLook_MaxWeaponPitchAngle;                      // 0x0514(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeLookPitchAngle;                                // 0x0518(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeLookYawAngle;                                  // 0x051C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeLookRate;                                      // 0x0520(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeLookInterpolationSpeed;                        // 0x0524(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewYaw;                                           // 0x0528(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitch;                                         // 0x052C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Freelook_YawCurve;                                 // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12DD[0x30];                                    // 0x0538(0x0030)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnStartedTargeting;                                // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedTargeting;                               // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFaceAnimComponent*                     FaceAnimComponent;                                 // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        Mesh1PTransform;                                   // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFpsSkeletalMeshComponent*              Mesh_1P;                                           // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkelMeshWithLinkedBoundsComponent*     HeadMesh;                                          // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   Helmet;                                            // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   HelmetAccessory;                                   // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HelmetAttachSocketName;                            // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  ADS_DOF_PostProcess;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClientBotPlayerInputComponent*         M_clientBotPlayerInputComponent;                   // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           DebugInventory;                                    // 0x05D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         LocalDebugInventory;                               // 0x05E0(0x0010)(ZeroConstructor, Transient, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterWeapon*                         CurrentWeapon;                                     // 0x05F0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12DE[0xC];                                     // 0x05F8(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bWantsToRun : 1;                                   // 0x0604(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12DF[0x1B];                                    // 0x0605(0x001B)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundCue*                              RunLoopSound;                                      // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              RunStopSound;                                      // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBeforeRunStopSound;                         // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProneEyeHeight;                                    // 0x0634(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EyeHeightTransitionSpeed;                          // 0x0638(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHeadBobProfileManager                 HeadBobProfileManager;                             // 0x063C(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SprintingStrafeMultipliler;                        // 0x06D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDiveToProneManager                    DiveToProneManager;                                // 0x06D8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EDiveToProneStatus                            DiveToProne_CurrentStatus;                         // 0x0730(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E0[0x4F];                                    // 0x0731(0x004F)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bWasSprintingOnProneInitiated;                     // 0x0780(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDiveToProneDebugOutput;                           // 0x0781(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E1[0x16];                                    // 0x0782(0x0016)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             DiveToProneSound_GroundImpact;                     // 0x0798(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DiveToProneSound_Start;                            // 0x07A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FStepHeightSettings                    StepHeightSettings;                                // 0x07A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E2[0x4];                                     // 0x07F8(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         LocomotionHeadbobbingScale;                        // 0x07FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E3[0xA0];                                    // 0x0800(0x00A0)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AShooterWeapon*>                 Inventory;                                         // 0x08A0(0x0010)(Net, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLInventorySlot                             LastEquippedSlot;                                  // 0x08B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLInventorySlot                             LastEquippedWeaponSlot;                            // 0x08B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E4[0x6];                                     // 0x08B2(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMapComponent*                       MapComponent;                                      // 0x08B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsViewingMap : 1;                                 // 0x08C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12E5[0x7];                                     // 0x08C1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UInputComponent*                        MapModeBlockedInput;                               // 0x08C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E6[0x10];                                    // 0x08D0(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SuppressionRecoveryRate;                           // 0x08E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionLockTimer;                              // 0x08E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSuppression;                                    // 0x08E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E7[0x4];                                     // 0x08EC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     SuppressionBlendable;                              // 0x08F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SuppressionLocalSound;                             // 0x08F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Suppression_SoundCurve;                            // 0x0900(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Suppression_ShakeCurve_Explosion;                  // 0x0908(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Suppression_ShakeCurve_Firearm;                    // 0x0910(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               Suppression_CamShake_Explosion;                    // 0x0918(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               Suppression_CamShake_Firearms;                     // 0x0920(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFrameSuppressionInfo                  ReplicatedSuppressionInfo;                         // 0x0928(0x0008)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E8[0x10];                                    // 0x0930(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInstanceDynamic*               M_PostProcessDMI;                                  // 0x0940(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  PlayerPostProcess;                                 // 0x0948(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        Suppress_Heartbeat;                                // 0x0950(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLUseContext                         UseContext;                                        // 0x0958(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseContextLocked : 1;                             // 0x0964(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseContextActive : 1;                             // 0x0964(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bCanDeployBipod;                                   // 0x0965(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E9[0x2];                                     // 0x0966(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLUseContext                         DeployContext;                                     // 0x0968(0x000C)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             DeploySurface;                                     // 0x0974(0x0088)(Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         SurfaceQueryIndex;                                 // 0x09FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12EA[0x10];                                    // 0x0A00(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterCharacter*                      OnRouteMedic;                                      // 0x0A10(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMedicRequestState                            MedicRequestState;                                 // 0x0A18(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12EB[0x7];                                     // 0x0A19(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnWeaponChangedDelegate;                           // 0x0A20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateChangedDelegate;                            // 0x0A30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12EC[0x4];                                     // 0x0A40(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CriticalTime;                                      // 0x0A44(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldToLetGoTime;                                   // 0x0A48(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxCriticalChances;                                // 0x0A4C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12ED[0x8];                                     // 0x0A50(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         HealthFXInterp_Speed;                              // 0x0A58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12EE[0x4];                                     // 0x0A5C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         HealthPulseSpeedLow;                               // 0x0A60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthPulseSpeedHigh;                              // 0x0A64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplatterLockTime;                                  // 0x0A68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplatterFadeSpeed;                                 // 0x0A6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12EF[0xC];                                     // 0x0A70(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Health;                                            // 0x0A7C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBleeding;                                       // 0x0A80(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F0[0x3];                                     // 0x0A81(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         WoundedBleedTime;                                  // 0x0A84(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WoundedBleedAmount;                                // 0x0A88(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLHealthState                               HealthState;                                       // 0x0A8C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F1[0x3];                                     // 0x0A8D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLHealthDeltaInfo                    LastHealthDeltaInfo;                               // 0x0A90(0x0208)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F2[0x30];                                    // 0x0C98(0x0030)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRepRemoteHealData                     RemoteHealInfo;                                    // 0x0CC8(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UShapeComponent*                        HealingCollisionShape;                             // 0x0CD8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HealingCollisionAttachmentSocket;                  // 0x0CE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AController*>                    HitAssistants;                                     // 0x0CE8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        VoiceAudioComponent;                               // 0x0CF8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        BreathAudioComponent;                              // 0x0D00(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLVoiceData*                          VoiceData;                                         // 0x0D08(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenBreaths;                             // 0x0D10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenVocalisations;                       // 0x0D14(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EHLLDamageType, TSoftObjectPtr<class USoundBase>> DamageSounds;                                      // 0x0D18(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenImpactSounds;                        // 0x0D68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F3[0x10];                                    // 0x0D6C(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         WoundedLoopMinVolume;                              // 0x0D7C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSurfaceSounds                         LandSounds;                                        // 0x0D80(0x0160)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAudioComponent*                        HealthLoopAC;                                      // 0x0EE0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponSway_ProneModifier;                          // 0x0EE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponSway_CrouchedModifier;                       // 0x0EEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponSway_StandingModifier;                       // 0x0EF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponSway_FallingModifier;                        // 0x0EF4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F4[0x40];                                    // 0x0EF8(0x0040)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     HideMeshMaterial;                                  // 0x0F38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F5[0x4];                                     // 0x0F40(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MinTimeBetweenJumps;                               // 0x0F44(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F6[0x10];                                    // 0x0F48(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FKillTimerInfo                         KillTimerInfo;                                     // 0x0F58(0x0008)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         SectorKillTime;                                    // 0x0F60(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         SectorVehicleKillTime;                             // 0x0F61(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         DrownKillTime;                                     // 0x0F62(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F7[0x1];                                     // 0x0F63(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         KillTimer_FXInterpSpeed;                           // 0x0F64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F8[0x4];                                     // 0x0F68(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         TotemPollingRepulsionPower;                        // 0x0F6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F9[0x8];                                     // 0x0F70(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UCurveFloat*                            FallDamageCurve;                                   // 0x0F78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               FallCameraShake;                                   // 0x0F80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               ProneCameraShake;                                  // 0x0F88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               ProneLandedCameraShake;                            // 0x0F90(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               CrouchCameraShake;                                 // 0x0F98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               StandCameraShake;                                  // 0x0FA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               JumpCameraShake;                                   // 0x0FA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               ThrowCameraShake;                                  // 0x0FB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               StartSprintingCameraShake;                         // 0x0FB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               StopSprintingCameraShake;                          // 0x0FC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallShakeUpperSpeedLimit;                          // 0x0FC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinStanceTransitionTime;                           // 0x0FCC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastStanceTransitionTime;                          // 0x0FD0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12FA[0x14];                                    // 0x0FD4(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<ECharacterStance>                      StanceTransitionsToQueueIfFalling;                 // 0x0FE8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             StartCrouchSound;                                  // 0x0FF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             StartUncrouchSound;                                // 0x1000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             StartProneSound;                                   // 0x1008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             StartUnproneSound;                                 // 0x1010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseStanceTransitionQueue;                         // 0x1018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12FB[0x7];                                     // 0x1019(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AHLLSeat*                               CurrentSeat;                                       // 0x1020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRepSeatPendingTransition              RepSeatTransition;                                 // 0x1028(0x0002)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12FC[0x6];                                     // 0x102A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnCharacterSeatChange;                             // 0x1030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12FD[0x18];                                    // 0x1040(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UPostProcessComponent*                  Close_DOF_PostProcess;                             // 0x1058(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12FE[0x8];                                     // 0x1060(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UAudioComponent*                        AC_TurnInPlace;                                    // 0x1068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             TurnInPlaceSound;                                  // 0x1070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             TurnInPlaceStopSound;                              // 0x1078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLGoreComponent*                      GoreComponent;                                     // 0x1080(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12FF[0x80];                                    // 0x1088(0x0080)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DeployCameraBlendSpeed;                            // 0x1108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedScaleFactor_Default;                          // 0x110C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedScaleFactor_Crouched;                         // 0x1110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedScaleFactor_Prone;                            // 0x1114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLFootstepData*                       FootstepData;                                      // 0x1118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1300[0x20];                                    // 0x1120(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         HeadTiltAngle;                                     // 0x1140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TiltBlendSpeed;                                    // 0x1144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1301[0x18];                                    // 0x1148(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRigPivotSettings                      RigPivotSettings;                                  // 0x1160(0x0054)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1302[0x14];                                    // 0x11B4(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ObstacleDistance;                                  // 0x11C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstacleHeight;                                    // 0x11CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVaultingMoveType                             VaultingMoveType;                                  // 0x11D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1303[0x7];                                     // 0x11D1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UVaultingComponent*                     Vaulting;                                          // 0x11D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1304[0x20];                                    // 0x11E0(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class UAudioComponent>         UseContextAC;                                      // 0x1200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseContextACStarted : 1;                          // 0x1208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1305[0x7];                                     // 0x1209(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UInputComponent*                        M_grenadeInput;                                    // 0x1210(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1306[0x8];                                     // 0x1218(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UBurningComponent*                      BurningComponent;                                  // 0x1220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWantsToADS : 1;                                   // 0x1228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsTargeting : 1;                                  // 0x1228(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ETeam                                         M_BackupTeam;                                      // 0x1229(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1307[0xE];                                     // 0x122A(0x000E)(Fixing Size After Last Property [ Dumper-69 ])
	uint32                                        AmmoReplenishStyleOverride;                        // 0x1238(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmmoReplenishAmountOverride;                       // 0x123C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLIndicatorComponent*                 PlayerIndicator;                                   // 0x1240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 MedicIndicator;                                    // 0x1248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 CriticalIndicator;                                 // 0x1250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1308[0xC];                                     // 0x1258(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector_NetQuantize                    RelativeHeadLocation;                              // 0x1264(0x000C)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    RelativeMeshLocation;                              // 0x1270(0x000C)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1309[0x18];                                    // 0x127C(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CameraVerticalMovementSpeed;                       // 0x1294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130A[0x18];                                    // 0x1298(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class AActor*                                 LastDamageCauser;                                  // 0x12B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                LastDamageType;                                    // 0x12B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RagdollBlendAnimPercent;                           // 0x12C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130B[0x4];                                     // 0x12C4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimMontage*                           StandingDeathAnimations;                           // 0x12C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CrouchedDeathAnimations;                           // 0x12D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ProneDeathAnimations;                              // 0x12D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130C[0x8];                                     // 0x12E0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UStaticMesh*                            BackerHelmetMesh;                                  // 0x12E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PreOrderHelmetMesh;                                // 0x12F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             EnterWaterSound;                                   // 0x12F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ExitWaterSound;                                    // 0x1300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSplashZVeloc;                                   // 0x1308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenSplashFX;                            // 0x130C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130D[0x10];                                    // 0x1310(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class ULeaningComponent*                      Leaning;                                           // 0x1320(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowTPPMeshInFPP : 1;                             // 0x1328(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_130E[0x7];                                     // 0x1329(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UShooterCharacterMarkersComponent*      MarkersComponent;                                  // 0x1330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          PronePoseMesh;                                     // 0x1338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          CrouchPoseMesh;                                    // 0x1340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          StandingPoseMesh;                                  // 0x1348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130F[0x58];                                    // 0x1350(0x0058)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MaxAutoRunDoubleTapInterval;                       // 0x13A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1310[0x8];                                     // 0x13AC(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	ECharacterStance                              CharacterStance;                                   // 0x13B4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1311[0x3];                                     // 0x13B5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   FPPCameraBone;                                     // 0x13B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsSpectatorMode : 1;                              // 0x13C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1312[0xF];                                     // 0x13C1(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	class UVibrationEventController*              CrawlVibrationController;                          // 0x13D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              JumpVibrationController;                           // 0x13D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              DamageVibrationController;                         // 0x13E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              CriticalVibrationController;                       // 0x13E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              WoundedVibrationController;                        // 0x13F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             WoundedLoop_PadOverride;                           // 0x13F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class USoundBase*, class USoundBase*>    PadOverrides;                                      // 0x1400(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1313[0x8];                                     // 0x1450(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDisabledInventoryItem                 DisabledInventoryItem;                             // 0x1458(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1314[0x8];                                     // 0x1468(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLWeatherVFXComponent*                WeatherVFXComponent;                               // 0x1470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLWeatherManagerDebugComponent*       WeatherManagerDebugComponent;                      // 0x1478(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeRole(const class FString& RoleName);
	void ClearCloseDOF();
	void ClientMedicResponsePing(const class FString& MedicName, const bool CanMakeIt);
	void CommitSuicide();
	void Debug_RebaseCheck();
	void Debug_TriggerRebase();
	void EquipSlot(EHLLInventorySlot Slot, bool EquipEvenIfRunning, bool EquipEvenIfInputIsDisabled);
	void GamepadDeployMG();
	void GamepadEquipPrimaryMelee_Pressed();
	void GamepadEquipPrimaryMelee_Released();
	void GamepadInventoryRadial_Pressed();
	void GamepadInventoryRadial_Released();
	void GamepadInventoryRadial_TimerComplete();
	void GiveClips(const int32 ClipCount);
	void GiveWeapon(const class FString& WeaponName);
	void HLLOnStateChanged__DelegateSignature(const EHLLHealthState PreviousState, const EHLLHealthState NewState);
	void HLLOnWeaponChanged__DelegateSignature(class AShooterWeapon* LastWeapon, class AShooterWeapon* NewWeapon);
	void KilledBy(class AController* InKiller, const TSubclassOf<class UDamageType> DamageClass, class AActor* Causer);
	void OnCharacterSeatChange__DelegateSignature(const class AShooterCharacter* Character, const class AHLLSeat* Seat);
	void OnFinishedTargeting__DelegateSignature();
	void OnRep_Bleeding();
	void OnRep_CharacterStance(ECharacterStance LastCharacterStance);
	void OnRep_CurrentWeapon(class AShooterWeapon* LastWeapon);
	void OnRep_LastHealthDeltaInfo(const struct FHLLHealthDeltaInfo& PrevInfo);
	void OnRep_RemoteHealInfo();
	void OnRep_SpectatorMode();
	void OnRep_SuppressionInfo(const struct FFrameSuppressionInfo& PreviousValue);
	void OnRouteMedicHealthStateChanged(const EHLLHealthState PreviousState, const EHLLHealthState NewState);
	void OnSeatDestroyed(class AActor* DestroyedActor);
	void OnStartedTargeting__DelegateSignature();
	void OnStopMelee();
	void OnWindowFocusChanged(bool bHasFocus);
	void PrintCollisionDebugInfo();
	void RedeployFast();
	void RestoreHealth(const float Amount, class AController* HealInstigator, class AActor* HealCauser, const bool bAmountIsPercentage);
	void Server_CommitSuicide();
	void Server_RedeployFast();
	void Server_RequestMedic();
	void Server_SetAmmoReplenishOnHeal(const uint8 InAmmoReplishStyle, const float InAmmoReplenishAmount);
	void Server_SetViewingMap(const bool bNewState);
	void Server_TryEnterSeatActor(const class AActor* InSeatActor);
	void Server_UpdateSeatCapsuleOffsets(const struct FNetSeatCapsuleOffsets& NewOffsets);
	void ServerAddWeapon(class AShooterWeapon* Weapon, const int32 InventoryIndex);
	void ServerChangeRole(const struct FLoadout& Loadout, const EPlayerRole PlayerRole);
	void ServerEquipWeapon(class AShooterWeapon* NewWeapon);
	void ServerGiveClips(const int32 ClipCount);
	void ServerGiveWeapon(TSubclassOf<class AShooterWeapon> WeaponClass, const int32 InitialClips, const int32 MaxiumClips);
	void ServerLetGo(const bool bTimedOut);
	void ServerMedicResponsePing(class AShooterCharacter* DownedPlayer, const struct FVector& MarkerLocation, const bool bCanMakeIt);
	void ServerRemoveWeapon(class AShooterWeapon* Weapon);
	void ServerRequestResupply(class UHLLAmmoComponent* InContainer);
	void ServerSetRunning(bool bNewRunning, bool bToggle);
	void ServerSetTargeting(bool bNewTargeting);
	void ServerSetWasRunningWhenProneInitiated(bool bNewWasRunning);
	void ServerStartPlantObjectiveInteraction(class APlantObjectiveArea* ObjectiveArea);
	void ServerStopPlantObjectiveInteraction(class APlantObjectiveArea* ObjectiveArea);
	void ServerTearOff();
	void ServerTryDismantleItem(class UObject* InItem);
	void ServerTryStartDismantle(class UObject* InItem);
	void ServerTryStopDismantle(class UObject* InItem);
	void ServerUpdateRelativeHeadAndMeshLocation(const struct FVector_NetQuantize& InRelativeHeadLocation, const struct FVector_NetQuantize& InRelativeMeshLocation);
	void ServerUpdateRelativeHeadLocation(const struct FVector_NetQuantize& InRelativeHeadLocation);
	void ServerUpdateRelativeMeshLocation(const struct FVector_NetQuantize& InRelativeMeshLocation);
	void SetAmmoReplenishOnHeal(const uint8 InAmmoReplishStyle, const float InAmmoReplenishAmount);
	void SetLocomotionHeadBobbingEnabled(bool bEnabled);
	void SetMovementBlockedByAnimation(bool Blocked);
	void SetWasRunningWhenProneInitiated(bool bNewWasRunning);
	void StartControllerLean(bool bLeanLeft);
	void ToggleCloseDOF(const ECloseDOFFlags Param_Flags, const bool bEnabled);
	void TriggerFootstep(const EFoot Foot, const bool bThirdPerson);
	void UpdateADSBlend(const float NewTime);
	void UpdatePendingSeatTransition();

	class FName AllowDeployWeapon() const;
	class FName AllowUndeployWeapon() const;
	bool CanChangeWeapon() const;
	struct FRotator GetAimOffsets() const;
	ECharacterStance GetCharacterStance() const;
	float GetCriticalTimeRemaining() const;
	float GetCurrentHealth() const;
	class AHLLSeat* GetCurrentSeat() const;
	float GetDismantleItemTime() const;
	float GetDismantleItemTimeRemaining() const;
	bool GetDiveToProneInProgress() const;
	float GetDiveToProneScale(const class UCurveFloat* Curve) const;
	float GetDiveToProneTransitionSpeedScale() const;
	bool GetFloorTransform(struct FTransform* FloorTransform, const bool bDrawDebug) const;
	class USkelMeshWithLinkedBoundsComponent* GetHeadMesh() const;
	EHLLHealthState GetHealthState() const;
	float GetHoldToLetGoTimeRemaining() const;
	void GetInputState(bool* MoveLeftIsPressed, bool* MoveRightIsPressed, bool* MoveForwardIsPressed, bool* MoveBackwardsIsPressed) const;
	int32 GetInventoryCount() const;
	bool GetLocomotionHeadBobbingEnabled() const;
	class USkeletalMeshComponent* GetMesh1P() const;
	EPlayerRole GetPlayerRole() const;
	ECharacterStance GetPreviousCharacterStance() const;
	float GetResupplyTime() const;
	float GetResupplyTimeRemaining() const;
	class UVaultingComponent* GetVaultingComponent() const;
	class AShooterWeapon* GetWeapon() const;
	EWeaponType GetWeaponType() const;
	class UHLLWeatherManagerDebugComponent* GetWeatherManagerDebugComponent() const;
	class UHLLWeatherVFXComponent* GetWeatherVFXComponent() const;
	bool IsBoltCycleInProgress() const;
	bool IsFiring() const;
	bool IsFirstPerson() const;
	bool IsInReinforcedSector() const;
	bool IsInScope() const;
	bool IsMissingHealth() const;
	bool IsProne() const;
	bool IsReplayingMoves() const;
	bool IsResupplying() const;
	bool IsRunning(const bool bCheckMaxSpeed) const;
	bool IsSeated() const;
	bool IsSteadyingAim() const;
	bool IsTargeting() const;
	bool IsWeaponDeployed() const;
	bool WantsToRun() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCharacter">();
	}
	static class AShooterCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterCharacter>();
	}
};
static_assert(alignof(AShooterCharacter) == 0x000010, "Wrong alignment on AShooterCharacter");
static_assert(sizeof(AShooterCharacter) == 0x001480, "Wrong size on AShooterCharacter");
static_assert(offsetof(AShooterCharacter, FreelookWeaponReturnInterpolationSpeed) == 0x000508, "Member 'AShooterCharacter::FreelookWeaponReturnInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FreeLook_WeaponPitchRange) == 0x00050C, "Member 'AShooterCharacter::FreeLook_WeaponPitchRange' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FreeLook_MinWeaponPitchAngle) == 0x000510, "Member 'AShooterCharacter::FreeLook_MinWeaponPitchAngle' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FreeLook_MaxWeaponPitchAngle) == 0x000514, "Member 'AShooterCharacter::FreeLook_MaxWeaponPitchAngle' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FreeLookPitchAngle) == 0x000518, "Member 'AShooterCharacter::FreeLookPitchAngle' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FreeLookYawAngle) == 0x00051C, "Member 'AShooterCharacter::FreeLookYawAngle' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FreeLookRate) == 0x000520, "Member 'AShooterCharacter::FreeLookRate' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FreeLookInterpolationSpeed) == 0x000524, "Member 'AShooterCharacter::FreeLookInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ViewYaw) == 0x000528, "Member 'AShooterCharacter::ViewYaw' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ViewPitch) == 0x00052C, "Member 'AShooterCharacter::ViewPitch' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Freelook_YawCurve) == 0x000530, "Member 'AShooterCharacter::Freelook_YawCurve' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, OnStartedTargeting) == 0x000568, "Member 'AShooterCharacter::OnStartedTargeting' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, OnFinishedTargeting) == 0x000578, "Member 'AShooterCharacter::OnFinishedTargeting' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FaceAnimComponent) == 0x000588, "Member 'AShooterCharacter::FaceAnimComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Mesh1PTransform) == 0x000590, "Member 'AShooterCharacter::Mesh1PTransform' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Mesh_1P) == 0x000598, "Member 'AShooterCharacter::Mesh_1P' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HeadMesh) == 0x0005A0, "Member 'AShooterCharacter::HeadMesh' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Helmet) == 0x0005A8, "Member 'AShooterCharacter::Helmet' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HelmetAccessory) == 0x0005B0, "Member 'AShooterCharacter::HelmetAccessory' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HelmetAttachSocketName) == 0x0005B8, "Member 'AShooterCharacter::HelmetAttachSocketName' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ADS_DOF_PostProcess) == 0x0005C0, "Member 'AShooterCharacter::ADS_DOF_PostProcess' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, M_clientBotPlayerInputComponent) == 0x0005C8, "Member 'AShooterCharacter::M_clientBotPlayerInputComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DebugInventory) == 0x0005D0, "Member 'AShooterCharacter::DebugInventory' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LocalDebugInventory) == 0x0005E0, "Member 'AShooterCharacter::LocalDebugInventory' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CurrentWeapon) == 0x0005F0, "Member 'AShooterCharacter::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RunLoopSound) == 0x000620, "Member 'AShooterCharacter::RunLoopSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RunStopSound) == 0x000628, "Member 'AShooterCharacter::RunStopSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MinTimeBeforeRunStopSound) == 0x000630, "Member 'AShooterCharacter::MinTimeBeforeRunStopSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ProneEyeHeight) == 0x000634, "Member 'AShooterCharacter::ProneEyeHeight' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, EyeHeightTransitionSpeed) == 0x000638, "Member 'AShooterCharacter::EyeHeightTransitionSpeed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HeadBobProfileManager) == 0x00063C, "Member 'AShooterCharacter::HeadBobProfileManager' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SprintingStrafeMultipliler) == 0x0006D4, "Member 'AShooterCharacter::SprintingStrafeMultipliler' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DiveToProneManager) == 0x0006D8, "Member 'AShooterCharacter::DiveToProneManager' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DiveToProne_CurrentStatus) == 0x000730, "Member 'AShooterCharacter::DiveToProne_CurrentStatus' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, bWasSprintingOnProneInitiated) == 0x000780, "Member 'AShooterCharacter::bWasSprintingOnProneInitiated' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, bDiveToProneDebugOutput) == 0x000781, "Member 'AShooterCharacter::bDiveToProneDebugOutput' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DiveToProneSound_GroundImpact) == 0x000798, "Member 'AShooterCharacter::DiveToProneSound_GroundImpact' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DiveToProneSound_Start) == 0x0007A0, "Member 'AShooterCharacter::DiveToProneSound_Start' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StepHeightSettings) == 0x0007A8, "Member 'AShooterCharacter::StepHeightSettings' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LocomotionHeadbobbingScale) == 0x0007FC, "Member 'AShooterCharacter::LocomotionHeadbobbingScale' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Inventory) == 0x0008A0, "Member 'AShooterCharacter::Inventory' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LastEquippedSlot) == 0x0008B0, "Member 'AShooterCharacter::LastEquippedSlot' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LastEquippedWeaponSlot) == 0x0008B1, "Member 'AShooterCharacter::LastEquippedWeaponSlot' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MapComponent) == 0x0008B8, "Member 'AShooterCharacter::MapComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MapModeBlockedInput) == 0x0008C8, "Member 'AShooterCharacter::MapModeBlockedInput' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SuppressionRecoveryRate) == 0x0008E0, "Member 'AShooterCharacter::SuppressionRecoveryRate' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SuppressionLockTimer) == 0x0008E4, "Member 'AShooterCharacter::SuppressionLockTimer' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MaxSuppression) == 0x0008E8, "Member 'AShooterCharacter::MaxSuppression' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SuppressionBlendable) == 0x0008F0, "Member 'AShooterCharacter::SuppressionBlendable' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SuppressionLocalSound) == 0x0008F8, "Member 'AShooterCharacter::SuppressionLocalSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Suppression_SoundCurve) == 0x000900, "Member 'AShooterCharacter::Suppression_SoundCurve' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Suppression_ShakeCurve_Explosion) == 0x000908, "Member 'AShooterCharacter::Suppression_ShakeCurve_Explosion' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Suppression_ShakeCurve_Firearm) == 0x000910, "Member 'AShooterCharacter::Suppression_ShakeCurve_Firearm' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Suppression_CamShake_Explosion) == 0x000918, "Member 'AShooterCharacter::Suppression_CamShake_Explosion' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Suppression_CamShake_Firearms) == 0x000920, "Member 'AShooterCharacter::Suppression_CamShake_Firearms' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ReplicatedSuppressionInfo) == 0x000928, "Member 'AShooterCharacter::ReplicatedSuppressionInfo' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, M_PostProcessDMI) == 0x000940, "Member 'AShooterCharacter::M_PostProcessDMI' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, PlayerPostProcess) == 0x000948, "Member 'AShooterCharacter::PlayerPostProcess' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Suppress_Heartbeat) == 0x000950, "Member 'AShooterCharacter::Suppress_Heartbeat' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, UseContext) == 0x000958, "Member 'AShooterCharacter::UseContext' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, bCanDeployBipod) == 0x000965, "Member 'AShooterCharacter::bCanDeployBipod' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DeployContext) == 0x000968, "Member 'AShooterCharacter::DeployContext' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DeploySurface) == 0x000974, "Member 'AShooterCharacter::DeploySurface' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SurfaceQueryIndex) == 0x0009FC, "Member 'AShooterCharacter::SurfaceQueryIndex' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, OnRouteMedic) == 0x000A10, "Member 'AShooterCharacter::OnRouteMedic' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MedicRequestState) == 0x000A18, "Member 'AShooterCharacter::MedicRequestState' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, OnWeaponChangedDelegate) == 0x000A20, "Member 'AShooterCharacter::OnWeaponChangedDelegate' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, OnStateChangedDelegate) == 0x000A30, "Member 'AShooterCharacter::OnStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CriticalTime) == 0x000A44, "Member 'AShooterCharacter::CriticalTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HoldToLetGoTime) == 0x000A48, "Member 'AShooterCharacter::HoldToLetGoTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MaxCriticalChances) == 0x000A4C, "Member 'AShooterCharacter::MaxCriticalChances' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HealthFXInterp_Speed) == 0x000A58, "Member 'AShooterCharacter::HealthFXInterp_Speed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HealthPulseSpeedLow) == 0x000A60, "Member 'AShooterCharacter::HealthPulseSpeedLow' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HealthPulseSpeedHigh) == 0x000A64, "Member 'AShooterCharacter::HealthPulseSpeedHigh' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SplatterLockTime) == 0x000A68, "Member 'AShooterCharacter::SplatterLockTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SplatterFadeSpeed) == 0x000A6C, "Member 'AShooterCharacter::SplatterFadeSpeed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Health) == 0x000A7C, "Member 'AShooterCharacter::Health' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, bIsBleeding) == 0x000A80, "Member 'AShooterCharacter::bIsBleeding' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WoundedBleedTime) == 0x000A84, "Member 'AShooterCharacter::WoundedBleedTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WoundedBleedAmount) == 0x000A88, "Member 'AShooterCharacter::WoundedBleedAmount' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HealthState) == 0x000A8C, "Member 'AShooterCharacter::HealthState' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LastHealthDeltaInfo) == 0x000A90, "Member 'AShooterCharacter::LastHealthDeltaInfo' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RemoteHealInfo) == 0x000CC8, "Member 'AShooterCharacter::RemoteHealInfo' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HealingCollisionShape) == 0x000CD8, "Member 'AShooterCharacter::HealingCollisionShape' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HealingCollisionAttachmentSocket) == 0x000CE0, "Member 'AShooterCharacter::HealingCollisionAttachmentSocket' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HitAssistants) == 0x000CE8, "Member 'AShooterCharacter::HitAssistants' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, VoiceAudioComponent) == 0x000CF8, "Member 'AShooterCharacter::VoiceAudioComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, BreathAudioComponent) == 0x000D00, "Member 'AShooterCharacter::BreathAudioComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, VoiceData) == 0x000D08, "Member 'AShooterCharacter::VoiceData' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MinTimeBetweenBreaths) == 0x000D10, "Member 'AShooterCharacter::MinTimeBetweenBreaths' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MinTimeBetweenVocalisations) == 0x000D14, "Member 'AShooterCharacter::MinTimeBetweenVocalisations' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DamageSounds) == 0x000D18, "Member 'AShooterCharacter::DamageSounds' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MinTimeBetweenImpactSounds) == 0x000D68, "Member 'AShooterCharacter::MinTimeBetweenImpactSounds' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WoundedLoopMinVolume) == 0x000D7C, "Member 'AShooterCharacter::WoundedLoopMinVolume' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LandSounds) == 0x000D80, "Member 'AShooterCharacter::LandSounds' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HealthLoopAC) == 0x000EE0, "Member 'AShooterCharacter::HealthLoopAC' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WeaponSway_ProneModifier) == 0x000EE8, "Member 'AShooterCharacter::WeaponSway_ProneModifier' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WeaponSway_CrouchedModifier) == 0x000EEC, "Member 'AShooterCharacter::WeaponSway_CrouchedModifier' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WeaponSway_StandingModifier) == 0x000EF0, "Member 'AShooterCharacter::WeaponSway_StandingModifier' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WeaponSway_FallingModifier) == 0x000EF4, "Member 'AShooterCharacter::WeaponSway_FallingModifier' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HideMeshMaterial) == 0x000F38, "Member 'AShooterCharacter::HideMeshMaterial' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MinTimeBetweenJumps) == 0x000F44, "Member 'AShooterCharacter::MinTimeBetweenJumps' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, KillTimerInfo) == 0x000F58, "Member 'AShooterCharacter::KillTimerInfo' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SectorKillTime) == 0x000F60, "Member 'AShooterCharacter::SectorKillTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SectorVehicleKillTime) == 0x000F61, "Member 'AShooterCharacter::SectorVehicleKillTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DrownKillTime) == 0x000F62, "Member 'AShooterCharacter::DrownKillTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, KillTimer_FXInterpSpeed) == 0x000F64, "Member 'AShooterCharacter::KillTimer_FXInterpSpeed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, TotemPollingRepulsionPower) == 0x000F6C, "Member 'AShooterCharacter::TotemPollingRepulsionPower' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FallDamageCurve) == 0x000F78, "Member 'AShooterCharacter::FallDamageCurve' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FallCameraShake) == 0x000F80, "Member 'AShooterCharacter::FallCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ProneCameraShake) == 0x000F88, "Member 'AShooterCharacter::ProneCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ProneLandedCameraShake) == 0x000F90, "Member 'AShooterCharacter::ProneLandedCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CrouchCameraShake) == 0x000F98, "Member 'AShooterCharacter::CrouchCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StandCameraShake) == 0x000FA0, "Member 'AShooterCharacter::StandCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, JumpCameraShake) == 0x000FA8, "Member 'AShooterCharacter::JumpCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ThrowCameraShake) == 0x000FB0, "Member 'AShooterCharacter::ThrowCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StartSprintingCameraShake) == 0x000FB8, "Member 'AShooterCharacter::StartSprintingCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StopSprintingCameraShake) == 0x000FC0, "Member 'AShooterCharacter::StopSprintingCameraShake' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FallShakeUpperSpeedLimit) == 0x000FC8, "Member 'AShooterCharacter::FallShakeUpperSpeedLimit' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MinStanceTransitionTime) == 0x000FCC, "Member 'AShooterCharacter::MinStanceTransitionTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LastStanceTransitionTime) == 0x000FD0, "Member 'AShooterCharacter::LastStanceTransitionTime' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StanceTransitionsToQueueIfFalling) == 0x000FE8, "Member 'AShooterCharacter::StanceTransitionsToQueueIfFalling' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StartCrouchSound) == 0x000FF8, "Member 'AShooterCharacter::StartCrouchSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StartUncrouchSound) == 0x001000, "Member 'AShooterCharacter::StartUncrouchSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StartProneSound) == 0x001008, "Member 'AShooterCharacter::StartProneSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StartUnproneSound) == 0x001010, "Member 'AShooterCharacter::StartUnproneSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, bUseStanceTransitionQueue) == 0x001018, "Member 'AShooterCharacter::bUseStanceTransitionQueue' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CurrentSeat) == 0x001020, "Member 'AShooterCharacter::CurrentSeat' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RepSeatTransition) == 0x001028, "Member 'AShooterCharacter::RepSeatTransition' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, OnCharacterSeatChange) == 0x001030, "Member 'AShooterCharacter::OnCharacterSeatChange' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Close_DOF_PostProcess) == 0x001058, "Member 'AShooterCharacter::Close_DOF_PostProcess' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, AC_TurnInPlace) == 0x001068, "Member 'AShooterCharacter::AC_TurnInPlace' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, TurnInPlaceSound) == 0x001070, "Member 'AShooterCharacter::TurnInPlaceSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, TurnInPlaceStopSound) == 0x001078, "Member 'AShooterCharacter::TurnInPlaceStopSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, GoreComponent) == 0x001080, "Member 'AShooterCharacter::GoreComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DeployCameraBlendSpeed) == 0x001108, "Member 'AShooterCharacter::DeployCameraBlendSpeed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SpeedScaleFactor_Default) == 0x00110C, "Member 'AShooterCharacter::SpeedScaleFactor_Default' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SpeedScaleFactor_Crouched) == 0x001110, "Member 'AShooterCharacter::SpeedScaleFactor_Crouched' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, SpeedScaleFactor_Prone) == 0x001114, "Member 'AShooterCharacter::SpeedScaleFactor_Prone' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FootstepData) == 0x001118, "Member 'AShooterCharacter::FootstepData' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, HeadTiltAngle) == 0x001140, "Member 'AShooterCharacter::HeadTiltAngle' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, TiltBlendSpeed) == 0x001144, "Member 'AShooterCharacter::TiltBlendSpeed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RigPivotSettings) == 0x001160, "Member 'AShooterCharacter::RigPivotSettings' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ObstacleDistance) == 0x0011C8, "Member 'AShooterCharacter::ObstacleDistance' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ObstacleHeight) == 0x0011CC, "Member 'AShooterCharacter::ObstacleHeight' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, VaultingMoveType) == 0x0011D0, "Member 'AShooterCharacter::VaultingMoveType' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Vaulting) == 0x0011D8, "Member 'AShooterCharacter::Vaulting' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, UseContextAC) == 0x001200, "Member 'AShooterCharacter::UseContextAC' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, M_grenadeInput) == 0x001210, "Member 'AShooterCharacter::M_grenadeInput' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, BurningComponent) == 0x001220, "Member 'AShooterCharacter::BurningComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, M_BackupTeam) == 0x001229, "Member 'AShooterCharacter::M_BackupTeam' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, AmmoReplenishStyleOverride) == 0x001238, "Member 'AShooterCharacter::AmmoReplenishStyleOverride' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, AmmoReplenishAmountOverride) == 0x00123C, "Member 'AShooterCharacter::AmmoReplenishAmountOverride' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, PlayerIndicator) == 0x001240, "Member 'AShooterCharacter::PlayerIndicator' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MedicIndicator) == 0x001248, "Member 'AShooterCharacter::MedicIndicator' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CriticalIndicator) == 0x001250, "Member 'AShooterCharacter::CriticalIndicator' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RelativeHeadLocation) == 0x001264, "Member 'AShooterCharacter::RelativeHeadLocation' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RelativeMeshLocation) == 0x001270, "Member 'AShooterCharacter::RelativeMeshLocation' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CameraVerticalMovementSpeed) == 0x001294, "Member 'AShooterCharacter::CameraVerticalMovementSpeed' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LastDamageCauser) == 0x0012B0, "Member 'AShooterCharacter::LastDamageCauser' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, LastDamageType) == 0x0012B8, "Member 'AShooterCharacter::LastDamageType' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, RagdollBlendAnimPercent) == 0x0012C0, "Member 'AShooterCharacter::RagdollBlendAnimPercent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StandingDeathAnimations) == 0x0012C8, "Member 'AShooterCharacter::StandingDeathAnimations' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CrouchedDeathAnimations) == 0x0012D0, "Member 'AShooterCharacter::CrouchedDeathAnimations' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ProneDeathAnimations) == 0x0012D8, "Member 'AShooterCharacter::ProneDeathAnimations' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, BackerHelmetMesh) == 0x0012E8, "Member 'AShooterCharacter::BackerHelmetMesh' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, PreOrderHelmetMesh) == 0x0012F0, "Member 'AShooterCharacter::PreOrderHelmetMesh' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, EnterWaterSound) == 0x0012F8, "Member 'AShooterCharacter::EnterWaterSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, ExitWaterSound) == 0x001300, "Member 'AShooterCharacter::ExitWaterSound' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MinSplashZVeloc) == 0x001308, "Member 'AShooterCharacter::MinSplashZVeloc' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MinTimeBetweenSplashFX) == 0x00130C, "Member 'AShooterCharacter::MinTimeBetweenSplashFX' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, Leaning) == 0x001320, "Member 'AShooterCharacter::Leaning' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MarkersComponent) == 0x001330, "Member 'AShooterCharacter::MarkersComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, PronePoseMesh) == 0x001338, "Member 'AShooterCharacter::PronePoseMesh' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CrouchPoseMesh) == 0x001340, "Member 'AShooterCharacter::CrouchPoseMesh' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, StandingPoseMesh) == 0x001348, "Member 'AShooterCharacter::StandingPoseMesh' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, MaxAutoRunDoubleTapInterval) == 0x0013A8, "Member 'AShooterCharacter::MaxAutoRunDoubleTapInterval' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CharacterStance) == 0x0013B4, "Member 'AShooterCharacter::CharacterStance' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, FPPCameraBone) == 0x0013B8, "Member 'AShooterCharacter::FPPCameraBone' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CrawlVibrationController) == 0x0013D0, "Member 'AShooterCharacter::CrawlVibrationController' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, JumpVibrationController) == 0x0013D8, "Member 'AShooterCharacter::JumpVibrationController' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DamageVibrationController) == 0x0013E0, "Member 'AShooterCharacter::DamageVibrationController' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, CriticalVibrationController) == 0x0013E8, "Member 'AShooterCharacter::CriticalVibrationController' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WoundedVibrationController) == 0x0013F0, "Member 'AShooterCharacter::WoundedVibrationController' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WoundedLoop_PadOverride) == 0x0013F8, "Member 'AShooterCharacter::WoundedLoop_PadOverride' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, PadOverrides) == 0x001400, "Member 'AShooterCharacter::PadOverrides' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, DisabledInventoryItem) == 0x001458, "Member 'AShooterCharacter::DisabledInventoryItem' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WeatherVFXComponent) == 0x001470, "Member 'AShooterCharacter::WeatherVFXComponent' has a wrong offset!");
static_assert(offsetof(AShooterCharacter, WeatherManagerDebugComponent) == 0x001478, "Member 'AShooterCharacter::WeatherManagerDebugComponent' has a wrong offset!");

// Class HLL.ShooterBot
// 0x0010 (0x1490 - 0x1480)
class AShooterBot final : public AShooterCharacter
{
public:
	class UBehaviorTree*                          BotBehavior;                                       // 0x1480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131F[0x8];                                     // 0x1488(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterBot">();
	}
	static class AShooterBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterBot>();
	}
};
static_assert(alignof(AShooterBot) == 0x000010, "Wrong alignment on AShooterBot");
static_assert(sizeof(AShooterBot) == 0x001490, "Wrong size on AShooterBot");
static_assert(offsetof(AShooterBot, BotBehavior) == 0x001480, "Member 'AShooterBot::BotBehavior' has a wrong offset!");

// Class HLL.HLLArmourWeaponMuzzleOcclusionComponent
// 0x0020 (0x00D0 - 0x00B0)
class UHLLArmourWeaponMuzzleOcclusionComponent final : public UActorComponent
{
public:
	class FName                                   TurretBoneName;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1320[0x10];                                    // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class AHLLArmourWeapon*                       Weapon;                                            // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeaponMuzzleOcclusionComponent">();
	}
	static class UHLLArmourWeaponMuzzleOcclusionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLArmourWeaponMuzzleOcclusionComponent>();
	}
};
static_assert(alignof(UHLLArmourWeaponMuzzleOcclusionComponent) == 0x000008, "Wrong alignment on UHLLArmourWeaponMuzzleOcclusionComponent");
static_assert(sizeof(UHLLArmourWeaponMuzzleOcclusionComponent) == 0x0000D0, "Wrong size on UHLLArmourWeaponMuzzleOcclusionComponent");
static_assert(offsetof(UHLLArmourWeaponMuzzleOcclusionComponent, TurretBoneName) == 0x0000B0, "Member 'UHLLArmourWeaponMuzzleOcclusionComponent::TurretBoneName' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponMuzzleOcclusionComponent, Weapon) == 0x0000C8, "Member 'UHLLArmourWeaponMuzzleOcclusionComponent::Weapon' has a wrong offset!");

// Class HLL.HLLMapData_Player_Replicator
// 0x0148 (0x0368 - 0x0220)
class AHLLMapData_Player_Replicator : public AInfo
{
public:
	uint8                                         Pad_1321[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AHLLMapData_Player>         DataClass;                                         // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMapDataPlayerArray                    Data;                                              // 0x0230(0x0120)(Net, Protected, NativeAccessSpecifierProtected)
	TArray<class AHLLMapData_Player*>             MapDataPlayerArray;                                // 0x0350(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1322[0x8];                                     // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Player_Replicator">();
	}
	static class AHLLMapData_Player_Replicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Player_Replicator>();
	}
};
static_assert(alignof(AHLLMapData_Player_Replicator) == 0x000008, "Wrong alignment on AHLLMapData_Player_Replicator");
static_assert(sizeof(AHLLMapData_Player_Replicator) == 0x000368, "Wrong size on AHLLMapData_Player_Replicator");
static_assert(offsetof(AHLLMapData_Player_Replicator, DataClass) == 0x000228, "Member 'AHLLMapData_Player_Replicator::DataClass' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Player_Replicator, Data) == 0x000230, "Member 'AHLLMapData_Player_Replicator::Data' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Player_Replicator, MapDataPlayerArray) == 0x000350, "Member 'AHLLMapData_Player_Replicator::MapDataPlayerArray' has a wrong offset!");

// Class HLL.HLLArmourWeaponUI
// 0x0078 (0x02A8 - 0x0230)
class UHLLArmourWeaponUI : public UUserWidget
{
public:
	class AHLLArmourWeapon*                       AssignedWeapon;                                    // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLArmourWeaponUI_AmmoItem> AmmoItemWidget;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLArmourWeaponUI_AmmoItem*>    ActiveAmmoItems;                                   // 0x0240(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 WeaponIcon;                                        // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponNameText;                                    // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponHeaderText;                                  // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           LoadProgress;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                SingleAmmoContainer;                               // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AmmoClip;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AmmoClips;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AmmoState;                                         // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MunitionsCost;                                     // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        MunitionsSwitcher;                                 // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           MultiAmmoContainer;                                // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeaponUI">();
	}
	static class UHLLArmourWeaponUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLArmourWeaponUI>();
	}
};
static_assert(alignof(UHLLArmourWeaponUI) == 0x000008, "Wrong alignment on UHLLArmourWeaponUI");
static_assert(sizeof(UHLLArmourWeaponUI) == 0x0002A8, "Wrong size on UHLLArmourWeaponUI");
static_assert(offsetof(UHLLArmourWeaponUI, AssignedWeapon) == 0x000230, "Member 'UHLLArmourWeaponUI::AssignedWeapon' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, AmmoItemWidget) == 0x000238, "Member 'UHLLArmourWeaponUI::AmmoItemWidget' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, ActiveAmmoItems) == 0x000240, "Member 'UHLLArmourWeaponUI::ActiveAmmoItems' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, WeaponIcon) == 0x000250, "Member 'UHLLArmourWeaponUI::WeaponIcon' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, WeaponNameText) == 0x000258, "Member 'UHLLArmourWeaponUI::WeaponNameText' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, WeaponHeaderText) == 0x000260, "Member 'UHLLArmourWeaponUI::WeaponHeaderText' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, LoadProgress) == 0x000268, "Member 'UHLLArmourWeaponUI::LoadProgress' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, SingleAmmoContainer) == 0x000270, "Member 'UHLLArmourWeaponUI::SingleAmmoContainer' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, AmmoClip) == 0x000278, "Member 'UHLLArmourWeaponUI::AmmoClip' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, AmmoClips) == 0x000280, "Member 'UHLLArmourWeaponUI::AmmoClips' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, AmmoState) == 0x000288, "Member 'UHLLArmourWeaponUI::AmmoState' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, MunitionsCost) == 0x000290, "Member 'UHLLArmourWeaponUI::MunitionsCost' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, MunitionsSwitcher) == 0x000298, "Member 'UHLLArmourWeaponUI::MunitionsSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI, MultiAmmoContainer) == 0x0002A0, "Member 'UHLLArmourWeaponUI::MultiAmmoContainer' has a wrong offset!");

// Class HLL.HLLDrownDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLDrownDamage : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDrownDamage">();
	}
	static class UHLLDrownDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDrownDamage>();
	}
};
static_assert(alignof(UHLLDrownDamage) == 0x000008, "Wrong alignment on UHLLDrownDamage");
static_assert(sizeof(UHLLDrownDamage) == 0x0001E8, "Wrong size on UHLLDrownDamage");

// Class HLL.HLLArmourWeaponUI_AmmoItem
// 0x0050 (0x0280 - 0x0230)
class UHLLArmourWeaponUI_AmmoItem : public UUserWidget
{
public:
	class UHLLArmourWeaponUI*                     OwningPanel;                                       // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AmmoIndex;                                         // 0x0238(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1323[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLKeyText*                            SelectKeyText;                                     // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                SelectionBorder;                                   // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AmmoName;                                          // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AmmoIcon;                                          // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AmmoClip;                                          // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AmmoClips;                                         // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MunitionsCost;                                     // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        MunitionsSwitcher;                                 // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeaponUI_AmmoItem">();
	}
	static class UHLLArmourWeaponUI_AmmoItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLArmourWeaponUI_AmmoItem>();
	}
};
static_assert(alignof(UHLLArmourWeaponUI_AmmoItem) == 0x000008, "Wrong alignment on UHLLArmourWeaponUI_AmmoItem");
static_assert(sizeof(UHLLArmourWeaponUI_AmmoItem) == 0x000280, "Wrong size on UHLLArmourWeaponUI_AmmoItem");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, OwningPanel) == 0x000230, "Member 'UHLLArmourWeaponUI_AmmoItem::OwningPanel' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, AmmoIndex) == 0x000238, "Member 'UHLLArmourWeaponUI_AmmoItem::AmmoIndex' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, SelectKeyText) == 0x000240, "Member 'UHLLArmourWeaponUI_AmmoItem::SelectKeyText' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, SelectionBorder) == 0x000248, "Member 'UHLLArmourWeaponUI_AmmoItem::SelectionBorder' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, AmmoName) == 0x000250, "Member 'UHLLArmourWeaponUI_AmmoItem::AmmoName' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, AmmoIcon) == 0x000258, "Member 'UHLLArmourWeaponUI_AmmoItem::AmmoIcon' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, AmmoClip) == 0x000260, "Member 'UHLLArmourWeaponUI_AmmoItem::AmmoClip' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, AmmoClips) == 0x000268, "Member 'UHLLArmourWeaponUI_AmmoItem::AmmoClips' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, MunitionsCost) == 0x000270, "Member 'UHLLArmourWeaponUI_AmmoItem::MunitionsCost' has a wrong offset!");
static_assert(offsetof(UHLLArmourWeaponUI_AmmoItem, MunitionsSwitcher) == 0x000278, "Member 'UHLLArmourWeaponUI_AmmoItem::MunitionsSwitcher' has a wrong offset!");

// Class HLL.HLLArmourWeapon_Ballistic
// 0x0040 (0x05A0 - 0x0560)
class AHLLArmourWeapon_Ballistic final : public AHLLArmourWeapon
{
public:
	TArray<struct FZeroAngle>                     ZeroAngles;                                        // 0x0560(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ZeroAngleIndex;                                    // 0x0570(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBallisticShotID                       WeaponSeed;                                        // 0x0571(0x0001)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1324[0x2];                                     // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRepShot                               RepShot;                                           // 0x0574(0x001C)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ShotSpread;                                        // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1325[0x4];                                     // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLBallisticsComponent_Vehicle*        BallisticHandler;                                  // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_RepShot();
	void OnRep_WeaponSeed();
	void Server_AckBatchedNullHits(const struct FBallisticBatchedNulls& BatchedNulls);
	void Server_AckNullHit(const struct FBallisticShotID& ShotID);
	void Server_FireWeapon(const struct FBallisticShotID& FinalShotID, const struct FVector_NetQuantize& ClientBasePos, const struct FVector_NetQuantizeNormal& ClientBaseDir);
	void Server_VerifyBatchedHits(const struct FBallisticBatchedHits& BatchedHits);
	void Server_VerifyHitCharacter(const struct FBallisticHit_Character& HitData);
	void Server_VerifyHitGeneric(const struct FBallisticHit_Generic& HitData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeapon_Ballistic">();
	}
	static class AHLLArmourWeapon_Ballistic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArmourWeapon_Ballistic>();
	}
};
static_assert(alignof(AHLLArmourWeapon_Ballistic) == 0x000008, "Wrong alignment on AHLLArmourWeapon_Ballistic");
static_assert(sizeof(AHLLArmourWeapon_Ballistic) == 0x0005A0, "Wrong size on AHLLArmourWeapon_Ballistic");
static_assert(offsetof(AHLLArmourWeapon_Ballistic, ZeroAngles) == 0x000560, "Member 'AHLLArmourWeapon_Ballistic::ZeroAngles' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_Ballistic, ZeroAngleIndex) == 0x000570, "Member 'AHLLArmourWeapon_Ballistic::ZeroAngleIndex' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_Ballistic, WeaponSeed) == 0x000571, "Member 'AHLLArmourWeapon_Ballistic::WeaponSeed' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_Ballistic, RepShot) == 0x000574, "Member 'AHLLArmourWeapon_Ballistic::RepShot' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_Ballistic, ShotSpread) == 0x000590, "Member 'AHLLArmourWeapon_Ballistic::ShotSpread' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_Ballistic, BallisticHandler) == 0x000598, "Member 'AHLLArmourWeapon_Ballistic::BallisticHandler' has a wrong offset!");

// Class HLL.HLLGhostAbilitySafezone
// 0x0010 (0x0230 - 0x0220)
class AHLLGhostAbilitySafezone final : public AActor
{
public:
	class USceneComponent*                        DummyRoot;                                         // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGhostAbilitySafezone">();
	}
	static class AHLLGhostAbilitySafezone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLGhostAbilitySafezone>();
	}
};
static_assert(alignof(AHLLGhostAbilitySafezone) == 0x000008, "Wrong alignment on AHLLGhostAbilitySafezone");
static_assert(sizeof(AHLLGhostAbilitySafezone) == 0x000230, "Wrong size on AHLLGhostAbilitySafezone");
static_assert(offsetof(AHLLGhostAbilitySafezone, DummyRoot) == 0x000220, "Member 'AHLLGhostAbilitySafezone::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLGhostAbilitySafezone, Mesh) == 0x000228, "Member 'AHLLGhostAbilitySafezone::Mesh' has a wrong offset!");

// Class HLL.RCONMessageEncryption
// 0x0000 (0x0028 - 0x0028)
class URCONMessageEncryption final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONMessageEncryption">();
	}
	static class URCONMessageEncryption* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONMessageEncryption>();
	}
};
static_assert(alignof(URCONMessageEncryption) == 0x000008, "Wrong alignment on URCONMessageEncryption");
static_assert(sizeof(URCONMessageEncryption) == 0x000028, "Wrong size on URCONMessageEncryption");

// Class HLL.HLLArmourWeapon_Howitzer
// 0x0020 (0x0580 - 0x0560)
class AHLLArmourWeapon_Howitzer final : public AHLLArmourWeapon
{
public:
	TArray<TSubclassOf<class AHLLHowitzerShell>>  Shells;                                            // 0x0560(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinMaxRange;                                       // 0x0570(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinMaxDispersion;                                  // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Server_FireHowitzer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeapon_Howitzer">();
	}
	static class AHLLArmourWeapon_Howitzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArmourWeapon_Howitzer>();
	}
};
static_assert(alignof(AHLLArmourWeapon_Howitzer) == 0x000008, "Wrong alignment on AHLLArmourWeapon_Howitzer");
static_assert(sizeof(AHLLArmourWeapon_Howitzer) == 0x000580, "Wrong size on AHLLArmourWeapon_Howitzer");
static_assert(offsetof(AHLLArmourWeapon_Howitzer, Shells) == 0x000560, "Member 'AHLLArmourWeapon_Howitzer::Shells' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_Howitzer, MinMaxRange) == 0x000570, "Member 'AHLLArmourWeapon_Howitzer::MinMaxRange' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_Howitzer, MinMaxDispersion) == 0x000578, "Member 'AHLLArmourWeapon_Howitzer::MinMaxDispersion' has a wrong offset!");

// Class HLL.HLLArmourWeapon_MountedHowitzer
// 0x0028 (0x0588 - 0x0560)
class AHLLArmourWeapon_MountedHowitzer final : public AHLLArmourWeapon
{
public:
	struct FVector2D                              MinMaxRange;                                       // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinMaxDispersion;                                  // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AHLLHowitzerShell>>  Shells;                                            // 0x0570(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourWeaponMuzzleOcclusionComponent* MuzzleOcclusionComponent;                          // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Server_FireWeapon(const struct FVector_NetQuantize& ClientOrigin, const struct FVector_NetQuantizeNormal& ClientDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeapon_MountedHowitzer">();
	}
	static class AHLLArmourWeapon_MountedHowitzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArmourWeapon_MountedHowitzer>();
	}
};
static_assert(alignof(AHLLArmourWeapon_MountedHowitzer) == 0x000008, "Wrong alignment on AHLLArmourWeapon_MountedHowitzer");
static_assert(sizeof(AHLLArmourWeapon_MountedHowitzer) == 0x000588, "Wrong size on AHLLArmourWeapon_MountedHowitzer");
static_assert(offsetof(AHLLArmourWeapon_MountedHowitzer, MinMaxRange) == 0x000560, "Member 'AHLLArmourWeapon_MountedHowitzer::MinMaxRange' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_MountedHowitzer, MinMaxDispersion) == 0x000568, "Member 'AHLLArmourWeapon_MountedHowitzer::MinMaxDispersion' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_MountedHowitzer, Shells) == 0x000570, "Member 'AHLLArmourWeapon_MountedHowitzer::Shells' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_MountedHowitzer, MuzzleOcclusionComponent) == 0x000580, "Member 'AHLLArmourWeapon_MountedHowitzer::MuzzleOcclusionComponent' has a wrong offset!");

// Class HLL.ShooterAIController
// 0x0020 (0x0348 - 0x0328)
class AShooterAIController final : public AAIController
{
public:
	class UBlackboardComponent*                   BlackboardComp;                                    // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 BehaviorComp;                                      // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1327[0x10];                                    // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void FindClosestEnemy();
	bool FindClosestEnemyWithLOS(class AShooterCharacter* ExcludeEnemy);
	void ShootEnemy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterAIController">();
	}
	static class AShooterAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterAIController>();
	}
};
static_assert(alignof(AShooterAIController) == 0x000008, "Wrong alignment on AShooterAIController");
static_assert(sizeof(AShooterAIController) == 0x000348, "Wrong size on AShooterAIController");
static_assert(offsetof(AShooterAIController, BlackboardComp) == 0x000328, "Member 'AShooterAIController::BlackboardComp' has a wrong offset!");
static_assert(offsetof(AShooterAIController, BehaviorComp) == 0x000330, "Member 'AShooterAIController::BehaviorComp' has a wrong offset!");

// Class HLL.HllArmourWeapon_MountedShooterWeapon
// 0x00A0 (0x0600 - 0x0560)
class AHllArmourWeapon_MountedShooterWeapon final : public AHLLArmourWeapon
{
public:
	struct FRecoilAndSpread                       ModifiedRecoilAndSpread;                           // 0x0560(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableWeaponOverheating;                          // 0x0590(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1329[0x7];                                     // 0x0591(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterWeapon*                         MountedWeapon;                                     // 0x0598(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_132A[0x60];                                    // 0x05A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Server_FireWeapon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HllArmourWeapon_MountedShooterWeapon">();
	}
	static class AHllArmourWeapon_MountedShooterWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHllArmourWeapon_MountedShooterWeapon>();
	}
};
static_assert(alignof(AHllArmourWeapon_MountedShooterWeapon) == 0x000008, "Wrong alignment on AHllArmourWeapon_MountedShooterWeapon");
static_assert(sizeof(AHllArmourWeapon_MountedShooterWeapon) == 0x000600, "Wrong size on AHllArmourWeapon_MountedShooterWeapon");
static_assert(offsetof(AHllArmourWeapon_MountedShooterWeapon, ModifiedRecoilAndSpread) == 0x000560, "Member 'AHllArmourWeapon_MountedShooterWeapon::ModifiedRecoilAndSpread' has a wrong offset!");
static_assert(offsetof(AHllArmourWeapon_MountedShooterWeapon, bEnableWeaponOverheating) == 0x000590, "Member 'AHllArmourWeapon_MountedShooterWeapon::bEnableWeaponOverheating' has a wrong offset!");
static_assert(offsetof(AHllArmourWeapon_MountedShooterWeapon, MountedWeapon) == 0x000598, "Member 'AHllArmourWeapon_MountedShooterWeapon::MountedWeapon' has a wrong offset!");

// Class HLL.HLLArmourWeapon_Projectile
// 0x0018 (0x0578 - 0x0560)
class AHLLArmourWeapon_Projectile : public AHLLArmourWeapon
{
public:
	class UHLLArmourWeaponMuzzleOcclusionComponent* MuzzleOcclusionComponent;                          // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AShooterProjectile>> Projectiles;                                       // 0x0568(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Server_FireWeapon(const struct FVector_NetQuantize& ClientOrigin, const struct FVector_NetQuantizeNormal& ClientDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeapon_Projectile">();
	}
	static class AHLLArmourWeapon_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArmourWeapon_Projectile>();
	}
};
static_assert(alignof(AHLLArmourWeapon_Projectile) == 0x000008, "Wrong alignment on AHLLArmourWeapon_Projectile");
static_assert(sizeof(AHLLArmourWeapon_Projectile) == 0x000578, "Wrong size on AHLLArmourWeapon_Projectile");
static_assert(offsetof(AHLLArmourWeapon_Projectile, MuzzleOcclusionComponent) == 0x000560, "Member 'AHLLArmourWeapon_Projectile::MuzzleOcclusionComponent' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_Projectile, Projectiles) == 0x000568, "Member 'AHLLArmourWeapon_Projectile::Projectiles' has a wrong offset!");

// Class HLL.HLLArmourWeapon_ReconGun
// 0x0058 (0x05B8 - 0x0560)
class AHLLArmourWeapon_ReconGun final : public AHLLArmourWeapon
{
public:
	float                                         ScannedAreaInterpSpeed;                            // 0x0560(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScannedAreaRadius;                                 // 0x0564(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EObjectTypeQuery>                      ScanObjectTypes;                                   // 0x0568(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutDuration;                                   // 0x0578(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_132B[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UStaticMesh*                            ReconAreaMesh;                                     // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReconAreaMaterial;                                 // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReconAreaSphereMID;                                // 0x0590(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   ReconAreaVisualsComponent;                         // 0x0598(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ShotLocation;                                      // 0x05A0(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_132C[0xC];                                     // 0x05AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_ShotLocation();
	void Server_FireReconGun(const struct FVector_NetQuantize& Origin, const struct FVector_NetQuantizeNormal& Direction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArmourWeapon_ReconGun">();
	}
	static class AHLLArmourWeapon_ReconGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArmourWeapon_ReconGun>();
	}
};
static_assert(alignof(AHLLArmourWeapon_ReconGun) == 0x000008, "Wrong alignment on AHLLArmourWeapon_ReconGun");
static_assert(sizeof(AHLLArmourWeapon_ReconGun) == 0x0005B8, "Wrong size on AHLLArmourWeapon_ReconGun");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, ScannedAreaInterpSpeed) == 0x000560, "Member 'AHLLArmourWeapon_ReconGun::ScannedAreaInterpSpeed' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, ScannedAreaRadius) == 0x000564, "Member 'AHLLArmourWeapon_ReconGun::ScannedAreaRadius' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, ScanObjectTypes) == 0x000568, "Member 'AHLLArmourWeapon_ReconGun::ScanObjectTypes' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, FadeOutDuration) == 0x000578, "Member 'AHLLArmourWeapon_ReconGun::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, ReconAreaMesh) == 0x000580, "Member 'AHLLArmourWeapon_ReconGun::ReconAreaMesh' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, ReconAreaMaterial) == 0x000588, "Member 'AHLLArmourWeapon_ReconGun::ReconAreaMaterial' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, ReconAreaSphereMID) == 0x000590, "Member 'AHLLArmourWeapon_ReconGun::ReconAreaSphereMID' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, ReconAreaVisualsComponent) == 0x000598, "Member 'AHLLArmourWeapon_ReconGun::ReconAreaVisualsComponent' has a wrong offset!");
static_assert(offsetof(AHLLArmourWeapon_ReconGun, ShotLocation) == 0x0005A0, "Member 'AHLLArmourWeapon_ReconGun::ShotLocation' has a wrong offset!");

// Class HLL.HLLArtillerySpawner
// 0x0018 (0x0238 - 0x0220)
class AHLLArtillerySpawner final : public AActor
{
public:
	class USceneComponent*                        DummyRoot;                                         // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLArtilleryBase>          ArtilleryClass;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyInitialUpgrade;                              // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132D[0x7];                                     // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLArtillerySpawner">();
	}
	static class AHLLArtillerySpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLArtillerySpawner>();
	}
};
static_assert(alignof(AHLLArtillerySpawner) == 0x000008, "Wrong alignment on AHLLArtillerySpawner");
static_assert(sizeof(AHLLArtillerySpawner) == 0x000238, "Wrong size on AHLLArtillerySpawner");
static_assert(offsetof(AHLLArtillerySpawner, DummyRoot) == 0x000220, "Member 'AHLLArtillerySpawner::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLArtillerySpawner, ArtilleryClass) == 0x000228, "Member 'AHLLArtillerySpawner::ArtilleryClass' has a wrong offset!");
static_assert(offsetof(AHLLArtillerySpawner, bApplyInitialUpgrade) == 0x000230, "Member 'AHLLArtillerySpawner::bApplyInitialUpgrade' has a wrong offset!");

// Class HLL.HLLAudioVolume
// 0x0008 (0x02B0 - 0x02A8)
class AHLLAudioVolume final : public AAudioVolume
{
public:
	uint8                                         bAutoRegisterVolume : 1;                           // 0x02A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EAudioVolumeType                              VolumeType;                                        // 0x02A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132E[0x6];                                     // 0x02AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void RegisterAudioVolume();
	void UnregisterAudioVolume();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAudioVolume">();
	}
	static class AHLLAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAudioVolume>();
	}
};
static_assert(alignof(AHLLAudioVolume) == 0x000008, "Wrong alignment on AHLLAudioVolume");
static_assert(sizeof(AHLLAudioVolume) == 0x0002B0, "Wrong size on AHLLAudioVolume");
static_assert(offsetof(AHLLAudioVolume, VolumeType) == 0x0002A9, "Member 'AHLLAudioVolume::VolumeType' has a wrong offset!");

// Class HLL.HLLBallisticsComponent_Vehicle
// 0x0000 (0x0190 - 0x0190)
class UHLLBallisticsComponent_Vehicle final : public UHLLBallisticsComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBallisticsComponent_Vehicle">();
	}
	static class UHLLBallisticsComponent_Vehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLBallisticsComponent_Vehicle>();
	}
};
static_assert(alignof(UHLLBallisticsComponent_Vehicle) == 0x000008, "Wrong alignment on UHLLBallisticsComponent_Vehicle");
static_assert(sizeof(UHLLBallisticsComponent_Vehicle) == 0x000190, "Wrong size on UHLLBallisticsComponent_Vehicle");

// Class HLL.HLLBallisticsManager
// 0x0070 (0x00A0 - 0x0030)
class UHLLBallisticsManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_132F[0x18];                                    // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLBallisticsComponent*>        BallisticComponents;                               // 0x0048(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UHLLProjectile*>                 ProjectileClasses;                                 // 0x0058(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHLLBallisticsDebugger*                 Debugger;                                          // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBallisticsTickFunction                BallisticsTickFunction;                            // 0x0070(0x0030)(NativeAccessSpecifierPrivate)

public:
	static class UHLLBallisticsManager* Get(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBallisticsManager">();
	}
	static class UHLLBallisticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLBallisticsManager>();
	}
};
static_assert(alignof(UHLLBallisticsManager) == 0x000008, "Wrong alignment on UHLLBallisticsManager");
static_assert(sizeof(UHLLBallisticsManager) == 0x0000A0, "Wrong size on UHLLBallisticsManager");
static_assert(offsetof(UHLLBallisticsManager, BallisticComponents) == 0x000048, "Member 'UHLLBallisticsManager::BallisticComponents' has a wrong offset!");
static_assert(offsetof(UHLLBallisticsManager, ProjectileClasses) == 0x000058, "Member 'UHLLBallisticsManager::ProjectileClasses' has a wrong offset!");
static_assert(offsetof(UHLLBallisticsManager, Debugger) == 0x000068, "Member 'UHLLBallisticsManager::Debugger' has a wrong offset!");
static_assert(offsetof(UHLLBallisticsManager, BallisticsTickFunction) == 0x000070, "Member 'UHLLBallisticsManager::BallisticsTickFunction' has a wrong offset!");

// Class HLL.HLLBurnableInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLBurnableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBurnableInterface">();
	}
	static class IHLLBurnableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLBurnableInterface>();
	}
};
static_assert(alignof(IHLLBurnableInterface) == 0x000008, "Wrong alignment on IHLLBurnableInterface");
static_assert(sizeof(IHLLBurnableInterface) == 0x000028, "Wrong size on IHLLBurnableInterface");

// Class HLL.HLLComboBox
// 0x0CA8 (0x0DB0 - 0x0108)
class UHLLComboBox final : public UWidget
{
public:
	uint8                                         Pad_1330[0x18];                                    // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x0120(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTableRowStyle                         ItemStyle;                                         // 0x0510(0x07C8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x0CD8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxListHeight;                                     // 0x0CE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1331[0x4];                                     // 0x0CEC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateFontInfo                         Font;                                              // 0x0CF0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x0D40(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x0D68(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1332[0x47];                                    // 0x0D69(0x0047)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLComboBox">();
	}
	static class UHLLComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLComboBox>();
	}
};
static_assert(alignof(UHLLComboBox) == 0x000008, "Wrong alignment on UHLLComboBox");
static_assert(sizeof(UHLLComboBox) == 0x000DB0, "Wrong size on UHLLComboBox");
static_assert(offsetof(UHLLComboBox, WidgetStyle) == 0x000120, "Member 'UHLLComboBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UHLLComboBox, ItemStyle) == 0x000510, "Member 'UHLLComboBox::ItemStyle' has a wrong offset!");
static_assert(offsetof(UHLLComboBox, ContentPadding) == 0x000CD8, "Member 'UHLLComboBox::ContentPadding' has a wrong offset!");
static_assert(offsetof(UHLLComboBox, MaxListHeight) == 0x000CE8, "Member 'UHLLComboBox::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UHLLComboBox, Font) == 0x000CF0, "Member 'UHLLComboBox::Font' has a wrong offset!");
static_assert(offsetof(UHLLComboBox, ForegroundColor) == 0x000D40, "Member 'UHLLComboBox::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UHLLComboBox, bIsFocusable) == 0x000D68, "Member 'UHLLComboBox::bIsFocusable' has a wrong offset!");

// Class HLL.HLLCommanderAbility_StrafingRun
// 0x0090 (0x0430 - 0x03A0)
class AHLLCommanderAbility_StrafingRun final : public AHLLCommanderAbility_SplineFollower
{
public:
	TSubclassOf<class AShooterImpactEffect>       ImpactEffect;                                      // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlaneGunSpacing;                                   // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShotRandomOffset;                                  // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShotRadius;                                        // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShotAngle;                                         // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Suppression;                                       // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionRadius;                                 // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FireTime;                                          // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverageLength;                                    // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumShots;                                          // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UShooterDamageType>         DamageType;                                        // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MuzzleFlash;                                       // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             MuzzleSound;                                       // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UParticleSystemComponent>> MuzzleFlashPSC;                                    // 0x03E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UAudioComponent>> MuzzleAC;                                          // 0x03F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1333[0x28];                                    // 0x0408(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderAbility_StrafingRun">();
	}
	static class AHLLCommanderAbility_StrafingRun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLCommanderAbility_StrafingRun>();
	}
};
static_assert(alignof(AHLLCommanderAbility_StrafingRun) == 0x000008, "Wrong alignment on AHLLCommanderAbility_StrafingRun");
static_assert(sizeof(AHLLCommanderAbility_StrafingRun) == 0x000430, "Wrong size on AHLLCommanderAbility_StrafingRun");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, ImpactEffect) == 0x0003A0, "Member 'AHLLCommanderAbility_StrafingRun::ImpactEffect' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, PlaneGunSpacing) == 0x0003A8, "Member 'AHLLCommanderAbility_StrafingRun::PlaneGunSpacing' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, ShotRandomOffset) == 0x0003AC, "Member 'AHLLCommanderAbility_StrafingRun::ShotRandomOffset' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, ShotRadius) == 0x0003B0, "Member 'AHLLCommanderAbility_StrafingRun::ShotRadius' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, ShotAngle) == 0x0003B4, "Member 'AHLLCommanderAbility_StrafingRun::ShotAngle' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, Damage) == 0x0003B8, "Member 'AHLLCommanderAbility_StrafingRun::Damage' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, Suppression) == 0x0003BC, "Member 'AHLLCommanderAbility_StrafingRun::Suppression' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, SuppressionRadius) == 0x0003C0, "Member 'AHLLCommanderAbility_StrafingRun::SuppressionRadius' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, FireTime) == 0x0003C4, "Member 'AHLLCommanderAbility_StrafingRun::FireTime' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, CoverageLength) == 0x0003C8, "Member 'AHLLCommanderAbility_StrafingRun::CoverageLength' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, NumShots) == 0x0003CC, "Member 'AHLLCommanderAbility_StrafingRun::NumShots' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, DamageType) == 0x0003D0, "Member 'AHLLCommanderAbility_StrafingRun::DamageType' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, MuzzleFlash) == 0x0003D8, "Member 'AHLLCommanderAbility_StrafingRun::MuzzleFlash' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, MuzzleSound) == 0x0003E0, "Member 'AHLLCommanderAbility_StrafingRun::MuzzleSound' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, MuzzleFlashPSC) == 0x0003E8, "Member 'AHLLCommanderAbility_StrafingRun::MuzzleFlashPSC' has a wrong offset!");
static_assert(offsetof(AHLLCommanderAbility_StrafingRun, MuzzleAC) == 0x0003F8, "Member 'AHLLCommanderAbility_StrafingRun::MuzzleAC' has a wrong offset!");

// Class HLL.HLLCommanderUI
// 0x00C8 (0x02F8 - 0x0230)
class UHLLCommanderUI : public UUserWidget
{
public:
	uint8                                         Pad_1334[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLCommanderUISubCategory> SubCategoryWidgetClass;                            // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DefaultTooltip;                                    // 0x0248(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemTooltip;                                       // 0x0260(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class UHLLCommanderUIItem*>            ListItems;                                         // 0x0278(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FScrollerItems>                 OrderedListItems;                                  // 0x0288(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLCommanderUIItem*                    SelectedItem;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLCommanderUIItem*                    HoveredItem;                                       // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLCommanderUISubCategory*>     SubCategoryWidgets;                                // 0x02A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1335[0x8];                                     // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             AbilityTooltip;                                    // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             MunitionsScroller;                                 // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ManpowerScroller;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             FuelScroller;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBoxManpower;                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBoxMunitions;                              // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VerticalBoxFuel;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateList();

	class UScrollBox* GetScroller(const EGameResource Type) const;
	class AHLLCommanderAbility* GetSelectedAbility() const;
	class UHLLCommanderUIItem* GetSelectedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderUI">();
	}
	static class UHLLCommanderUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCommanderUI>();
	}
};
static_assert(alignof(UHLLCommanderUI) == 0x000008, "Wrong alignment on UHLLCommanderUI");
static_assert(sizeof(UHLLCommanderUI) == 0x0002F8, "Wrong size on UHLLCommanderUI");
static_assert(offsetof(UHLLCommanderUI, SubCategoryWidgetClass) == 0x000240, "Member 'UHLLCommanderUI::SubCategoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, DefaultTooltip) == 0x000248, "Member 'UHLLCommanderUI::DefaultTooltip' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, ItemTooltip) == 0x000260, "Member 'UHLLCommanderUI::ItemTooltip' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, ListItems) == 0x000278, "Member 'UHLLCommanderUI::ListItems' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, OrderedListItems) == 0x000288, "Member 'UHLLCommanderUI::OrderedListItems' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, SelectedItem) == 0x000298, "Member 'UHLLCommanderUI::SelectedItem' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, HoveredItem) == 0x0002A0, "Member 'UHLLCommanderUI::HoveredItem' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, SubCategoryWidgets) == 0x0002A8, "Member 'UHLLCommanderUI::SubCategoryWidgets' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, AbilityTooltip) == 0x0002C0, "Member 'UHLLCommanderUI::AbilityTooltip' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, MunitionsScroller) == 0x0002C8, "Member 'UHLLCommanderUI::MunitionsScroller' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, ManpowerScroller) == 0x0002D0, "Member 'UHLLCommanderUI::ManpowerScroller' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, FuelScroller) == 0x0002D8, "Member 'UHLLCommanderUI::FuelScroller' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, VerticalBoxManpower) == 0x0002E0, "Member 'UHLLCommanderUI::VerticalBoxManpower' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, VerticalBoxMunitions) == 0x0002E8, "Member 'UHLLCommanderUI::VerticalBoxMunitions' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUI, VerticalBoxFuel) == 0x0002F0, "Member 'UHLLCommanderUI::VerticalBoxFuel' has a wrong offset!");

// Class HLL.HLLCommanderUIItem
// 0x0070 (0x02A0 - 0x0230)
class UHLLCommanderUIItem : public UUserWidget
{
public:
	uint8                                         Pad_1337[0x4];                                     // 0x0230(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class AHLLCommanderAbility>    AssignedAbility;                                   // 0x0234(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHLLCommanderUI>         OwningUI;                                          // 0x023C(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1338[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UButton*                                RootButton;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                RootBorder;                                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                IconBorder;                                        // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DisplayIcon;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DisplayIconProgress;                               // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DisplayName;                                       // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CooldownBar;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Cost;                                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ExecuteButton;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PulseAnim;                                         // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1339[0x8];                                     // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UHLLCommanderUI* GetCommanderUIParent();
	bool IsGamepadHovered();
	void OnButtonHovered();
	void OnButtonPressed();
	void OnButtonUnHovered();
	void OnExecute();
	void OnGamepadHovered(bool bInGamepadHovered);
	void OnInputDeviceChanged(bool bIsUsingGamepad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCommanderUIItem">();
	}
	static class UHLLCommanderUIItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCommanderUIItem>();
	}
};
static_assert(alignof(UHLLCommanderUIItem) == 0x000008, "Wrong alignment on UHLLCommanderUIItem");
static_assert(sizeof(UHLLCommanderUIItem) == 0x0002A0, "Wrong size on UHLLCommanderUIItem");
static_assert(offsetof(UHLLCommanderUIItem, AssignedAbility) == 0x000234, "Member 'UHLLCommanderUIItem::AssignedAbility' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, OwningUI) == 0x00023C, "Member 'UHLLCommanderUIItem::OwningUI' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, RootButton) == 0x000248, "Member 'UHLLCommanderUIItem::RootButton' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, RootBorder) == 0x000250, "Member 'UHLLCommanderUIItem::RootBorder' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, IconBorder) == 0x000258, "Member 'UHLLCommanderUIItem::IconBorder' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, DisplayIcon) == 0x000260, "Member 'UHLLCommanderUIItem::DisplayIcon' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, DisplayIconProgress) == 0x000268, "Member 'UHLLCommanderUIItem::DisplayIconProgress' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, DisplayName) == 0x000270, "Member 'UHLLCommanderUIItem::DisplayName' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, CooldownBar) == 0x000278, "Member 'UHLLCommanderUIItem::CooldownBar' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, Cost) == 0x000280, "Member 'UHLLCommanderUIItem::Cost' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, ExecuteButton) == 0x000288, "Member 'UHLLCommanderUIItem::ExecuteButton' has a wrong offset!");
static_assert(offsetof(UHLLCommanderUIItem, PulseAnim) == 0x000290, "Member 'UHLLCommanderUIItem::PulseAnim' has a wrong offset!");

// Class HLL.HLLControllerDisconnectionDialogBox
// 0x0008 (0x0328 - 0x0320)
class UHLLControllerDisconnectionDialogBox final : public UHLLDialogBox
{
public:
	uint8                                         Pad_133A[0x8];                                     // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UHLLControllerDisconnectionDialogBox* CreateControllerDisconnectionDialogBox(class ULocalPlayer* ContextPlayer, bool bUserLost);
	static class UHLLControllerDisconnectionDialogBox* GetActiveControllerDisconnectionDialogBox();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLControllerDisconnectionDialogBox">();
	}
	static class UHLLControllerDisconnectionDialogBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLControllerDisconnectionDialogBox>();
	}
};
static_assert(alignof(UHLLControllerDisconnectionDialogBox) == 0x000008, "Wrong alignment on UHLLControllerDisconnectionDialogBox");
static_assert(sizeof(UHLLControllerDisconnectionDialogBox) == 0x000328, "Wrong size on UHLLControllerDisconnectionDialogBox");

// Class HLL.HLLControlPointIndicator
// 0x01E0 (0x0490 - 0x02B0)
class UHLLControlPointIndicator final : public UHLLIndicatorBase
{
public:
	bool                                          IsExpandedState;                                   // 0x02B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_133C[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ExpandedAngle;                                     // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AnimExpandCollapse;                                // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ObjectiveNameText;                                 // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DistanceText;                                      // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FlagBrush;                                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CaptureProgress_Enemy;                             // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CaptureProgress_Friendly;                          // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ResourceBrush;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            OffensiveIcon;                                     // 0x02F0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DefensiveIcon;                                     // 0x0378(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ControlPointLockedIcon;                            // 0x0400(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	class ASeedingControlPoint*                   OwningControlPoint;                                // 0x0488(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void K2_SetExpandedState(const bool bIsExpanded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLControlPointIndicator">();
	}
	static class UHLLControlPointIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLControlPointIndicator>();
	}
};
static_assert(alignof(UHLLControlPointIndicator) == 0x000008, "Wrong alignment on UHLLControlPointIndicator");
static_assert(sizeof(UHLLControlPointIndicator) == 0x000490, "Wrong size on UHLLControlPointIndicator");
static_assert(offsetof(UHLLControlPointIndicator, IsExpandedState) == 0x0002B0, "Member 'UHLLControlPointIndicator::IsExpandedState' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, ExpandedAngle) == 0x0002B4, "Member 'UHLLControlPointIndicator::ExpandedAngle' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, AnimExpandCollapse) == 0x0002B8, "Member 'UHLLControlPointIndicator::AnimExpandCollapse' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, ObjectiveNameText) == 0x0002C0, "Member 'UHLLControlPointIndicator::ObjectiveNameText' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, DistanceText) == 0x0002C8, "Member 'UHLLControlPointIndicator::DistanceText' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, FlagBrush) == 0x0002D0, "Member 'UHLLControlPointIndicator::FlagBrush' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, CaptureProgress_Enemy) == 0x0002D8, "Member 'UHLLControlPointIndicator::CaptureProgress_Enemy' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, CaptureProgress_Friendly) == 0x0002E0, "Member 'UHLLControlPointIndicator::CaptureProgress_Friendly' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, ResourceBrush) == 0x0002E8, "Member 'UHLLControlPointIndicator::ResourceBrush' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, OffensiveIcon) == 0x0002F0, "Member 'UHLLControlPointIndicator::OffensiveIcon' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, DefensiveIcon) == 0x000378, "Member 'UHLLControlPointIndicator::DefensiveIcon' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, ControlPointLockedIcon) == 0x000400, "Member 'UHLLControlPointIndicator::ControlPointLockedIcon' has a wrong offset!");
static_assert(offsetof(UHLLControlPointIndicator, OwningControlPoint) == 0x000488, "Member 'UHLLControlPointIndicator::OwningControlPoint' has a wrong offset!");

// Class HLL.HLLCosmeticCharacterAnimInstance
// 0x0010 (0x0280 - 0x0270)
class UHLLCosmeticCharacterAnimInstance : public UAnimInstance
{
public:
	ELoadoutAnimType                              AnimationType;                                     // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_133D[0x7];                                     // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimSequence*                          InheritancePose;                                   // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnLoadoutDataChanged();

	class AHLLCosmeticCharacter* GetCosmeticCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCosmeticCharacterAnimInstance">();
	}
	static class UHLLCosmeticCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCosmeticCharacterAnimInstance>();
	}
};
static_assert(alignof(UHLLCosmeticCharacterAnimInstance) == 0x000010, "Wrong alignment on UHLLCosmeticCharacterAnimInstance");
static_assert(sizeof(UHLLCosmeticCharacterAnimInstance) == 0x000280, "Wrong size on UHLLCosmeticCharacterAnimInstance");
static_assert(offsetof(UHLLCosmeticCharacterAnimInstance, AnimationType) == 0x000270, "Member 'UHLLCosmeticCharacterAnimInstance::AnimationType' has a wrong offset!");
static_assert(offsetof(UHLLCosmeticCharacterAnimInstance, InheritancePose) == 0x000278, "Member 'UHLLCosmeticCharacterAnimInstance::InheritancePose' has a wrong offset!");

// Class HLL.Tiger
// 0x0008 (0x0600 - 0x05F8)
class ATiger final : public ABaseTank
{
public:
	class UTracksComponent*                       Tracks2;                                           // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tiger">();
	}
	static class ATiger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATiger>();
	}
};
static_assert(alignof(ATiger) == 0x000008, "Wrong alignment on ATiger");
static_assert(sizeof(ATiger) == 0x000600, "Wrong size on ATiger");
static_assert(offsetof(ATiger, Tracks2) == 0x0005F8, "Member 'ATiger::Tracks2' has a wrong offset!");

// Class HLL.HLLCriticalPlayerIndicator
// 0x0258 (0x0508 - 0x02B0)
class UHLLCriticalPlayerIndicator : public UHLLIndicatorBase
{
public:
	struct FSlateBrush                            BandageBrush;                                      // 0x02B0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CriticalBrush;                                     // 0x0338(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CriticalMedicRequestedBrush;                       // 0x03C0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CriticalMedicOnRouteBrush;                         // 0x0448(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bShowBandageWhenOffscreen : 1;                     // 0x04D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowCriticalWhenOffscreen : 1;                    // 0x04D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_133E[0x7];                                     // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UCurveFloat*                            BandagePulseCurve;                                 // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CriticalPulseCurve;                                // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            PulseSizeCurve;                                    // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_133F[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             DistanceText;                                      // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Line;                                              // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCriticalPlayerIndicator">();
	}
	static class UHLLCriticalPlayerIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCriticalPlayerIndicator>();
	}
};
static_assert(alignof(UHLLCriticalPlayerIndicator) == 0x000008, "Wrong alignment on UHLLCriticalPlayerIndicator");
static_assert(sizeof(UHLLCriticalPlayerIndicator) == 0x000508, "Wrong size on UHLLCriticalPlayerIndicator");
static_assert(offsetof(UHLLCriticalPlayerIndicator, BandageBrush) == 0x0002B0, "Member 'UHLLCriticalPlayerIndicator::BandageBrush' has a wrong offset!");
static_assert(offsetof(UHLLCriticalPlayerIndicator, CriticalBrush) == 0x000338, "Member 'UHLLCriticalPlayerIndicator::CriticalBrush' has a wrong offset!");
static_assert(offsetof(UHLLCriticalPlayerIndicator, CriticalMedicRequestedBrush) == 0x0003C0, "Member 'UHLLCriticalPlayerIndicator::CriticalMedicRequestedBrush' has a wrong offset!");
static_assert(offsetof(UHLLCriticalPlayerIndicator, CriticalMedicOnRouteBrush) == 0x000448, "Member 'UHLLCriticalPlayerIndicator::CriticalMedicOnRouteBrush' has a wrong offset!");
static_assert(offsetof(UHLLCriticalPlayerIndicator, BandagePulseCurve) == 0x0004D8, "Member 'UHLLCriticalPlayerIndicator::BandagePulseCurve' has a wrong offset!");
static_assert(offsetof(UHLLCriticalPlayerIndicator, CriticalPulseCurve) == 0x0004E0, "Member 'UHLLCriticalPlayerIndicator::CriticalPulseCurve' has a wrong offset!");
static_assert(offsetof(UHLLCriticalPlayerIndicator, PulseSizeCurve) == 0x0004E8, "Member 'UHLLCriticalPlayerIndicator::PulseSizeCurve' has a wrong offset!");
static_assert(offsetof(UHLLCriticalPlayerIndicator, DistanceText) == 0x0004F8, "Member 'UHLLCriticalPlayerIndicator::DistanceText' has a wrong offset!");
static_assert(offsetof(UHLLCriticalPlayerIndicator, Line) == 0x000500, "Member 'UHLLCriticalPlayerIndicator::Line' has a wrong offset!");

// Class HLL.HLLDamageIndicator
// 0x0140 (0x0370 - 0x0230)
class UHLLDamageIndicator : public UUserWidget
{
public:
	struct FSlateBrush                            DirectionalDamageBrush;                            // 0x0230(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            FlashDamageBrush;                                  // 0x02B8(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         OffsetFromCenter;                                  // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStickyIndicators : 1;                             // 0x0344(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1340[0x3];                                     // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UCurveFloat*                            DirectionalIndicatorFadeCurve;                     // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            FlashIndicatorFadeCurve;                           // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RootPanel;                                         // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1341[0x10];                                    // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDamageIndicator">();
	}
	static class UHLLDamageIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDamageIndicator>();
	}
};
static_assert(alignof(UHLLDamageIndicator) == 0x000008, "Wrong alignment on UHLLDamageIndicator");
static_assert(sizeof(UHLLDamageIndicator) == 0x000370, "Wrong size on UHLLDamageIndicator");
static_assert(offsetof(UHLLDamageIndicator, DirectionalDamageBrush) == 0x000230, "Member 'UHLLDamageIndicator::DirectionalDamageBrush' has a wrong offset!");
static_assert(offsetof(UHLLDamageIndicator, FlashDamageBrush) == 0x0002B8, "Member 'UHLLDamageIndicator::FlashDamageBrush' has a wrong offset!");
static_assert(offsetof(UHLLDamageIndicator, OffsetFromCenter) == 0x000340, "Member 'UHLLDamageIndicator::OffsetFromCenter' has a wrong offset!");
static_assert(offsetof(UHLLDamageIndicator, DirectionalIndicatorFadeCurve) == 0x000348, "Member 'UHLLDamageIndicator::DirectionalIndicatorFadeCurve' has a wrong offset!");
static_assert(offsetof(UHLLDamageIndicator, FlashIndicatorFadeCurve) == 0x000350, "Member 'UHLLDamageIndicator::FlashIndicatorFadeCurve' has a wrong offset!");
static_assert(offsetof(UHLLDamageIndicator, RootPanel) == 0x000358, "Member 'UHLLDamageIndicator::RootPanel' has a wrong offset!");

// Class HLL.HLLDamageSourceInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLDamageSourceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDamageSourceInterface">();
	}
	static class IHLLDamageSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLDamageSourceInterface>();
	}
};
static_assert(alignof(IHLLDamageSourceInterface) == 0x000008, "Wrong alignment on IHLLDamageSourceInterface");
static_assert(sizeof(IHLLDamageSourceInterface) == 0x000028, "Wrong size on IHLLDamageSourceInterface");

// Class HLL.HLLDeathScreen
// 0x0088 (0x02B8 - 0x0230)
class UHLLDeathScreen : public UUserWidget
{
public:
	uint8                                         Pad_1342[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SpawnTime;                                         // 0x0238(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnDelay;                                      // 0x023C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDeathInfo                             DeathInfo;                                         // 0x0240(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeInAnimation;                                   // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         TeamKillBox;                                       // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TeamKillMessage;                                   // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PunishMessage;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RespawnInfo;                                       // 0x0280(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UButton*                                RedeployButton;                                    // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ButtonText;                                        // 0x02A0(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	void OnRespawn();
	void RefreshButtonPrompt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDeathScreen">();
	}
	static class UHLLDeathScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDeathScreen>();
	}
};
static_assert(alignof(UHLLDeathScreen) == 0x000008, "Wrong alignment on UHLLDeathScreen");
static_assert(sizeof(UHLLDeathScreen) == 0x0002B8, "Wrong size on UHLLDeathScreen");
static_assert(offsetof(UHLLDeathScreen, SpawnTime) == 0x000238, "Member 'UHLLDeathScreen::SpawnTime' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, RespawnDelay) == 0x00023C, "Member 'UHLLDeathScreen::RespawnDelay' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, DeathInfo) == 0x000240, "Member 'UHLLDeathScreen::DeathInfo' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, FadeInAnimation) == 0x000260, "Member 'UHLLDeathScreen::FadeInAnimation' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, TeamKillBox) == 0x000268, "Member 'UHLLDeathScreen::TeamKillBox' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, TeamKillMessage) == 0x000270, "Member 'UHLLDeathScreen::TeamKillMessage' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, PunishMessage) == 0x000278, "Member 'UHLLDeathScreen::PunishMessage' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, RespawnInfo) == 0x000280, "Member 'UHLLDeathScreen::RespawnInfo' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, RedeployButton) == 0x000298, "Member 'UHLLDeathScreen::RedeployButton' has a wrong offset!");
static_assert(offsetof(UHLLDeathScreen, ButtonText) == 0x0002A0, "Member 'UHLLDeathScreen::ButtonText' has a wrong offset!");

// Class HLL.VaultingTestCharacter
// 0x0010 (0x1490 - 0x1480)
class AVaultingTestCharacter final : public AShooterCharacter
{
public:
	uint8                                         bShouldRun : 1;                                    // 0x1480(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldWalk : 1;                                   // 0x1480(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowCapsule : 1;                                  // 0x1480(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1343[0xF];                                     // 0x1481(0x000F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Vault(float InObstacleDistance, float InObstacleHeight, EVaultingMoveType InMoveType);

	bool IsVaulting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultingTestCharacter">();
	}
	static class AVaultingTestCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVaultingTestCharacter>();
	}
};
static_assert(alignof(AVaultingTestCharacter) == 0x000010, "Wrong alignment on AVaultingTestCharacter");
static_assert(sizeof(AVaultingTestCharacter) == 0x001490, "Wrong size on AVaultingTestCharacter");

// Class HLL.HLLDeploymentMap
// 0x0040 (0x04A0 - 0x0460)
class UHLLDeploymentMap : public UHLLOverviewMap
{
public:
	FMulticastInlineDelegateProperty_             OnSpawnPointSelectionChanged;                      // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UHLLMapIconBase*>                SpawnPoints;                                       // 0x0470(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLMapIconBase*>                CategorisedSpawnPoints;                            // 0x0480(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1345[0x10];                                    // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ActivateGamepadCursor();
	void ClearSpawnSelection();
	TArray<class UHLLMapIconBase*> GetSpawnPoints();
	TArray<class UHLLMapIconBase*> GetSpawnPointsWithHeadings();
	void OnSpawnPointSelectionChanged__DelegateSignature();

	TScriptInterface<class IDynamicSpawnInterface> GetSelectedSpawn() const;
	bool HasSelectedSpawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDeploymentMap">();
	}
	static class UHLLDeploymentMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDeploymentMap>();
	}
};
static_assert(alignof(UHLLDeploymentMap) == 0x000008, "Wrong alignment on UHLLDeploymentMap");
static_assert(sizeof(UHLLDeploymentMap) == 0x0004A0, "Wrong size on UHLLDeploymentMap");
static_assert(offsetof(UHLLDeploymentMap, OnSpawnPointSelectionChanged) == 0x000460, "Member 'UHLLDeploymentMap::OnSpawnPointSelectionChanged' has a wrong offset!");
static_assert(offsetof(UHLLDeploymentMap, SpawnPoints) == 0x000470, "Member 'UHLLDeploymentMap::SpawnPoints' has a wrong offset!");
static_assert(offsetof(UHLLDeploymentMap, CategorisedSpawnPoints) == 0x000480, "Member 'UHLLDeploymentMap::CategorisedSpawnPoints' has a wrong offset!");

// Class HLL.HLLDeployment_TeamSelect
// 0x0020 (0x0250 - 0x0230)
class UHLLDeployment_TeamSelect : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnTeamSelected;                                    // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UHLLDeployment_TeamSelectItem*          Team_Allies;                                       // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLDeployment_TeamSelectItem*          Team_Axis;                                         // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTeamSelected__DelegateSignature(const ETeam Team);
	void SelectTeam(const ETeam Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDeployment_TeamSelect">();
	}
	static class UHLLDeployment_TeamSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDeployment_TeamSelect>();
	}
};
static_assert(alignof(UHLLDeployment_TeamSelect) == 0x000008, "Wrong alignment on UHLLDeployment_TeamSelect");
static_assert(sizeof(UHLLDeployment_TeamSelect) == 0x000250, "Wrong size on UHLLDeployment_TeamSelect");
static_assert(offsetof(UHLLDeployment_TeamSelect, OnTeamSelected) == 0x000230, "Member 'UHLLDeployment_TeamSelect::OnTeamSelected' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelect, Team_Allies) == 0x000240, "Member 'UHLLDeployment_TeamSelect::Team_Allies' has a wrong offset!");
static_assert(offsetof(UHLLDeployment_TeamSelect, Team_Axis) == 0x000248, "Member 'UHLLDeployment_TeamSelect::Team_Axis' has a wrong offset!");

// Class HLL.HLLDesktopUIManager
// 0x0000 (0x0180 - 0x0180)
class UHLLDesktopUIManager final : public UHLLConsoleUIManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDesktopUIManager">();
	}
	static class UHLLDesktopUIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDesktopUIManager>();
	}
};
static_assert(alignof(UHLLDesktopUIManager) == 0x000008, "Wrong alignment on UHLLDesktopUIManager");
static_assert(sizeof(UHLLDesktopUIManager) == 0x000180, "Wrong size on UHLLDesktopUIManager");

// Class HLL.HLLDismantleInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLDismantleInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDismantleInterface">();
	}
	static class IHLLDismantleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLDismantleInterface>();
	}
};
static_assert(alignof(IHLLDismantleInterface) == 0x000008, "Wrong alignment on IHLLDismantleInterface");
static_assert(sizeof(IHLLDismantleInterface) == 0x000028, "Wrong size on IHLLDismantleInterface");

// Class HLL.VehicleDrop_Supplies
// 0x0008 (0x02F0 - 0x02E8)
class AVehicleDrop_Supplies final : public AVehicleDrop
{
public:
	class UHLLSupplyComponent*                    SupplyComponent;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleDrop_Supplies">();
	}
	static class AVehicleDrop_Supplies* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleDrop_Supplies>();
	}
};
static_assert(alignof(AVehicleDrop_Supplies) == 0x000008, "Wrong alignment on AVehicleDrop_Supplies");
static_assert(sizeof(AVehicleDrop_Supplies) == 0x0002F0, "Wrong size on AVehicleDrop_Supplies");
static_assert(offsetof(AVehicleDrop_Supplies, SupplyComponent) == 0x0002E8, "Member 'AVehicleDrop_Supplies::SupplyComponent' has a wrong offset!");

// Class HLL.HLLDispenserItem_AbilityGarrison
// 0x0000 (0x0580 - 0x0580)
class AHLLDispenserItem_AbilityGarrison final : public AHLLDispenserItem_DynamicSpawnGhost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_AbilityGarrison">();
	}
	static class AHLLDispenserItem_AbilityGarrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_AbilityGarrison>();
	}
};
static_assert(alignof(AHLLDispenserItem_AbilityGarrison) == 0x000008, "Wrong alignment on AHLLDispenserItem_AbilityGarrison");
static_assert(sizeof(AHLLDispenserItem_AbilityGarrison) == 0x000580, "Wrong size on AHLLDispenserItem_AbilityGarrison");

// Class HLL.VehicleWorldShiftingComponent
// 0x0010 (0x00C0 - 0x00B0)
class UVehicleWorldShiftingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_1346[0x10];                                    // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleWorldShiftingComponent">();
	}
	static class UVehicleWorldShiftingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleWorldShiftingComponent>();
	}
};
static_assert(alignof(UVehicleWorldShiftingComponent) == 0x000008, "Wrong alignment on UVehicleWorldShiftingComponent");
static_assert(sizeof(UVehicleWorldShiftingComponent) == 0x0000C0, "Wrong size on UVehicleWorldShiftingComponent");

// Class HLL.HLLDispenserItem_Outpost
// 0x0008 (0x0588 - 0x0580)
class AHLLDispenserItem_Outpost : public AHLLDispenserItem_DynamicSpawnGhost
{
public:
	uint8                                         bAutoDestroyOutpostsPlacedByOtherOfficers : 1;     // 0x0580(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1347[0x7];                                     // 0x0581(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_Outpost">();
	}
	static class AHLLDispenserItem_Outpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_Outpost>();
	}
};
static_assert(alignof(AHLLDispenserItem_Outpost) == 0x000008, "Wrong alignment on AHLLDispenserItem_Outpost");
static_assert(sizeof(AHLLDispenserItem_Outpost) == 0x000588, "Wrong size on AHLLDispenserItem_Outpost");

// Class HLL.HLLDispenserItem_TimedSatchel
// 0x0010 (0x0528 - 0x0518)
class AHLLDispenserItem_TimedSatchel : public AHLLDispenserItem_Base
{
public:
	TArray<uint8>                                 TimeValues;                                        // 0x0518(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserItem_TimedSatchel">();
	}
	static class AHLLDispenserItem_TimedSatchel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLDispenserItem_TimedSatchel>();
	}
};
static_assert(alignof(AHLLDispenserItem_TimedSatchel) == 0x000008, "Wrong alignment on AHLLDispenserItem_TimedSatchel");
static_assert(sizeof(AHLLDispenserItem_TimedSatchel) == 0x000528, "Wrong size on AHLLDispenserItem_TimedSatchel");
static_assert(offsetof(AHLLDispenserItem_TimedSatchel, TimeValues) == 0x000518, "Member 'AHLLDispenserItem_TimedSatchel::TimeValues' has a wrong offset!");

// Class HLL.HLLFakeCursor
// 0x0000 (0x0230 - 0x0230)
class UHLLFakeCursor : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLFakeCursor">();
	}
	static class UHLLFakeCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLFakeCursor>();
	}
};
static_assert(alignof(UHLLFakeCursor) == 0x000008, "Wrong alignment on UHLLFakeCursor");
static_assert(sizeof(UHLLFakeCursor) == 0x000230, "Wrong size on UHLLFakeCursor");

// Class HLL.HLLWeaponForceFeedbackData
// 0x0010 (0x0040 - 0x0030)
class UHLLWeaponForceFeedbackData final : public UHLLWeaponVibrationData
{
public:
	TArray<struct FHLLWeaponForceFeedbackEvent>   Events;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeaponForceFeedbackData">();
	}
	static class UHLLWeaponForceFeedbackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeaponForceFeedbackData>();
	}
};
static_assert(alignof(UHLLWeaponForceFeedbackData) == 0x000008, "Wrong alignment on UHLLWeaponForceFeedbackData");
static_assert(sizeof(UHLLWeaponForceFeedbackData) == 0x000040, "Wrong size on UHLLWeaponForceFeedbackData");
static_assert(offsetof(UHLLWeaponForceFeedbackData, Events) == 0x000030, "Member 'UHLLWeaponForceFeedbackData::Events' has a wrong offset!");

// Class HLL.HLLVehicleForceFeedbackData
// 0x0010 (0x0048 - 0x0038)
class UHLLVehicleForceFeedbackData final : public UHLLVehicleVibrationData
{
public:
	TArray<struct FHLLVehicleForceFeedbackEvent>  Events;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleForceFeedbackData">();
	}
	static class UHLLVehicleForceFeedbackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVehicleForceFeedbackData>();
	}
};
static_assert(alignof(UHLLVehicleForceFeedbackData) == 0x000008, "Wrong alignment on UHLLVehicleForceFeedbackData");
static_assert(sizeof(UHLLVehicleForceFeedbackData) == 0x000048, "Wrong size on UHLLVehicleForceFeedbackData");
static_assert(offsetof(UHLLVehicleForceFeedbackData, Events) == 0x000038, "Member 'UHLLVehicleForceFeedbackData::Events' has a wrong offset!");

// Class HLL.ForceFeedbackEventController
// 0x0010 (0x0038 - 0x0028)
class UForceFeedbackEventController final : public UVibrationEventController
{
public:
	class UForceFeedbackComponent*                FeedbackComponent;                                 // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1348[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackEventController">();
	}
	static class UForceFeedbackEventController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackEventController>();
	}
};
static_assert(alignof(UForceFeedbackEventController) == 0x000008, "Wrong alignment on UForceFeedbackEventController");
static_assert(sizeof(UForceFeedbackEventController) == 0x000038, "Wrong size on UForceFeedbackEventController");
static_assert(offsetof(UForceFeedbackEventController, FeedbackComponent) == 0x000028, "Member 'UForceFeedbackEventController::FeedbackComponent' has a wrong offset!");

// Class HLL.HLLGameWarmupVolume
// 0x0048 (0x0268 - 0x0220)
class AHLLGameWarmupVolume : public AActor
{
public:
	float                                         ExpireTime;                                        // 0x0220(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1349[0x4];                                     // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UBoxComponent*                          VolumeCollision;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   WallMesh;                                          // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MeshDMI;                                           // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        CountdownAC;                                       // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134A[0x4];                                     // 0x0248(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         FadeOutTime;                                       // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CountdownSoundTime;                                // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134B[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             CountdownSound;                                    // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             StingerSound;                                      // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGameWarmupVolume">();
	}
	static class AHLLGameWarmupVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLGameWarmupVolume>();
	}
};
static_assert(alignof(AHLLGameWarmupVolume) == 0x000008, "Wrong alignment on AHLLGameWarmupVolume");
static_assert(sizeof(AHLLGameWarmupVolume) == 0x000268, "Wrong size on AHLLGameWarmupVolume");
static_assert(offsetof(AHLLGameWarmupVolume, ExpireTime) == 0x000220, "Member 'AHLLGameWarmupVolume::ExpireTime' has a wrong offset!");
static_assert(offsetof(AHLLGameWarmupVolume, VolumeCollision) == 0x000228, "Member 'AHLLGameWarmupVolume::VolumeCollision' has a wrong offset!");
static_assert(offsetof(AHLLGameWarmupVolume, WallMesh) == 0x000230, "Member 'AHLLGameWarmupVolume::WallMesh' has a wrong offset!");
static_assert(offsetof(AHLLGameWarmupVolume, MeshDMI) == 0x000238, "Member 'AHLLGameWarmupVolume::MeshDMI' has a wrong offset!");
static_assert(offsetof(AHLLGameWarmupVolume, CountdownAC) == 0x000240, "Member 'AHLLGameWarmupVolume::CountdownAC' has a wrong offset!");
static_assert(offsetof(AHLLGameWarmupVolume, FadeOutTime) == 0x00024C, "Member 'AHLLGameWarmupVolume::FadeOutTime' has a wrong offset!");
static_assert(offsetof(AHLLGameWarmupVolume, CountdownSoundTime) == 0x000250, "Member 'AHLLGameWarmupVolume::CountdownSoundTime' has a wrong offset!");
static_assert(offsetof(AHLLGameWarmupVolume, CountdownSound) == 0x000258, "Member 'AHLLGameWarmupVolume::CountdownSound' has a wrong offset!");
static_assert(offsetof(AHLLGameWarmupVolume, StingerSound) == 0x000260, "Member 'AHLLGameWarmupVolume::StingerSound' has a wrong offset!");

// Class HLL.HLLGhostOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLGhostOwnerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGhostOwnerInterface">();
	}
	static class IHLLGhostOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLGhostOwnerInterface>();
	}
};
static_assert(alignof(IHLLGhostOwnerInterface) == 0x000008, "Wrong alignment on IHLLGhostOwnerInterface");
static_assert(sizeof(IHLLGhostOwnerInterface) == 0x000028, "Wrong size on IHLLGhostOwnerInterface");

// Class HLL.HLLGrenadeSmokeEffect
// 0x0010 (0x0880 - 0x0870)
class AHLLGrenadeSmokeEffect : public AShooterImpactEffect
{
public:
	class UStaticMeshComponent*                   GrenadeMesh;                                       // 0x0870(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplodedTime;                                      // 0x0878(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134C[0x4];                                     // 0x087C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGrenadeSmokeEffect">();
	}
	static class AHLLGrenadeSmokeEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLGrenadeSmokeEffect>();
	}
};
static_assert(alignof(AHLLGrenadeSmokeEffect) == 0x000008, "Wrong alignment on AHLLGrenadeSmokeEffect");
static_assert(sizeof(AHLLGrenadeSmokeEffect) == 0x000880, "Wrong size on AHLLGrenadeSmokeEffect");
static_assert(offsetof(AHLLGrenadeSmokeEffect, GrenadeMesh) == 0x000870, "Member 'AHLLGrenadeSmokeEffect::GrenadeMesh' has a wrong offset!");
static_assert(offsetof(AHLLGrenadeSmokeEffect, ExplodedTime) == 0x000878, "Member 'AHLLGrenadeSmokeEffect::ExplodedTime' has a wrong offset!");

// Class HLL.HLLGunnerUI_Howitzer
// 0x0040 (0x02B0 - 0x0270)
class UHLLGunnerUI_Howitzer final : public UHLLSeatWidgetBase
{
public:
	int32                                         NumRangeEntries;                                   // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134D[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLGunnerUI_HowitzerRangeItem> ItemClass;                                         // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLGunnerUI_HowitzerRangeItem*> ItemList;                                          // 0x0280(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           RangeVBox;                                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourWeaponUI*                     ArtilleryWeaponInfo;                               // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TraverseValue;                                     // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ElevationValue;                                    // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGunnerUI_Howitzer">();
	}
	static class UHLLGunnerUI_Howitzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLGunnerUI_Howitzer>();
	}
};
static_assert(alignof(UHLLGunnerUI_Howitzer) == 0x000008, "Wrong alignment on UHLLGunnerUI_Howitzer");
static_assert(sizeof(UHLLGunnerUI_Howitzer) == 0x0002B0, "Wrong size on UHLLGunnerUI_Howitzer");
static_assert(offsetof(UHLLGunnerUI_Howitzer, NumRangeEntries) == 0x000270, "Member 'UHLLGunnerUI_Howitzer::NumRangeEntries' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_Howitzer, ItemClass) == 0x000278, "Member 'UHLLGunnerUI_Howitzer::ItemClass' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_Howitzer, ItemList) == 0x000280, "Member 'UHLLGunnerUI_Howitzer::ItemList' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_Howitzer, RangeVBox) == 0x000290, "Member 'UHLLGunnerUI_Howitzer::RangeVBox' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_Howitzer, ArtilleryWeaponInfo) == 0x000298, "Member 'UHLLGunnerUI_Howitzer::ArtilleryWeaponInfo' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_Howitzer, TraverseValue) == 0x0002A0, "Member 'UHLLGunnerUI_Howitzer::TraverseValue' has a wrong offset!");
static_assert(offsetof(UHLLGunnerUI_Howitzer, ElevationValue) == 0x0002A8, "Member 'UHLLGunnerUI_Howitzer::ElevationValue' has a wrong offset!");

// Class HLL.HLLWeaponHapticData
// 0x0010 (0x0040 - 0x0030)
class UHLLWeaponHapticData final : public UHLLWeaponVibrationData
{
public:
	TArray<struct FHLLWeaponHapticEvent>          Events;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeaponHapticData">();
	}
	static class UHLLWeaponHapticData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeaponHapticData>();
	}
};
static_assert(alignof(UHLLWeaponHapticData) == 0x000008, "Wrong alignment on UHLLWeaponHapticData");
static_assert(sizeof(UHLLWeaponHapticData) == 0x000040, "Wrong size on UHLLWeaponHapticData");
static_assert(offsetof(UHLLWeaponHapticData, Events) == 0x000030, "Member 'UHLLWeaponHapticData::Events' has a wrong offset!");

// Class HLL.HLLVehicleHapticData
// 0x0010 (0x0048 - 0x0038)
class UHLLVehicleHapticData final : public UHLLVehicleVibrationData
{
public:
	TArray<struct FHLLVehicleHapticEvent>         Events;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleHapticData">();
	}
	static class UHLLVehicleHapticData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVehicleHapticData>();
	}
};
static_assert(alignof(UHLLVehicleHapticData) == 0x000008, "Wrong alignment on UHLLVehicleHapticData");
static_assert(sizeof(UHLLVehicleHapticData) == 0x000048, "Wrong size on UHLLVehicleHapticData");
static_assert(offsetof(UHLLVehicleHapticData, Events) == 0x000038, "Member 'UHLLVehicleHapticData::Events' has a wrong offset!");

// Class HLL.HLLHowitzer
// 0x0008 (0x0390 - 0x0388)
class AHLLHowitzer final : public AHLLArtilleryBase
{
public:
	uint8                                         Pad_134E[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLHowitzer">();
	}
	static class AHLLHowitzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLHowitzer>();
	}
};
static_assert(alignof(AHLLHowitzer) == 0x000008, "Wrong alignment on AHLLHowitzer");
static_assert(sizeof(AHLLHowitzer) == 0x000390, "Wrong size on AHLLHowitzer");

// Class HLL.HLLHUDBase
// 0x0180 (0x03B0 - 0x0230)
class alignas(0x10) UHLLHUDBase : public UUserWidget
{
public:
	class UCanvasPanel*                           WorldWidgetPanel;                                  // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           WorldWidgetPanel_Toggleable;                       // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134F[0xE0];                                    // 0x0240(0x00E0)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLIndicatorBase*>              ActiveIndicatorWidgets;                            // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 SectorDisplayPriorities;                           // 0x0330(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SectorWarningMessage;                              // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           HealVBox;                                          // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HealMessage;                                       // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HealProgress;                                      // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TeamKillMessage;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1350[0x8];                                     // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLWeaponListItem>         WeaponListItem;                                    // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponListShowTime;                                // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1351[0x4];                                     // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLWeaponListItem*>             ActiveWeaponListItems;                             // 0x0380(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           WeaponListVBox;                                    // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1352[0x8];                                     // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidget*                                SecondaryOutput;                                   // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                WarmupWidget;                                      // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisplayGameplayMessage(const class FText& Message, float LifeSpan);
	class UIngameCompass* GetCompassWidget();
	void HandleControlPointCapturedEvent(const class FText& ObjectiveName, const ETeam& CaptureTeam, const ETeam& PlayerTeam);
	void HandleDisplayControlPointState(const class ASeedingControlPoint* ControlPoint, const class FText& CaptureTeamState, const bool IsWithinHardCap);
	void HandleExplosiveDisarmedEvent(const class FText& ObjectiveName, const ETeam& PlantingTeam, const ETeam& PlayerTeam);
	void HandleExplosivePlantedEvent(const class FText& ObjectiveName, const ETeam& PlantingTeam, const ETeam& PlayerTeam);
	void HandleObjectiveDestroyedEvent(const class FText& ObjectiveName, const ETeam& PlantingTeam, const ETeam& PlayerTeam);
	void HandleOnEnterControlPoint(const class FText& ObjectiveName, const class ASeedingControlPoint* ControlPoint);
	void HandleOnExitControlPoint(const class ASeedingControlPoint* ControlPoint);
	void HandleOnPhaseChanged(const int32 CurrentPhaseID);
	void HandleSectorCapturedEvent(const struct FSectorCapturedInfo& DisplayInfo);
	void HideRconSayMessage();
	void OnAdminCamUIModeChanged(const bool bAdminMode);
	void OnEnterNewSector(bool IsLocked);
	void SetDisplayedSectorState(const struct FDisplayedSectorState& State);
	void SetRemainingTime(const class FText& Text);
	void SetSectorName(const class FText& SectorName);
	void SetTeamState(const struct FDisplayedTeamState& State);
	void SetWeapon(const class AShooterWeapon* InWeapon);
	void ShowNewRconSayMessage(const class FString& Message);
	void TriggerNoFireAnimation(const class FName Reason);
	void UpdatePlatoon();
	void UpdateTugOfWar(const TArray<struct FDisplayedSectorState>& OrderedSectors);
	void WeaponList_Display(const bool Display);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLHUDBase">();
	}
	static class UHLLHUDBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLHUDBase>();
	}
};
static_assert(alignof(UHLLHUDBase) == 0x000010, "Wrong alignment on UHLLHUDBase");
static_assert(sizeof(UHLLHUDBase) == 0x0003B0, "Wrong size on UHLLHUDBase");
static_assert(offsetof(UHLLHUDBase, WorldWidgetPanel) == 0x000230, "Member 'UHLLHUDBase::WorldWidgetPanel' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, WorldWidgetPanel_Toggleable) == 0x000238, "Member 'UHLLHUDBase::WorldWidgetPanel_Toggleable' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, ActiveIndicatorWidgets) == 0x000320, "Member 'UHLLHUDBase::ActiveIndicatorWidgets' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, SectorDisplayPriorities) == 0x000330, "Member 'UHLLHUDBase::SectorDisplayPriorities' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, SectorWarningMessage) == 0x000340, "Member 'UHLLHUDBase::SectorWarningMessage' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, HealVBox) == 0x000348, "Member 'UHLLHUDBase::HealVBox' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, HealMessage) == 0x000350, "Member 'UHLLHUDBase::HealMessage' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, HealProgress) == 0x000358, "Member 'UHLLHUDBase::HealProgress' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, TeamKillMessage) == 0x000360, "Member 'UHLLHUDBase::TeamKillMessage' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, WeaponListItem) == 0x000370, "Member 'UHLLHUDBase::WeaponListItem' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, WeaponListShowTime) == 0x000378, "Member 'UHLLHUDBase::WeaponListShowTime' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, ActiveWeaponListItems) == 0x000380, "Member 'UHLLHUDBase::ActiveWeaponListItems' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, WeaponListVBox) == 0x000390, "Member 'UHLLHUDBase::WeaponListVBox' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, SecondaryOutput) == 0x0003A0, "Member 'UHLLHUDBase::SecondaryOutput' has a wrong offset!");
static_assert(offsetof(UHLLHUDBase, WarmupWidget) == 0x0003A8, "Member 'UHLLHUDBase::WarmupWidget' has a wrong offset!");

// Class HLL.HLLIndicatorComponent_Marker
// 0x0000 (0x00C0 - 0x00C0)
class UHLLIndicatorComponent_Marker final : public UHLLIndicatorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLIndicatorComponent_Marker">();
	}
	static class UHLLIndicatorComponent_Marker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLIndicatorComponent_Marker>();
	}
};
static_assert(alignof(UHLLIndicatorComponent_Marker) == 0x000008, "Wrong alignment on UHLLIndicatorComponent_Marker");
static_assert(sizeof(UHLLIndicatorComponent_Marker) == 0x0000C0, "Wrong size on UHLLIndicatorComponent_Marker");

// Class HLL.HLLInputUtils
// 0x0000 (0x0028 - 0x0028)
class UHLLInputUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool IsUsingGamepad(const class UObject* WorldContextObject);
	static bool ShouldExecuteInput(const class UObject* WorldContextObject, const EHLLActionBindingMode BindingMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLInputUtils">();
	}
	static class UHLLInputUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLInputUtils>();
	}
};
static_assert(alignof(UHLLInputUtils) == 0x000008, "Wrong alignment on UHLLInputUtils");
static_assert(sizeof(UHLLInputUtils) == 0x000028, "Wrong size on UHLLInputUtils");

// Class HLL.HLLKeyText
// 0x0028 (0x02C8 - 0x02A0)
class UHLLKeyText final : public UTextBlock
{
public:
	class FText                                   DefaultText;                                       // 0x02A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FName                                   KeybindName;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsAxis : 1;                                       // 0x02C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowSquareBrackets : 1;                           // 0x02C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_135B[0x3];                                     // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         AxisScale;                                         // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetAxisKeybindScale(const float NewScale);
	void SetKeybindName(const class FName& InName);
	void SetKeybindType(const bool bAxisBinding);
	void UpdateBinding();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLKeyText">();
	}
	static class UHLLKeyText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLKeyText>();
	}
};
static_assert(alignof(UHLLKeyText) == 0x000008, "Wrong alignment on UHLLKeyText");
static_assert(sizeof(UHLLKeyText) == 0x0002C8, "Wrong size on UHLLKeyText");
static_assert(offsetof(UHLLKeyText, DefaultText) == 0x0002A0, "Member 'UHLLKeyText::DefaultText' has a wrong offset!");
static_assert(offsetof(UHLLKeyText, KeybindName) == 0x0002B8, "Member 'UHLLKeyText::KeybindName' has a wrong offset!");
static_assert(offsetof(UHLLKeyText, AxisScale) == 0x0002C4, "Member 'UHLLKeyText::AxisScale' has a wrong offset!");

// Class HLL.HLLLoaderUI
// 0x0020 (0x0290 - 0x0270)
class UHLLLoaderUI : public UHLLSeatWidgetBase
{
public:
	class UHLLArmourWeaponUI*                     ArtilleryWeaponInfo;                               // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         ReloadKeyText;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RotateKeyText;                                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         ShellKeyText;                                      // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLLoaderUI">();
	}
	static class UHLLLoaderUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLLoaderUI>();
	}
};
static_assert(alignof(UHLLLoaderUI) == 0x000008, "Wrong alignment on UHLLLoaderUI");
static_assert(sizeof(UHLLLoaderUI) == 0x000290, "Wrong size on UHLLLoaderUI");
static_assert(offsetof(UHLLLoaderUI, ArtilleryWeaponInfo) == 0x000270, "Member 'UHLLLoaderUI::ArtilleryWeaponInfo' has a wrong offset!");
static_assert(offsetof(UHLLLoaderUI, ReloadKeyText) == 0x000278, "Member 'UHLLLoaderUI::ReloadKeyText' has a wrong offset!");
static_assert(offsetof(UHLLLoaderUI, RotateKeyText) == 0x000280, "Member 'UHLLLoaderUI::RotateKeyText' has a wrong offset!");
static_assert(offsetof(UHLLLoaderUI, ShellKeyText) == 0x000288, "Member 'UHLLLoaderUI::ShellKeyText' has a wrong offset!");

// Class HLL.HLLMainMenuBase
// 0x0020 (0x0250 - 0x0230)
class UHLLMainMenuBase : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             BackDelegate;                                      // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         bCanZoom : 1;                                      // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_135C[0x7];                                     // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetSwitcher*                        PanelSwitcher;                                     // 0x0248(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BackDelegate__DelegateSignature();
	void ClearPendingEnlist();
	void CloseFieldManualFromWarRoom();
	void GoToHomePage();
	void GoToStorePage();
	void K2_OnCancelQuit();
	void OnPartyUpdated();
	void OnQuitGameDialog(const int32 OptionIndex);
	void OnQuitRequested();
	void SetBackgroundBlurVisibility(ESlateVisibility InVisibility);
	void SetZoomEnabled(const bool bEnabled);

	bool CanEnlist() const;
	bool HasPendingReturnToEnlist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMainMenuBase">();
	}
	static class UHLLMainMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMainMenuBase>();
	}
};
static_assert(alignof(UHLLMainMenuBase) == 0x000008, "Wrong alignment on UHLLMainMenuBase");
static_assert(sizeof(UHLLMainMenuBase) == 0x000250, "Wrong size on UHLLMainMenuBase");
static_assert(offsetof(UHLLMainMenuBase, BackDelegate) == 0x000230, "Member 'UHLLMainMenuBase::BackDelegate' has a wrong offset!");
static_assert(offsetof(UHLLMainMenuBase, PanelSwitcher) == 0x000248, "Member 'UHLLMainMenuBase::PanelSwitcher' has a wrong offset!");

// Class HLL.HLLMapComponent
// 0x0018 (0x00C8 - 0x00B0)
class UHLLMapComponent final : public UActorComponent
{
public:
	TSubclassOf<class AHLLMapDataBase>            DataClass;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoRegister : 1;                                 // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowClientSideCreation : 1;                      // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_135D[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AHLLMapDataBase*                        DataInstance;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DestroyMapData();
	void InitMapData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapComponent">();
	}
	static class UHLLMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapComponent>();
	}
};
static_assert(alignof(UHLLMapComponent) == 0x000008, "Wrong alignment on UHLLMapComponent");
static_assert(sizeof(UHLLMapComponent) == 0x0000C8, "Wrong size on UHLLMapComponent");
static_assert(offsetof(UHLLMapComponent, DataClass) == 0x0000B0, "Member 'UHLLMapComponent::DataClass' has a wrong offset!");
static_assert(offsetof(UHLLMapComponent, DataInstance) == 0x0000C0, "Member 'UHLLMapComponent::DataInstance' has a wrong offset!");

// Class HLL.HLLMapData_Ability
// 0x0008 (0x0250 - 0x0248)
class AHLLMapData_Ability final : public AHLLMapData_Basic
{
public:
	class AHLLCommanderAbility_Placeable*         AssignedAbility;                                   // 0x0248(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Ability">();
	}
	static class AHLLMapData_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Ability>();
	}
};
static_assert(alignof(AHLLMapData_Ability) == 0x000008, "Wrong alignment on AHLLMapData_Ability");
static_assert(sizeof(AHLLMapData_Ability) == 0x000250, "Wrong size on AHLLMapData_Ability");
static_assert(offsetof(AHLLMapData_Ability, AssignedAbility) == 0x000248, "Member 'AHLLMapData_Ability::AssignedAbility' has a wrong offset!");

// Class HLL.HLLMapData_ControlPoint
// 0x0000 (0x0238 - 0x0238)
class AHLLMapData_ControlPoint final : public AHLLMapDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_ControlPoint">();
	}
	static class AHLLMapData_ControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_ControlPoint>();
	}
};
static_assert(alignof(AHLLMapData_ControlPoint) == 0x000008, "Wrong alignment on AHLLMapData_ControlPoint");
static_assert(sizeof(AHLLMapData_ControlPoint) == 0x000238, "Wrong size on AHLLMapData_ControlPoint");

// Class HLL.HLLMapData_Flare
// 0x0008 (0x0250 - 0x0248)
class AHLLMapData_Flare : public AHLLMapData_Basic
{
public:
	float                                         FlareRadius;                                       // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135E[0x4];                                     // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Flare">();
	}
	static class AHLLMapData_Flare* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Flare>();
	}
};
static_assert(alignof(AHLLMapData_Flare) == 0x000008, "Wrong alignment on AHLLMapData_Flare");
static_assert(sizeof(AHLLMapData_Flare) == 0x000250, "Wrong size on AHLLMapData_Flare");
static_assert(offsetof(AHLLMapData_Flare, FlareRadius) == 0x000248, "Member 'AHLLMapData_Flare::FlareRadius' has a wrong offset!");

// Class HLL.HLLMapData_MobileSpawn
// 0x0000 (0x0248 - 0x0248)
class AHLLMapData_MobileSpawn final : public AHLLMapData_DynamicSpawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_MobileSpawn">();
	}
	static class AHLLMapData_MobileSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_MobileSpawn>();
	}
};
static_assert(alignof(AHLLMapData_MobileSpawn) == 0x000008, "Wrong alignment on AHLLMapData_MobileSpawn");
static_assert(sizeof(AHLLMapData_MobileSpawn) == 0x000248, "Wrong size on AHLLMapData_MobileSpawn");

// Class HLL.HLLMapData_Player
// 0x0020 (0x0258 - 0x0238)
class AHLLMapData_Player : public AHLLMapDataBase
{
public:
	uint8                                         PlayerYaw;                                         // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsSeated : 1;                                     // 0x0239(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_135F[0x6];                                     // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class APlayerState*                           PlayerState;                                       // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1360[0x10];                                    // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Player">();
	}
	static class AHLLMapData_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Player>();
	}
};
static_assert(alignof(AHLLMapData_Player) == 0x000008, "Wrong alignment on AHLLMapData_Player");
static_assert(sizeof(AHLLMapData_Player) == 0x000258, "Wrong size on AHLLMapData_Player");
static_assert(offsetof(AHLLMapData_Player, PlayerYaw) == 0x000238, "Member 'AHLLMapData_Player::PlayerYaw' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Player, PlayerState) == 0x000240, "Member 'AHLLMapData_Player::PlayerState' has a wrong offset!");

// Class HLL.HLLMapData_ReconItem
// 0x0020 (0x0268 - 0x0248)
class AHLLMapData_ReconItem : public AHLLMapData_Basic
{
public:
	struct FReconDataItem                         ReconData;                                         // 0x0248(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_ReconItem">();
	}
	static class AHLLMapData_ReconItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_ReconItem>();
	}
};
static_assert(alignof(AHLLMapData_ReconItem) == 0x000008, "Wrong alignment on AHLLMapData_ReconItem");
static_assert(sizeof(AHLLMapData_ReconItem) == 0x000268, "Wrong size on AHLLMapData_ReconItem");
static_assert(offsetof(AHLLMapData_ReconItem, ReconData) == 0x000248, "Member 'AHLLMapData_ReconItem::ReconData' has a wrong offset!");

// Class HLL.HLLUI_NetworkNotifications
// 0x0008 (0x0238 - 0x0230)
class UHLLUI_NetworkNotifications final : public UUserWidget
{
public:
	uint8                                         Pad_1361[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void UpdateHighPacketLossIconVisibility(const bool HighPacketLoss);
	void UpdateHighPingIconVisibility(const bool HighPing);
	void UpdateStrictNatIconVisibility(const bool NatStrict);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_NetworkNotifications">();
	}
	static class UHLLUI_NetworkNotifications* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_NetworkNotifications>();
	}
};
static_assert(alignof(UHLLUI_NetworkNotifications) == 0x000008, "Wrong alignment on UHLLUI_NetworkNotifications");
static_assert(sizeof(UHLLUI_NetworkNotifications) == 0x000238, "Wrong size on UHLLUI_NetworkNotifications");

// Class HLL.HLLMapData_ResourceNode
// 0x0000 (0x0248 - 0x0248)
class AHLLMapData_ResourceNode : public AHLLMapData_Basic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_ResourceNode">();
	}
	static class AHLLMapData_ResourceNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_ResourceNode>();
	}
};
static_assert(alignof(AHLLMapData_ResourceNode) == 0x000008, "Wrong alignment on AHLLMapData_ResourceNode");
static_assert(sizeof(AHLLMapData_ResourceNode) == 0x000248, "Wrong size on AHLLMapData_ResourceNode");

// Class HLL.HLLMapData_Sector
// 0x0008 (0x0240 - 0x0238)
class AHLLMapData_Sector : public AHLLMapDataBase
{
public:
	uint8                                         Pad_1362[0x8];                                     // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Sector">();
	}
	static class AHLLMapData_Sector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Sector>();
	}
};
static_assert(alignof(AHLLMapData_Sector) == 0x000008, "Wrong alignment on AHLLMapData_Sector");
static_assert(sizeof(AHLLMapData_Sector) == 0x000240, "Wrong size on AHLLMapData_Sector");

// Class HLL.HLLSeatIcon
// 0x0050 (0x0280 - 0x0230)
class UHLLSeatIcon : public UUserWidget
{
public:
	class FText                                   EmptyOccupantText;                                 // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RestrictedSeatText;                                // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UBorder*                                SeatBorder;                                        // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OccupantName;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SeatIcon;                                          // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SwitchToKeyName;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatIcon">();
	}
	static class UHLLSeatIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSeatIcon>();
	}
};
static_assert(alignof(UHLLSeatIcon) == 0x000008, "Wrong alignment on UHLLSeatIcon");
static_assert(sizeof(UHLLSeatIcon) == 0x000280, "Wrong size on UHLLSeatIcon");
static_assert(offsetof(UHLLSeatIcon, EmptyOccupantText) == 0x000230, "Member 'UHLLSeatIcon::EmptyOccupantText' has a wrong offset!");
static_assert(offsetof(UHLLSeatIcon, RestrictedSeatText) == 0x000248, "Member 'UHLLSeatIcon::RestrictedSeatText' has a wrong offset!");
static_assert(offsetof(UHLLSeatIcon, SeatBorder) == 0x000260, "Member 'UHLLSeatIcon::SeatBorder' has a wrong offset!");
static_assert(offsetof(UHLLSeatIcon, OccupantName) == 0x000268, "Member 'UHLLSeatIcon::OccupantName' has a wrong offset!");
static_assert(offsetof(UHLLSeatIcon, SeatIcon) == 0x000270, "Member 'UHLLSeatIcon::SeatIcon' has a wrong offset!");
static_assert(offsetof(UHLLSeatIcon, SwitchToKeyName) == 0x000278, "Member 'UHLLSeatIcon::SwitchToKeyName' has a wrong offset!");

// Class HLL.HLLMapData_SectorBooster
// 0x0000 (0x0238 - 0x0238)
class AHLLMapData_SectorBooster : public AHLLMapDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_SectorBooster">();
	}
	static class AHLLMapData_SectorBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_SectorBooster>();
	}
};
static_assert(alignof(AHLLMapData_SectorBooster) == 0x000008, "Wrong alignment on AHLLMapData_SectorBooster");
static_assert(sizeof(AHLLMapData_SectorBooster) == 0x000238, "Wrong size on AHLLMapData_SectorBooster");

// Class HLL.HLLMapData_Supplies
// 0x0008 (0x0250 - 0x0248)
class AHLLMapData_Supplies : public AHLLMapData_Basic
{
public:
	ESupplyType                                   SupplyType;                                        // 0x0248(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1363[0x1];                                     // 0x0249(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	uint16                                        SuppliesRemaining;                                 // 0x024A(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1364[0x4];                                     // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapData_Supplies">();
	}
	static class AHLLMapData_Supplies* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMapData_Supplies>();
	}
};
static_assert(alignof(AHLLMapData_Supplies) == 0x000008, "Wrong alignment on AHLLMapData_Supplies");
static_assert(sizeof(AHLLMapData_Supplies) == 0x000250, "Wrong size on AHLLMapData_Supplies");
static_assert(offsetof(AHLLMapData_Supplies, SupplyType) == 0x000248, "Member 'AHLLMapData_Supplies::SupplyType' has a wrong offset!");
static_assert(offsetof(AHLLMapData_Supplies, SuppliesRemaining) == 0x00024A, "Member 'AHLLMapData_Supplies::SuppliesRemaining' has a wrong offset!");

// Class HLL.HLLUI_RoleItem
// 0x0038 (0x0268 - 0x0230)
class UHLLUI_RoleItem : public UUserWidget
{
public:
	TWeakObjectPtr<class UHLLUI_CharacterSelection> ParentPanel;                                       // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerRole                                   Role;                                              // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1365[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UCheckBox*                              FavouriteChecker;                                  // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RoleIcon;                                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RoleName;                                          // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RoleLevel;                                         // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           RoleLevelProgress;                                 // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_NotifySelectionChanged(const EFaction InFaction, const bool bThisIsSelected, const bool bThisIsFavourite);
	void OnRolePressed();
	void OnSelected();
	void OnToggleFavourite();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_RoleItem">();
	}
	static class UHLLUI_RoleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_RoleItem>();
	}
};
static_assert(alignof(UHLLUI_RoleItem) == 0x000008, "Wrong alignment on UHLLUI_RoleItem");
static_assert(sizeof(UHLLUI_RoleItem) == 0x000268, "Wrong size on UHLLUI_RoleItem");
static_assert(offsetof(UHLLUI_RoleItem, ParentPanel) == 0x000230, "Member 'UHLLUI_RoleItem::ParentPanel' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleItem, Role) == 0x000238, "Member 'UHLLUI_RoleItem::Role' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleItem, FavouriteChecker) == 0x000240, "Member 'UHLLUI_RoleItem::FavouriteChecker' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleItem, RoleIcon) == 0x000248, "Member 'UHLLUI_RoleItem::RoleIcon' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleItem, RoleName) == 0x000250, "Member 'UHLLUI_RoleItem::RoleName' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleItem, RoleLevel) == 0x000258, "Member 'UHLLUI_RoleItem::RoleLevel' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleItem, RoleLevelProgress) == 0x000260, "Member 'UHLLUI_RoleItem::RoleLevelProgress' has a wrong offset!");

// Class HLL.HLLUI_LoadoutTooltip
// 0x0018 (0x0248 - 0x0230)
class UHLLUI_LoadoutTooltip : public UUserWidget
{
public:
	class UTextBlock*                             ItemName;                                          // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RequirementText;                                   // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitInfo(const struct FLoadout& LoadoutInfo);
	void InitTooltip(class UHLLUI_Loadout* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_LoadoutTooltip">();
	}
	static class UHLLUI_LoadoutTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_LoadoutTooltip>();
	}
};
static_assert(alignof(UHLLUI_LoadoutTooltip) == 0x000008, "Wrong alignment on UHLLUI_LoadoutTooltip");
static_assert(sizeof(UHLLUI_LoadoutTooltip) == 0x000248, "Wrong size on UHLLUI_LoadoutTooltip");
static_assert(offsetof(UHLLUI_LoadoutTooltip, ItemName) == 0x000230, "Member 'UHLLUI_LoadoutTooltip::ItemName' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutTooltip, RequirementText) == 0x000238, "Member 'UHLLUI_LoadoutTooltip::RequirementText' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutTooltip, ViewportClient) == 0x000240, "Member 'UHLLUI_LoadoutTooltip::ViewportClient' has a wrong offset!");

// Class HLL.HLLMapIcon_Ability
// 0x0028 (0x0390 - 0x0368)
class UHLLMapIcon_Ability final : public UHLLMapIconBase
{
public:
	int32                                         PlacingPriority;                                   // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1366[0x4];                                     // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 DirectionIndicator;                                // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ProgressIndicator;                                 // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               CoverageIndicator;                                 // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                CoverageBorder;                                    // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Ability">();
	}
	static class UHLLMapIcon_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Ability>();
	}
};
static_assert(alignof(UHLLMapIcon_Ability) == 0x000008, "Wrong alignment on UHLLMapIcon_Ability");
static_assert(sizeof(UHLLMapIcon_Ability) == 0x000390, "Wrong size on UHLLMapIcon_Ability");
static_assert(offsetof(UHLLMapIcon_Ability, PlacingPriority) == 0x000368, "Member 'UHLLMapIcon_Ability::PlacingPriority' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Ability, DirectionIndicator) == 0x000370, "Member 'UHLLMapIcon_Ability::DirectionIndicator' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Ability, ProgressIndicator) == 0x000378, "Member 'UHLLMapIcon_Ability::ProgressIndicator' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Ability, CoverageIndicator) == 0x000380, "Member 'UHLLMapIcon_Ability::CoverageIndicator' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Ability, CoverageBorder) == 0x000388, "Member 'UHLLMapIcon_Ability::CoverageBorder' has a wrong offset!");

// Class HLL.HLLSeatHealthStatus
// 0x0020 (0x0250 - 0x0230)
class UHLLSeatHealthStatus : public UUserWidget
{
public:
	class UHLLArmourHealthComponent*              HealthComponent;                                   // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLSeatHealthStatusItem*>       Items;                                             // 0x0238(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                RepairInProgressWidget;                            // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PostAssignHealthComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatHealthStatus">();
	}
	static class UHLLSeatHealthStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSeatHealthStatus>();
	}
};
static_assert(alignof(UHLLSeatHealthStatus) == 0x000008, "Wrong alignment on UHLLSeatHealthStatus");
static_assert(sizeof(UHLLSeatHealthStatus) == 0x000250, "Wrong size on UHLLSeatHealthStatus");
static_assert(offsetof(UHLLSeatHealthStatus, HealthComponent) == 0x000230, "Member 'UHLLSeatHealthStatus::HealthComponent' has a wrong offset!");
static_assert(offsetof(UHLLSeatHealthStatus, Items) == 0x000238, "Member 'UHLLSeatHealthStatus::Items' has a wrong offset!");
static_assert(offsetof(UHLLSeatHealthStatus, RepairInProgressWidget) == 0x000248, "Member 'UHLLSeatHealthStatus::RepairInProgressWidget' has a wrong offset!");

// Class HLL.HLLMapIcon_AdminCam
// 0x0008 (0x0370 - 0x0368)
class UHLLMapIcon_AdminCam : public UHLLMapIconBase
{
public:
	class UWidget*                                RotationContainer;                                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_AdminCam">();
	}
	static class UHLLMapIcon_AdminCam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_AdminCam>();
	}
};
static_assert(alignof(UHLLMapIcon_AdminCam) == 0x000008, "Wrong alignment on UHLLMapIcon_AdminCam");
static_assert(sizeof(UHLLMapIcon_AdminCam) == 0x000370, "Wrong size on UHLLMapIcon_AdminCam");
static_assert(offsetof(UHLLMapIcon_AdminCam, RotationContainer) == 0x000368, "Member 'UHLLMapIcon_AdminCam::RotationContainer' has a wrong offset!");

// Class HLL.HLLMapIcon_SpawnBase
// 0x0140 (0x04A8 - 0x0368)
class UHLLMapIcon_SpawnBase : public UHLLMapIconBase
{
public:
	struct FLinearColor                           DotColour_Selected;                                // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DotColour_Unselected;                              // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DotColour_EnemyNear;                               // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GradientColour_Default;                            // 0x0398(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GradientColour_Selected;                           // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GradientColour_Pulsing;                            // 0x03B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GradientColour_EnemyNear;                          // 0x03C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectionRingColour_Default;                       // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectionRingColour_EnemyNear;                     // 0x03E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconColour_Default;                                // 0x03F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconColour_Platoon;                                // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconColour_Enemy;                                  // 0x0418(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bColouriseIconWhenSelected : 1;                    // 0x0428(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1367[0x3];                                     // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FLinearColor                           IconColour_Selected;                               // 0x042C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PulseColour_Platoon;                               // 0x043C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PulseColour_Ally;                                  // 0x044C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1368[0x4];                                     // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 IconDot;                                           // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Gradient;                                          // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PulseRing;                                         // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SelectionRing;                                     // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlatoonIDText;                                     // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NearbyEnemyIndicator;                              // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_PulseLoop;                                    // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_SelectedLoop;                                 // 0x0498(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Selected;                                     // 0x04A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnShouldBePulsingChanged(const bool bShouldPulse);

	bool CanPlayerSpawnHere() const;
	bool ShouldBePulsing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_SpawnBase">();
	}
	static class UHLLMapIcon_SpawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_SpawnBase>();
	}
};
static_assert(alignof(UHLLMapIcon_SpawnBase) == 0x000008, "Wrong alignment on UHLLMapIcon_SpawnBase");
static_assert(sizeof(UHLLMapIcon_SpawnBase) == 0x0004A8, "Wrong size on UHLLMapIcon_SpawnBase");
static_assert(offsetof(UHLLMapIcon_SpawnBase, DotColour_Selected) == 0x000368, "Member 'UHLLMapIcon_SpawnBase::DotColour_Selected' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, DotColour_Unselected) == 0x000378, "Member 'UHLLMapIcon_SpawnBase::DotColour_Unselected' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, DotColour_EnemyNear) == 0x000388, "Member 'UHLLMapIcon_SpawnBase::DotColour_EnemyNear' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, GradientColour_Default) == 0x000398, "Member 'UHLLMapIcon_SpawnBase::GradientColour_Default' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, GradientColour_Selected) == 0x0003A8, "Member 'UHLLMapIcon_SpawnBase::GradientColour_Selected' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, GradientColour_Pulsing) == 0x0003B8, "Member 'UHLLMapIcon_SpawnBase::GradientColour_Pulsing' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, GradientColour_EnemyNear) == 0x0003C8, "Member 'UHLLMapIcon_SpawnBase::GradientColour_EnemyNear' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, SelectionRingColour_Default) == 0x0003D8, "Member 'UHLLMapIcon_SpawnBase::SelectionRingColour_Default' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, SelectionRingColour_EnemyNear) == 0x0003E8, "Member 'UHLLMapIcon_SpawnBase::SelectionRingColour_EnemyNear' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, IconColour_Default) == 0x0003F8, "Member 'UHLLMapIcon_SpawnBase::IconColour_Default' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, IconColour_Platoon) == 0x000408, "Member 'UHLLMapIcon_SpawnBase::IconColour_Platoon' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, IconColour_Enemy) == 0x000418, "Member 'UHLLMapIcon_SpawnBase::IconColour_Enemy' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, IconColour_Selected) == 0x00042C, "Member 'UHLLMapIcon_SpawnBase::IconColour_Selected' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, PulseColour_Platoon) == 0x00043C, "Member 'UHLLMapIcon_SpawnBase::PulseColour_Platoon' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, PulseColour_Ally) == 0x00044C, "Member 'UHLLMapIcon_SpawnBase::PulseColour_Ally' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, IconDot) == 0x000460, "Member 'UHLLMapIcon_SpawnBase::IconDot' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, Gradient) == 0x000468, "Member 'UHLLMapIcon_SpawnBase::Gradient' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, PulseRing) == 0x000470, "Member 'UHLLMapIcon_SpawnBase::PulseRing' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, SelectionRing) == 0x000478, "Member 'UHLLMapIcon_SpawnBase::SelectionRing' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, PlatoonIDText) == 0x000480, "Member 'UHLLMapIcon_SpawnBase::PlatoonIDText' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, NearbyEnemyIndicator) == 0x000488, "Member 'UHLLMapIcon_SpawnBase::NearbyEnemyIndicator' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, Anim_PulseLoop) == 0x000490, "Member 'UHLLMapIcon_SpawnBase::Anim_PulseLoop' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, Anim_SelectedLoop) == 0x000498, "Member 'UHLLMapIcon_SpawnBase::Anim_SelectedLoop' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_SpawnBase, Anim_Selected) == 0x0004A0, "Member 'UHLLMapIcon_SpawnBase::Anim_Selected' has a wrong offset!");

// Class HLL.HLLSeat_ArtilleryBase
// 0x0010 (0x09D0 - 0x09C0)
class AHLLSeat_ArtilleryBase : public AHLLSeat
{
public:
	class USoundBase*                             HitSound;                                          // 0x09C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1369[0x8];                                     // 0x09C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void NotifyOccupantDealtDamage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeat_ArtilleryBase">();
	}
	static class AHLLSeat_ArtilleryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSeat_ArtilleryBase>();
	}
};
static_assert(alignof(AHLLSeat_ArtilleryBase) == 0x000010, "Wrong alignment on AHLLSeat_ArtilleryBase");
static_assert(sizeof(AHLLSeat_ArtilleryBase) == 0x0009D0, "Wrong size on AHLLSeat_ArtilleryBase");
static_assert(offsetof(AHLLSeat_ArtilleryBase, HitSound) == 0x0009C0, "Member 'AHLLSeat_ArtilleryBase::HitSound' has a wrong offset!");

// Class HLL.HLLSeat_ArtilleryLoader
// 0x0000 (0x09D0 - 0x09D0)
class AHLLSeat_ArtilleryLoader : public AHLLSeat_ArtilleryBase
{
public:
	void Server_LoadAmmo(const uint8 SelectedAmmo);
	void Server_RequestRotation(const struct FPitchYawControllerTargetRotationValues& TargetRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeat_ArtilleryLoader">();
	}
	static class AHLLSeat_ArtilleryLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSeat_ArtilleryLoader>();
	}
};
static_assert(alignof(AHLLSeat_ArtilleryLoader) == 0x000010, "Wrong alignment on AHLLSeat_ArtilleryLoader");
static_assert(sizeof(AHLLSeat_ArtilleryLoader) == 0x0009D0, "Wrong size on AHLLSeat_ArtilleryLoader");

// Class HLL.HLLMapIcon_Airhead
// 0x0000 (0x04A8 - 0x04A8)
class UHLLMapIcon_Airhead : public UHLLMapIcon_SpawnBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Airhead">();
	}
	static class UHLLMapIcon_Airhead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Airhead>();
	}
};
static_assert(alignof(UHLLMapIcon_Airhead) == 0x000008, "Wrong alignment on UHLLMapIcon_Airhead");
static_assert(sizeof(UHLLMapIcon_Airhead) == 0x0004A8, "Wrong size on UHLLMapIcon_Airhead");

// Class HLL.HLLSeatNameplateContainer
// 0x0038 (0x02F8 - 0x02C0)
class UHLLSeatNameplateContainer final : public UHLLNameplateIndicatorBase
{
public:
	TSubclassOf<class UHLLSeatIndicatorItem>      ItemClass;                                         // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowOnlyDriver : 1;                               // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowPassengerCount : 1;                           // 0x02C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_136A[0x7];                                     // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLSeatIndicatorItem*>          ItemWidgets;                                       // 0x02D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           OccupantVBox;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                AdditionalOccupants;                               // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalOccupantText;                            // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatNameplateContainer">();
	}
	static class UHLLSeatNameplateContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSeatNameplateContainer>();
	}
};
static_assert(alignof(UHLLSeatNameplateContainer) == 0x000008, "Wrong alignment on UHLLSeatNameplateContainer");
static_assert(sizeof(UHLLSeatNameplateContainer) == 0x0002F8, "Wrong size on UHLLSeatNameplateContainer");
static_assert(offsetof(UHLLSeatNameplateContainer, ItemClass) == 0x0002C0, "Member 'UHLLSeatNameplateContainer::ItemClass' has a wrong offset!");
static_assert(offsetof(UHLLSeatNameplateContainer, ItemWidgets) == 0x0002D0, "Member 'UHLLSeatNameplateContainer::ItemWidgets' has a wrong offset!");
static_assert(offsetof(UHLLSeatNameplateContainer, OccupantVBox) == 0x0002E0, "Member 'UHLLSeatNameplateContainer::OccupantVBox' has a wrong offset!");
static_assert(offsetof(UHLLSeatNameplateContainer, AdditionalOccupants) == 0x0002E8, "Member 'UHLLSeatNameplateContainer::AdditionalOccupants' has a wrong offset!");
static_assert(offsetof(UHLLSeatNameplateContainer, AdditionalOccupantText) == 0x0002F0, "Member 'UHLLSeatNameplateContainer::AdditionalOccupantText' has a wrong offset!");

// Class HLL.HLLMapIcon_Artillery
// 0x0000 (0x0370 - 0x0370)
class UHLLMapIcon_Artillery : public UHLLMapIcon_SeatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Artillery">();
	}
	static class UHLLMapIcon_Artillery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Artillery>();
	}
};
static_assert(alignof(UHLLMapIcon_Artillery) == 0x000008, "Wrong alignment on UHLLMapIcon_Artillery");
static_assert(sizeof(UHLLMapIcon_Artillery) == 0x000370, "Wrong size on UHLLMapIcon_Artillery");

// Class HLL.HLLMapIcon_BaseLineSectorSpawn
// 0x0000 (0x04A8 - 0x04A8)
class UHLLMapIcon_BaseLineSectorSpawn : public UHLLMapIcon_SpawnBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_BaseLineSectorSpawn">();
	}
	static class UHLLMapIcon_BaseLineSectorSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_BaseLineSectorSpawn>();
	}
};
static_assert(alignof(UHLLMapIcon_BaseLineSectorSpawn) == 0x000008, "Wrong alignment on UHLLMapIcon_BaseLineSectorSpawn");
static_assert(sizeof(UHLLMapIcon_BaseLineSectorSpawn) == 0x0004A8, "Wrong size on UHLLMapIcon_BaseLineSectorSpawn");

// Class HLL.HLLScrollBox
// 0x0000 (0x0880 - 0x0880)
class UHLLScrollBox final : public UScrollBox
{
public:
	bool IsScrollBarVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLScrollBox">();
	}
	static class UHLLScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLScrollBox>();
	}
};
static_assert(alignof(UHLLScrollBox) == 0x000008, "Wrong alignment on UHLLScrollBox");
static_assert(sizeof(UHLLScrollBox) == 0x000880, "Wrong size on UHLLScrollBox");

// Class HLL.HLLMapIcon_Flare
// 0x0008 (0x0370 - 0x0368)
class UHLLMapIcon_Flare : public UHLLMapIcon_Basic
{
public:
	class USizeBox*                               FlareRadiusSizer;                                  // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Flare">();
	}
	static class UHLLMapIcon_Flare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Flare>();
	}
};
static_assert(alignof(UHLLMapIcon_Flare) == 0x000008, "Wrong alignment on UHLLMapIcon_Flare");
static_assert(sizeof(UHLLMapIcon_Flare) == 0x000370, "Wrong size on UHLLMapIcon_Flare");
static_assert(offsetof(UHLLMapIcon_Flare, FlareRadiusSizer) == 0x000368, "Member 'UHLLMapIcon_Flare::FlareRadiusSizer' has a wrong offset!");

// Class HLL.HLLMapIcon_ForwardPosition
// 0x0010 (0x04B8 - 0x04A8)
class UHLLMapIcon_ForwardPosition : public UHLLMapIcon_SpawnBase
{
public:
	float                                         ForwardPositionRadiusSize;                         // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_136B[0x4];                                     // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USizeBox*                               RadiusSBox;                                        // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_ForwardPosition">();
	}
	static class UHLLMapIcon_ForwardPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_ForwardPosition>();
	}
};
static_assert(alignof(UHLLMapIcon_ForwardPosition) == 0x000008, "Wrong alignment on UHLLMapIcon_ForwardPosition");
static_assert(sizeof(UHLLMapIcon_ForwardPosition) == 0x0004B8, "Wrong size on UHLLMapIcon_ForwardPosition");
static_assert(offsetof(UHLLMapIcon_ForwardPosition, ForwardPositionRadiusSize) == 0x0004A8, "Member 'UHLLMapIcon_ForwardPosition::ForwardPositionRadiusSize' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_ForwardPosition, RadiusSBox) == 0x0004B0, "Member 'UHLLMapIcon_ForwardPosition::RadiusSBox' has a wrong offset!");

// Class HLL.HLLSpawnClearInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLSpawnClearInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSpawnClearInterface">();
	}
	static class IHLLSpawnClearInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLSpawnClearInterface>();
	}
};
static_assert(alignof(IHLLSpawnClearInterface) == 0x000008, "Wrong alignment on IHLLSpawnClearInterface");
static_assert(sizeof(IHLLSpawnClearInterface) == 0x000028, "Wrong size on IHLLSpawnClearInterface");

// Class HLL.HLLMapIcon_Garrison
// 0x0000 (0x04A8 - 0x04A8)
class UHLLMapIcon_Garrison : public UHLLMapIcon_SpawnBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Garrison">();
	}
	static class UHLLMapIcon_Garrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Garrison>();
	}
};
static_assert(alignof(UHLLMapIcon_Garrison) == 0x000008, "Wrong alignment on UHLLMapIcon_Garrison");
static_assert(sizeof(UHLLMapIcon_Garrison) == 0x0004A8, "Wrong size on UHLLMapIcon_Garrison");

// Class HLL.HLLSectorIndicator
// 0x0078 (0x0328 - 0x02B0)
class UHLLSectorIndicator : public UHLLIndicatorBase
{
public:
	class UTextBlock*                             SectorNameText;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CaptureProgress_Friendly;                          // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CaptureProgress_Enemy;                             // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CurrentCap;                                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DistanceText;                                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ResourceBrush;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FlagBrush;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AnimExpandCollapse;                                // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExpandedState;                                    // 0x02F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_136C[0x3];                                     // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ExpandedAngle;                                     // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Colour_Neutral;                                    // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Colour_Friendly;                                   // 0x0308(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Colour_Enemy;                                      // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_SetExpandedState(const bool bIsExpanded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSectorIndicator">();
	}
	static class UHLLSectorIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSectorIndicator>();
	}
};
static_assert(alignof(UHLLSectorIndicator) == 0x000008, "Wrong alignment on UHLLSectorIndicator");
static_assert(sizeof(UHLLSectorIndicator) == 0x000328, "Wrong size on UHLLSectorIndicator");
static_assert(offsetof(UHLLSectorIndicator, SectorNameText) == 0x0002B0, "Member 'UHLLSectorIndicator::SectorNameText' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, CaptureProgress_Friendly) == 0x0002B8, "Member 'UHLLSectorIndicator::CaptureProgress_Friendly' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, CaptureProgress_Enemy) == 0x0002C0, "Member 'UHLLSectorIndicator::CaptureProgress_Enemy' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, CurrentCap) == 0x0002C8, "Member 'UHLLSectorIndicator::CurrentCap' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, DistanceText) == 0x0002D0, "Member 'UHLLSectorIndicator::DistanceText' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, ResourceBrush) == 0x0002D8, "Member 'UHLLSectorIndicator::ResourceBrush' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, FlagBrush) == 0x0002E0, "Member 'UHLLSectorIndicator::FlagBrush' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, AnimExpandCollapse) == 0x0002E8, "Member 'UHLLSectorIndicator::AnimExpandCollapse' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, bExpandedState) == 0x0002F0, "Member 'UHLLSectorIndicator::bExpandedState' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, ExpandedAngle) == 0x0002F4, "Member 'UHLLSectorIndicator::ExpandedAngle' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, Colour_Neutral) == 0x0002F8, "Member 'UHLLSectorIndicator::Colour_Neutral' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, Colour_Friendly) == 0x000308, "Member 'UHLLSectorIndicator::Colour_Friendly' has a wrong offset!");
static_assert(offsetof(UHLLSectorIndicator, Colour_Enemy) == 0x000318, "Member 'UHLLSectorIndicator::Colour_Enemy' has a wrong offset!");

// Class HLL.HLLMapIcon_MobileSpawn
// 0x0000 (0x04A8 - 0x04A8)
class UHLLMapIcon_MobileSpawn final : public UHLLMapIcon_SpawnBase
{
public:
	bool IsBlockedByLockedEnemySector() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_MobileSpawn">();
	}
	static class UHLLMapIcon_MobileSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_MobileSpawn>();
	}
};
static_assert(alignof(UHLLMapIcon_MobileSpawn) == 0x000008, "Wrong alignment on UHLLMapIcon_MobileSpawn");
static_assert(sizeof(UHLLMapIcon_MobileSpawn) == 0x0004A8, "Wrong size on UHLLMapIcon_MobileSpawn");

// Class HLL.HLLMapIcon_Outpost
// 0x0198 (0x0640 - 0x04A8)
class UHLLMapIcon_Outpost : public UHLLMapIcon_SpawnBase
{
public:
	struct FSlateBrush                            UnitOutpostIcon;                                   // 0x04A8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            TeamOutpostIcon;                                   // 0x0530(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ReconOutpostIcon;                                  // 0x05B8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	struct FSlateBrush GetIcon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Outpost">();
	}
	static class UHLLMapIcon_Outpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Outpost>();
	}
};
static_assert(alignof(UHLLMapIcon_Outpost) == 0x000008, "Wrong alignment on UHLLMapIcon_Outpost");
static_assert(sizeof(UHLLMapIcon_Outpost) == 0x000640, "Wrong size on UHLLMapIcon_Outpost");
static_assert(offsetof(UHLLMapIcon_Outpost, UnitOutpostIcon) == 0x0004A8, "Member 'UHLLMapIcon_Outpost::UnitOutpostIcon' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Outpost, TeamOutpostIcon) == 0x000530, "Member 'UHLLMapIcon_Outpost::TeamOutpostIcon' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Outpost, ReconOutpostIcon) == 0x0005B8, "Member 'UHLLMapIcon_Outpost::ReconOutpostIcon' has a wrong offset!");

// Class HLL.HLLSeatInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLSeatInterface final : public IInterface
{
public:
	void DestroySeats();
	void OnRep_AnySeat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatInterface">();
	}
	static class IHLLSeatInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLSeatInterface>();
	}
};
static_assert(alignof(IHLLSeatInterface) == 0x000008, "Wrong alignment on IHLLSeatInterface");
static_assert(sizeof(IHLLSeatInterface) == 0x000028, "Wrong size on IHLLSeatInterface");

// Class HLL.HLLMapIcon_PlantObjective
// 0x0018 (0x0380 - 0x0368)
class UHLLMapIcon_PlantObjective final : public UHLLMapIconBase
{
public:
	class UTextBlock*                             ObjectiveNameText;                                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBanner;                                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NearbyEnemyIndicator;                              // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_PlantObjective">();
	}
	static class UHLLMapIcon_PlantObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_PlantObjective>();
	}
};
static_assert(alignof(UHLLMapIcon_PlantObjective) == 0x000008, "Wrong alignment on UHLLMapIcon_PlantObjective");
static_assert(sizeof(UHLLMapIcon_PlantObjective) == 0x000380, "Wrong size on UHLLMapIcon_PlantObjective");
static_assert(offsetof(UHLLMapIcon_PlantObjective, ObjectiveNameText) == 0x000368, "Member 'UHLLMapIcon_PlantObjective::ObjectiveNameText' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_PlantObjective, ProgressBanner) == 0x000370, "Member 'UHLLMapIcon_PlantObjective::ProgressBanner' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_PlantObjective, NearbyEnemyIndicator) == 0x000378, "Member 'UHLLMapIcon_PlantObjective::NearbyEnemyIndicator' has a wrong offset!");

// Class HLL.HLLSnapComponent
// 0x0010 (0x0200 - 0x01F0)
class UHLLSnapComponent final : public USceneComponent
{
public:
	TArray<struct FSnapPlane>                     SnapPlanes;                                        // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool FindClosestSnapForGroupAndSockets(const TArray<class UHLLSnapComponent*>& SnapComponents, const TMap<class FName, struct FTransform>& Sockets, int32* ComponentIndex, int32* SnapIndex, class FName* Socket, struct FVector2D* SnapPosition, float* WorldDistSqrd, const struct FSnapQueryParams& QParams);

	void BuildQueryBlacklist(TSet<int32>* OutBlacklist, const struct FSnapQueryParams& QParams) const;
	bool ComputeSnapActorTransform(const int32 SnapIndex, const struct FVector2D& SnapPosition, const struct FTransform& SocketToActor, struct FTransform* ActorTransform, const float SnapRotation) const;
	bool ComputeSnapSocketTransform(const int32 SnapIndex, const struct FVector2D& SnapPosition, struct FTransform* SocketTransform, const float SnapRotation) const;
	void DrawSnapPlanes(const struct FColor& Colour, const struct FColor& SecondaryColour, const int32 SecondaryIndex, float Time, const float Thickness) const;
	int32 FindClosestSnap(const struct FVector& WorldLocation, const struct FVector& WorldDirection, struct FVector2D* SnapPosition, float* WorldDistSqrd, const TSet<int32>& Blacklist) const;
	int32 FindClosestSnapForSockets(const TMap<class FName, struct FTransform>& Sockets, class FName* BestSocket, struct FVector2D* SnapPosition, float* WorldDistSqrd, const TSet<int32>& Blacklist) const;
	bool ProjectVectorToSnapSurface(const int32 SnapIndex, struct FVector* Vector) const;
	bool SnapSurfaceNormal(const int32 SnapIndex, struct FVector* Normal) const;
	bool SnapWorldPosition(const int32 SnapIndex, const struct FVector2D& SnapPosition, struct FVector* WorldPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSnapComponent">();
	}
	static class UHLLSnapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSnapComponent>();
	}
};
static_assert(alignof(UHLLSnapComponent) == 0x000010, "Wrong alignment on UHLLSnapComponent");
static_assert(sizeof(UHLLSnapComponent) == 0x000200, "Wrong size on UHLLSnapComponent");
static_assert(offsetof(UHLLSnapComponent, SnapPlanes) == 0x0001F0, "Member 'UHLLSnapComponent::SnapPlanes' has a wrong offset!");

// Class HLL.HLLMapIcon_ReconItem
// 0x0000 (0x0368 - 0x0368)
class UHLLMapIcon_ReconItem : public UHLLMapIcon_Basic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_ReconItem">();
	}
	static class UHLLMapIcon_ReconItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_ReconItem>();
	}
};
static_assert(alignof(UHLLMapIcon_ReconItem) == 0x000008, "Wrong alignment on UHLLMapIcon_ReconItem");
static_assert(sizeof(UHLLMapIcon_ReconItem) == 0x000368, "Wrong size on UHLLMapIcon_ReconItem");

// Class HLL.HLLSupplyIndicator
// 0x0008 (0x02B8 - 0x02B0)
class UHLLSupplyIndicator : public UHLLIndicatorBase
{
public:
	class UTextBlock*                             SupplyText;                                        // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSupplyIndicator">();
	}
	static class UHLLSupplyIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSupplyIndicator>();
	}
};
static_assert(alignof(UHLLSupplyIndicator) == 0x000008, "Wrong alignment on UHLLSupplyIndicator");
static_assert(sizeof(UHLLSupplyIndicator) == 0x0002B8, "Wrong size on UHLLSupplyIndicator");
static_assert(offsetof(UHLLSupplyIndicator, SupplyText) == 0x0002B0, "Member 'UHLLSupplyIndicator::SupplyText' has a wrong offset!");

// Class HLL.HLLMapIcon_Sector
// 0x0058 (0x03C0 - 0x0368)
class UHLLMapIcon_Sector : public UHLLMapIconBase
{
public:
	class UTextBlock*                             SectorName;                                        // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDisplayedSectorState                  SectorStateInfo;                                   // 0x0370(0x0048)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          DisplayIcon;                                       // 0x03B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_137A[0x7];                                     // 0x03B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Sector">();
	}
	static class UHLLMapIcon_Sector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Sector>();
	}
};
static_assert(alignof(UHLLMapIcon_Sector) == 0x000008, "Wrong alignment on UHLLMapIcon_Sector");
static_assert(sizeof(UHLLMapIcon_Sector) == 0x0003C0, "Wrong size on UHLLMapIcon_Sector");
static_assert(offsetof(UHLLMapIcon_Sector, SectorName) == 0x000368, "Member 'UHLLMapIcon_Sector::SectorName' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Sector, SectorStateInfo) == 0x000370, "Member 'UHLLMapIcon_Sector::SectorStateInfo' has a wrong offset!");
static_assert(offsetof(UHLLMapIcon_Sector, DisplayIcon) == 0x0003B8, "Member 'UHLLMapIcon_Sector::DisplayIcon' has a wrong offset!");

// Class HLL.HLLSplashScreen
// 0x0030 (0x0260 - 0x0230)
class UHLLSplashScreen : public UUserWidget
{
public:
	class UTextBlock*                             UserNameText;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137B[0x28];                                    // 0x0238(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void FailedToConnectToServices();
	void Initializing();
	void ResetText();
	void SetIgnoreInput(bool IgnoreInput);

	bool GetIgnoreInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSplashScreen">();
	}
	static class UHLLSplashScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSplashScreen>();
	}
};
static_assert(alignof(UHLLSplashScreen) == 0x000008, "Wrong alignment on UHLLSplashScreen");
static_assert(sizeof(UHLLSplashScreen) == 0x000260, "Wrong size on UHLLSplashScreen");
static_assert(offsetof(UHLLSplashScreen, UserNameText) == 0x000230, "Member 'UHLLSplashScreen::UserNameText' has a wrong offset!");

// Class HLL.HLLMapIcon_Supplies
// 0x0000 (0x0368 - 0x0368)
class UHLLMapIcon_Supplies : public UHLLMapIconBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Supplies">();
	}
	static class UHLLMapIcon_Supplies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Supplies>();
	}
};
static_assert(alignof(UHLLMapIcon_Supplies) == 0x000008, "Wrong alignment on UHLLMapIcon_Supplies");
static_assert(sizeof(UHLLMapIcon_Supplies) == 0x000368, "Wrong size on UHLLMapIcon_Supplies");

// Class HLL.HLLMapIcon_Vehicle
// 0x0000 (0x0370 - 0x0370)
class UHLLMapIcon_Vehicle : public UHLLMapIcon_SeatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Vehicle">();
	}
	static class UHLLMapIcon_Vehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Vehicle>();
	}
};
static_assert(alignof(UHLLMapIcon_Vehicle) == 0x000008, "Wrong alignment on UHLLMapIcon_Vehicle");
static_assert(sizeof(UHLLMapIcon_Vehicle) == 0x000370, "Wrong size on UHLLMapIcon_Vehicle");

// Class HLL.HLLSettings
// 0x0170 (0x01A8 - 0x0038)
class UHLLSettings final : public UDeveloperSettings
{
public:
	int32                                         PlayerLevelStart;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerLevelMod;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPlayerLevels;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoleLevelStart;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoleLevelMod;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRoleLevels;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRank;                                           // 0x0050(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137C[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<int32>                                 PlayerLevelTable;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 RoleLevelTable;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UDataTable>>      CosmeticData;                                      // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              DivisionData;                                      // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              GamepadLayouts;                                    // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UHLLTeamLoadouts>> Loadouts;                                          // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class USoundBase>>      MatchWinMusic;                                     // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              DLCData;                                           // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              RegionalKeyData;                                   // 0x0120(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              MapMetaTable;                                      // 0x0148(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              MapTable;                                          // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        LoadedObjects;                                     // 0x0198(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsFactionAllowed(const EFaction Faction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSettings">();
	}
	static class UHLLSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSettings>();
	}
};
static_assert(alignof(UHLLSettings) == 0x000008, "Wrong alignment on UHLLSettings");
static_assert(sizeof(UHLLSettings) == 0x0001A8, "Wrong size on UHLLSettings");
static_assert(offsetof(UHLLSettings, PlayerLevelStart) == 0x000038, "Member 'UHLLSettings::PlayerLevelStart' has a wrong offset!");
static_assert(offsetof(UHLLSettings, PlayerLevelMod) == 0x00003C, "Member 'UHLLSettings::PlayerLevelMod' has a wrong offset!");
static_assert(offsetof(UHLLSettings, MaxPlayerLevels) == 0x000040, "Member 'UHLLSettings::MaxPlayerLevels' has a wrong offset!");
static_assert(offsetof(UHLLSettings, RoleLevelStart) == 0x000044, "Member 'UHLLSettings::RoleLevelStart' has a wrong offset!");
static_assert(offsetof(UHLLSettings, RoleLevelMod) == 0x000048, "Member 'UHLLSettings::RoleLevelMod' has a wrong offset!");
static_assert(offsetof(UHLLSettings, MaxRoleLevels) == 0x00004C, "Member 'UHLLSettings::MaxRoleLevels' has a wrong offset!");
static_assert(offsetof(UHLLSettings, MaxRank) == 0x000050, "Member 'UHLLSettings::MaxRank' has a wrong offset!");
static_assert(offsetof(UHLLSettings, PlayerLevelTable) == 0x000058, "Member 'UHLLSettings::PlayerLevelTable' has a wrong offset!");
static_assert(offsetof(UHLLSettings, RoleLevelTable) == 0x000068, "Member 'UHLLSettings::RoleLevelTable' has a wrong offset!");
static_assert(offsetof(UHLLSettings, CosmeticData) == 0x000078, "Member 'UHLLSettings::CosmeticData' has a wrong offset!");
static_assert(offsetof(UHLLSettings, DivisionData) == 0x000088, "Member 'UHLLSettings::DivisionData' has a wrong offset!");
static_assert(offsetof(UHLLSettings, GamepadLayouts) == 0x0000B0, "Member 'UHLLSettings::GamepadLayouts' has a wrong offset!");
static_assert(offsetof(UHLLSettings, Loadouts) == 0x0000D8, "Member 'UHLLSettings::Loadouts' has a wrong offset!");
static_assert(offsetof(UHLLSettings, MatchWinMusic) == 0x0000E8, "Member 'UHLLSettings::MatchWinMusic' has a wrong offset!");
static_assert(offsetof(UHLLSettings, DLCData) == 0x0000F8, "Member 'UHLLSettings::DLCData' has a wrong offset!");
static_assert(offsetof(UHLLSettings, RegionalKeyData) == 0x000120, "Member 'UHLLSettings::RegionalKeyData' has a wrong offset!");
static_assert(offsetof(UHLLSettings, MapMetaTable) == 0x000148, "Member 'UHLLSettings::MapMetaTable' has a wrong offset!");
static_assert(offsetof(UHLLSettings, MapTable) == 0x000170, "Member 'UHLLSettings::MapTable' has a wrong offset!");
static_assert(offsetof(UHLLSettings, LoadedObjects) == 0x000198, "Member 'UHLLSettings::LoadedObjects' has a wrong offset!");

// Class HLL.HLLMapIcon_Vehicle_HalfTrack
// 0x0000 (0x0370 - 0x0370)
class UHLLMapIcon_Vehicle_HalfTrack final : public UHLLMapIcon_Vehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapIcon_Vehicle_HalfTrack">();
	}
	static class UHLLMapIcon_Vehicle_HalfTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapIcon_Vehicle_HalfTrack>();
	}
};
static_assert(alignof(UHLLMapIcon_Vehicle_HalfTrack) == 0x000008, "Wrong alignment on UHLLMapIcon_Vehicle_HalfTrack");
static_assert(sizeof(UHLLMapIcon_Vehicle_HalfTrack) == 0x000370, "Wrong size on UHLLMapIcon_Vehicle_HalfTrack");

// Class HLL.HLLUISettings
// 0x0028 (0x0060 - 0x0038)
class UHLLUISettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class USlateWidgetStyleAsset>  UIStyleSet;                                        // 0x0038(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUISettings">();
	}
	static class UHLLUISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUISettings>();
	}
};
static_assert(alignof(UHLLUISettings) == 0x000008, "Wrong alignment on UHLLUISettings");
static_assert(sizeof(UHLLUISettings) == 0x000060, "Wrong size on UHLLUISettings");
static_assert(offsetof(UHLLUISettings, UIStyleSet) == 0x000038, "Member 'UHLLUISettings::UIStyleSet' has a wrong offset!");

// Class HLL.HLLMapTooltip_Marker
// 0x0048 (0x02A8 - 0x0260)
class UHLLMapTooltip_Marker : public UHLLTooltipBase
{
public:
	class UScaleBox*                              MapIconScaleBox;                                   // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TooltipName;                                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlacedInfo;                                        // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Description;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             VisibilityInfo;                                    // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TooltipDistance;                                   // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Countdown;                                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ClickToRemove;                                     // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TooltipIcon;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapTooltip_Marker">();
	}
	static class UHLLMapTooltip_Marker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapTooltip_Marker>();
	}
};
static_assert(alignof(UHLLMapTooltip_Marker) == 0x000008, "Wrong alignment on UHLLMapTooltip_Marker");
static_assert(sizeof(UHLLMapTooltip_Marker) == 0x0002A8, "Wrong size on UHLLMapTooltip_Marker");
static_assert(offsetof(UHLLMapTooltip_Marker, MapIconScaleBox) == 0x000260, "Member 'UHLLMapTooltip_Marker::MapIconScaleBox' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Marker, TooltipName) == 0x000268, "Member 'UHLLMapTooltip_Marker::TooltipName' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Marker, PlacedInfo) == 0x000270, "Member 'UHLLMapTooltip_Marker::PlacedInfo' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Marker, Description) == 0x000278, "Member 'UHLLMapTooltip_Marker::Description' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Marker, VisibilityInfo) == 0x000280, "Member 'UHLLMapTooltip_Marker::VisibilityInfo' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Marker, TooltipDistance) == 0x000288, "Member 'UHLLMapTooltip_Marker::TooltipDistance' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Marker, Countdown) == 0x000290, "Member 'UHLLMapTooltip_Marker::Countdown' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Marker, ClickToRemove) == 0x000298, "Member 'UHLLMapTooltip_Marker::ClickToRemove' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_Marker, TooltipIcon) == 0x0002A0, "Member 'UHLLMapTooltip_Marker::TooltipIcon' has a wrong offset!");

// Class HLL.HLLMapTooltip_SeatBase
// 0x0008 (0x0268 - 0x0260)
class UHLLMapTooltip_SeatBase : public UHLLTooltipBase
{
public:
	class UVerticalBox*                           SeatVBox;                                          // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapTooltip_SeatBase">();
	}
	static class UHLLMapTooltip_SeatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapTooltip_SeatBase>();
	}
};
static_assert(alignof(UHLLMapTooltip_SeatBase) == 0x000008, "Wrong alignment on UHLLMapTooltip_SeatBase");
static_assert(sizeof(UHLLMapTooltip_SeatBase) == 0x000268, "Wrong size on UHLLMapTooltip_SeatBase");
static_assert(offsetof(UHLLMapTooltip_SeatBase, SeatVBox) == 0x000260, "Member 'UHLLMapTooltip_SeatBase::SeatVBox' has a wrong offset!");

// Class HLL.HLLMapTooltip_SeatBaseItem
// 0x0010 (0x0240 - 0x0230)
class UHLLMapTooltip_SeatBaseItem : public UUserWidget
{
public:
	class UTextBlock*                             PlayerName;                                        // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlayerRole;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMapTooltip_SeatBaseItem">();
	}
	static class UHLLMapTooltip_SeatBaseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMapTooltip_SeatBaseItem>();
	}
};
static_assert(alignof(UHLLMapTooltip_SeatBaseItem) == 0x000008, "Wrong alignment on UHLLMapTooltip_SeatBaseItem");
static_assert(sizeof(UHLLMapTooltip_SeatBaseItem) == 0x000240, "Wrong size on UHLLMapTooltip_SeatBaseItem");
static_assert(offsetof(UHLLMapTooltip_SeatBaseItem, PlayerName) == 0x000230, "Member 'UHLLMapTooltip_SeatBaseItem::PlayerName' has a wrong offset!");
static_assert(offsetof(UHLLMapTooltip_SeatBaseItem, PlayerRole) == 0x000238, "Member 'UHLLMapTooltip_SeatBaseItem::PlayerRole' has a wrong offset!");

// Class HLL.HLLUI_CreditsOrganisation
// 0x0010 (0x0240 - 0x0230)
class UHLLUI_CreditsOrganisation : public UUserWidget
{
public:
	class UTextBlock*                             OrganisationName;                                  // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 OrganisationLogo;                                  // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_CreditsOrganisation">();
	}
	static class UHLLUI_CreditsOrganisation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_CreditsOrganisation>();
	}
};
static_assert(alignof(UHLLUI_CreditsOrganisation) == 0x000008, "Wrong alignment on UHLLUI_CreditsOrganisation");
static_assert(sizeof(UHLLUI_CreditsOrganisation) == 0x000240, "Wrong size on UHLLUI_CreditsOrganisation");
static_assert(offsetof(UHLLUI_CreditsOrganisation, OrganisationName) == 0x000230, "Member 'UHLLUI_CreditsOrganisation::OrganisationName' has a wrong offset!");
static_assert(offsetof(UHLLUI_CreditsOrganisation, OrganisationLogo) == 0x000238, "Member 'UHLLUI_CreditsOrganisation::OrganisationLogo' has a wrong offset!");

// Class HLL.HLLMarkers_MapMenuItem
// 0x0030 (0x0260 - 0x0230)
class UHLLMarkers_MapMenuItem : public UUserWidget
{
public:
	EHLLMarker                                    AssignedMarker;                                    // 0x0230(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137D[0x3];                                     // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class UHLLMarkers_MapMenu>     OwningMenu;                                        // 0x0234(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137E[0x4];                                     // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 IconType;                                          // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerName;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerCount;                                       // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137F[0x8];                                     // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UHLLMarkers_MapMenu* GetOwningMenu();
	class UButton* GetRootButton();
	bool IsGamepadHovered();
	bool IsUsingGamepad();
	void K2_InitMarker(const EHLLMarker Type, const struct FMarkerMetaData& MetaData);
	void OnButtonHovered();
	void OnGamepadHoveredChanged();
	void OnSelectItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMarkers_MapMenuItem">();
	}
	static class UHLLMarkers_MapMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMarkers_MapMenuItem>();
	}
};
static_assert(alignof(UHLLMarkers_MapMenuItem) == 0x000008, "Wrong alignment on UHLLMarkers_MapMenuItem");
static_assert(sizeof(UHLLMarkers_MapMenuItem) == 0x000260, "Wrong size on UHLLMarkers_MapMenuItem");
static_assert(offsetof(UHLLMarkers_MapMenuItem, AssignedMarker) == 0x000230, "Member 'UHLLMarkers_MapMenuItem::AssignedMarker' has a wrong offset!");
static_assert(offsetof(UHLLMarkers_MapMenuItem, OwningMenu) == 0x000234, "Member 'UHLLMarkers_MapMenuItem::OwningMenu' has a wrong offset!");
static_assert(offsetof(UHLLMarkers_MapMenuItem, IconType) == 0x000240, "Member 'UHLLMarkers_MapMenuItem::IconType' has a wrong offset!");
static_assert(offsetof(UHLLMarkers_MapMenuItem, MarkerName) == 0x000248, "Member 'UHLLMarkers_MapMenuItem::MarkerName' has a wrong offset!");
static_assert(offsetof(UHLLMarkers_MapMenuItem, MarkerCount) == 0x000250, "Member 'UHLLMarkers_MapMenuItem::MarkerCount' has a wrong offset!");

// Class HLL.HLLMatchmaking
// 0x0098 (0x02C8 - 0x0230)
class UHLLMatchmaking : public UUserWidget
{
public:
	uint8                                         Pad_1381[0x60];                                    // 0x0230(0x0060)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLConsoleUIManager*                   UIManager;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHLLPartyButton*>                PartyButtonArray;                                  // 0x0298(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJoiningParty;                                     // 0x02A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1382[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FRegionInfos>                   RegionsList;                                       // 0x02B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1383[0x8];                                     // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BP_Initialize();
	void CancelMatchmaking(bool bLeaveParty);
	void ForceStartMatchmaking(class FName PlaylistName);
	TArray<class FText> GetListOfAvailableRegionNames();
	class FText GetLocalizedRegionText(const class FString& InRegionStr);
	EMatchmakingStatus GetMatchmakingStatus();
	class FText GetMatchmakingStatusAsFText();
	TArray<struct FOnlinePartyRemotePlayer> GetPartyPlayerNames();
	class FText GetTimeSpentMatchmaking();
	bool HasPartyBeenCreated();
	bool InviteToParty();
	bool IsInitialized();
	bool IsMatchmaking();
	bool JoinMatchmakingServer();
	void OnDisableCrossplayPreference();
	void OnEnableCrossplayPreference();
	void OnExternalSetMatchmakingPreferences(const bool InStarted, const class FString& InPreferredRegion, const bool InPrivateLobby, const bool InCrossplatform);
	void OnOSSStatsRefreshed(const struct FUniqueNetIdRepl& UserId);
	void OnRefreshFocusOnMenu();
	void OnRefreshPartyList();
	void OnSetPartyCreated();
	void RebindDelegates();
	bool SetMatchmakingPreferences(const class FString& InPreferredRegion, bool InPrivateLobby, bool InCrossplatform);
	bool StartMatchmaking();
	void UpdateStatus(const EMatchmakingStatus& OutStatus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMatchmaking">();
	}
	static class UHLLMatchmaking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMatchmaking>();
	}
};
static_assert(alignof(UHLLMatchmaking) == 0x000008, "Wrong alignment on UHLLMatchmaking");
static_assert(sizeof(UHLLMatchmaking) == 0x0002C8, "Wrong size on UHLLMatchmaking");
static_assert(offsetof(UHLLMatchmaking, UIManager) == 0x000290, "Member 'UHLLMatchmaking::UIManager' has a wrong offset!");
static_assert(offsetof(UHLLMatchmaking, PartyButtonArray) == 0x000298, "Member 'UHLLMatchmaking::PartyButtonArray' has a wrong offset!");
static_assert(offsetof(UHLLMatchmaking, bJoiningParty) == 0x0002A8, "Member 'UHLLMatchmaking::bJoiningParty' has a wrong offset!");
static_assert(offsetof(UHLLMatchmaking, RegionsList) == 0x0002B0, "Member 'UHLLMatchmaking::RegionsList' has a wrong offset!");

// Class HLL.HLLTeamContainer
// 0x00B0 (0x02E0 - 0x0230)
class UHLLTeamContainer : public UUserWidget
{
public:
	uint8                                         Pad_1387[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLRoundSummaryPlatoon>    PlatoonWidgetClass;                                // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLRoundSummaryPlayer>     PlayerWidgetClass;                                 // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FScoreboardPlayerWidget>        PlayerWidgets;                                     // 0x0248(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1388[0x50];                                    // 0x0258(0x0050)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLRoundSummaryPlayer*                 FirstPlayer;                                       // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLRoundSummaryPlayer*                 CommanderPlayer;                                   // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLRoundSummaryPlatoon*                EmptyPlatoon;                                      // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         AssignedTeam;                                      // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1389[0x7];                                     // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UScrollBox*                             TeamScroller;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           PlatoonVBox;                                       // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLResourceStatus*                     ResourceStatus;                                    // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UHLLRoundSummaryPlayer* GetCommander();
	class UHLLRoundSummaryPlatoon* GetEmptyPlatoon();
	class UHLLRoundSummaryPlayer* GetFirstPlayer();
	class UVerticalBox* GetPlatoonContainer();
	void ReceiveInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLTeamContainer">();
	}
	static class UHLLTeamContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLTeamContainer>();
	}
};
static_assert(alignof(UHLLTeamContainer) == 0x000008, "Wrong alignment on UHLLTeamContainer");
static_assert(sizeof(UHLLTeamContainer) == 0x0002E0, "Wrong size on UHLLTeamContainer");
static_assert(offsetof(UHLLTeamContainer, PlatoonWidgetClass) == 0x000238, "Member 'UHLLTeamContainer::PlatoonWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, PlayerWidgetClass) == 0x000240, "Member 'UHLLTeamContainer::PlayerWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, PlayerWidgets) == 0x000248, "Member 'UHLLTeamContainer::PlayerWidgets' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, FirstPlayer) == 0x0002A8, "Member 'UHLLTeamContainer::FirstPlayer' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, CommanderPlayer) == 0x0002B0, "Member 'UHLLTeamContainer::CommanderPlayer' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, EmptyPlatoon) == 0x0002B8, "Member 'UHLLTeamContainer::EmptyPlatoon' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, AssignedTeam) == 0x0002C0, "Member 'UHLLTeamContainer::AssignedTeam' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, TeamScroller) == 0x0002C8, "Member 'UHLLTeamContainer::TeamScroller' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, PlatoonVBox) == 0x0002D0, "Member 'UHLLTeamContainer::PlatoonVBox' has a wrong offset!");
static_assert(offsetof(UHLLTeamContainer, ResourceStatus) == 0x0002D8, "Member 'UHLLTeamContainer::ResourceStatus' has a wrong offset!");

// Class HLL.HLLMenuButton
// 0x0040 (0x0270 - 0x0230)
class UHLLMenuButton final : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnPress;                                           // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0240(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 HoverIcon;                                         // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RootButton;                                        // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ButtonText;                                        // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHovered();
	void OnPressed();
	void OnUnhovered();
	void SetButtonText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMenuButton">();
	}
	static class UHLLMenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMenuButton>();
	}
};
static_assert(alignof(UHLLMenuButton) == 0x000008, "Wrong alignment on UHLLMenuButton");
static_assert(sizeof(UHLLMenuButton) == 0x000270, "Wrong size on UHLLMenuButton");
static_assert(offsetof(UHLLMenuButton, OnPress) == 0x000230, "Member 'UHLLMenuButton::OnPress' has a wrong offset!");
static_assert(offsetof(UHLLMenuButton, Text) == 0x000240, "Member 'UHLLMenuButton::Text' has a wrong offset!");
static_assert(offsetof(UHLLMenuButton, HoverIcon) == 0x000258, "Member 'UHLLMenuButton::HoverIcon' has a wrong offset!");
static_assert(offsetof(UHLLMenuButton, RootButton) == 0x000260, "Member 'UHLLMenuButton::RootButton' has a wrong offset!");
static_assert(offsetof(UHLLMenuButton, ButtonText) == 0x000268, "Member 'UHLLMenuButton::ButtonText' has a wrong offset!");

// Class HLL.HLLMineBase
// 0x0078 (0x0440 - 0x03C8)
class AHLLMineBase : public AHLLExplosive
{
public:
	class UStaticMeshComponent*                   MineMesh;                                          // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<EObjectTypeQuery>                        FilterObjectTypes;                                 // 0x03D0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bQueryOverlapsOnDeath : 1;                         // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bQueryHitsForDetonation : 1;                       // 0x0420(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ECollisionChannel                             HitQueryChannel;                                   // 0x0421(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138A[0x2];                                     // 0x0422(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MinOverlapVelocity;                                // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleHalfHeight;                                 // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleRadius;                                     // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleOffset;                                     // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  QueryProfile;                                      // 0x0434(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138B[0x4];                                     // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMineBase">();
	}
	static class AHLLMineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLMineBase>();
	}
};
static_assert(alignof(AHLLMineBase) == 0x000008, "Wrong alignment on AHLLMineBase");
static_assert(sizeof(AHLLMineBase) == 0x000440, "Wrong size on AHLLMineBase");
static_assert(offsetof(AHLLMineBase, MineMesh) == 0x0003C8, "Member 'AHLLMineBase::MineMesh' has a wrong offset!");
static_assert(offsetof(AHLLMineBase, FilterObjectTypes) == 0x0003D0, "Member 'AHLLMineBase::FilterObjectTypes' has a wrong offset!");
static_assert(offsetof(AHLLMineBase, HitQueryChannel) == 0x000421, "Member 'AHLLMineBase::HitQueryChannel' has a wrong offset!");
static_assert(offsetof(AHLLMineBase, MinOverlapVelocity) == 0x000424, "Member 'AHLLMineBase::MinOverlapVelocity' has a wrong offset!");
static_assert(offsetof(AHLLMineBase, CapsuleHalfHeight) == 0x000428, "Member 'AHLLMineBase::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(AHLLMineBase, CapsuleRadius) == 0x00042C, "Member 'AHLLMineBase::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(AHLLMineBase, CapsuleOffset) == 0x000430, "Member 'AHLLMineBase::CapsuleOffset' has a wrong offset!");
static_assert(offsetof(AHLLMineBase, QueryProfile) == 0x000434, "Member 'AHLLMineBase::QueryProfile' has a wrong offset!");

// Class HLL.HLLUI_CosmeticItemTooltip
// 0x0020 (0x0250 - 0x0230)
class UHLLUI_CosmeticItemTooltip : public UUserWidget
{
public:
	class UTextBlock*                             ItemName;                                          // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RequirementText;                                   // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemAdditionalText;                                // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitInfo(const struct FHLLCosmeticItemData_CharacterBase& CharacterInfo);
	void InitTooltip(class UHLLUI_CosmeticItem* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_CosmeticItemTooltip">();
	}
	static class UHLLUI_CosmeticItemTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_CosmeticItemTooltip>();
	}
};
static_assert(alignof(UHLLUI_CosmeticItemTooltip) == 0x000008, "Wrong alignment on UHLLUI_CosmeticItemTooltip");
static_assert(sizeof(UHLLUI_CosmeticItemTooltip) == 0x000250, "Wrong size on UHLLUI_CosmeticItemTooltip");
static_assert(offsetof(UHLLUI_CosmeticItemTooltip, ItemName) == 0x000230, "Member 'UHLLUI_CosmeticItemTooltip::ItemName' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItemTooltip, RequirementText) == 0x000238, "Member 'UHLLUI_CosmeticItemTooltip::RequirementText' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItemTooltip, ItemAdditionalText) == 0x000240, "Member 'UHLLUI_CosmeticItemTooltip::ItemAdditionalText' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItemTooltip, ViewportClient) == 0x000248, "Member 'UHLLUI_CosmeticItemTooltip::ViewportClient' has a wrong offset!");

// Class HLL.HLLMineIndicator
// 0x0000 (0x02B0 - 0x02B0)
class UHLLMineIndicator : public UHLLIndicatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLMineIndicator">();
	}
	static class UHLLMineIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLMineIndicator>();
	}
};
static_assert(alignof(UHLLMineIndicator) == 0x000008, "Wrong alignment on UHLLMineIndicator");
static_assert(sizeof(UHLLMineIndicator) == 0x0002B0, "Wrong size on UHLLMineIndicator");

// Class HLL.HLLUI_InviteList
// 0x0030 (0x0260 - 0x0230)
class UHLLUI_InviteList : public UUserWidget
{
public:
	class UScrollBox*                             InviteScrollBox;                                   // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             QueryingInviteText;                                // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NoInviteText;                                      // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLUI_InviteItem*>              InviteItemWidgets;                                 // 0x0248(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_InviteItem>          InviteItemWidget;                                  // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void QueryInvites();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_InviteList">();
	}
	static class UHLLUI_InviteList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_InviteList>();
	}
};
static_assert(alignof(UHLLUI_InviteList) == 0x000008, "Wrong alignment on UHLLUI_InviteList");
static_assert(sizeof(UHLLUI_InviteList) == 0x000260, "Wrong size on UHLLUI_InviteList");
static_assert(offsetof(UHLLUI_InviteList, InviteScrollBox) == 0x000230, "Member 'UHLLUI_InviteList::InviteScrollBox' has a wrong offset!");
static_assert(offsetof(UHLLUI_InviteList, QueryingInviteText) == 0x000238, "Member 'UHLLUI_InviteList::QueryingInviteText' has a wrong offset!");
static_assert(offsetof(UHLLUI_InviteList, NoInviteText) == 0x000240, "Member 'UHLLUI_InviteList::NoInviteText' has a wrong offset!");
static_assert(offsetof(UHLLUI_InviteList, InviteItemWidgets) == 0x000248, "Member 'UHLLUI_InviteList::InviteItemWidgets' has a wrong offset!");
static_assert(offsetof(UHLLUI_InviteList, InviteItemWidget) == 0x000258, "Member 'UHLLUI_InviteList::InviteItemWidget' has a wrong offset!");

// Class HLL.HLLOnlinePlayerStats
// 0x00A8 (0x00D0 - 0x0028)
class UHLLOnlinePlayerStats final : public UObject
{
public:
	uint8                                         Pad_138C[0x20];                                    // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLStatDeltaAccumulator               ActiveAccumulator;                                 // 0x0048(0x0010)(NativeAccessSpecifierPrivate)
	struct FHLLStatDeltaAccumulator               PendingWriteAccumulator;                           // 0x0058(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_138D[0x10];                                    // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bPendingStartWrite : 1;                            // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bWaitingForRefresh : 1;                            // 0x0078(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bWaitingForWrite : 1;                              // 0x0078(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bWaitingForFlush : 1;                              // 0x0078(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bKillOnComplete : 1;                               // 0x0078(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bInitialStatsPopulated : 1;                        // 0x0078(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_138E[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FPackedOnlineStats                     InitialStatValues;                                 // 0x0080(0x0020)(NativeAccessSpecifierPrivate)
	uint8                                         bOnlineStatsPopulated : 1;                         // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_138F[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FPackedOnlineStats                     CachedOnlineStatValues;                            // 0x00A8(0x0020)(NativeAccessSpecifierPrivate)
	struct FDateTime                              StartTime;                                         // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FString GatherDebugString() const;
	class FString GatherStatValueString(const bool bForceOSSOnly, const bool bIncludePending) const;
	bool GetFloatStat(const EHLLOnlinePlayerStat Stat, float* Value, const bool bForceOSSOnly, const bool bIncludePending) const;
	bool GetIntStat(const EHLLOnlinePlayerStat Stat, int32* Value, const bool bForceOSSOnly, const bool bIncludePending) const;
	bool GetRoleXPStats(TArray<int32>* OutStats, const bool bForceOSSOnly, const bool bIncludePending) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLOnlinePlayerStats">();
	}
	static class UHLLOnlinePlayerStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLOnlinePlayerStats>();
	}
};
static_assert(alignof(UHLLOnlinePlayerStats) == 0x000008, "Wrong alignment on UHLLOnlinePlayerStats");
static_assert(sizeof(UHLLOnlinePlayerStats) == 0x0000D0, "Wrong size on UHLLOnlinePlayerStats");
static_assert(offsetof(UHLLOnlinePlayerStats, ActiveAccumulator) == 0x000048, "Member 'UHLLOnlinePlayerStats::ActiveAccumulator' has a wrong offset!");
static_assert(offsetof(UHLLOnlinePlayerStats, PendingWriteAccumulator) == 0x000058, "Member 'UHLLOnlinePlayerStats::PendingWriteAccumulator' has a wrong offset!");
static_assert(offsetof(UHLLOnlinePlayerStats, InitialStatValues) == 0x000080, "Member 'UHLLOnlinePlayerStats::InitialStatValues' has a wrong offset!");
static_assert(offsetof(UHLLOnlinePlayerStats, CachedOnlineStatValues) == 0x0000A8, "Member 'UHLLOnlinePlayerStats::CachedOnlineStatValues' has a wrong offset!");
static_assert(offsetof(UHLLOnlinePlayerStats, StartTime) == 0x0000C8, "Member 'UHLLOnlinePlayerStats::StartTime' has a wrong offset!");

// Class HLL.HLLOnlineStatsManager
// 0x0058 (0x0080 - 0x0028)
class UHLLOnlineStatsManager final : public UObject
{
public:
	uint8                                         Pad_1396[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             GlobalStatsUpdateDelegate;                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TArray<class UHLLOnlinePlayerStats*>          PlayerStatObjects;                                 // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_WriteMatchStats;                                // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1397[0x28];                                    // 0x0058(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UHLLOnlineStatsManager* GetChecked(const class UObject* WorldContextObject);

	void HLLStatsUpdate__DelegateSignature(const struct FUniqueNetIdRepl& UserId);

	class UHLLOnlinePlayerStats* GetPlayerStats(const class APlayerController* ForPlayer, const bool bChecked) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLOnlineStatsManager">();
	}
	static class UHLLOnlineStatsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLOnlineStatsManager>();
	}
};
static_assert(alignof(UHLLOnlineStatsManager) == 0x000008, "Wrong alignment on UHLLOnlineStatsManager");
static_assert(sizeof(UHLLOnlineStatsManager) == 0x000080, "Wrong size on UHLLOnlineStatsManager");
static_assert(offsetof(UHLLOnlineStatsManager, GlobalStatsUpdateDelegate) == 0x000030, "Member 'UHLLOnlineStatsManager::GlobalStatsUpdateDelegate' has a wrong offset!");
static_assert(offsetof(UHLLOnlineStatsManager, PlayerStatObjects) == 0x000040, "Member 'UHLLOnlineStatsManager::PlayerStatObjects' has a wrong offset!");
static_assert(offsetof(UHLLOnlineStatsManager, TH_WriteMatchStats) == 0x000050, "Member 'UHLLOnlineStatsManager::TH_WriteMatchStats' has a wrong offset!");

// Class HLL.HLLUI_CreditsCategory_Department
// 0x0008 (0x0238 - 0x0230)
class UHLLUI_CreditsCategory_Department : public UUserWidget
{
public:
	class UTextBlock*                             TitleText;                                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_CreditsCategory_Department">();
	}
	static class UHLLUI_CreditsCategory_Department* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_CreditsCategory_Department>();
	}
};
static_assert(alignof(UHLLUI_CreditsCategory_Department) == 0x000008, "Wrong alignment on UHLLUI_CreditsCategory_Department");
static_assert(sizeof(UHLLUI_CreditsCategory_Department) == 0x000238, "Wrong size on UHLLUI_CreditsCategory_Department");
static_assert(offsetof(UHLLUI_CreditsCategory_Department, TitleText) == 0x000230, "Member 'UHLLUI_CreditsCategory_Department::TitleText' has a wrong offset!");

// Class HLL.HLLOptionScreenBase
// 0x0168 (0x0398 - 0x0230)
class UHLLOptionScreenBase : public UUserWidget
{
public:
	uint8                                         Pad_1399[0x118];                                   // 0x0230(0x0118)(Fixing Size After Last Property [ Dumper-69 ])
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139A[0x8];                                     // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UVoipMicCheckWidget>        VoipMicCheckWidgetClass;                           // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHLLUI_OptionSelection*                 VoipConnectionButton;                              // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             VoipConnectionStatusText;                          // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             VoipConnectionLabel;                               // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139B[0x20];                                    // 0x0378(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindOnInputChangedDelegate();
	bool CanLinkEpicAccount();
	void DisplayCapturedExistingKeybindOverrideAlertsIfAny();
	TArray<struct FHLLGamepadInputAction> GetGamepadCategoryBindings(const EHLLActionCategory Category);
	class FString GetPublicPlayerID(class AShooterPlayerState* PS);
	void LoginEpicAccount();
	void LogoutEpicAccount();
	void OnClose();
	void OnInputDeviceChanged(bool NewValue);
	void OnVoipConnectionButtonClicked();
	void PerformVoipMicCheck();
	void Refresh();
	void RefreshAudioOptions();
	void RefreshButtonPrompts();
	void ResetKeyBindings();
	void RestoreKeyBindingsSnapshot();
	void SaveKeyBindingsSnapshot();
	void SetLayout(const class FName& ChosenLayout);
	void SetOptionUpdateInProgress(bool bValue);
	void SetRequestedRendererAPI(EHLLGraphicsRHISetting InValue);
	void UnBindOnInputChangedDelegate();
	bool UpdateKeyBinding(const struct FHLLInputAction& Action, bool PrimaryKey, const struct FKey& Key);
	void UpdateVoipConnectionButtonText(const class FText& NewText);

	struct FHLLKeyBinding FindBindingForAction(const struct FHLLInputAction& Action) const;
	TArray<struct FHLLKeyBinding> GetAdminCameraBindings() const;
	TArray<struct FHLLKeyBinding> GetArtilleryGunnerBindings() const;
	TArray<struct FHLLKeyBinding> GetArtilleryLoaderBindings() const;
	TArray<struct FHLLKeyBinding> GetCategoryBindings(EHLLActionCategory Category) const;
	TArray<struct FHLLKeyBinding> GetCommonBindings() const;
	TArray<struct FHLLKeyBinding> GetDriverBindings() const;
	TArray<struct FHLLKeyBinding> GetInfantryBindings() const;
	bool GetOptionUpdateInProgress() const;
	class FText GetSelectedGamepadLayout() const;
	class UShooterGameUserSettings* GetUserSettings() const;
	TArray<struct FHLLKeyBinding> GetVehicleGunnerBindings() const;
	bool IsSafeToApplySettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLOptionScreenBase">();
	}
	static class UHLLOptionScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLOptionScreenBase>();
	}
};
static_assert(alignof(UHLLOptionScreenBase) == 0x000008, "Wrong alignment on UHLLOptionScreenBase");
static_assert(sizeof(UHLLOptionScreenBase) == 0x000398, "Wrong size on UHLLOptionScreenBase");
static_assert(offsetof(UHLLOptionScreenBase, ViewportClient) == 0x000348, "Member 'UHLLOptionScreenBase::ViewportClient' has a wrong offset!");
static_assert(offsetof(UHLLOptionScreenBase, VoipMicCheckWidgetClass) == 0x000358, "Member 'UHLLOptionScreenBase::VoipMicCheckWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLOptionScreenBase, VoipConnectionButton) == 0x000360, "Member 'UHLLOptionScreenBase::VoipConnectionButton' has a wrong offset!");
static_assert(offsetof(UHLLOptionScreenBase, VoipConnectionStatusText) == 0x000368, "Member 'UHLLOptionScreenBase::VoipConnectionStatusText' has a wrong offset!");
static_assert(offsetof(UHLLOptionScreenBase, VoipConnectionLabel) == 0x000370, "Member 'UHLLOptionScreenBase::VoipConnectionLabel' has a wrong offset!");

// Class HLL.HLLUI_CosmeticCategory
// 0x0080 (0x02B0 - 0x0230)
class UHLLUI_CosmeticCategory : public UUserWidget
{
public:
	TWeakObjectPtr<class UHLLUI_CharacterSelection> ParentPanel;                                       // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLCosmeticType                              CosmeticType;                                      // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A0[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLUI_CosmeticItem>        ItemWidget;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_CosmeticItemTooltip> ItemTooltipWidget;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxColumns;                                        // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A1[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLUI_CosmeticItem*>            ActiveItems;                                       // 0x0258(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLUI_CosmeticItemTooltip*             TooltipItem;                                       // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowingVariations : 1;                            // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_13A2[0x7];                                     // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UScrollBox*                             ItemScroller;                                      // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      ItemPanel;                                         // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CategoryText;                                      // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             UnlockedText;                                      // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FilterDivisionItems;                               // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A3[0x17];                                    // 0x0299(0x0017)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void K2_PostSetItems(const int32 UnlockedCount, const int32 TotalCount);

	class FString DebugVariationMapString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_CosmeticCategory">();
	}
	static class UHLLUI_CosmeticCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_CosmeticCategory>();
	}
};
static_assert(alignof(UHLLUI_CosmeticCategory) == 0x000008, "Wrong alignment on UHLLUI_CosmeticCategory");
static_assert(sizeof(UHLLUI_CosmeticCategory) == 0x0002B0, "Wrong size on UHLLUI_CosmeticCategory");
static_assert(offsetof(UHLLUI_CosmeticCategory, ParentPanel) == 0x000230, "Member 'UHLLUI_CosmeticCategory::ParentPanel' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, CosmeticType) == 0x000238, "Member 'UHLLUI_CosmeticCategory::CosmeticType' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, ItemWidget) == 0x000240, "Member 'UHLLUI_CosmeticCategory::ItemWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, ItemTooltipWidget) == 0x000248, "Member 'UHLLUI_CosmeticCategory::ItemTooltipWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, MaxColumns) == 0x000250, "Member 'UHLLUI_CosmeticCategory::MaxColumns' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, ActiveItems) == 0x000258, "Member 'UHLLUI_CosmeticCategory::ActiveItems' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, TooltipItem) == 0x000268, "Member 'UHLLUI_CosmeticCategory::TooltipItem' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, ItemScroller) == 0x000278, "Member 'UHLLUI_CosmeticCategory::ItemScroller' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, ItemPanel) == 0x000280, "Member 'UHLLUI_CosmeticCategory::ItemPanel' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, CategoryText) == 0x000288, "Member 'UHLLUI_CosmeticCategory::CategoryText' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, UnlockedText) == 0x000290, "Member 'UHLLUI_CosmeticCategory::UnlockedText' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticCategory, FilterDivisionItems) == 0x000298, "Member 'UHLLUI_CosmeticCategory::FilterDivisionItems' has a wrong offset!");

// Class HLL.HLLParachuteMeshComponent
// 0x0020 (0x0AE0 - 0x0AC0)
class UHLLParachuteMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         bParachuteState : 1;                               // 0x0AB8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_13A4[0x7];                                     // 0x0AB9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimMontage*                           CloseMontage;                                      // 0x0AC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnParachuteFinishedClosing;                        // 0x0AC8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A5[0x8];                                     // 0x0AD8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnParachuteFinishedClosing__DelegateSignature(class UHLLParachuteMeshComponent* Parachute);
	void SetParachuteClosed(const bool bInstant);
	void SetParachuteOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLParachuteMeshComponent">();
	}
	static class UHLLParachuteMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLParachuteMeshComponent>();
	}
};
static_assert(alignof(UHLLParachuteMeshComponent) == 0x000010, "Wrong alignment on UHLLParachuteMeshComponent");
static_assert(sizeof(UHLLParachuteMeshComponent) == 0x000AE0, "Wrong size on UHLLParachuteMeshComponent");
static_assert(offsetof(UHLLParachuteMeshComponent, CloseMontage) == 0x000AC0, "Member 'UHLLParachuteMeshComponent::CloseMontage' has a wrong offset!");
static_assert(offsetof(UHLLParachuteMeshComponent, OnParachuteFinishedClosing) == 0x000AC8, "Member 'UHLLParachuteMeshComponent::OnParachuteFinishedClosing' has a wrong offset!");

// Class HLL.HLLUI_FriendListForInvite
// 0x0030 (0x0260 - 0x0230)
class UHLLUI_FriendListForInvite : public UUserWidget
{
public:
	class UScrollBox*                             FriendScrollBox;                                   // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             QueryingFriendText;                                // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NoFriendText;                                      // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLUI_FriendInviteItem*>        FriendInviteItemWidgets;                           // 0x0248(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_FriendInviteItem>    FriendInviteItemWidget;                            // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void QueryFriends();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_FriendListForInvite">();
	}
	static class UHLLUI_FriendListForInvite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_FriendListForInvite>();
	}
};
static_assert(alignof(UHLLUI_FriendListForInvite) == 0x000008, "Wrong alignment on UHLLUI_FriendListForInvite");
static_assert(sizeof(UHLLUI_FriendListForInvite) == 0x000260, "Wrong size on UHLLUI_FriendListForInvite");
static_assert(offsetof(UHLLUI_FriendListForInvite, FriendScrollBox) == 0x000230, "Member 'UHLLUI_FriendListForInvite::FriendScrollBox' has a wrong offset!");
static_assert(offsetof(UHLLUI_FriendListForInvite, QueryingFriendText) == 0x000238, "Member 'UHLLUI_FriendListForInvite::QueryingFriendText' has a wrong offset!");
static_assert(offsetof(UHLLUI_FriendListForInvite, NoFriendText) == 0x000240, "Member 'UHLLUI_FriendListForInvite::NoFriendText' has a wrong offset!");
static_assert(offsetof(UHLLUI_FriendListForInvite, FriendInviteItemWidgets) == 0x000248, "Member 'UHLLUI_FriendListForInvite::FriendInviteItemWidgets' has a wrong offset!");
static_assert(offsetof(UHLLUI_FriendListForInvite, FriendInviteItemWidget) == 0x000258, "Member 'UHLLUI_FriendListForInvite::FriendInviteItemWidget' has a wrong offset!");

// Class HLL.HLLUI_PlayerLevel
// 0x0040 (0x0270 - 0x0230)
class UHLLUI_PlayerLevel : public UUserWidget
{
public:
	uint8                                         bUseGrouping : 1;                                  // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_13A6[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             PlayerName;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerLevel;                                       // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentXP;                                         // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NextLevelXP;                                       // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           LevelProgress;                                     // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                RankContainer;                                     // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RankIcon;                                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GlobalOnPlayerStatsRefreshed(const struct FUniqueNetIdRepl& UserId);
	void K2_OnUpdate(const int32 PlayerXP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_PlayerLevel">();
	}
	static class UHLLUI_PlayerLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_PlayerLevel>();
	}
};
static_assert(alignof(UHLLUI_PlayerLevel) == 0x000008, "Wrong alignment on UHLLUI_PlayerLevel");
static_assert(sizeof(UHLLUI_PlayerLevel) == 0x000270, "Wrong size on UHLLUI_PlayerLevel");
static_assert(offsetof(UHLLUI_PlayerLevel, PlayerName) == 0x000238, "Member 'UHLLUI_PlayerLevel::PlayerName' has a wrong offset!");
static_assert(offsetof(UHLLUI_PlayerLevel, PlayerLevel) == 0x000240, "Member 'UHLLUI_PlayerLevel::PlayerLevel' has a wrong offset!");
static_assert(offsetof(UHLLUI_PlayerLevel, CurrentXP) == 0x000248, "Member 'UHLLUI_PlayerLevel::CurrentXP' has a wrong offset!");
static_assert(offsetof(UHLLUI_PlayerLevel, NextLevelXP) == 0x000250, "Member 'UHLLUI_PlayerLevel::NextLevelXP' has a wrong offset!");
static_assert(offsetof(UHLLUI_PlayerLevel, LevelProgress) == 0x000258, "Member 'UHLLUI_PlayerLevel::LevelProgress' has a wrong offset!");
static_assert(offsetof(UHLLUI_PlayerLevel, RankContainer) == 0x000260, "Member 'UHLLUI_PlayerLevel::RankContainer' has a wrong offset!");
static_assert(offsetof(UHLLUI_PlayerLevel, RankIcon) == 0x000268, "Member 'UHLLUI_PlayerLevel::RankIcon' has a wrong offset!");

// Class HLL.HLLParticleModule_Limiter
// 0x0038 (0x0068 - 0x0030)
class UHLLParticleModule_Limiter final : public UHLLParticleModule_Base
{
public:
	struct FRawDistributionFloat                  MaxRange;                                          // 0x0030(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ELimitMode                                    LimitMode;                                         // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseEmitterLocation;                               // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A7[0x6];                                     // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLParticleModule_Limiter">();
	}
	static class UHLLParticleModule_Limiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLParticleModule_Limiter>();
	}
};
static_assert(alignof(UHLLParticleModule_Limiter) == 0x000008, "Wrong alignment on UHLLParticleModule_Limiter");
static_assert(sizeof(UHLLParticleModule_Limiter) == 0x000068, "Wrong size on UHLLParticleModule_Limiter");
static_assert(offsetof(UHLLParticleModule_Limiter, MaxRange) == 0x000030, "Member 'UHLLParticleModule_Limiter::MaxRange' has a wrong offset!");
static_assert(offsetof(UHLLParticleModule_Limiter, LimitMode) == 0x000060, "Member 'UHLLParticleModule_Limiter::LimitMode' has a wrong offset!");
static_assert(offsetof(UHLLParticleModule_Limiter, bUseEmitterLocation) == 0x000061, "Member 'UHLLParticleModule_Limiter::bUseEmitterLocation' has a wrong offset!");

// Class HLL.HLLPartyButton
// 0x0010 (0x0240 - 0x0230)
class UHLLPartyButton : public UUserWidget
{
public:
	class FString                                 GlobalPlayerId;                                    // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnPlayerSpeaking(bool bIsSpeaking);
	void OnUpdatePlayerXp(const int32& OutXP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPartyButton">();
	}
	static class UHLLPartyButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPartyButton>();
	}
};
static_assert(alignof(UHLLPartyButton) == 0x000008, "Wrong alignment on UHLLPartyButton");
static_assert(sizeof(UHLLPartyButton) == 0x000240, "Wrong size on UHLLPartyButton");
static_assert(offsetof(UHLLPartyButton, GlobalPlayerId) == 0x000230, "Member 'UHLLPartyButton::GlobalPlayerId' has a wrong offset!");

// Class HLL.HLLUI_Loadout
// 0x00A8 (0x02D8 - 0x0230)
class UHLLUI_Loadout : public UUserWidget
{
public:
	TWeakObjectPtr<class UHLLUI_LoadoutSelector>  ParentSelector;                                    // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemIcon;                                          // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsSelected : 1;                                   // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsUnlocked : 1;                                   // 0x0248(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         LoadoutID;                                         // 0x0249(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A8[0x6];                                     // 0x024A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateBrush                            DefaultIcon;                                       // 0x0250(0x0088)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetItemDescription();
	float GetItemUnlockProgressPercentage();
	void K2_InitItem(const struct FLoadout& InLoadoutData, const uint8 InItemID, const bool bInIsUnlocked);
	void K2_SetSelected(const bool bInIsSelected);
	void OnApply();
	void OnPreview();
	void OnStopPreview();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_Loadout">();
	}
	static class UHLLUI_Loadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_Loadout>();
	}
};
static_assert(alignof(UHLLUI_Loadout) == 0x000008, "Wrong alignment on UHLLUI_Loadout");
static_assert(sizeof(UHLLUI_Loadout) == 0x0002D8, "Wrong size on UHLLUI_Loadout");
static_assert(offsetof(UHLLUI_Loadout, ParentSelector) == 0x000230, "Member 'UHLLUI_Loadout::ParentSelector' has a wrong offset!");
static_assert(offsetof(UHLLUI_Loadout, ItemIcon) == 0x000238, "Member 'UHLLUI_Loadout::ItemIcon' has a wrong offset!");
static_assert(offsetof(UHLLUI_Loadout, ItemName) == 0x000240, "Member 'UHLLUI_Loadout::ItemName' has a wrong offset!");
static_assert(offsetof(UHLLUI_Loadout, LoadoutID) == 0x000249, "Member 'UHLLUI_Loadout::LoadoutID' has a wrong offset!");
static_assert(offsetof(UHLLUI_Loadout, DefaultIcon) == 0x000250, "Member 'UHLLUI_Loadout::DefaultIcon' has a wrong offset!");

// Class HLL.HLLPartyManagementList
// 0x0018 (0x0248 - 0x0230)
class UHLLPartyManagementList : public UUserWidget
{
public:
	TArray<class UHLLPartyButton*>                PartyButtonArray;                                  // 0x0230(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLConsoleUIManager*                   UIManager;                                         // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDisableCrossplayPreference();
	void OnEnableCrossplayPreference();
	void OnOSSStatsRefreshed(const struct FUniqueNetIdRepl& UserId);
	void OnRefreshPartyList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPartyManagementList">();
	}
	static class UHLLPartyManagementList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPartyManagementList>();
	}
};
static_assert(alignof(UHLLPartyManagementList) == 0x000008, "Wrong alignment on UHLLPartyManagementList");
static_assert(sizeof(UHLLPartyManagementList) == 0x000248, "Wrong size on UHLLPartyManagementList");
static_assert(offsetof(UHLLPartyManagementList, PartyButtonArray) == 0x000230, "Member 'UHLLPartyManagementList::PartyButtonArray' has a wrong offset!");
static_assert(offsetof(UHLLPartyManagementList, UIManager) == 0x000240, "Member 'UHLLPartyManagementList::UIManager' has a wrong offset!");

// Class HLL.HLLUI_DivisionsItem
// 0x0048 (0x0278 - 0x0230)
class UHLLUI_DivisionsItem : public UUserWidget
{
public:
	EDivision                                     DivisionType;                                      // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13AA[0x3];                                     // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class UHLLUI_CharacterSelection> ParentPanel;                                       // 0x0234(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13AB[0x4];                                     // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 ItemIcon;                                          // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RootButton;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemDescription;                                   // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUnlocked;                                       // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13AC[0x16];                                    // 0x0262(0x0016)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ApplyDivisionCosmetics();
	bool GetUnlockedStatus();
	void PreviewDivisionCosmetics();
	void SetItemDataFromDivisionsCosmeticProfile(const struct FDivisionCosmeticProfile& CosmeticProfile);
	void StopPreviewDivisionCosmetics();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_DivisionsItem">();
	}
	static class UHLLUI_DivisionsItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_DivisionsItem>();
	}
};
static_assert(alignof(UHLLUI_DivisionsItem) == 0x000008, "Wrong alignment on UHLLUI_DivisionsItem");
static_assert(sizeof(UHLLUI_DivisionsItem) == 0x000278, "Wrong size on UHLLUI_DivisionsItem");
static_assert(offsetof(UHLLUI_DivisionsItem, DivisionType) == 0x000230, "Member 'UHLLUI_DivisionsItem::DivisionType' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsItem, ParentPanel) == 0x000234, "Member 'UHLLUI_DivisionsItem::ParentPanel' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsItem, ItemIcon) == 0x000240, "Member 'UHLLUI_DivisionsItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsItem, RootButton) == 0x000248, "Member 'UHLLUI_DivisionsItem::RootButton' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsItem, ItemName) == 0x000250, "Member 'UHLLUI_DivisionsItem::ItemName' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsItem, ItemDescription) == 0x000258, "Member 'UHLLUI_DivisionsItem::ItemDescription' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsItem, bIsUnlocked) == 0x000260, "Member 'UHLLUI_DivisionsItem::bIsUnlocked' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsItem, bIsSelected) == 0x000261, "Member 'UHLLUI_DivisionsItem::bIsSelected' has a wrong offset!");

// Class HLL.HLLAbility_Encouraged
// 0x0008 (0x0378 - 0x0370)
class AHLLAbility_Encouraged final : public AHLLAbility_PassiveBase
{
public:
	int32                                         Multiplier;                                        // 0x0370(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13AD[0x4];                                     // 0x0374(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLAbility_Encouraged">();
	}
	static class AHLLAbility_Encouraged* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLAbility_Encouraged>();
	}
};
static_assert(alignof(AHLLAbility_Encouraged) == 0x000008, "Wrong alignment on AHLLAbility_Encouraged");
static_assert(sizeof(AHLLAbility_Encouraged) == 0x000378, "Wrong size on AHLLAbility_Encouraged");
static_assert(offsetof(AHLLAbility_Encouraged, Multiplier) == 0x000370, "Member 'AHLLAbility_Encouraged::Multiplier' has a wrong offset!");

// Class HLL.HLLPhysicalMaterial
// 0x0020 (0x00A0 - 0x0080)
class UHLLPhysicalMaterial final : public UPhysicalMaterial
{
public:
	uint8                                         bSupportBulletPenetration : 1;                     // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverlapGeneratesProjectileFX : 1;                 // 0x0080(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableEntryFX : 1;                                // 0x0080(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableExitFX : 1;                                 // 0x0080(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreDamageOnPenetration : 1;                    // 0x0080(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13AE[0x3];                                     // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         RequiredPower;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReduction;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityReduction;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DebugColour;                                       // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPhysicalMaterial">();
	}
	static class UHLLPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPhysicalMaterial>();
	}
};
static_assert(alignof(UHLLPhysicalMaterial) == 0x000008, "Wrong alignment on UHLLPhysicalMaterial");
static_assert(sizeof(UHLLPhysicalMaterial) == 0x0000A0, "Wrong size on UHLLPhysicalMaterial");
static_assert(offsetof(UHLLPhysicalMaterial, RequiredPower) == 0x000084, "Member 'UHLLPhysicalMaterial::RequiredPower' has a wrong offset!");
static_assert(offsetof(UHLLPhysicalMaterial, DamageReduction) == 0x000088, "Member 'UHLLPhysicalMaterial::DamageReduction' has a wrong offset!");
static_assert(offsetof(UHLLPhysicalMaterial, VelocityReduction) == 0x00008C, "Member 'UHLLPhysicalMaterial::VelocityReduction' has a wrong offset!");
static_assert(offsetof(UHLLPhysicalMaterial, DebugColour) == 0x000090, "Member 'UHLLPhysicalMaterial::DebugColour' has a wrong offset!");

// Class HLL.HLLUpgradeData
// 0x0120 (0x0150 - 0x0030)
class UHLLUpgradeData : public UDataAsset
{
public:
	int32                                         UpgradeTime;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SuppliesCost;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   UpgradeText;                                       // 0x0038(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            UpgradeIcon;                                       // 0x0050(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bUpgradeDamageFilter;                              // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          UpgradeDamageFilter;                               // 0x00D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13AF[0x2];                                     // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   ActionScore;                                       // 0x00DC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OwnerActionScore;                                  // 0x00E4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreModifier;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OwnerScoreModifier;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinContributionForScore;                           // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLPlayerStat                                ContributorStatWhenApplied;                        // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLPlayerStat                                OwnerStatWhenApplied;                              // 0x00F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bApplyToContributors : 1;                          // 0x00FA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bApplyToStructureOwner : 1;                        // 0x00FA(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EUpgradeScoringMethod                         OwnerScoringMethod;                                // 0x00FB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLAchievementStat                           AchievementStat;                                   // 0x00FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B0[0x3];                                     // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	uint32                                        IncrementAmount;                                   // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinContributionForAchievement;                     // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B1[0x8];                                     // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FTransform                             UpgradeEffectRelativeTransform;                    // 0x0110(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                             UpgradeSound;                                      // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        UpgradeParticle;                                   // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUpgradeData">();
	}
	static class UHLLUpgradeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUpgradeData>();
	}
};
static_assert(alignof(UHLLUpgradeData) == 0x000010, "Wrong alignment on UHLLUpgradeData");
static_assert(sizeof(UHLLUpgradeData) == 0x000150, "Wrong size on UHLLUpgradeData");
static_assert(offsetof(UHLLUpgradeData, UpgradeTime) == 0x000030, "Member 'UHLLUpgradeData::UpgradeTime' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, SuppliesCost) == 0x000034, "Member 'UHLLUpgradeData::SuppliesCost' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, UpgradeText) == 0x000038, "Member 'UHLLUpgradeData::UpgradeText' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, UpgradeIcon) == 0x000050, "Member 'UHLLUpgradeData::UpgradeIcon' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, bUpgradeDamageFilter) == 0x0000D8, "Member 'UHLLUpgradeData::bUpgradeDamageFilter' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, UpgradeDamageFilter) == 0x0000D9, "Member 'UHLLUpgradeData::UpgradeDamageFilter' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, ActionScore) == 0x0000DC, "Member 'UHLLUpgradeData::ActionScore' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, OwnerActionScore) == 0x0000E4, "Member 'UHLLUpgradeData::OwnerActionScore' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, ScoreModifier) == 0x0000EC, "Member 'UHLLUpgradeData::ScoreModifier' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, OwnerScoreModifier) == 0x0000F0, "Member 'UHLLUpgradeData::OwnerScoreModifier' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, MinContributionForScore) == 0x0000F4, "Member 'UHLLUpgradeData::MinContributionForScore' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, ContributorStatWhenApplied) == 0x0000F8, "Member 'UHLLUpgradeData::ContributorStatWhenApplied' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, OwnerStatWhenApplied) == 0x0000F9, "Member 'UHLLUpgradeData::OwnerStatWhenApplied' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, OwnerScoringMethod) == 0x0000FB, "Member 'UHLLUpgradeData::OwnerScoringMethod' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, AchievementStat) == 0x0000FC, "Member 'UHLLUpgradeData::AchievementStat' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, IncrementAmount) == 0x000100, "Member 'UHLLUpgradeData::IncrementAmount' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, MinContributionForAchievement) == 0x000104, "Member 'UHLLUpgradeData::MinContributionForAchievement' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, UpgradeEffectRelativeTransform) == 0x000110, "Member 'UHLLUpgradeData::UpgradeEffectRelativeTransform' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, UpgradeSound) == 0x000140, "Member 'UHLLUpgradeData::UpgradeSound' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeData, UpgradeParticle) == 0x000148, "Member 'UHLLUpgradeData::UpgradeParticle' has a wrong offset!");

// Class HLL.HLLUpgradeData_Structure
// 0x0010 (0x0160 - 0x0150)
class UHLLUpgradeData_Structure final : public UHLLUpgradeData
{
public:
	class UStaticMesh*                            UpgradeMesh;                                       // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B2[0x8];                                     // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUpgradeData_Structure">();
	}
	static class UHLLUpgradeData_Structure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUpgradeData_Structure>();
	}
};
static_assert(alignof(UHLLUpgradeData_Structure) == 0x000010, "Wrong alignment on UHLLUpgradeData_Structure");
static_assert(sizeof(UHLLUpgradeData_Structure) == 0x000160, "Wrong size on UHLLUpgradeData_Structure");
static_assert(offsetof(UHLLUpgradeData_Structure, UpgradeMesh) == 0x000150, "Member 'UHLLUpgradeData_Structure::UpgradeMesh' has a wrong offset!");

// Class HLL.HLLPlantObjectiveIndicator
// 0x0030 (0x02E0 - 0x02B0)
class UHLLPlantObjectiveIndicator final : public UHLLIndicatorBase
{
public:
	class APlantObjectiveArea*                    OwningObjective;                                   // 0x02B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsExpandedState;                                   // 0x02B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B3[0x3];                                     // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ExpandedAngle;                                     // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ObjectiveNameText;                                 // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DistanceText;                                      // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FlagBrush;                                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AnimExpandCollapse;                                // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_SetExpandedState(const bool bIsExpanded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPlantObjectiveIndicator">();
	}
	static class UHLLPlantObjectiveIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPlantObjectiveIndicator>();
	}
};
static_assert(alignof(UHLLPlantObjectiveIndicator) == 0x000008, "Wrong alignment on UHLLPlantObjectiveIndicator");
static_assert(sizeof(UHLLPlantObjectiveIndicator) == 0x0002E0, "Wrong size on UHLLPlantObjectiveIndicator");
static_assert(offsetof(UHLLPlantObjectiveIndicator, OwningObjective) == 0x0002B0, "Member 'UHLLPlantObjectiveIndicator::OwningObjective' has a wrong offset!");
static_assert(offsetof(UHLLPlantObjectiveIndicator, IsExpandedState) == 0x0002B8, "Member 'UHLLPlantObjectiveIndicator::IsExpandedState' has a wrong offset!");
static_assert(offsetof(UHLLPlantObjectiveIndicator, ExpandedAngle) == 0x0002BC, "Member 'UHLLPlantObjectiveIndicator::ExpandedAngle' has a wrong offset!");
static_assert(offsetof(UHLLPlantObjectiveIndicator, ObjectiveNameText) == 0x0002C0, "Member 'UHLLPlantObjectiveIndicator::ObjectiveNameText' has a wrong offset!");
static_assert(offsetof(UHLLPlantObjectiveIndicator, DistanceText) == 0x0002C8, "Member 'UHLLPlantObjectiveIndicator::DistanceText' has a wrong offset!");
static_assert(offsetof(UHLLPlantObjectiveIndicator, FlagBrush) == 0x0002D0, "Member 'UHLLPlantObjectiveIndicator::FlagBrush' has a wrong offset!");
static_assert(offsetof(UHLLPlantObjectiveIndicator, AnimExpandCollapse) == 0x0002D8, "Member 'UHLLPlantObjectiveIndicator::AnimExpandCollapse' has a wrong offset!");

// Class HLL.HLLUI_ServerBrowserItem
// 0x0080 (0x02B0 - 0x0230)
class UHLLUI_ServerBrowserItem : public UUserWidget
{
public:
	TWeakObjectPtr<class UHLLUI_ServerBrowser>    ServerBrowser;                                     // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ItemIndex;                                         // 0x0238(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LongServerNameScrollSpeed;                         // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              FavouriteToggle;                                   // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ServerThumbnail;                                   // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerName;                                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerCount;                                       // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MaxPlayerCount;                                    // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Ping;                                              // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MapName;                                           // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ModeName;                                          // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OffensiveModeAttackingFaction;                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PasswordWidget;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             LongNameScroller;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LastTimePlayedText;                                // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                HistoryClearButton;                                // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B4[0x8];                                     // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearFromHistory();
	void Deselect();
	void Hovered();
	void Select();
	void SelectAndJoin();
	void ToggleFavourite();
	void Unhovered();
	void UpdateItem(const struct FHLLUI_ServerResult& ForResult, const bool bIsSelected);

	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_ServerBrowserItem">();
	}
	static class UHLLUI_ServerBrowserItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_ServerBrowserItem>();
	}
};
static_assert(alignof(UHLLUI_ServerBrowserItem) == 0x000008, "Wrong alignment on UHLLUI_ServerBrowserItem");
static_assert(sizeof(UHLLUI_ServerBrowserItem) == 0x0002B0, "Wrong size on UHLLUI_ServerBrowserItem");
static_assert(offsetof(UHLLUI_ServerBrowserItem, ServerBrowser) == 0x000230, "Member 'UHLLUI_ServerBrowserItem::ServerBrowser' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, ItemIndex) == 0x000238, "Member 'UHLLUI_ServerBrowserItem::ItemIndex' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, LongServerNameScrollSpeed) == 0x00023C, "Member 'UHLLUI_ServerBrowserItem::LongServerNameScrollSpeed' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, FavouriteToggle) == 0x000240, "Member 'UHLLUI_ServerBrowserItem::FavouriteToggle' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, ServerThumbnail) == 0x000248, "Member 'UHLLUI_ServerBrowserItem::ServerThumbnail' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, ServerName) == 0x000250, "Member 'UHLLUI_ServerBrowserItem::ServerName' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, PlayerCount) == 0x000258, "Member 'UHLLUI_ServerBrowserItem::PlayerCount' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, MaxPlayerCount) == 0x000260, "Member 'UHLLUI_ServerBrowserItem::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, Ping) == 0x000268, "Member 'UHLLUI_ServerBrowserItem::Ping' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, MapName) == 0x000270, "Member 'UHLLUI_ServerBrowserItem::MapName' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, ModeName) == 0x000278, "Member 'UHLLUI_ServerBrowserItem::ModeName' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, OffensiveModeAttackingFaction) == 0x000280, "Member 'UHLLUI_ServerBrowserItem::OffensiveModeAttackingFaction' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, PasswordWidget) == 0x000288, "Member 'UHLLUI_ServerBrowserItem::PasswordWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, LongNameScroller) == 0x000290, "Member 'UHLLUI_ServerBrowserItem::LongNameScroller' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, LastTimePlayedText) == 0x000298, "Member 'UHLLUI_ServerBrowserItem::LastTimePlayedText' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowserItem, HistoryClearButton) == 0x0002A0, "Member 'UHLLUI_ServerBrowserItem::HistoryClearButton' has a wrong offset!");

// Class HLL.HLLPlayerIndicator
// 0x0030 (0x02F0 - 0x02C0)
class UHLLPlayerIndicator : public UHLLNameplateIndicatorBase
{
public:
	class UBorder*                                RootBorder;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                IconBorder;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        IconSwitcher;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerRoleGlyph;                                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B6[0x8];                                     // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPlayerIndicator">();
	}
	static class UHLLPlayerIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPlayerIndicator>();
	}
};
static_assert(alignof(UHLLPlayerIndicator) == 0x000008, "Wrong alignment on UHLLPlayerIndicator");
static_assert(sizeof(UHLLPlayerIndicator) == 0x0002F0, "Wrong size on UHLLPlayerIndicator");
static_assert(offsetof(UHLLPlayerIndicator, RootBorder) == 0x0002C0, "Member 'UHLLPlayerIndicator::RootBorder' has a wrong offset!");
static_assert(offsetof(UHLLPlayerIndicator, IconBorder) == 0x0002C8, "Member 'UHLLPlayerIndicator::IconBorder' has a wrong offset!");
static_assert(offsetof(UHLLPlayerIndicator, PlayerNameText) == 0x0002D0, "Member 'UHLLPlayerIndicator::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UHLLPlayerIndicator, IconSwitcher) == 0x0002D8, "Member 'UHLLPlayerIndicator::IconSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLPlayerIndicator, PlayerRoleGlyph) == 0x0002E0, "Member 'UHLLPlayerIndicator::PlayerRoleGlyph' has a wrong offset!");

// Class HLL.HLLPlayerManagementActions
// 0x0000 (0x0230 - 0x0230)
class UHLLPlayerManagementActions final : public UUserWidget
{
public:
	void InitWithPlayer(class UHLLRoundSummaryPlayer* PlayerWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPlayerManagementActions">();
	}
	static class UHLLPlayerManagementActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPlayerManagementActions>();
	}
};
static_assert(alignof(UHLLPlayerManagementActions) == 0x000008, "Wrong alignment on UHLLPlayerManagementActions");
static_assert(sizeof(UHLLPlayerManagementActions) == 0x000230, "Wrong size on UHLLPlayerManagementActions");

// Class HLL.HLLPlayerManagementReportDialog
// 0x0028 (0x0258 - 0x0230)
class UHLLPlayerManagementReportDialog final : public UUserWidget
{
public:
	class FString                                 GlobalPlayerId;                                    // 0x0230(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B7[0x18];                                    // 0x0240(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Close();
	void OnInitWithPlayer(class UHLLRoundSummaryPlayer* PlayerWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLPlayerManagementReportDialog">();
	}
	static class UHLLPlayerManagementReportDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLPlayerManagementReportDialog>();
	}
};
static_assert(alignof(UHLLPlayerManagementReportDialog) == 0x000008, "Wrong alignment on UHLLPlayerManagementReportDialog");
static_assert(sizeof(UHLLPlayerManagementReportDialog) == 0x000258, "Wrong size on UHLLPlayerManagementReportDialog");
static_assert(offsetof(UHLLPlayerManagementReportDialog, GlobalPlayerId) == 0x000230, "Member 'UHLLPlayerManagementReportDialog::GlobalPlayerId' has a wrong offset!");

// Class HLL.HLLUI_AvailableRoleItem
// 0x0040 (0x02A8 - 0x0268)
class UHLLUI_AvailableRoleItem : public UHLLUI_RoleItem
{
public:
	bool                                          IsAvailable;                                       // 0x0268(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B8[0x3];                                     // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FLinearColor                           IconColour_Current;                                // 0x026C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconColour_Available;                              // 0x027C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconColour_NotAvailable;                           // 0x028C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B9[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             RoleLimits;                                        // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_AvailableRoleItem">();
	}
	static class UHLLUI_AvailableRoleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_AvailableRoleItem>();
	}
};
static_assert(alignof(UHLLUI_AvailableRoleItem) == 0x000008, "Wrong alignment on UHLLUI_AvailableRoleItem");
static_assert(sizeof(UHLLUI_AvailableRoleItem) == 0x0002A8, "Wrong size on UHLLUI_AvailableRoleItem");
static_assert(offsetof(UHLLUI_AvailableRoleItem, IsAvailable) == 0x000268, "Member 'UHLLUI_AvailableRoleItem::IsAvailable' has a wrong offset!");
static_assert(offsetof(UHLLUI_AvailableRoleItem, IconColour_Current) == 0x00026C, "Member 'UHLLUI_AvailableRoleItem::IconColour_Current' has a wrong offset!");
static_assert(offsetof(UHLLUI_AvailableRoleItem, IconColour_Available) == 0x00027C, "Member 'UHLLUI_AvailableRoleItem::IconColour_Available' has a wrong offset!");
static_assert(offsetof(UHLLUI_AvailableRoleItem, IconColour_NotAvailable) == 0x00028C, "Member 'UHLLUI_AvailableRoleItem::IconColour_NotAvailable' has a wrong offset!");
static_assert(offsetof(UHLLUI_AvailableRoleItem, RoleLimits) == 0x0002A0, "Member 'UHLLUI_AvailableRoleItem::RoleLimits' has a wrong offset!");

// Class HLL.HLLProjectileMovement
// 0x0030 (0x0200 - 0x01D0)
class UHLLProjectileMovement final : public UProjectileMovementComponent
{
public:
	uint8                                         Pad_13BA[0x30];                                    // 0x01D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLProjectileMovement">();
	}
	static class UHLLProjectileMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLProjectileMovement>();
	}
};
static_assert(alignof(UHLLProjectileMovement) == 0x000010, "Wrong alignment on UHLLProjectileMovement");
static_assert(sizeof(UHLLProjectileMovement) == 0x000200, "Wrong size on UHLLProjectileMovement");

// Class HLL.HLLProjectile_CharacterBullet
// 0x0000 (0x0168 - 0x0168)
class UHLLProjectile_CharacterBullet final : public UHLLProjectile_Bullet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLProjectile_CharacterBullet">();
	}
	static class UHLLProjectile_CharacterBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLProjectile_CharacterBullet>();
	}
};
static_assert(alignof(UHLLProjectile_CharacterBullet) == 0x000008, "Wrong alignment on UHLLProjectile_CharacterBullet");
static_assert(sizeof(UHLLProjectile_CharacterBullet) == 0x000168, "Wrong size on UHLLProjectile_CharacterBullet");

// Class HLL.HLLRadialMenu_Base
// 0x00E8 (0x0318 - 0x0230)
class UHLLRadialMenu_Base : public UUserWidget
{
public:
	TSubclassOf<class UHLLRadialMenu_Separator>   SeparatorClass;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectionDeadzone;                                 // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLimitRadialSelection : 1;                         // 0x023C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowMouseWhenOpen : 1;                            // 0x023C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_13BB[0x3];                                     // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SelectionMaxRadiusInflation;                       // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13BC[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateSound                            OpenedSound;                                       // 0x0248(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            ClosedSound;                                       // 0x0260(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            ClosedAndExecuteSuccessSound;                      // 0x0278(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            ClosedAndExecuteFailedSound;                       // 0x0290(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_13BD[0x18];                                    // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLRadialMenu_Segment*>         Segments;                                          // 0x02C0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLRadialMenu_Separator*>       Separators;                                        // 0x02D0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsShown : 1;                                      // 0x02E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_13BE[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UOverlay*                               SegmentContainer;                                  // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               SeparatorContainer;                                // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Arrow;                                             // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ToggleAnimation;                                   // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13BF[0x10];                                    // 0x0308(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UHLLRadialMenu_Segment* AddSegment(TSubclassOf<class UHLLRadialMenu_Segment> SegmentClass, const bool bUpdate);
	void CenterMouse();
	void Hide(const bool bAnimate, const bool bExecuteSelection);
	bool OnHidden(const bool bExecuteSelection);
	void OnSelectionChanged(const int32 OldIndex, const int32 NewIndex);
	void OnShown();
	void RemoveAllSegments(const bool bUpdate);
	void RemoveSegment(class UHLLRadialMenu_Segment* Segment, const bool bUpdate);
	void Show(const bool bAnimate);
	void UpdateSegmentStates();
	void UpdateSeparators();

	int32 GetCurrentSelection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_Base">();
	}
	static class UHLLRadialMenu_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_Base>();
	}
};
static_assert(alignof(UHLLRadialMenu_Base) == 0x000008, "Wrong alignment on UHLLRadialMenu_Base");
static_assert(sizeof(UHLLRadialMenu_Base) == 0x000318, "Wrong size on UHLLRadialMenu_Base");
static_assert(offsetof(UHLLRadialMenu_Base, SeparatorClass) == 0x000230, "Member 'UHLLRadialMenu_Base::SeparatorClass' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, SelectionDeadzone) == 0x000238, "Member 'UHLLRadialMenu_Base::SelectionDeadzone' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, SelectionMaxRadiusInflation) == 0x000240, "Member 'UHLLRadialMenu_Base::SelectionMaxRadiusInflation' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, OpenedSound) == 0x000248, "Member 'UHLLRadialMenu_Base::OpenedSound' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, ClosedSound) == 0x000260, "Member 'UHLLRadialMenu_Base::ClosedSound' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, ClosedAndExecuteSuccessSound) == 0x000278, "Member 'UHLLRadialMenu_Base::ClosedAndExecuteSuccessSound' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, ClosedAndExecuteFailedSound) == 0x000290, "Member 'UHLLRadialMenu_Base::ClosedAndExecuteFailedSound' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, Segments) == 0x0002C0, "Member 'UHLLRadialMenu_Base::Segments' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, Separators) == 0x0002D0, "Member 'UHLLRadialMenu_Base::Separators' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, SegmentContainer) == 0x0002E8, "Member 'UHLLRadialMenu_Base::SegmentContainer' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, SeparatorContainer) == 0x0002F0, "Member 'UHLLRadialMenu_Base::SeparatorContainer' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, Arrow) == 0x0002F8, "Member 'UHLLRadialMenu_Base::Arrow' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_Base, ToggleAnimation) == 0x000300, "Member 'UHLLRadialMenu_Base::ToggleAnimation' has a wrong offset!");

// Class HLL.HLLRadialMenu_Separator
// 0x0000 (0x0238 - 0x0238)
class UHLLRadialMenu_Separator : public UHLLRadialMenu_ChildBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_Separator">();
	}
	static class UHLLRadialMenu_Separator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_Separator>();
	}
};
static_assert(alignof(UHLLRadialMenu_Separator) == 0x000008, "Wrong alignment on UHLLRadialMenu_Separator");
static_assert(sizeof(UHLLRadialMenu_Separator) == 0x000238, "Wrong size on UHLLRadialMenu_Separator");

// Class HLL.SeatCameraController
// 0x0040 (0x00F0 - 0x00B0)
class USeatCameraController final : public UActorComponent
{
public:
	uint8                                         Pad_13C2[0x10];                                    // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         PitchMin;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRate;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLimitYaw : 1;                                     // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13C3[0x3];                                     // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         YawMin;                                            // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMax;                                            // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRate;                                           // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C4[0x14];                                    // 0x00DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeatCameraController">();
	}
	static class USeatCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeatCameraController>();
	}
};
static_assert(alignof(USeatCameraController) == 0x000008, "Wrong alignment on USeatCameraController");
static_assert(sizeof(USeatCameraController) == 0x0000F0, "Wrong size on USeatCameraController");
static_assert(offsetof(USeatCameraController, PitchMin) == 0x0000C0, "Member 'USeatCameraController::PitchMin' has a wrong offset!");
static_assert(offsetof(USeatCameraController, PitchMax) == 0x0000C4, "Member 'USeatCameraController::PitchMax' has a wrong offset!");
static_assert(offsetof(USeatCameraController, PitchRate) == 0x0000C8, "Member 'USeatCameraController::PitchRate' has a wrong offset!");
static_assert(offsetof(USeatCameraController, YawMin) == 0x0000D0, "Member 'USeatCameraController::YawMin' has a wrong offset!");
static_assert(offsetof(USeatCameraController, YawMax) == 0x0000D4, "Member 'USeatCameraController::YawMax' has a wrong offset!");
static_assert(offsetof(USeatCameraController, YawRate) == 0x0000D8, "Member 'USeatCameraController::YawRate' has a wrong offset!");

// Class HLL.HLLRadialMenu_ChatBase
// 0x0020 (0x0338 - 0x0318)
class UHLLRadialMenu_ChatBase : public UHLLRadialMenu_Base
{
public:
	TSubclassOf<class UHLLRadialMenu_ChatSegment> SegmentClass;                                      // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChatName;                                          // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChatDesc;                                          // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChatVisibility;                                    // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveSetBlurBackground(bool bInBlurBackground);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_ChatBase">();
	}
	static class UHLLRadialMenu_ChatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_ChatBase>();
	}
};
static_assert(alignof(UHLLRadialMenu_ChatBase) == 0x000008, "Wrong alignment on UHLLRadialMenu_ChatBase");
static_assert(sizeof(UHLLRadialMenu_ChatBase) == 0x000338, "Wrong size on UHLLRadialMenu_ChatBase");
static_assert(offsetof(UHLLRadialMenu_ChatBase, SegmentClass) == 0x000318, "Member 'UHLLRadialMenu_ChatBase::SegmentClass' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_ChatBase, ChatName) == 0x000320, "Member 'UHLLRadialMenu_ChatBase::ChatName' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_ChatBase, ChatDesc) == 0x000328, "Member 'UHLLRadialMenu_ChatBase::ChatDesc' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_ChatBase, ChatVisibility) == 0x000330, "Member 'UHLLRadialMenu_ChatBase::ChatVisibility' has a wrong offset!");

// Class HLL.HLLRadialMenu_MarkersBase
// 0x0028 (0x0340 - 0x0318)
class UHLLRadialMenu_MarkersBase : public UHLLRadialMenu_Base
{
public:
	TSubclassOf<class UHLLRadialMenu_MarkersSegment> SegmentClass;                                      // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerName;                                        // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerDesc;                                        // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerCount;                                       // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerVisibility;                                  // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_MarkersBase">();
	}
	static class UHLLRadialMenu_MarkersBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_MarkersBase>();
	}
};
static_assert(alignof(UHLLRadialMenu_MarkersBase) == 0x000008, "Wrong alignment on UHLLRadialMenu_MarkersBase");
static_assert(sizeof(UHLLRadialMenu_MarkersBase) == 0x000340, "Wrong size on UHLLRadialMenu_MarkersBase");
static_assert(offsetof(UHLLRadialMenu_MarkersBase, SegmentClass) == 0x000318, "Member 'UHLLRadialMenu_MarkersBase::SegmentClass' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_MarkersBase, MarkerName) == 0x000320, "Member 'UHLLRadialMenu_MarkersBase::MarkerName' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_MarkersBase, MarkerDesc) == 0x000328, "Member 'UHLLRadialMenu_MarkersBase::MarkerDesc' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_MarkersBase, MarkerCount) == 0x000330, "Member 'UHLLRadialMenu_MarkersBase::MarkerCount' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_MarkersBase, MarkerVisibility) == 0x000338, "Member 'UHLLRadialMenu_MarkersBase::MarkerVisibility' has a wrong offset!");

// Class HLL.HLLRadialMenu_WeaponBase
// 0x0010 (0x0328 - 0x0318)
class UHLLRadialMenu_WeaponBase : public UHLLRadialMenu_Base
{
public:
	TSubclassOf<class UHLLRadialMenu_WeaponSegment> SegmentClass;                                      // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponName;                                        // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveSetBlurBackground(bool bInBlurBackground);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRadialMenu_WeaponBase">();
	}
	static class UHLLRadialMenu_WeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRadialMenu_WeaponBase>();
	}
};
static_assert(alignof(UHLLRadialMenu_WeaponBase) == 0x000008, "Wrong alignment on UHLLRadialMenu_WeaponBase");
static_assert(sizeof(UHLLRadialMenu_WeaponBase) == 0x000328, "Wrong size on UHLLRadialMenu_WeaponBase");
static_assert(offsetof(UHLLRadialMenu_WeaponBase, SegmentClass) == 0x000318, "Member 'UHLLRadialMenu_WeaponBase::SegmentClass' has a wrong offset!");
static_assert(offsetof(UHLLRadialMenu_WeaponBase, WeaponName) == 0x000320, "Member 'UHLLRadialMenu_WeaponBase::WeaponName' has a wrong offset!");

// Class HLL.HLLRconCommandWindow
// 0x0018 (0x0248 - 0x0230)
class UHLLRconCommandWindow : public UUserWidget
{
public:
	class UButton*                                CloseButton;                                       // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C5[0x10];                                    // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearUI();
	void OnClosed();
	void OnReceivedReply(const class FString& ReplyMessage);
	void OnSubmitCommand(const class FString& Command);
	void SetSubmitButtonEnabled(bool IsEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRconCommandWindow">();
	}
	static class UHLLRconCommandWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRconCommandWindow>();
	}
};
static_assert(alignof(UHLLRconCommandWindow) == 0x000008, "Wrong alignment on UHLLRconCommandWindow");
static_assert(sizeof(UHLLRconCommandWindow) == 0x000248, "Wrong size on UHLLRconCommandWindow");
static_assert(offsetof(UHLLRconCommandWindow, CloseButton) == 0x000230, "Member 'UHLLRconCommandWindow::CloseButton' has a wrong offset!");

// Class HLL.HLLRecoilTester
// 0x0068 (0x0288 - 0x0220)
class AHLLRecoilTester final : public AActor
{
public:
	uint8                                         NumBurstsToFire;                                   // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C6[0x3];                                     // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         LineDrawTime;                                      // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitDrawTime;                                       // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ShotsPerBurst;                                     // 0x022C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C7[0x3];                                     // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FShotOffset>                    ShotOffsets;                                       // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRecoilAndSpreadState                  RecoilState;                                       // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRecoilAndSpread                       RecoilConfig;                                      // 0x0248(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UArrowComponent*                        BaseArrow;                                         // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        AimArrow;                                          // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Reset();
	void RunTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRecoilTester">();
	}
	static class AHLLRecoilTester* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLRecoilTester>();
	}
};
static_assert(alignof(AHLLRecoilTester) == 0x000008, "Wrong alignment on AHLLRecoilTester");
static_assert(sizeof(AHLLRecoilTester) == 0x000288, "Wrong size on AHLLRecoilTester");
static_assert(offsetof(AHLLRecoilTester, NumBurstsToFire) == 0x000220, "Member 'AHLLRecoilTester::NumBurstsToFire' has a wrong offset!");
static_assert(offsetof(AHLLRecoilTester, LineDrawTime) == 0x000224, "Member 'AHLLRecoilTester::LineDrawTime' has a wrong offset!");
static_assert(offsetof(AHLLRecoilTester, HitDrawTime) == 0x000228, "Member 'AHLLRecoilTester::HitDrawTime' has a wrong offset!");
static_assert(offsetof(AHLLRecoilTester, ShotsPerBurst) == 0x00022C, "Member 'AHLLRecoilTester::ShotsPerBurst' has a wrong offset!");
static_assert(offsetof(AHLLRecoilTester, ShotOffsets) == 0x000230, "Member 'AHLLRecoilTester::ShotOffsets' has a wrong offset!");
static_assert(offsetof(AHLLRecoilTester, RecoilState) == 0x000240, "Member 'AHLLRecoilTester::RecoilState' has a wrong offset!");
static_assert(offsetof(AHLLRecoilTester, RecoilConfig) == 0x000248, "Member 'AHLLRecoilTester::RecoilConfig' has a wrong offset!");
static_assert(offsetof(AHLLRecoilTester, BaseArrow) == 0x000278, "Member 'AHLLRecoilTester::BaseArrow' has a wrong offset!");
static_assert(offsetof(AHLLRecoilTester, AimArrow) == 0x000280, "Member 'AHLLRecoilTester::AimArrow' has a wrong offset!");

// Class HLL.HLLSupplyDropBase
// 0x00D0 (0x02F0 - 0x0220)
class AHLLSupplyDropBase : public AActor
{
public:
	uint8                                         Pad_13C8[0x68];                                    // 0x0220(0x0068)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        SceneRoot;                                         // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSimpleHealthComponent*              HealthComponent;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDismantlingComponent*                  DismantlingComponent;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPingableComponent*                     PingableComponent;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DismantleTime;                                     // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C9[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   DisplayName;                                       // 0x02C8(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ETeam                                         OwningTeam;                                        // 0x02E0(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLDamageFilterType                          DamageFilterType;                                  // 0x02E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13CA[0x6];                                     // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerState*                    SpawnedByPlayer;                                   // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSupplyDropBase">();
	}
	static class AHLLSupplyDropBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSupplyDropBase>();
	}
};
static_assert(alignof(AHLLSupplyDropBase) == 0x000008, "Wrong alignment on AHLLSupplyDropBase");
static_assert(sizeof(AHLLSupplyDropBase) == 0x0002F0, "Wrong size on AHLLSupplyDropBase");
static_assert(offsetof(AHLLSupplyDropBase, SceneRoot) == 0x000288, "Member 'AHLLSupplyDropBase::SceneRoot' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, Mesh) == 0x000290, "Member 'AHLLSupplyDropBase::Mesh' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, MapComponent) == 0x000298, "Member 'AHLLSupplyDropBase::MapComponent' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, IndicatorComponent) == 0x0002A0, "Member 'AHLLSupplyDropBase::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, HealthComponent) == 0x0002A8, "Member 'AHLLSupplyDropBase::HealthComponent' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, DismantlingComponent) == 0x0002B0, "Member 'AHLLSupplyDropBase::DismantlingComponent' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, PingableComponent) == 0x0002B8, "Member 'AHLLSupplyDropBase::PingableComponent' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, DismantleTime) == 0x0002C0, "Member 'AHLLSupplyDropBase::DismantleTime' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, DisplayName) == 0x0002C8, "Member 'AHLLSupplyDropBase::DisplayName' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, OwningTeam) == 0x0002E0, "Member 'AHLLSupplyDropBase::OwningTeam' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, DamageFilterType) == 0x0002E1, "Member 'AHLLSupplyDropBase::DamageFilterType' has a wrong offset!");
static_assert(offsetof(AHLLSupplyDropBase, SpawnedByPlayer) == 0x0002E8, "Member 'AHLLSupplyDropBase::SpawnedByPlayer' has a wrong offset!");

// Class HLL.HLLSupplyDrop_Crate
// 0x0008 (0x02F8 - 0x02F0)
class AHLLSupplyDrop_Crate : public AHLLSupplyDropBase
{
public:
	class UHLLSupplyComponent*                    SupplyComponent;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSupplyDrop_Crate">();
	}
	static class AHLLSupplyDrop_Crate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSupplyDrop_Crate>();
	}
};
static_assert(alignof(AHLLSupplyDrop_Crate) == 0x000008, "Wrong alignment on AHLLSupplyDrop_Crate");
static_assert(sizeof(AHLLSupplyDrop_Crate) == 0x0002F8, "Wrong size on AHLLSupplyDrop_Crate");
static_assert(offsetof(AHLLSupplyDrop_Crate, SupplyComponent) == 0x0002F0, "Member 'AHLLSupplyDrop_Crate::SupplyComponent' has a wrong offset!");

// Class HLL.HLLReconInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLReconInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLReconInterface">();
	}
	static class IHLLReconInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLReconInterface>();
	}
};
static_assert(alignof(IHLLReconInterface) == 0x000008, "Wrong alignment on IHLLReconInterface");
static_assert(sizeof(IHLLReconInterface) == 0x000028, "Wrong size on IHLLReconInterface");

// Class HLL.HLLRepairStation
// 0x0048 (0x03C8 - 0x0380)
class AHLLRepairStation : public AHLLDispenseStructure
{
public:
	int32                                         RepairPerSecond;                                   // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepairRadius;                                      // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             RepairSound;                                       // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RepairActionScore;                                 // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13CB[0x8];                                     // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bIsRepairing : 1;                                  // 0x03A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_13CC[0x7];                                     // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UParticleSystemComponent*               RepairParticle;                                    // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         RepairAC;                                          // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Repairing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRepairStation">();
	}
	static class AHLLRepairStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLRepairStation>();
	}
};
static_assert(alignof(AHLLRepairStation) == 0x000008, "Wrong alignment on AHLLRepairStation");
static_assert(sizeof(AHLLRepairStation) == 0x0003C8, "Wrong size on AHLLRepairStation");
static_assert(offsetof(AHLLRepairStation, RepairPerSecond) == 0x000380, "Member 'AHLLRepairStation::RepairPerSecond' has a wrong offset!");
static_assert(offsetof(AHLLRepairStation, RepairRadius) == 0x000384, "Member 'AHLLRepairStation::RepairRadius' has a wrong offset!");
static_assert(offsetof(AHLLRepairStation, RepairSound) == 0x000388, "Member 'AHLLRepairStation::RepairSound' has a wrong offset!");
static_assert(offsetof(AHLLRepairStation, RepairActionScore) == 0x000390, "Member 'AHLLRepairStation::RepairActionScore' has a wrong offset!");
static_assert(offsetof(AHLLRepairStation, RepairParticle) == 0x0003A8, "Member 'AHLLRepairStation::RepairParticle' has a wrong offset!");
static_assert(offsetof(AHLLRepairStation, RepairAC) == 0x0003B0, "Member 'AHLLRepairStation::RepairAC' has a wrong offset!");
static_assert(offsetof(AHLLRepairStation, MapComponent) == 0x0003B8, "Member 'AHLLRepairStation::MapComponent' has a wrong offset!");
static_assert(offsetof(AHLLRepairStation, IndicatorComponent) == 0x0003C0, "Member 'AHLLRepairStation::IndicatorComponent' has a wrong offset!");

// Class HLL.HLLSuppressionInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLSuppressionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSuppressionInterface">();
	}
	static class IHLLSuppressionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLSuppressionInterface>();
	}
};
static_assert(alignof(IHLLSuppressionInterface) == 0x000008, "Wrong alignment on IHLLSuppressionInterface");
static_assert(sizeof(IHLLSuppressionInterface) == 0x000028, "Wrong size on IHLLSuppressionInterface");

// Class HLL.HLLReplicationGraphNode_AlwaysRelevant_ForConnection
// 0x0248 (0x0298 - 0x0050)
class UHLLReplicationGraphNode_AlwaysRelevant_ForConnection final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_13CD[0x228];                                   // 0x0050(0x0228)(Fixing Size After Last Property [ Dumper-69 ])
	class AActor*                                 LastPawn;                                          // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAlwaysRelevantActorInfo>       PastRelevantActors;                                // 0x0280(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13CE[0x8];                                     // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLReplicationGraphNode_AlwaysRelevant_ForConnection">();
	}
	static class UHLLReplicationGraphNode_AlwaysRelevant_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLReplicationGraphNode_AlwaysRelevant_ForConnection>();
	}
};
static_assert(alignof(UHLLReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000008, "Wrong alignment on UHLLReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(sizeof(UHLLReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000298, "Wrong size on UHLLReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(offsetof(UHLLReplicationGraphNode_AlwaysRelevant_ForConnection, LastPawn) == 0x000278, "Member 'UHLLReplicationGraphNode_AlwaysRelevant_ForConnection::LastPawn' has a wrong offset!");
static_assert(offsetof(UHLLReplicationGraphNode_AlwaysRelevant_ForConnection, PastRelevantActors) == 0x000280, "Member 'UHLLReplicationGraphNode_AlwaysRelevant_ForConnection::PastRelevantActors' has a wrong offset!");

// Class HLL.HLLReplicationGraphNode_PlayerStateFrequencyLimiter
// 0x0030 (0x0080 - 0x0050)
class UHLLReplicationGraphNode_PlayerStateFrequencyLimiter final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_13CF[0x30];                                    // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLReplicationGraphNode_PlayerStateFrequencyLimiter">();
	}
	static class UHLLReplicationGraphNode_PlayerStateFrequencyLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLReplicationGraphNode_PlayerStateFrequencyLimiter>();
	}
};
static_assert(alignof(UHLLReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000008, "Wrong alignment on UHLLReplicationGraphNode_PlayerStateFrequencyLimiter");
static_assert(sizeof(UHLLReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000080, "Wrong size on UHLLReplicationGraphNode_PlayerStateFrequencyLimiter");

// Class HLL.HLLSupplyComponent
// 0x0040 (0x00F0 - 0x00B0)
class UHLLSupplyComponent final : public UActorComponent
{
public:
	uint8                                         bAutoRegisterSupplies : 1;                         // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13D0[0x1F];                                    // 0x00B1(0x001F)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bInfiniteSupplies;                                 // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D1[0x3];                                     // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         NumSupplies;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SupplyRange;                                       // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        NumSuppliesRemaining;                              // 0x00DC(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRegisteredSupplies : 1;                           // 0x00DE(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_13D2[0x1];                                     // 0x00DF(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   SupplyUseScore;                                    // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bScaleScoreByAmount : 1;                           // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_13D3[0x7];                                     // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static int32 GetTotalSupplies(const TArray<class UHLLSupplyComponent*>& FromSupplies);

	void OnRep_SuppliesRemaining();
	void UpdateRegistration();

	int32 GetSuppliesRemaining() const;
	float GetSupplyRange() const;
	float GetSupplyRangeSqrd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSupplyComponent">();
	}
	static class UHLLSupplyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSupplyComponent>();
	}
};
static_assert(alignof(UHLLSupplyComponent) == 0x000008, "Wrong alignment on UHLLSupplyComponent");
static_assert(sizeof(UHLLSupplyComponent) == 0x0000F0, "Wrong size on UHLLSupplyComponent");
static_assert(offsetof(UHLLSupplyComponent, bInfiniteSupplies) == 0x0000D0, "Member 'UHLLSupplyComponent::bInfiniteSupplies' has a wrong offset!");
static_assert(offsetof(UHLLSupplyComponent, NumSupplies) == 0x0000D4, "Member 'UHLLSupplyComponent::NumSupplies' has a wrong offset!");
static_assert(offsetof(UHLLSupplyComponent, SupplyRange) == 0x0000D8, "Member 'UHLLSupplyComponent::SupplyRange' has a wrong offset!");
static_assert(offsetof(UHLLSupplyComponent, NumSuppliesRemaining) == 0x0000DC, "Member 'UHLLSupplyComponent::NumSuppliesRemaining' has a wrong offset!");
static_assert(offsetof(UHLLSupplyComponent, SupplyUseScore) == 0x0000E0, "Member 'UHLLSupplyComponent::SupplyUseScore' has a wrong offset!");

// Class HLL.HLLReplicationGraphNode_Team
// 0x0028 (0x0078 - 0x0050)
class UHLLReplicationGraphNode_Team final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_13D5[0x28];                                    // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLReplicationGraphNode_Team">();
	}
	static class UHLLReplicationGraphNode_Team* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLReplicationGraphNode_Team>();
	}
};
static_assert(alignof(UHLLReplicationGraphNode_Team) == 0x000008, "Wrong alignment on UHLLReplicationGraphNode_Team");
static_assert(sizeof(UHLLReplicationGraphNode_Team) == 0x000078, "Wrong size on UHLLReplicationGraphNode_Team");

// Class HLL.HLLResourceGenerator
// 0x0020 (0x00D0 - 0x00B0)
class UHLLResourceGenerator final : public UActorComponent
{
public:
	ESectorResourceType                           ResourceType;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D6[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         GenerationAmount;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GenerationActionScore;                             // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CachedSectorDistance;                              // 0x00C0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D7[0xC];                                     // 0x00C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	int32 DistFromBase();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLResourceGenerator">();
	}
	static class UHLLResourceGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLResourceGenerator>();
	}
};
static_assert(alignof(UHLLResourceGenerator) == 0x000008, "Wrong alignment on UHLLResourceGenerator");
static_assert(sizeof(UHLLResourceGenerator) == 0x0000D0, "Wrong size on UHLLResourceGenerator");
static_assert(offsetof(UHLLResourceGenerator, ResourceType) == 0x0000B0, "Member 'UHLLResourceGenerator::ResourceType' has a wrong offset!");
static_assert(offsetof(UHLLResourceGenerator, GenerationAmount) == 0x0000B4, "Member 'UHLLResourceGenerator::GenerationAmount' has a wrong offset!");
static_assert(offsetof(UHLLResourceGenerator, GenerationActionScore) == 0x0000B8, "Member 'UHLLResourceGenerator::GenerationActionScore' has a wrong offset!");
static_assert(offsetof(UHLLResourceGenerator, CachedSectorDistance) == 0x0000C0, "Member 'UHLLResourceGenerator::CachedSectorDistance' has a wrong offset!");

// Class HLL.HLLResourceNodeIndicator
// 0x0008 (0x02B8 - 0x02B0)
class UHLLResourceNodeIndicator : public UHLLIndicatorBase
{
public:
	class UTextBlock*                             GenerationText;                                    // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLResourceNodeIndicator">();
	}
	static class UHLLResourceNodeIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLResourceNodeIndicator>();
	}
};
static_assert(alignof(UHLLResourceNodeIndicator) == 0x000008, "Wrong alignment on UHLLResourceNodeIndicator");
static_assert(sizeof(UHLLResourceNodeIndicator) == 0x0002B8, "Wrong size on UHLLResourceNodeIndicator");
static_assert(offsetof(UHLLResourceNodeIndicator, GenerationText) == 0x0002B0, "Member 'UHLLResourceNodeIndicator::GenerationText' has a wrong offset!");

// Class HLL.HLLRichPresence
// 0x0010 (0x0040 - 0x0030)
class UHLLRichPresence final : public UGameInstanceSubsystem
{
public:
	float                                         TimeBetweenPresenceUpdates;                        // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13D8[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FTimerHandle                           TH_Update;                                         // 0x0038(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void UpdateImmediate(const class UObject* WorldContextObject);

	void DoRichPrecenseUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRichPresence">();
	}
	static class UHLLRichPresence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRichPresence>();
	}
};
static_assert(alignof(UHLLRichPresence) == 0x000008, "Wrong alignment on UHLLRichPresence");
static_assert(sizeof(UHLLRichPresence) == 0x000040, "Wrong size on UHLLRichPresence");
static_assert(offsetof(UHLLRichPresence, TimeBetweenPresenceUpdates) == 0x000030, "Member 'UHLLRichPresence::TimeBetweenPresenceUpdates' has a wrong offset!");
static_assert(offsetof(UHLLRichPresence, TH_Update) == 0x000038, "Member 'UHLLRichPresence::TH_Update' has a wrong offset!");

// Class HLL.HLLRoundSummaryDetails
// 0x00E8 (0x0318 - 0x0230)
class UHLLRoundSummaryDetails : public UUserWidget
{
public:
	EViewMode                                     CurrentViewMode;                                   // 0x0230(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D9[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLRoundSummaryStat*>           StatWidgets;                                       // 0x0240(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLRoundSummaryStatGroup*>      GroupWidgets;                                      // 0x0250(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bMatchEnded : 1;                                   // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          ViewingPersonal;                                   // 0x0261(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13DA[0x2];                                     // 0x0262(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         StatUpdateFrequency;                               // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersonalStatsListDataAsset*            CachedPersonalStatsList;                           // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13DB[0x8];                                     // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UPersonalStatsListDataAsset*            DefaultStatsList;                                  // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLTeamContainer>          TeamContainerClass;                                // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLRoundSummaryStatGroup>  GroupWidgetClass;                                  // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLRoundSummaryStat>       StatWidgetClass;                                   // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLTeamContainer*                      AxisTeamData;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLTeamContainer*                      AlliedTeamData;                                    // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             LHSSlot;                                           // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             RHSSlot;                                           // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinScoreText;                                      // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LHSTeamName;                                       // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RHSTeamName;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LHSPlayerCount;                                    // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RHSPlayerCount;                                    // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LHSTeamIcon;                                       // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RHSTeamIcon;                                       // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                CommendationHint;                                  // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           StatPanel;                                         // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        ContentSwitcher;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerPopulationText;                              // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      StatGridPanel;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CanGiveAccolade();
	class UNamedSlot* GetLHSSlot();
	class UNamedSlot* GetRHSSlot();
	void K2_PostInit();
	void OnAccoladesPressed();
	void OnBackPressed();
	void OnInputChanged();
	void OnInputDeviceChanged(bool NewValue);
	void OnScoreboardClosed();
	void OnScoreboardOpened();
	void ReceiveRefreshScreen();
	void SetMode(const EViewMode ViewMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoundSummaryDetails">();
	}
	static class UHLLRoundSummaryDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoundSummaryDetails>();
	}
};
static_assert(alignof(UHLLRoundSummaryDetails) == 0x000008, "Wrong alignment on UHLLRoundSummaryDetails");
static_assert(sizeof(UHLLRoundSummaryDetails) == 0x000318, "Wrong size on UHLLRoundSummaryDetails");
static_assert(offsetof(UHLLRoundSummaryDetails, CurrentViewMode) == 0x000230, "Member 'UHLLRoundSummaryDetails::CurrentViewMode' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, ViewportClient) == 0x000238, "Member 'UHLLRoundSummaryDetails::ViewportClient' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, StatWidgets) == 0x000240, "Member 'UHLLRoundSummaryDetails::StatWidgets' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, GroupWidgets) == 0x000250, "Member 'UHLLRoundSummaryDetails::GroupWidgets' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, ViewingPersonal) == 0x000261, "Member 'UHLLRoundSummaryDetails::ViewingPersonal' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, StatUpdateFrequency) == 0x000264, "Member 'UHLLRoundSummaryDetails::StatUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, CachedPersonalStatsList) == 0x000268, "Member 'UHLLRoundSummaryDetails::CachedPersonalStatsList' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, DefaultStatsList) == 0x000278, "Member 'UHLLRoundSummaryDetails::DefaultStatsList' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, TeamContainerClass) == 0x000280, "Member 'UHLLRoundSummaryDetails::TeamContainerClass' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, GroupWidgetClass) == 0x000288, "Member 'UHLLRoundSummaryDetails::GroupWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, StatWidgetClass) == 0x000290, "Member 'UHLLRoundSummaryDetails::StatWidgetClass' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, AxisTeamData) == 0x000298, "Member 'UHLLRoundSummaryDetails::AxisTeamData' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, AlliedTeamData) == 0x0002A0, "Member 'UHLLRoundSummaryDetails::AlliedTeamData' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, LHSSlot) == 0x0002A8, "Member 'UHLLRoundSummaryDetails::LHSSlot' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, RHSSlot) == 0x0002B0, "Member 'UHLLRoundSummaryDetails::RHSSlot' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, WinScoreText) == 0x0002B8, "Member 'UHLLRoundSummaryDetails::WinScoreText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, LHSTeamName) == 0x0002C0, "Member 'UHLLRoundSummaryDetails::LHSTeamName' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, RHSTeamName) == 0x0002C8, "Member 'UHLLRoundSummaryDetails::RHSTeamName' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, LHSPlayerCount) == 0x0002D0, "Member 'UHLLRoundSummaryDetails::LHSPlayerCount' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, RHSPlayerCount) == 0x0002D8, "Member 'UHLLRoundSummaryDetails::RHSPlayerCount' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, LHSTeamIcon) == 0x0002E0, "Member 'UHLLRoundSummaryDetails::LHSTeamIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, RHSTeamIcon) == 0x0002E8, "Member 'UHLLRoundSummaryDetails::RHSTeamIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, CommendationHint) == 0x0002F0, "Member 'UHLLRoundSummaryDetails::CommendationHint' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, StatPanel) == 0x0002F8, "Member 'UHLLRoundSummaryDetails::StatPanel' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, ContentSwitcher) == 0x000300, "Member 'UHLLRoundSummaryDetails::ContentSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, ServerPopulationText) == 0x000308, "Member 'UHLLRoundSummaryDetails::ServerPopulationText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryDetails, StatGridPanel) == 0x000310, "Member 'UHLLRoundSummaryDetails::StatGridPanel' has a wrong offset!");

// Class HLL.HLLRoundSummaryStatGroup
// 0x0018 (0x0248 - 0x0230)
class UHLLRoundSummaryStatGroup : public UUserWidget
{
public:
	int32                                         MaxColumns;                                        // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DC[0x4];                                     // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             NameText;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUniformGridPanel*                      GridPanel;                                         // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoundSummaryStatGroup">();
	}
	static class UHLLRoundSummaryStatGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoundSummaryStatGroup>();
	}
};
static_assert(alignof(UHLLRoundSummaryStatGroup) == 0x000008, "Wrong alignment on UHLLRoundSummaryStatGroup");
static_assert(sizeof(UHLLRoundSummaryStatGroup) == 0x000248, "Wrong size on UHLLRoundSummaryStatGroup");
static_assert(offsetof(UHLLRoundSummaryStatGroup, MaxColumns) == 0x000230, "Member 'UHLLRoundSummaryStatGroup::MaxColumns' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryStatGroup, NameText) == 0x000238, "Member 'UHLLRoundSummaryStatGroup::NameText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryStatGroup, GridPanel) == 0x000240, "Member 'UHLLRoundSummaryStatGroup::GridPanel' has a wrong offset!");

// Class HLL.HLLRoundSummaryPlayer
// 0x0138 (0x0368 - 0x0230)
class UHLLRoundSummaryPlayer : public UUserWidget
{
public:
	bool                                          bIsLocalPlayer;                                    // 0x0230(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DD[0x1];                                     // 0x0231(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bHasFocus;                                         // 0x0232(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DE[0x15];                                    // 0x0233(0x0015)(Fixing Size After Last Property [ Dumper-69 ])
	class UBorder*                                RootBorder;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlayerName;                                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlayerClan;                                        // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PlayerIcon;                                        // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 RankIcon;                                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           RankIconContainer;                                 // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlayerLevel;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PingValue;                                         // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             CombatValue;                                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             OffenseValue;                                      // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             DefenseValue;                                      // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             SupportValue;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             CommendCount;                                      // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                CommendButton;                                     // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 CommendIcon;                                       // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuAnchor*                            MenuAnchor;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DF[0x2];                                     // 0x02C8(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	ECommendationTooltipType                      CommendationType;                                  // 0x02CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E0[0x5];                                     // 0x02CB(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 VoipIcon;                                          // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BlockButton;                                       // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlatformIcon;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PlatformIconContainer;                             // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AShooterPlayerState>     AssignedPlayer;                                    // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 KickIcon;                                          // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             VotingText;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   KickTooltipText;                                   // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	class FText                                   BlockCommunicationTooltipText;                     // 0x0320(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	class FText                                   MuteTooltipText;                                   // 0x0338(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	class UWidget*                                FriendWidget;                                      // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E1[0x10];                                    // 0x0358(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddT17Friend();
	void BlockPlayer();
	bool CanAddT17Friend();
	bool CanBlock();
	bool CanMutePlayer();
	bool CanReport();
	bool CanUnblock();
	bool GetCanCommend();
	bool IsInParty();
	bool IsPlayerBlockedAllCommunication();
	bool IsPlayerMuted();
	bool IsSamePlatformAsLocal();
	void KickFromParty();
	void OnAddFriend();
	void OnCommend();
	void OnKick();
	struct FEventReply OnKickIconClicked(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent);
	struct FEventReply OnMuteIconClicked(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent);
	void OnNotifyReportDialogClosed();
	void ReceiveInit();
	void ReportPlayer();
	void ShowPlatformProfileUI();
	void ToggleBlockAllCommunication();
	void ToggleMute();
	void UnblockPlayer();

	bool IsKickingEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoundSummaryPlayer">();
	}
	static class UHLLRoundSummaryPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoundSummaryPlayer>();
	}
};
static_assert(alignof(UHLLRoundSummaryPlayer) == 0x000008, "Wrong alignment on UHLLRoundSummaryPlayer");
static_assert(sizeof(UHLLRoundSummaryPlayer) == 0x000368, "Wrong size on UHLLRoundSummaryPlayer");
static_assert(offsetof(UHLLRoundSummaryPlayer, bIsLocalPlayer) == 0x000230, "Member 'UHLLRoundSummaryPlayer::bIsLocalPlayer' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, bHasFocus) == 0x000232, "Member 'UHLLRoundSummaryPlayer::bHasFocus' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, RootBorder) == 0x000248, "Member 'UHLLRoundSummaryPlayer::RootBorder' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, PlayerName) == 0x000250, "Member 'UHLLRoundSummaryPlayer::PlayerName' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, PlayerClan) == 0x000258, "Member 'UHLLRoundSummaryPlayer::PlayerClan' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, PlayerIcon) == 0x000260, "Member 'UHLLRoundSummaryPlayer::PlayerIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, RankIcon) == 0x000268, "Member 'UHLLRoundSummaryPlayer::RankIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, RankIconContainer) == 0x000270, "Member 'UHLLRoundSummaryPlayer::RankIconContainer' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, PlayerLevel) == 0x000278, "Member 'UHLLRoundSummaryPlayer::PlayerLevel' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, PingValue) == 0x000280, "Member 'UHLLRoundSummaryPlayer::PingValue' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, CombatValue) == 0x000288, "Member 'UHLLRoundSummaryPlayer::CombatValue' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, OffenseValue) == 0x000290, "Member 'UHLLRoundSummaryPlayer::OffenseValue' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, DefenseValue) == 0x000298, "Member 'UHLLRoundSummaryPlayer::DefenseValue' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, SupportValue) == 0x0002A0, "Member 'UHLLRoundSummaryPlayer::SupportValue' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, CommendCount) == 0x0002A8, "Member 'UHLLRoundSummaryPlayer::CommendCount' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, CommendButton) == 0x0002B0, "Member 'UHLLRoundSummaryPlayer::CommendButton' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, CommendIcon) == 0x0002B8, "Member 'UHLLRoundSummaryPlayer::CommendIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, MenuAnchor) == 0x0002C0, "Member 'UHLLRoundSummaryPlayer::MenuAnchor' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, CommendationType) == 0x0002CA, "Member 'UHLLRoundSummaryPlayer::CommendationType' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, VoipIcon) == 0x0002D0, "Member 'UHLLRoundSummaryPlayer::VoipIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, BlockButton) == 0x0002D8, "Member 'UHLLRoundSummaryPlayer::BlockButton' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, PlatformIcon) == 0x0002E0, "Member 'UHLLRoundSummaryPlayer::PlatformIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, PlatformIconContainer) == 0x0002E8, "Member 'UHLLRoundSummaryPlayer::PlatformIconContainer' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, AssignedPlayer) == 0x0002F0, "Member 'UHLLRoundSummaryPlayer::AssignedPlayer' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, KickIcon) == 0x0002F8, "Member 'UHLLRoundSummaryPlayer::KickIcon' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, VotingText) == 0x000300, "Member 'UHLLRoundSummaryPlayer::VotingText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, KickTooltipText) == 0x000308, "Member 'UHLLRoundSummaryPlayer::KickTooltipText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, BlockCommunicationTooltipText) == 0x000320, "Member 'UHLLRoundSummaryPlayer::BlockCommunicationTooltipText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, MuteTooltipText) == 0x000338, "Member 'UHLLRoundSummaryPlayer::MuteTooltipText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryPlayer, FriendWidget) == 0x000350, "Member 'UHLLRoundSummaryPlayer::FriendWidget' has a wrong offset!");

// Class HLL.HLLXPItem
// 0x0028 (0x0258 - 0x0230)
class UHLLXPItem : public UUserWidget
{
public:
	class UTextBlock*                             NameText;                                          // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ValueText;                                         // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Anim_Show;                                         // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PlayerIcon;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0250(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsMultiplier : 1;                                 // 0x0254(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13E2[0x3];                                     // 0x0255(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLXPItem">();
	}
	static class UHLLXPItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLXPItem>();
	}
};
static_assert(alignof(UHLLXPItem) == 0x000008, "Wrong alignment on UHLLXPItem");
static_assert(sizeof(UHLLXPItem) == 0x000258, "Wrong size on UHLLXPItem");
static_assert(offsetof(UHLLXPItem, NameText) == 0x000230, "Member 'UHLLXPItem::NameText' has a wrong offset!");
static_assert(offsetof(UHLLXPItem, ValueText) == 0x000238, "Member 'UHLLXPItem::ValueText' has a wrong offset!");
static_assert(offsetof(UHLLXPItem, Anim_Show) == 0x000240, "Member 'UHLLXPItem::Anim_Show' has a wrong offset!");
static_assert(offsetof(UHLLXPItem, PlayerIcon) == 0x000248, "Member 'UHLLXPItem::PlayerIcon' has a wrong offset!");
static_assert(offsetof(UHLLXPItem, Value) == 0x000250, "Member 'UHLLXPItem::Value' has a wrong offset!");

// Class HLL.HLLRoundSummaryTeam
// 0x0030 (0x0260 - 0x0230)
class UHLLRoundSummaryTeam : public UUserWidget
{
public:
	uint8                                         Pad_13E3[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 TeamFlag;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MunitionsText;                                     // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ManpowerText;                                      // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FuelText;                                          // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ScoreValue;                                        // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLRoundSummaryTeam">();
	}
	static class UHLLRoundSummaryTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLRoundSummaryTeam>();
	}
};
static_assert(alignof(UHLLRoundSummaryTeam) == 0x000008, "Wrong alignment on UHLLRoundSummaryTeam");
static_assert(sizeof(UHLLRoundSummaryTeam) == 0x000260, "Wrong size on UHLLRoundSummaryTeam");
static_assert(offsetof(UHLLRoundSummaryTeam, TeamFlag) == 0x000238, "Member 'UHLLRoundSummaryTeam::TeamFlag' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryTeam, MunitionsText) == 0x000240, "Member 'UHLLRoundSummaryTeam::MunitionsText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryTeam, ManpowerText) == 0x000248, "Member 'UHLLRoundSummaryTeam::ManpowerText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryTeam, FuelText) == 0x000250, "Member 'UHLLRoundSummaryTeam::FuelText' has a wrong offset!");
static_assert(offsetof(UHLLRoundSummaryTeam, ScoreValue) == 0x000258, "Member 'UHLLRoundSummaryTeam::ScoreValue' has a wrong offset!");

// Class HLL.HLLSatchelIndicator
// 0x0008 (0x02B8 - 0x02B0)
class UHLLSatchelIndicator : public UHLLIndicatorBase
{
public:
	class UImage*                                 CountdownProg;                                     // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSatchelIndicator">();
	}
	static class UHLLSatchelIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSatchelIndicator>();
	}
};
static_assert(alignof(UHLLSatchelIndicator) == 0x000008, "Wrong alignment on UHLLSatchelIndicator");
static_assert(sizeof(UHLLSatchelIndicator) == 0x0002B8, "Wrong size on UHLLSatchelIndicator");
static_assert(offsetof(UHLLSatchelIndicator, CountdownProg) == 0x0002B0, "Member 'UHLLSatchelIndicator::CountdownProg' has a wrong offset!");

// Class HLL.HLLSaveSystem
// 0x00E0 (0x0108 - 0x0028)
class UHLLSaveSystem final : public USaveGame
{
public:
	TArray<struct FHLLSavedCharacterCosmetics>    SavedCosmetics;                                    // 0x0028(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFaction                                      FavDisplayFaction;                                 // 0x0038(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   FavDisplayRole;                                    // 0x0039(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E4[0x6];                                     // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FHLLSavedCharacterLoadout>      SavedLoadouts;                                     // 0x0040(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MotionBlur;                                        // 0x0050(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E5[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLPlayerFlags                        PlayerFlags;                                       // 0x0054(0x0008)(SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E6[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLPlayerPreferences                  PlayerPreferences;                                 // 0x0060(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FRecentPlayerData>              RecentPlayers;                                     // 0x0078(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_LastMatchID;                                     // 0x0088(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalabilityLevelsSnapshot             VideoSettings;                                     // 0x0098(0x0020)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            SavedUserSettingsMap;                              // 0x00B8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSaveSystem">();
	}
	static class UHLLSaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSaveSystem>();
	}
};
static_assert(alignof(UHLLSaveSystem) == 0x000008, "Wrong alignment on UHLLSaveSystem");
static_assert(sizeof(UHLLSaveSystem) == 0x000108, "Wrong size on UHLLSaveSystem");
static_assert(offsetof(UHLLSaveSystem, SavedCosmetics) == 0x000028, "Member 'UHLLSaveSystem::SavedCosmetics' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, FavDisplayFaction) == 0x000038, "Member 'UHLLSaveSystem::FavDisplayFaction' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, FavDisplayRole) == 0x000039, "Member 'UHLLSaveSystem::FavDisplayRole' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, SavedLoadouts) == 0x000040, "Member 'UHLLSaveSystem::SavedLoadouts' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, MotionBlur) == 0x000050, "Member 'UHLLSaveSystem::MotionBlur' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, PlayerFlags) == 0x000054, "Member 'UHLLSaveSystem::PlayerFlags' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, PlayerPreferences) == 0x000060, "Member 'UHLLSaveSystem::PlayerPreferences' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, RecentPlayers) == 0x000078, "Member 'UHLLSaveSystem::RecentPlayers' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, M_LastMatchID) == 0x000088, "Member 'UHLLSaveSystem::M_LastMatchID' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, VideoSettings) == 0x000098, "Member 'UHLLSaveSystem::VideoSettings' has a wrong offset!");
static_assert(offsetof(UHLLSaveSystem, SavedUserSettingsMap) == 0x0000B8, "Member 'UHLLSaveSystem::SavedUserSettingsMap' has a wrong offset!");

// Class HLL.HLLScopeImage
// 0x0008 (0x0218 - 0x0210)
class UHLLScopeImage final : public UImage
{
public:
	ESlateVisibility                              VisibilityWhenUnloaded;                            // 0x0210(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E7[0x7];                                     // 0x0211(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLScopeImage">();
	}
	static class UHLLScopeImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLScopeImage>();
	}
};
static_assert(alignof(UHLLScopeImage) == 0x000008, "Wrong alignment on UHLLScopeImage");
static_assert(sizeof(UHLLScopeImage) == 0x000218, "Wrong size on UHLLScopeImage");
static_assert(offsetof(UHLLScopeImage, VisibilityWhenUnloaded) == 0x000210, "Member 'UHLLScopeImage::VisibilityWhenUnloaded' has a wrong offset!");

// Class HLL.HLLScrollZoom
// 0x0210 (0x0318 - 0x0108)
class UHLLScrollZoom final : public UWidget
{
public:
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0108(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0118(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Brush;                                             // 0x0128(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDrawSectorInfo                        DrawSectorInfo;                                    // 0x01C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrawGridLines;                                    // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawSubGrid;                                      // 0x01D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawGridShadow;                                   // 0x01DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAntiAliasGrid;                                    // 0x01DB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawText;                                         // 0x01DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawSectors;                                      // 0x01DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E8[0x2];                                     // 0x01DE(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MaxZoom;                                           // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E9[0x4];                                     // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateFontInfo                         GridFont;                                          // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TopTextOffset;                                     // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LeftTextOffset;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MajorNumSegments;                                  // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MajorLineThickness;                                // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MajorShadowThickness;                              // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MajorLineColour;                                   // 0x0254(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MajorShadowColour;                                 // 0x0264(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MajorShadowOffset;                                 // 0x0274(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinorNumSegments;                                  // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorLineThickness;                                // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinorLineColour;                                   // 0x0284(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorMinZoom;                                      // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13EA[0x80];                                    // 0x0298(0x0080)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ResetZoom();
	void SetAntiAliasGrid(const bool bInAntiAliasGrid);
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushFromSoftTexture(TSoftObjectPtr<class UTexture2D> SoftTexture);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetDrawGridLines(const bool bInDrawGridLines);
	void SetDrawGridShadow(const bool bInDrawGridShadow);
	void SetDrawSectorBrush(const int32 Param_Index, const struct FSlateBrush& InBrush, const bool bUpdateSlateWidget);
	void SetDrawSectors(const bool bInDrawSectors);
	void SetDrawSectorsInfo(const struct FDrawSectorInfo& InSectorInfo);
	void SetDrawSubGrid(const bool bInDrawSubGrid);
	void SetDrawText(const bool bInDrawText);
	void SetGridFont(const struct FSlateFontInfo& InFontInfo);
	void SetLeftTextOffset(const struct FVector2D& InTextOffset);
	void SetMajor_LineColour(const struct FLinearColor& InLineColour);
	void SetMajor_LineThickness(const float InLineThickness);
	void SetMajor_NumSegments(const int32 InNumSegments);
	void SetMajor_ShadowColour(const struct FLinearColor& InShadowColour);
	void SetMajor_ShadowOffset(const struct FVector2D& InShadowOffset);
	void SetMajor_ShadowThickness(const float InShadowThickness);
	void SetMinor_LineColour(const struct FLinearColor& InLineColour);
	void SetMinor_LineThickness(const float InLineThickness);
	void SetMinor_MinZoom(const float InMinZoom);
	void SetMinor_NumSegments(const int32 InNumSegments);
	void SetOpacity(const float InOpacity);
	void SetTopTextOffset(const struct FVector2D& InTextOffset);
	void ZoomBlend();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLScrollZoom">();
	}
	static class UHLLScrollZoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLScrollZoom>();
	}
};
static_assert(alignof(UHLLScrollZoom) == 0x000008, "Wrong alignment on UHLLScrollZoom");
static_assert(sizeof(UHLLScrollZoom) == 0x000318, "Wrong size on UHLLScrollZoom");
static_assert(offsetof(UHLLScrollZoom, ColorAndOpacityDelegate) == 0x000108, "Member 'UHLLScrollZoom::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, BrushDelegate) == 0x000118, "Member 'UHLLScrollZoom::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, Brush) == 0x000128, "Member 'UHLLScrollZoom::Brush' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, ColorAndOpacity) == 0x0001B0, "Member 'UHLLScrollZoom::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, DrawSectorInfo) == 0x0001C0, "Member 'UHLLScrollZoom::DrawSectorInfo' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, bDrawGridLines) == 0x0001D8, "Member 'UHLLScrollZoom::bDrawGridLines' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, bDrawSubGrid) == 0x0001D9, "Member 'UHLLScrollZoom::bDrawSubGrid' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, bDrawGridShadow) == 0x0001DA, "Member 'UHLLScrollZoom::bDrawGridShadow' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, bAntiAliasGrid) == 0x0001DB, "Member 'UHLLScrollZoom::bAntiAliasGrid' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, bDrawText) == 0x0001DC, "Member 'UHLLScrollZoom::bDrawText' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, bDrawSectors) == 0x0001DD, "Member 'UHLLScrollZoom::bDrawSectors' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MaxZoom) == 0x0001E0, "Member 'UHLLScrollZoom::MaxZoom' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, GridFont) == 0x0001E8, "Member 'UHLLScrollZoom::GridFont' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, TopTextOffset) == 0x000238, "Member 'UHLLScrollZoom::TopTextOffset' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, LeftTextOffset) == 0x000240, "Member 'UHLLScrollZoom::LeftTextOffset' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MajorNumSegments) == 0x000248, "Member 'UHLLScrollZoom::MajorNumSegments' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MajorLineThickness) == 0x00024C, "Member 'UHLLScrollZoom::MajorLineThickness' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MajorShadowThickness) == 0x000250, "Member 'UHLLScrollZoom::MajorShadowThickness' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MajorLineColour) == 0x000254, "Member 'UHLLScrollZoom::MajorLineColour' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MajorShadowColour) == 0x000264, "Member 'UHLLScrollZoom::MajorShadowColour' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MajorShadowOffset) == 0x000274, "Member 'UHLLScrollZoom::MajorShadowOffset' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MinorNumSegments) == 0x00027C, "Member 'UHLLScrollZoom::MinorNumSegments' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MinorLineThickness) == 0x000280, "Member 'UHLLScrollZoom::MinorLineThickness' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MinorLineColour) == 0x000284, "Member 'UHLLScrollZoom::MinorLineColour' has a wrong offset!");
static_assert(offsetof(UHLLScrollZoom, MinorMinZoom) == 0x000294, "Member 'UHLLScrollZoom::MinorMinZoom' has a wrong offset!");

// Class HLL.T17ProfanityFilterSubsystem
// 0x0100 (0x0130 - 0x0030)
class UT17ProfanityFilterSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             PlayerArrayFilteringComplete;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnyDisplayNameFiltered;                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_13ED[0xE0];                                    // 0x0050(0x00E0)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void FilterPlayerArray(class AGameStateBase* GameState, EPlatforms UserPlatform, bool bPregameFilter);
	class FString GetDisplayNameIfFiltered(const class FString& DisplayName, const class FString& DefaultValueIfNotFiltered);
	bool IsDisplayNameFiltered(const class FString& DisplayName);
	void OnAnyDisplayNameFiltered__DelegateSignature(bool bResult);
	void OnPlayerArrayFilteringComplete__DelegateSignature(bool bResult);
	void ResetPregameFilter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T17ProfanityFilterSubsystem">();
	}
	static class UT17ProfanityFilterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UT17ProfanityFilterSubsystem>();
	}
};
static_assert(alignof(UT17ProfanityFilterSubsystem) == 0x000008, "Wrong alignment on UT17ProfanityFilterSubsystem");
static_assert(sizeof(UT17ProfanityFilterSubsystem) == 0x000130, "Wrong size on UT17ProfanityFilterSubsystem");
static_assert(offsetof(UT17ProfanityFilterSubsystem, PlayerArrayFilteringComplete) == 0x000030, "Member 'UT17ProfanityFilterSubsystem::PlayerArrayFilteringComplete' has a wrong offset!");
static_assert(offsetof(UT17ProfanityFilterSubsystem, OnAnyDisplayNameFiltered) == 0x000040, "Member 'UT17ProfanityFilterSubsystem::OnAnyDisplayNameFiltered' has a wrong offset!");

// Class HLL.HLLSeatHealthStatusItem
// 0x0040 (0x0270 - 0x0230)
class UHLLSeatHealthStatusItem : public UUserWidget
{
public:
	EHLLArmourCategory                            Category;                                          // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F0[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 Icon;                                              // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialProgress;                                    // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           LinearProgress;                                    // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Colour_Min;                                        // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Colour_Max;                                        // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateRatio(const float Ratio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatHealthStatusItem">();
	}
	static class UHLLSeatHealthStatusItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSeatHealthStatusItem>();
	}
};
static_assert(alignof(UHLLSeatHealthStatusItem) == 0x000008, "Wrong alignment on UHLLSeatHealthStatusItem");
static_assert(sizeof(UHLLSeatHealthStatusItem) == 0x000270, "Wrong size on UHLLSeatHealthStatusItem");
static_assert(offsetof(UHLLSeatHealthStatusItem, Category) == 0x000230, "Member 'UHLLSeatHealthStatusItem::Category' has a wrong offset!");
static_assert(offsetof(UHLLSeatHealthStatusItem, Icon) == 0x000238, "Member 'UHLLSeatHealthStatusItem::Icon' has a wrong offset!");
static_assert(offsetof(UHLLSeatHealthStatusItem, RadialProgress) == 0x000240, "Member 'UHLLSeatHealthStatusItem::RadialProgress' has a wrong offset!");
static_assert(offsetof(UHLLSeatHealthStatusItem, LinearProgress) == 0x000248, "Member 'UHLLSeatHealthStatusItem::LinearProgress' has a wrong offset!");
static_assert(offsetof(UHLLSeatHealthStatusItem, Colour_Min) == 0x000250, "Member 'UHLLSeatHealthStatusItem::Colour_Min' has a wrong offset!");
static_assert(offsetof(UHLLSeatHealthStatusItem, Colour_Max) == 0x000260, "Member 'UHLLSeatHealthStatusItem::Colour_Max' has a wrong offset!");

// Class HLL.HLLSeatIndicator
// 0x0000 (0x02B0 - 0x02B0)
class UHLLSeatIndicator : public UHLLIndicatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatIndicator">();
	}
	static class UHLLSeatIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSeatIndicator>();
	}
};
static_assert(alignof(UHLLSeatIndicator) == 0x000008, "Wrong alignment on UHLLSeatIndicator");
static_assert(sizeof(UHLLSeatIndicator) == 0x0002B0, "Wrong size on UHLLSeatIndicator");

// Class HLL.SMtoHISM
// 0x0008 (0x0228 - 0x0220)
class ASMtoHISM final : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CaptureScene();
	class UHierarchicalInstancedStaticMeshComponent* CreateHISM();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMtoHISM">();
	}
	static class ASMtoHISM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASMtoHISM>();
	}
};
static_assert(alignof(ASMtoHISM) == 0x000008, "Wrong alignment on ASMtoHISM");
static_assert(sizeof(ASMtoHISM) == 0x000228, "Wrong size on ASMtoHISM");
static_assert(offsetof(ASMtoHISM, Scene) == 0x000220, "Member 'ASMtoHISM::Scene' has a wrong offset!");

// Class HLL.HLLSeatIndicatorItem
// 0x0020 (0x0250 - 0x0230)
class UHLLSeatIndicatorItem final : public UUserWidget
{
public:
	class UImage*                                 SeatIcon;                                          // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                SeatOccupantBorder;                                // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SeatOccupantRole;                                  // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SeatOccupantText;                                  // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatIndicatorItem">();
	}
	static class UHLLSeatIndicatorItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSeatIndicatorItem>();
	}
};
static_assert(alignof(UHLLSeatIndicatorItem) == 0x000008, "Wrong alignment on UHLLSeatIndicatorItem");
static_assert(sizeof(UHLLSeatIndicatorItem) == 0x000250, "Wrong size on UHLLSeatIndicatorItem");
static_assert(offsetof(UHLLSeatIndicatorItem, SeatIcon) == 0x000230, "Member 'UHLLSeatIndicatorItem::SeatIcon' has a wrong offset!");
static_assert(offsetof(UHLLSeatIndicatorItem, SeatOccupantBorder) == 0x000238, "Member 'UHLLSeatIndicatorItem::SeatOccupantBorder' has a wrong offset!");
static_assert(offsetof(UHLLSeatIndicatorItem, SeatOccupantRole) == 0x000240, "Member 'UHLLSeatIndicatorItem::SeatOccupantRole' has a wrong offset!");
static_assert(offsetof(UHLLSeatIndicatorItem, SeatOccupantText) == 0x000248, "Member 'UHLLSeatIndicatorItem::SeatOccupantText' has a wrong offset!");

// Class HLL.HLLSeatMGInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLSeatMGInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeatMGInterface">();
	}
	static class IHLLSeatMGInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLSeatMGInterface>();
	}
};
static_assert(alignof(IHLLSeatMGInterface) == 0x000008, "Wrong alignment on IHLLSeatMGInterface");
static_assert(sizeof(IHLLSeatMGInterface) == 0x000028, "Wrong size on IHLLSeatMGInterface");

// Class HLL.TankDriverSeatUI
// 0x0078 (0x02F8 - 0x0280)
class UTankDriverSeatUI final : public UHLLTankSeatUI_Base
{
public:
	float                                         RPMSmoothingAlpha;                                 // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleRPM;                                           // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F1[0x8];                                     // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SpeedSmoothingAlpha;                               // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F2[0x4];                                     // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLArmourWeaponUI*                     DriverWeaponInfo;                                  // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLDial_Speedometer*                   Speedometer;                                       // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHLLDial_Tachometer*                    Tachometer;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           EngineProgressPanel;                               // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        EngineProgressTextSwitcher;                        // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             Starting;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             Stopping;                                          // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 EngineProgressWheel;                               // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextBlock*                         EngineKeyText;                                     // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextBlock*                         GearKeyText;                                       // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                HullMGBorder;                                      // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 HullMGReticle;                                     // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankDriverSeatUI">();
	}
	static class UTankDriverSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTankDriverSeatUI>();
	}
};
static_assert(alignof(UTankDriverSeatUI) == 0x000008, "Wrong alignment on UTankDriverSeatUI");
static_assert(sizeof(UTankDriverSeatUI) == 0x0002F8, "Wrong size on UTankDriverSeatUI");
static_assert(offsetof(UTankDriverSeatUI, RPMSmoothingAlpha) == 0x000280, "Member 'UTankDriverSeatUI::RPMSmoothingAlpha' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, IdleRPM) == 0x000284, "Member 'UTankDriverSeatUI::IdleRPM' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, SpeedSmoothingAlpha) == 0x000290, "Member 'UTankDriverSeatUI::SpeedSmoothingAlpha' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, DriverWeaponInfo) == 0x000298, "Member 'UTankDriverSeatUI::DriverWeaponInfo' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, Speedometer) == 0x0002A0, "Member 'UTankDriverSeatUI::Speedometer' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, Tachometer) == 0x0002A8, "Member 'UTankDriverSeatUI::Tachometer' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, EngineProgressPanel) == 0x0002B0, "Member 'UTankDriverSeatUI::EngineProgressPanel' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, EngineProgressTextSwitcher) == 0x0002B8, "Member 'UTankDriverSeatUI::EngineProgressTextSwitcher' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, Starting) == 0x0002C0, "Member 'UTankDriverSeatUI::Starting' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, Stopping) == 0x0002C8, "Member 'UTankDriverSeatUI::Stopping' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, EngineProgressWheel) == 0x0002D0, "Member 'UTankDriverSeatUI::EngineProgressWheel' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, EngineKeyText) == 0x0002D8, "Member 'UTankDriverSeatUI::EngineKeyText' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, GearKeyText) == 0x0002E0, "Member 'UTankDriverSeatUI::GearKeyText' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, HullMGBorder) == 0x0002E8, "Member 'UTankDriverSeatUI::HullMGBorder' has a wrong offset!");
static_assert(offsetof(UTankDriverSeatUI, HullMGReticle) == 0x0002F0, "Member 'UTankDriverSeatUI::HullMGReticle' has a wrong offset!");

// Class HLL.HLLSeat_ArtilleryGunner
// 0x0010 (0x09E0 - 0x09D0)
class AHLLSeat_ArtilleryGunner : public AHLLSeat_ArtilleryBase
{
public:
	uint8                                         Pad_13F3[0x1];                                     // 0x09D0(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bCanPrecisionAim;                                  // 0x09D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F4[0x2];                                     // 0x09D2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SlowPitchMultiplier;                               // 0x09D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowYawMultiplier;                                 // 0x09D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F5[0x4];                                     // 0x09DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Server_UpdateTurretRotation(const struct FPitchYawControllerTargetRotationValues& TargetRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeat_ArtilleryGunner">();
	}
	static class AHLLSeat_ArtilleryGunner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSeat_ArtilleryGunner>();
	}
};
static_assert(alignof(AHLLSeat_ArtilleryGunner) == 0x000010, "Wrong alignment on AHLLSeat_ArtilleryGunner");
static_assert(sizeof(AHLLSeat_ArtilleryGunner) == 0x0009E0, "Wrong size on AHLLSeat_ArtilleryGunner");
static_assert(offsetof(AHLLSeat_ArtilleryGunner, bCanPrecisionAim) == 0x0009D1, "Member 'AHLLSeat_ArtilleryGunner::bCanPrecisionAim' has a wrong offset!");
static_assert(offsetof(AHLLSeat_ArtilleryGunner, SlowPitchMultiplier) == 0x0009D4, "Member 'AHLLSeat_ArtilleryGunner::SlowPitchMultiplier' has a wrong offset!");
static_assert(offsetof(AHLLSeat_ArtilleryGunner, SlowYawMultiplier) == 0x0009D8, "Member 'AHLLSeat_ArtilleryGunner::SlowYawMultiplier' has a wrong offset!");

// Class HLL.HLLSeat_HowitzerGunner
// 0x0000 (0x09E0 - 0x09E0)
class AHLLSeat_HowitzerGunner final : public AHLLSeat_ArtilleryGunner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSeat_HowitzerGunner">();
	}
	static class AHLLSeat_HowitzerGunner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSeat_HowitzerGunner>();
	}
};
static_assert(alignof(AHLLSeat_HowitzerGunner) == 0x000010, "Wrong alignment on AHLLSeat_HowitzerGunner");
static_assert(sizeof(AHLLSeat_HowitzerGunner) == 0x0009E0, "Wrong size on AHLLSeat_HowitzerGunner");

// Class HLL.WeatherManager
// 0x0118 (0x0338 - 0x0220)
class AWeatherManager final : public AActor
{
public:
	EMode                                         ManagerMode;                                       // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponent                                    WeatherComponent;                                  // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F6[0x6];                                     // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UDA_WeatherManager_WeatherPresets*      WeatherPresetDataAsset;                            // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Clouds*              CloudsDataAsset;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LayerADensity;                                     // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LayerASpeed;                                       // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LayerBDensity;                                     // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LayerBSpeed;                                       // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverallDensity;                                    // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F7[0x4];                                     // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UDA_WeatherManager_Fog*                 FogDataAsset;                                      // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensity;                                        // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VolumetricFog;                                     // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F8[0x3];                                     // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ScatteringDistribution;                            // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtinctionScale;                                   // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewDistance;                                      // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFog;                                         // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F9[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UDA_WeatherManager_Lightning*           LightningDataAsset;                                // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StormIntensity;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StormDistance;                                     // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Rain*                RainDataAsset;                                     // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainIntensity;                                     // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainDensity;                                       // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Sky*                 SkyDataAsset;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NightTime;                                         // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13FA[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         TimeOfDay;                                         // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunIntensity;                                      // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SunColour;                                         // 0x02AC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunIndirectIntensity;                              // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunScatterIntensity;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunSize;                                           // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonIntensity;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MoonColour;                                        // 0x02CC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonIndirectIntensity;                             // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonScatterIntensity;                              // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonSize;                                          // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonBrightness;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonPhase;                                         // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarAmount;                                        // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarBrightness;                                    // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwinkleSpeed;                                      // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13FB[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UDA_WeatherManager_Snow*                SnowDataAsset;                                     // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnowIntensity;                                     // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnowDensity;                                       // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDA_WeatherManager_Wetness*             WetnessDataAsset;                                  // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wetness;                                           // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13FC[0x4];                                     // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UDA_WeatherManager_Wind*                WindDataAsset;                                     // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindDirection;                                     // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindIntensity;                                     // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindTurbulance;                                    // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13FD[0x4];                                     // 0x0334(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherManager">();
	}
	static class AWeatherManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeatherManager>();
	}
};
static_assert(alignof(AWeatherManager) == 0x000008, "Wrong alignment on AWeatherManager");
static_assert(sizeof(AWeatherManager) == 0x000338, "Wrong size on AWeatherManager");
static_assert(offsetof(AWeatherManager, ManagerMode) == 0x000220, "Member 'AWeatherManager::ManagerMode' has a wrong offset!");
static_assert(offsetof(AWeatherManager, WeatherComponent) == 0x000221, "Member 'AWeatherManager::WeatherComponent' has a wrong offset!");
static_assert(offsetof(AWeatherManager, WeatherPresetDataAsset) == 0x000228, "Member 'AWeatherManager::WeatherPresetDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, CloudsDataAsset) == 0x000230, "Member 'AWeatherManager::CloudsDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, LayerADensity) == 0x000238, "Member 'AWeatherManager::LayerADensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, LayerASpeed) == 0x00023C, "Member 'AWeatherManager::LayerASpeed' has a wrong offset!");
static_assert(offsetof(AWeatherManager, LayerBDensity) == 0x000240, "Member 'AWeatherManager::LayerBDensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, LayerBSpeed) == 0x000244, "Member 'AWeatherManager::LayerBSpeed' has a wrong offset!");
static_assert(offsetof(AWeatherManager, OverallDensity) == 0x000248, "Member 'AWeatherManager::OverallDensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, FogDataAsset) == 0x000250, "Member 'AWeatherManager::FogDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, FogDensity) == 0x000258, "Member 'AWeatherManager::FogDensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, FogHeightFalloff) == 0x00025C, "Member 'AWeatherManager::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(AWeatherManager, VolumetricFog) == 0x000260, "Member 'AWeatherManager::VolumetricFog' has a wrong offset!");
static_assert(offsetof(AWeatherManager, ScatteringDistribution) == 0x000264, "Member 'AWeatherManager::ScatteringDistribution' has a wrong offset!");
static_assert(offsetof(AWeatherManager, ExtinctionScale) == 0x000268, "Member 'AWeatherManager::ExtinctionScale' has a wrong offset!");
static_assert(offsetof(AWeatherManager, ViewDistance) == 0x00026C, "Member 'AWeatherManager::ViewDistance' has a wrong offset!");
static_assert(offsetof(AWeatherManager, GroundFog) == 0x000270, "Member 'AWeatherManager::GroundFog' has a wrong offset!");
static_assert(offsetof(AWeatherManager, LightningDataAsset) == 0x000278, "Member 'AWeatherManager::LightningDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, StormIntensity) == 0x000280, "Member 'AWeatherManager::StormIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, StormDistance) == 0x000284, "Member 'AWeatherManager::StormDistance' has a wrong offset!");
static_assert(offsetof(AWeatherManager, RainDataAsset) == 0x000288, "Member 'AWeatherManager::RainDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, RainIntensity) == 0x000290, "Member 'AWeatherManager::RainIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, RainDensity) == 0x000294, "Member 'AWeatherManager::RainDensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SkyDataAsset) == 0x000298, "Member 'AWeatherManager::SkyDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, NightTime) == 0x0002A0, "Member 'AWeatherManager::NightTime' has a wrong offset!");
static_assert(offsetof(AWeatherManager, TimeOfDay) == 0x0002A4, "Member 'AWeatherManager::TimeOfDay' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SunIntensity) == 0x0002A8, "Member 'AWeatherManager::SunIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SunColour) == 0x0002AC, "Member 'AWeatherManager::SunColour' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SunIndirectIntensity) == 0x0002BC, "Member 'AWeatherManager::SunIndirectIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SunScatterIntensity) == 0x0002C0, "Member 'AWeatherManager::SunScatterIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SunSize) == 0x0002C4, "Member 'AWeatherManager::SunSize' has a wrong offset!");
static_assert(offsetof(AWeatherManager, MoonIntensity) == 0x0002C8, "Member 'AWeatherManager::MoonIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, MoonColour) == 0x0002CC, "Member 'AWeatherManager::MoonColour' has a wrong offset!");
static_assert(offsetof(AWeatherManager, MoonIndirectIntensity) == 0x0002DC, "Member 'AWeatherManager::MoonIndirectIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, MoonScatterIntensity) == 0x0002E0, "Member 'AWeatherManager::MoonScatterIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, MoonSize) == 0x0002E4, "Member 'AWeatherManager::MoonSize' has a wrong offset!");
static_assert(offsetof(AWeatherManager, MoonBrightness) == 0x0002E8, "Member 'AWeatherManager::MoonBrightness' has a wrong offset!");
static_assert(offsetof(AWeatherManager, MoonPhase) == 0x0002EC, "Member 'AWeatherManager::MoonPhase' has a wrong offset!");
static_assert(offsetof(AWeatherManager, StarAmount) == 0x0002F0, "Member 'AWeatherManager::StarAmount' has a wrong offset!");
static_assert(offsetof(AWeatherManager, StarBrightness) == 0x0002F4, "Member 'AWeatherManager::StarBrightness' has a wrong offset!");
static_assert(offsetof(AWeatherManager, TwinkleSpeed) == 0x0002F8, "Member 'AWeatherManager::TwinkleSpeed' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SnowDataAsset) == 0x000300, "Member 'AWeatherManager::SnowDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SnowIntensity) == 0x000308, "Member 'AWeatherManager::SnowIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, SnowDensity) == 0x00030C, "Member 'AWeatherManager::SnowDensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, WetnessDataAsset) == 0x000310, "Member 'AWeatherManager::WetnessDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, Wetness) == 0x000318, "Member 'AWeatherManager::Wetness' has a wrong offset!");
static_assert(offsetof(AWeatherManager, WindDataAsset) == 0x000320, "Member 'AWeatherManager::WindDataAsset' has a wrong offset!");
static_assert(offsetof(AWeatherManager, WindDirection) == 0x000328, "Member 'AWeatherManager::WindDirection' has a wrong offset!");
static_assert(offsetof(AWeatherManager, WindIntensity) == 0x00032C, "Member 'AWeatherManager::WindIntensity' has a wrong offset!");
static_assert(offsetof(AWeatherManager, WindTurbulance) == 0x000330, "Member 'AWeatherManager::WindTurbulance' has a wrong offset!");

// Class HLL.HLLServerConfig
// 0x00A0 (0x00D0 - 0x0030)
class UHLLServerConfig final : public UEngineSubsystem
{
public:
	uint8                                         Pad_13FE[0x18];                                    // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bTeamAutoBalanceEnabled;                           // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TeamAutoBalanceThreshold;                          // 0x0049(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TeamSwitchingCooldownMinutes;                      // 0x004A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13FF[0x1];                                     // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         PlayerDamageModifier;                              // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPlayerSpeedModifier;                            // 0x0050(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1400[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FRCONMatchTimerData>            MatchTimerDataList;                                // 0x0058(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCONWarmupTimerData>           WarmupTimerDataList;                               // 0x0068(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCONInitialResourceData>       InitialResourceDataList;                           // 0x0078(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRCONWeatherToggleData>         WeatherToggleDataList;                             // 0x0088(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IdleKickTimeoutMinutes;                            // 0x0098(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HighPlayerPingThresholdMs;                         // 0x009C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVoteKickEnabled;                                  // 0x00A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1401[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FVoteThreshold>                 CustomVoteKickThresholds;                          // 0x00A8(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCustomSectorLayout>            CustomSectorLayouts;                               // 0x00B8(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRconV2Enabled;                                    // 0x00C8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1402[0x3];                                     // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         HighPacketLossPercentage;                          // 0x00CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLServerConfig">();
	}
	static class UHLLServerConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLServerConfig>();
	}
};
static_assert(alignof(UHLLServerConfig) == 0x000008, "Wrong alignment on UHLLServerConfig");
static_assert(sizeof(UHLLServerConfig) == 0x0000D0, "Wrong size on UHLLServerConfig");
static_assert(offsetof(UHLLServerConfig, bTeamAutoBalanceEnabled) == 0x000048, "Member 'UHLLServerConfig::bTeamAutoBalanceEnabled' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, TeamAutoBalanceThreshold) == 0x000049, "Member 'UHLLServerConfig::TeamAutoBalanceThreshold' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, TeamSwitchingCooldownMinutes) == 0x00004A, "Member 'UHLLServerConfig::TeamSwitchingCooldownMinutes' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, PlayerDamageModifier) == 0x00004C, "Member 'UHLLServerConfig::PlayerDamageModifier' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, MaxPlayerSpeedModifier) == 0x000050, "Member 'UHLLServerConfig::MaxPlayerSpeedModifier' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, MatchTimerDataList) == 0x000058, "Member 'UHLLServerConfig::MatchTimerDataList' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, WarmupTimerDataList) == 0x000068, "Member 'UHLLServerConfig::WarmupTimerDataList' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, InitialResourceDataList) == 0x000078, "Member 'UHLLServerConfig::InitialResourceDataList' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, WeatherToggleDataList) == 0x000088, "Member 'UHLLServerConfig::WeatherToggleDataList' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, IdleKickTimeoutMinutes) == 0x000098, "Member 'UHLLServerConfig::IdleKickTimeoutMinutes' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, HighPlayerPingThresholdMs) == 0x00009C, "Member 'UHLLServerConfig::HighPlayerPingThresholdMs' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, bVoteKickEnabled) == 0x0000A0, "Member 'UHLLServerConfig::bVoteKickEnabled' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, CustomVoteKickThresholds) == 0x0000A8, "Member 'UHLLServerConfig::CustomVoteKickThresholds' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, CustomSectorLayouts) == 0x0000B8, "Member 'UHLLServerConfig::CustomSectorLayouts' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, bRconV2Enabled) == 0x0000C8, "Member 'UHLLServerConfig::bRconV2Enabled' has a wrong offset!");
static_assert(offsetof(UHLLServerConfig, HighPacketLossPercentage) == 0x0000CC, "Member 'UHLLServerConfig::HighPacketLossPercentage' has a wrong offset!");

// Class HLL.HLLSimpleHealthComponent
// 0x00B0 (0x0160 - 0x00B0)
class UHLLSimpleHealthComponent final : public UActorComponent
{
public:
	float                                         DamageThreshold;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimpleDeathBehaviour                         DeathBehaviour;                                    // 0x00B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1403[0x3];                                     // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         PostDeathLifespan;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyScoreForKill;                                 // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHLLPlayerStat                                EnemyStatForKill;                                  // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHint                                         EnemyHintForKill;                                  // 0x00C5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDismantleBehaviourOverride : 1;                   // 0x00C6(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESimpleDeathBehaviour                         DismantleBehaviour;                                // 0x00C7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AController*>                    KillerInstigators;                                 // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       DeathEffect;                                       // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             EffectRelativeTransform;                           // 0x00E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLVehicleWreck>           WreckActor;                                        // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHandledDeath : 1;                                 // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1404[0x7];                                     // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UDamageType>                ExplosionDamageType;                               // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionDamage;                                   // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionRadius;                                   // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionSuppression;                              // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionSuppressionRadius;                        // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnKilled;                                          // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FRepHealthInfo                         HealthInfo;                                        // 0x0148(0x0008)(Edit, Net, Transient, DisableEditOnInstance, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ESimpleDeathNotify                            DeathNotifyBehaviour;                              // 0x0150(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDismantleNotifyOverride : 1;                      // 0x0151(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESimpleDeathNotify                            DismantleNotifyBehaviour;                          // 0x0152(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1405[0xD];                                     // 0x0153(0x000D)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Multi_OnDeath(const EHealthState State, const struct FRepSimpleHealthDeathParams& DeathInfo);
	void OnKilled__DelegateSignature(class UHLLSimpleHealthComponent* Component);
	void OnRep_HealthInfo(const struct FRepHealthInfo& OldInfo);

	float GetCurrentHealth() const;
	class AController* GetPrimaryKiller() const;
	bool IsAlive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSimpleHealthComponent">();
	}
	static class UHLLSimpleHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSimpleHealthComponent>();
	}
};
static_assert(alignof(UHLLSimpleHealthComponent) == 0x000010, "Wrong alignment on UHLLSimpleHealthComponent");
static_assert(sizeof(UHLLSimpleHealthComponent) == 0x000160, "Wrong size on UHLLSimpleHealthComponent");
static_assert(offsetof(UHLLSimpleHealthComponent, DamageThreshold) == 0x0000B0, "Member 'UHLLSimpleHealthComponent::DamageThreshold' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, DeathBehaviour) == 0x0000B4, "Member 'UHLLSimpleHealthComponent::DeathBehaviour' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, PostDeathLifespan) == 0x0000B8, "Member 'UHLLSimpleHealthComponent::PostDeathLifespan' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, EnemyScoreForKill) == 0x0000BC, "Member 'UHLLSimpleHealthComponent::EnemyScoreForKill' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, EnemyStatForKill) == 0x0000C4, "Member 'UHLLSimpleHealthComponent::EnemyStatForKill' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, EnemyHintForKill) == 0x0000C5, "Member 'UHLLSimpleHealthComponent::EnemyHintForKill' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, DismantleBehaviour) == 0x0000C7, "Member 'UHLLSimpleHealthComponent::DismantleBehaviour' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, KillerInstigators) == 0x0000C8, "Member 'UHLLSimpleHealthComponent::KillerInstigators' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, DeathEffect) == 0x0000D8, "Member 'UHLLSimpleHealthComponent::DeathEffect' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, EffectRelativeTransform) == 0x0000E0, "Member 'UHLLSimpleHealthComponent::EffectRelativeTransform' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, WreckActor) == 0x000110, "Member 'UHLLSimpleHealthComponent::WreckActor' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, ExplosionDamageType) == 0x000120, "Member 'UHLLSimpleHealthComponent::ExplosionDamageType' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, ExplosionDamage) == 0x000128, "Member 'UHLLSimpleHealthComponent::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, ExplosionRadius) == 0x00012C, "Member 'UHLLSimpleHealthComponent::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, ExplosionSuppression) == 0x000130, "Member 'UHLLSimpleHealthComponent::ExplosionSuppression' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, ExplosionSuppressionRadius) == 0x000134, "Member 'UHLLSimpleHealthComponent::ExplosionSuppressionRadius' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, OnKilled) == 0x000138, "Member 'UHLLSimpleHealthComponent::OnKilled' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, HealthInfo) == 0x000148, "Member 'UHLLSimpleHealthComponent::HealthInfo' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, DeathNotifyBehaviour) == 0x000150, "Member 'UHLLSimpleHealthComponent::DeathNotifyBehaviour' has a wrong offset!");
static_assert(offsetof(UHLLSimpleHealthComponent, DismantleNotifyBehaviour) == 0x000152, "Member 'UHLLSimpleHealthComponent::DismantleNotifyBehaviour' has a wrong offset!");

// Class HLL.ShooterPlayerState
// 0x0550 (0x0870 - 0x0320)
class AShooterPlayerState : public APlayerState
{
public:
	uint8                                         Pad_1407[0x20];                                    // 0x0320(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnRoleChanged;                                     // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTeamChanged;                                     // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlatoonChanged;                                  // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1408[0x4];                                     // 0x0370(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         NumKills;                                          // 0x0374(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDeaths;                                         // 0x0378(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bQuitter : 1;                                      // 0x037C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1409[0x3];                                     // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FDispenserLastBuiltTime>        DispenserLastBuiltTimes;                           // 0x0380(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_lastSpawnObject;                                 // 0x0390(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPendingPlatoonKickOnDeath : 1;                    // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_140A[0x3];                                     // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLPlayerScoreData                    ScoreData;                                         // 0x039C(0x0010)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140B[0x7C];                                    // 0x03AC(0x007C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         LastPawnRestartTime;                               // 0x0428(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140C[0x4];                                     // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLPlayerStats*                        MatchStatsTracker;                                 // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CurrentPingStatusHigh;                             // 0x0438(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PacketLossHighAtLastCheck;                         // 0x0439(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140D[0x56];                                    // 0x043A(0x0056)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         LastTeamSwitchTime;                                // 0x0490(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140E[0x4];                                     // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	uint16                                        PlayerLevel;                                       // 0x0498(0x0002)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140F[0x2];                                     // 0x049A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FHLLPlayerInfo                         RepPlayerInfo;                                     // 0x049C(0x002C)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1410[0x8];                                     // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FPlayerXPAction>                PlayerXPActions;                                   // 0x04D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         NumCommendationsReceived;                          // 0x04E0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1411[0x7];                                     // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnMarkerAddedOrUpdated;                            // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMarkerRemoved;                                   // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1412[0x10];                                    // 0x0508(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRepMarkerInfo                         RepMarkerInfo;                                     // 0x0518(0x0128)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1413[0x128];                                   // 0x0640(0x0128)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class FName, struct FHLLActionScore>     CachedScore;                                       // 0x0768(0x0050)(Protected, NativeAccessSpecifierProtected)
	EPlayingState                                 PlayingState;                                      // 0x07B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1414[0x7];                                     // 0x07B9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 GlobalPlayerId;                                    // 0x07C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlatforms                                    PlatformID;                                        // 0x07D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumPunishments;                                    // 0x07D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1415[0x2];                                     // 0x07D2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         AccruedPunishTime;                                 // 0x07D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSharedAmmoRegenStarted;                          // 0x07D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSharedAmmoRegenComplete;                         // 0x07E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                             AmmoRegenStartSound;                               // 0x07F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             AmmoRegenSound;                                    // 0x0800(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultAmmoRegenTime;                              // 0x0808(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLSharedAmmoData                     SharedAmmo;                                        // 0x080C(0x0030)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1416[0x14];                                    // 0x083C(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 ClanTag;                                           // 0x0850(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NextAvailableVoteTime_Instigator;                  // 0x0860(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NextAvailableVoteTime_Target;                      // 0x0864(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bVoteKickImmune : 1;                               // 0x0868(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1417[0x1];                                     // 0x0869(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bAutoAssignedTeamEnabled;                          // 0x086A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1418[0x5];                                     // 0x086B(0x0005)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearMarkers();
	void Client_DisplayMarkerTextInPlatoonChat(const EHLLMarker MarkerType, const class AShooterPlayerState* Sender);
	void ClientInformAboutDown(class AShooterPlayerState* Victim, const class UClass* DamageClass);
	void ClientInformAboutKill(class AShooterPlayerState* Victim, const class UClass* DamageClass, const uint8 KillFlags);
	void ClientWarnAboutImminentKick();
	void DeploymentSetTeam(ETeam PlayerTeam);
	void MulticastDeath(class AShooterPlayerState* Killer, const class UClass* DamageClass);
	void OnOSSStatsRefreshed(const struct FUniqueNetIdRepl& UserId);
	void OnPlayerInfoChanged_Platoon__DelegateSignature(class AShooterPlayerState* Player, const int32 PreviousIndex, const int32 NewIndex, class AHLLPlatoon* PreviousPlatoon, class AHLLPlatoon* NewPlatoon);
	void OnPlayerInfoChanged_Role__DelegateSignature(class AShooterPlayerState* Player, const EPlayerRole PreviousRole, const EPlayerRole NewRole);
	void OnPlayerInfoChanged_Team__DelegateSignature(class AShooterPlayerState* Player, const ETeam PreviousTeam, const ETeam NewTeam);
	void OnRep_Commendations(const uint8 PrevValue);
	void OnRep_GlobalPlayerId();
	void OnRep_MarkerInfos();
	void OnRep_PendingPlatoonKickOnDeath();
	void OnRep_PlayerInfo(const struct FHLLPlayerInfo& OldInfo);
	void OnRep_SharedAmmo(const struct FHLLSharedAmmoData& PreviousValue);
	void OnSharedAmmoEvent__DelegateSignature(class AShooterPlayerState* Player, const ESharedAmmoType Type);
	void PlayerMarkerEvent__DelegateSignature(class AShooterPlayerState* MarkerOwner, const struct FRepMarkerItem& MarkerInfo);
	void RemoveMarker(const EHLLMarker Type, const uint8 MarkerIndex);
	void RequestMarker(const EHLLMarker Type, const struct FVector& Location, const bool& CanAwardXP);
	void Server_RemoveMarker(const EHLLMarker Type, const uint8 MarkerIndex);
	void Server_RequestMarker(const EHLLMarker Type, const struct FVector_NetQuantize& InLocation, const bool CanAwardXP);
	void Server_SendMarkerTextToPlatoonChat(const EHLLMarker MarkerType);
	void Server_SetClanTag(const class FString& Tag);
	void ServerMarkNotIdle();
	void ServerSetIsBot(bool IsBot);
	void SetPlatoon(class AHLLPlatoon* InPlatoon);
	void SetPlayerRole(EPlayerRole PlayerRole);

	bool CanChangeTeam() const;
	class FString GetClanTag() const;
	class FText GetClanTagAsText() const;
	uint8 GetLoadoutID() const;
	EPlayerRole GetOldPlayerRole() const;
	class AHLLPlatoon* GetPlatoon() const;
	float GetPlayerDeployedTime() const;
	EFaction GetPlayerFaction() const;
	int32 GetPlayerLevel() const;
	EPlayerRole GetPlayerRole() const;
	class FString GetShortPlayerName(const int32 MaxChars) const;
	struct FTimespan GetTimeRemainingBeforeNextTeamChange() const;
	bool HasFilteredName() const;
	bool IsPendingPlatoonKickOnDeath() const;
	bool IsTeamSwitchingSupported() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerState">();
	}
	static class AShooterPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerState>();
	}
};
static_assert(alignof(AShooterPlayerState) == 0x000008, "Wrong alignment on AShooterPlayerState");
static_assert(sizeof(AShooterPlayerState) == 0x000870, "Wrong size on AShooterPlayerState");
static_assert(offsetof(AShooterPlayerState, OnRoleChanged) == 0x000340, "Member 'AShooterPlayerState::OnRoleChanged' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, OnTeamChanged) == 0x000350, "Member 'AShooterPlayerState::OnTeamChanged' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, OnPlatoonChanged) == 0x000360, "Member 'AShooterPlayerState::OnPlatoonChanged' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NumKills) == 0x000374, "Member 'AShooterPlayerState::NumKills' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NumDeaths) == 0x000378, "Member 'AShooterPlayerState::NumDeaths' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, DispenserLastBuiltTimes) == 0x000380, "Member 'AShooterPlayerState::DispenserLastBuiltTimes' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, M_lastSpawnObject) == 0x000390, "Member 'AShooterPlayerState::M_lastSpawnObject' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, ScoreData) == 0x00039C, "Member 'AShooterPlayerState::ScoreData' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, LastPawnRestartTime) == 0x000428, "Member 'AShooterPlayerState::LastPawnRestartTime' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, MatchStatsTracker) == 0x000430, "Member 'AShooterPlayerState::MatchStatsTracker' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, CurrentPingStatusHigh) == 0x000438, "Member 'AShooterPlayerState::CurrentPingStatusHigh' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, PacketLossHighAtLastCheck) == 0x000439, "Member 'AShooterPlayerState::PacketLossHighAtLastCheck' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, LastTeamSwitchTime) == 0x000490, "Member 'AShooterPlayerState::LastTeamSwitchTime' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, PlayerLevel) == 0x000498, "Member 'AShooterPlayerState::PlayerLevel' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, RepPlayerInfo) == 0x00049C, "Member 'AShooterPlayerState::RepPlayerInfo' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, PlayerXPActions) == 0x0004D0, "Member 'AShooterPlayerState::PlayerXPActions' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NumCommendationsReceived) == 0x0004E0, "Member 'AShooterPlayerState::NumCommendationsReceived' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, OnMarkerAddedOrUpdated) == 0x0004E8, "Member 'AShooterPlayerState::OnMarkerAddedOrUpdated' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, OnMarkerRemoved) == 0x0004F8, "Member 'AShooterPlayerState::OnMarkerRemoved' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, RepMarkerInfo) == 0x000518, "Member 'AShooterPlayerState::RepMarkerInfo' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, CachedScore) == 0x000768, "Member 'AShooterPlayerState::CachedScore' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, PlayingState) == 0x0007B8, "Member 'AShooterPlayerState::PlayingState' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, GlobalPlayerId) == 0x0007C0, "Member 'AShooterPlayerState::GlobalPlayerId' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, PlatformID) == 0x0007D0, "Member 'AShooterPlayerState::PlatformID' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NumPunishments) == 0x0007D1, "Member 'AShooterPlayerState::NumPunishments' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, AccruedPunishTime) == 0x0007D4, "Member 'AShooterPlayerState::AccruedPunishTime' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, OnSharedAmmoRegenStarted) == 0x0007D8, "Member 'AShooterPlayerState::OnSharedAmmoRegenStarted' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, OnSharedAmmoRegenComplete) == 0x0007E8, "Member 'AShooterPlayerState::OnSharedAmmoRegenComplete' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, AmmoRegenStartSound) == 0x0007F8, "Member 'AShooterPlayerState::AmmoRegenStartSound' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, AmmoRegenSound) == 0x000800, "Member 'AShooterPlayerState::AmmoRegenSound' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, DefaultAmmoRegenTime) == 0x000808, "Member 'AShooterPlayerState::DefaultAmmoRegenTime' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, SharedAmmo) == 0x00080C, "Member 'AShooterPlayerState::SharedAmmo' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, ClanTag) == 0x000850, "Member 'AShooterPlayerState::ClanTag' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NextAvailableVoteTime_Instigator) == 0x000860, "Member 'AShooterPlayerState::NextAvailableVoteTime_Instigator' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, NextAvailableVoteTime_Target) == 0x000864, "Member 'AShooterPlayerState::NextAvailableVoteTime_Target' has a wrong offset!");
static_assert(offsetof(AShooterPlayerState, bAutoAssignedTeamEnabled) == 0x00086A, "Member 'AShooterPlayerState::bAutoAssignedTeamEnabled' has a wrong offset!");

// Class HLL.HLLSnapQueryComponent
// 0x0030 (0x0220 - 0x01F0)
class UHLLSnapQueryComponent final : public USceneComponent
{
public:
	TArray<EObjectTypeQuery>                      SnapQueryObjects;                                  // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SnapQueryInflation;                                // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1424[0x4];                                     // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FSnapQueryPoint>                QueryPoints;                                       // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1425[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void DrawQueryPoints(const struct FTransform& XForm, const struct FColor& Colour, const struct FColor& SecondaryColour, const int32 SecondaryIndex, float Time, const float Thickness) const;
	bool PerformSnapQuery(const struct FSnapQueryParams& QueryParams, struct FSnapQueryResult* Result, int32* QueryPoint) const;
	bool QueryPointToActor(struct FTransform* XForm, const int32 Param_Index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSnapQueryComponent">();
	}
	static class UHLLSnapQueryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSnapQueryComponent>();
	}
};
static_assert(alignof(UHLLSnapQueryComponent) == 0x000010, "Wrong alignment on UHLLSnapQueryComponent");
static_assert(sizeof(UHLLSnapQueryComponent) == 0x000220, "Wrong size on UHLLSnapQueryComponent");
static_assert(offsetof(UHLLSnapQueryComponent, SnapQueryObjects) == 0x0001F0, "Member 'UHLLSnapQueryComponent::SnapQueryObjects' has a wrong offset!");
static_assert(offsetof(UHLLSnapQueryComponent, SnapQueryInflation) == 0x000200, "Member 'UHLLSnapQueryComponent::SnapQueryInflation' has a wrong offset!");
static_assert(offsetof(UHLLSnapQueryComponent, QueryPoints) == 0x000208, "Member 'UHLLSnapQueryComponent::QueryPoints' has a wrong offset!");

// Class HLL.HLLSpawnIndicator
// 0x0000 (0x02B0 - 0x02B0)
class UHLLSpawnIndicator : public UHLLIndicatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSpawnIndicator">();
	}
	static class UHLLSpawnIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSpawnIndicator>();
	}
};
static_assert(alignof(UHLLSpawnIndicator) == 0x000008, "Wrong alignment on UHLLSpawnIndicator");
static_assert(sizeof(UHLLSpawnIndicator) == 0x0002B0, "Wrong size on UHLLSpawnIndicator");

// Class HLL.HLLSplashScreenDesktop
// 0x0020 (0x0280 - 0x0260)
class UHLLSplashScreenDesktop final : public UHLLSplashScreen
{
public:
	uint8                                         Pad_1429[0x20];                                    // 0x0260(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSplashScreenDesktop">();
	}
	static class UHLLSplashScreenDesktop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSplashScreenDesktop>();
	}
};
static_assert(alignof(UHLLSplashScreenDesktop) == 0x000008, "Wrong alignment on UHLLSplashScreenDesktop");
static_assert(sizeof(UHLLSplashScreenDesktop) == 0x000280, "Wrong size on UHLLSplashScreenDesktop");

// Class HLL.HLLSupplyDrop_Player
// 0x0008 (0x02F8 - 0x02F0)
class AHLLSupplyDrop_Player : public AHLLSupplyDropBase
{
public:
	class UHLLAmmoComponent*                      AmmoComponent;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSupplyDrop_Player">();
	}
	static class AHLLSupplyDrop_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLSupplyDrop_Player>();
	}
};
static_assert(alignof(AHLLSupplyDrop_Player) == 0x000008, "Wrong alignment on AHLLSupplyDrop_Player");
static_assert(sizeof(AHLLSupplyDrop_Player) == 0x0002F8, "Wrong size on AHLLSupplyDrop_Player");
static_assert(offsetof(AHLLSupplyDrop_Player, AmmoComponent) == 0x0002F0, "Member 'AHLLSupplyDrop_Player::AmmoComponent' has a wrong offset!");

// Class HLL.HLLSupplyInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLSupplyInterface final : public IInterface
{
public:
	int32 GetSuppliesRemaining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSupplyInterface">();
	}
	static class IHLLSupplyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLSupplyInterface>();
	}
};
static_assert(alignof(IHLLSupplyInterface) == 0x000008, "Wrong alignment on IHLLSupplyInterface");
static_assert(sizeof(IHLLSupplyInterface) == 0x000028, "Wrong size on IHLLSupplyInterface");

// Class HLL.HLLTaggableInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLTaggableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLTaggableInterface">();
	}
	static class IHLLTaggableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLTaggableInterface>();
	}
};
static_assert(alignof(IHLLTaggableInterface) == 0x000008, "Wrong alignment on IHLLTaggableInterface");
static_assert(sizeof(IHLLTaggableInterface) == 0x000028, "Wrong size on IHLLTaggableInterface");

// Class HLL.ShooterCharacterMovement
// 0x0120 (0x0730 - 0x0610)
class UShooterCharacterMovement : public UCharacterMovementComponent
{
public:
	float                                         Dive_MaxGroundFriction;                            // 0x0610(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Dive_MaxBrakingFrictionFactor;                     // 0x0614(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Dive_MaxBrakingDecelerationWalking;                // 0x0618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142A[0xC];                                     // 0x061C(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MaxWalkSpeedADS;                                   // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedProne;                                 // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintSpeed;                                    // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintSpeedCrouched;                            // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarbedWireMaxSpeed;                                // 0x0638(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultingSpeed;                                     // 0x063C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultingHorizontalSpeed;                           // 0x0640(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingSpeed;                                     // 0x0644(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AShooterCharacter*                      M_owningCharacter;                                 // 0x0648(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142B[0x14];                                    // 0x0650(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         VaultEdgeFinishDistanceOffset;                     // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClimbEdgeFinishDistanceOffset;                     // 0x0668(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideExitVaultVelocityZ;                       // 0x066C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142C[0x3];                                     // 0x066D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ExitVaultVelocityZ;                                // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideExitVaultVelocityForward;                 // 0x0674(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142D[0x3];                                     // 0x0675(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ExitVaultVelocityForward;                          // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VaultTrajectoryEndZOffset;                         // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VaultCapsuleRecoverySpeed;                         // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClimbingCapsuleRecoverySpeed;                      // 0x0684(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReattachMeshVaultingInterpSpeed_Location;          // 0x0688(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReattachMeshVaultingInterpSpeed_Rotation;          // 0x068C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReattachMeshClimbingInterpSpeed_Location;          // 0x0690(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReattachMeshClimbingInterpSpeed_Rotation;          // 0x0694(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinMeshDistanceSqToReattachImmediately;            // 0x0698(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLandedFromVault;                                  // 0x069C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMomentumBasedVaulting;                            // 0x069D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142E[0x2];                                     // 0x069E(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MomentumVault_MinimumSpeed;                        // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MomentumVault_StartSpeedDelta;                     // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumVaultTime;                                  // 0x06A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VaultingCoolDown;                                  // 0x06AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDebugVisualisations;                          // 0x06B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142F[0x7F];                                    // 0x06B1(0x007F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void GetVaultingCapsuleSize(float* VaultingCapsuleRadius, float* VaultingCapsuleHalfHeight) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCharacterMovement">();
	}
	static class UShooterCharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterCharacterMovement>();
	}
};
static_assert(alignof(UShooterCharacterMovement) == 0x000010, "Wrong alignment on UShooterCharacterMovement");
static_assert(sizeof(UShooterCharacterMovement) == 0x000730, "Wrong size on UShooterCharacterMovement");
static_assert(offsetof(UShooterCharacterMovement, Dive_MaxGroundFriction) == 0x000610, "Member 'UShooterCharacterMovement::Dive_MaxGroundFriction' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, Dive_MaxBrakingFrictionFactor) == 0x000614, "Member 'UShooterCharacterMovement::Dive_MaxBrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, Dive_MaxBrakingDecelerationWalking) == 0x000618, "Member 'UShooterCharacterMovement::Dive_MaxBrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, MaxWalkSpeedADS) == 0x000628, "Member 'UShooterCharacterMovement::MaxWalkSpeedADS' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, MaxWalkSpeedProne) == 0x00062C, "Member 'UShooterCharacterMovement::MaxWalkSpeedProne' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, MaxSprintSpeed) == 0x000630, "Member 'UShooterCharacterMovement::MaxSprintSpeed' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, MaxSprintSpeedCrouched) == 0x000634, "Member 'UShooterCharacterMovement::MaxSprintSpeedCrouched' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, BarbedWireMaxSpeed) == 0x000638, "Member 'UShooterCharacterMovement::BarbedWireMaxSpeed' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, VaultingSpeed) == 0x00063C, "Member 'UShooterCharacterMovement::VaultingSpeed' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, VaultingHorizontalSpeed) == 0x000640, "Member 'UShooterCharacterMovement::VaultingHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ClimbingSpeed) == 0x000644, "Member 'UShooterCharacterMovement::ClimbingSpeed' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, M_owningCharacter) == 0x000648, "Member 'UShooterCharacterMovement::M_owningCharacter' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, VaultEdgeFinishDistanceOffset) == 0x000664, "Member 'UShooterCharacterMovement::VaultEdgeFinishDistanceOffset' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ClimbEdgeFinishDistanceOffset) == 0x000668, "Member 'UShooterCharacterMovement::ClimbEdgeFinishDistanceOffset' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, bOverrideExitVaultVelocityZ) == 0x00066C, "Member 'UShooterCharacterMovement::bOverrideExitVaultVelocityZ' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ExitVaultVelocityZ) == 0x000670, "Member 'UShooterCharacterMovement::ExitVaultVelocityZ' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, bOverrideExitVaultVelocityForward) == 0x000674, "Member 'UShooterCharacterMovement::bOverrideExitVaultVelocityForward' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ExitVaultVelocityForward) == 0x000678, "Member 'UShooterCharacterMovement::ExitVaultVelocityForward' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, VaultTrajectoryEndZOffset) == 0x00067C, "Member 'UShooterCharacterMovement::VaultTrajectoryEndZOffset' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, VaultCapsuleRecoverySpeed) == 0x000680, "Member 'UShooterCharacterMovement::VaultCapsuleRecoverySpeed' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ClimbingCapsuleRecoverySpeed) == 0x000684, "Member 'UShooterCharacterMovement::ClimbingCapsuleRecoverySpeed' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ReattachMeshVaultingInterpSpeed_Location) == 0x000688, "Member 'UShooterCharacterMovement::ReattachMeshVaultingInterpSpeed_Location' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ReattachMeshVaultingInterpSpeed_Rotation) == 0x00068C, "Member 'UShooterCharacterMovement::ReattachMeshVaultingInterpSpeed_Rotation' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ReattachMeshClimbingInterpSpeed_Location) == 0x000690, "Member 'UShooterCharacterMovement::ReattachMeshClimbingInterpSpeed_Location' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, ReattachMeshClimbingInterpSpeed_Rotation) == 0x000694, "Member 'UShooterCharacterMovement::ReattachMeshClimbingInterpSpeed_Rotation' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, MinMeshDistanceSqToReattachImmediately) == 0x000698, "Member 'UShooterCharacterMovement::MinMeshDistanceSqToReattachImmediately' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, bLandedFromVault) == 0x00069C, "Member 'UShooterCharacterMovement::bLandedFromVault' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, bMomentumBasedVaulting) == 0x00069D, "Member 'UShooterCharacterMovement::bMomentumBasedVaulting' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, MomentumVault_MinimumSpeed) == 0x0006A0, "Member 'UShooterCharacterMovement::MomentumVault_MinimumSpeed' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, MomentumVault_StartSpeedDelta) == 0x0006A4, "Member 'UShooterCharacterMovement::MomentumVault_StartSpeedDelta' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, MaximumVaultTime) == 0x0006A8, "Member 'UShooterCharacterMovement::MaximumVaultTime' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, VaultingCoolDown) == 0x0006AC, "Member 'UShooterCharacterMovement::VaultingCoolDown' has a wrong offset!");
static_assert(offsetof(UShooterCharacterMovement, bShowDebugVisualisations) == 0x0006B0, "Member 'UShooterCharacterMovement::bShowDebugVisualisations' has a wrong offset!");

// Class HLL.HLLUIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UHLLUIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString DebugWidgetsUnderCursor(const bool bIgnoreEnabledState);
	static void ForceMouseUpdate();
	static bool GetBrush_PlayerRole(const EPlayerRole InRole, struct FSlateBrush* OutBrush);
	static struct FChatColours GetChatColoursOverride(const EHLLChat InChat, const EPlayerRole OwnerRole, const bool bIsSelf);
	static bool GetChatMetaData(const EHLLChat InChat, struct FChatMetaData* OutMetaData);
	static struct FFactionUIData GetFactionUIData(const EFaction InFaction);
	static class UUserWidget* GetFocusedWidget(class APlayerController* Player);
	static class FText GetFriendlyFactionName(EFaction Faction);
	static class FText GetGameVersion();
	static class AShooterCharacter* GetHLLCharacter(const class UUserWidget* InWidget);
	static class AShooterHUD* GetHLLHUD(const class UUserWidget* InWidget);
	static class AShooterPlayerController* GetHLLPlayer(const class UUserWidget* InWidget);
	static class AShooterPlayerState* GetHLLPlayerState(const class UUserWidget* InWidget);
	static class UHLLMainMenuBase* GetMainMenuWidget(const class UObject* WorldContextObject, class APlayerController* Player);
	static struct FMarkerColours GetMarkerColours(const class AShooterPlayerState* Viewer, const class AShooterPlayerState* Owner);
	static struct FMarkerColours GetMarkerColoursOverride(const EHLLMarker InMarker, const class AShooterPlayerState* Viewer, const class AShooterPlayerState* Owner);
	static bool GetMarkerMetaData(const EHLLMarker InMarker, struct FMarkerMetaData* OutMetaData);
	static class FText GetMarkerVisibilityText(const EPlayerRole OwnerRole, const struct FMarkerMetaData& InMarkerMeta);
	static class FString GetMinutesFormattedAsString(int32 InMinutes, const class FString& InHourString, const class FString& InMinutesString);
	static class AHLLPlatoon* GetPlayerPlatoon(const class UUserWidget* InWidget, int32* PlatoonIndex);
	static EPlayerRole GetPlayerRole(const class UUserWidget* InWidget);
	static ETeam GetPlayerTeam(const class UUserWidget* InWidget);
	static struct FSocialMediaMeta GetSocialMediaMeta(const ESocialMedia SocialMediaType);
	static class FText GetStreamingPlayerName(const class APlayerState* InPS);
	static class FString GetStreamingPlayerUniqueId(const class APlayerState* InPS);
	static void GetStyleColours_Button(const struct FButtonStyle& InStyle, struct FLinearColor* Normal, struct FLinearColor* Hovered, struct FLinearColor* Pressed, struct FLinearColor* Disabled);
	static struct FHLLUIStyle GetUIStyle();
	static void InvertStyle_Button(const struct FButtonStyle& InStyle, struct FButtonStyle* OutStyle, const bool bInvertAlpha);
	static void InvertStyle_Checkbox(const struct FCheckBoxStyle& InStyle, struct FCheckBoxStyle* OutStyle, const bool bInvertAlpha);
	static int32 MaxMarkersOfType(const EHLLMarker InMarker);
	static void ReportPlayer(const class FString& GlobalPlayerId, const EReportPlayerReason Reason);
	static void SetBrushImage(const struct FSlateBrush& Brush, struct FSlateBrush* OutBrush, class UObject* Source);
	static void SetBrushTint(const struct FSlateBrush& InBrush, struct FSlateBrush* OutBrush, const struct FSlateColor& Tint);
	static void SetStyleColours_Button(const struct FButtonStyle& InStyle, struct FButtonStyle* OutStyle, const struct FLinearColor& Normal, const struct FLinearColor& Hovered, const struct FLinearColor& Pressed, const struct FLinearColor& Disabled);
	static void SetStyleImage_Button(const struct FButtonStyle& InStyle, struct FButtonStyle* OutStyle, class UObject* Source);
	static void SetStyleImage_Checkbox(const struct FCheckBoxStyle& InStyle, struct FCheckBoxStyle* OutStyle, class UObject* Unchecked, class UObject* Checked, class UObject* Undetermined);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUIFunctionLibrary">();
	}
	static class UHLLUIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUIFunctionLibrary>();
	}
};
static_assert(alignof(UHLLUIFunctionLibrary) == 0x000008, "Wrong alignment on UHLLUIFunctionLibrary");
static_assert(sizeof(UHLLUIFunctionLibrary) == 0x000028, "Wrong size on UHLLUIFunctionLibrary");

// Class HLL.ShooterGameState
// 0x0528 (0x07B8 - 0x0290)
class AShooterGameState : public AGameState
{
public:
	uint8                                         Pad_1445[0x18];                                    // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          AllowMobileSpawnsInEnemyTerritory;                 // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1446[0x4F];                                    // 0x02A9(0x004F)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         NumTeams;                                          // 0x02F8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainingTime;                                     // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimerPaused;                                      // 0x0300(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumAxisPlayers;                                    // 0x0301(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumAlliedPlayers;                                  // 0x0302(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxPlayerCount;                                    // 0x0303(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseWaveIntervalSeconds;                           // 0x0304(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHLLPlatoon*>                    AxisPlatoons;                                      // 0x0308(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHLLPlatoon*>                    AlliesPlatoons;                                    // 0x0318(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlatoonsUpdated;                                 // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	EGameModeType                                 GameModeType;                                      // 0x0338(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreSectors;                                    // 0x0339(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1447[0x6];                                     // 0x033A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UMapMeta*                               CachedMapMeta;                                     // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSectorState>                   M_sectors;                                         // 0x0348(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTeamState                             M_axisTeam;                                        // 0x0358(0x0008)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTeamState                             M_alliesTeam;                                      // 0x0360(0x0008)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1448[0x1];                                     // 0x0368(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	EHint                                         ObjectiveModeInitialSpawnHint;                     // 0x0369(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHint                                         ObjectiveModeHQSpawnHint;                          // 0x036A(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1449[0x15];                                    // 0x036B(0x0015)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bIsGameRunningOnMatchmakingServer;                 // 0x0380(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144A[0x7];                                     // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<ECheatRoles>                           AllowedCheatRoles;                                 // 0x0388(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHLLMapStateComponent*                  MapStateComponent;                                 // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOffensiveWarfareGameStateComponent*    OffensiveGameStateComponent;                       // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144B[0x20];                                    // 0x03A8(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLSupplyComponent*>            RegisteredSupplyComponents;                        // 0x03C8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ADynamicSpawn*>                  RegisteredSpawns;                                  // 0x03D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHLLResourceNode*>               RegisteredNodes;                                   // 0x03E8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActorCounter                          AxisActorCounter;                                  // 0x03F8(0x0118)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FActorCounter                          AlliesActorCounter;                                // 0x0510(0x0118)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnAbilitiesChanged;                                // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AHLLCommanderAbility*>           AxisCommanderAbilities;                            // 0x0638(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHLLCommanderAbility*>           AlliedCommanderAbilities;                          // 0x0648(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRepSpawnVehicleSlots                  AbilityVehicleSlots;                               // 0x0658(0x0028)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bUsingMultiObjectiveConquestGameMode;              // 0x0680(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144C[0x1];                                     // 0x0681(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	uint16                                        MultiObjectiveConquestInitialTickets;              // 0x0682(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144D[0x24];                                    // 0x0684(0x0024)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AShooterPlayerState*>            RepCommanders;                                     // 0x06A8(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_nextBaseSpawnWaveTime;                           // 0x06B8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AxisHQSectorIndex;                                 // 0x06BC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AlliedHQSectorIndex;                               // 0x06BD(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144E[0x2];                                     // 0x06BE(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	uint32                                        bHasHQSectors;                                     // 0x06C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144F[0x4];                                     // 0x06C4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AHLLMapData_Player_Replicator> PlayerReplicatorClass;                             // 0x06C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHLLMapData_Player_Replicator*>  MapDataPlayerReplicatorArray;                      // 0x06D0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1450[0xC];                                     // 0x06E0(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bTeamAutoBalanceEnabled : 1;                       // 0x06EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         TeamAutoBalanceThreshold;                          // 0x06ED(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TeamSwitchingCooldownMinutes;                      // 0x06EE(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1451[0x19];                                    // 0x06EF(0x0019)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHLLIndicatorComponent_Sector*>  SectorIndicators;                                  // 0x0708(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHLLReconDataComponent*                 ReconDataComponent;                                // 0x0718(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLVoteDataComponent*                  VoteDataComponent;                                 // 0x0720(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHLLGameWarmupVolume>       GameWarmupVolumeClass;                             // 0x0728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WarmupVolumeLifetime;                              // 0x0730(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1452[0x1C];                                    // 0x0734(0x001C)(Fixing Size After Last Property [ Dumper-69 ])
	class AHLLGameWarmupVolume*                   GameWarmupVolume;                                  // 0x0750(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1453[0x18];                                    // 0x0758(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnPlayerArrayUpdated;                              // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1454[0x8];                                     // 0x0780(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   ServerWelcomeMessageOverride;                      // 0x0788(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	struct FGameModifiers                         GameModifiers;                                     // 0x07A0(0x0008)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1455[0x10];                                    // 0x07A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class FText GetClaimCommanderFailedText(const EClaimCommanderFailedReason& Reason);
	static class AHLLCommanderAbility* K2_FindTeamAbility(const class UObject* WorldContextObject, const TSubclassOf<class AHLLCommanderAbility> AbilityClass, const ETeam ForTeam);

	void AbilityVehicleDestroyed(class AActor* Vehicle);
	void ClaimCommanderRole(class AShooterPlayerState* PlayerState, bool* Success, EClaimCommanderFailedReason* Reason);
	void ClientRPCSetClientBotRestrictMovementPosition(const struct FVector& NewPos);
	int32 GetCurrentConquestTickets_BP(const ETeam& ForTeam);
	bool HasArmyCommander(const ETeam Team);
	void HLLOnCommanderAbilitiesChanged__DelegateSignature();
	void NotifyCommandersChanged();
	void OnPlatoonsUpdated__DelegateSignature();
	void OnPlayerArrayUpdated__DelegateSignature(const TArray<class APlayerState*>& CurrentPlayers);
	void OnRep_Abilities();
	void OnRep_GameWarmupVolume();
	void OnRep_Platoons();
	void OnRep_RemainingTime();
	void OnRep_SectorsChanged();
	void OnTeamRegisteredActorDestroyed(class AActor* Instance);
	void RemovePlayerFromItsPlatoon(class APlayerState* Player);
	void TestFunction();

	EGameModeType GetGameModeType() const;
	int32 GetInitialConquestTickets_BP() const;
	void GetNumSectorsOwned(int32* OutAllied, int32* OutAxis, const bool bIncludeBaseSectors) const;
	EHint GetObjectiveModeHint(EHint BaseHintType) const;
	uint8 GetTeamActorCount(const ETeam ForTeam, const EActorCountClass Type) const;
	bool GetTeamAutobalanceEnabled() const;
	int32 GetTeamAutobalanceThreshold() const;
	class AShooterPlayerState* GetTeamCommander(const ETeam ForTeam) const;
	bool GetUsingLegacyConquestRuleset() const;
	bool GetUsingMultiObjectiveConquestGameMode() const;
	float NextBaseSpawnWaveTime() const;
	int32 NumPlatoonsOfTypeInTeam(ETeam Team, EPlatoonType Type) const;
	int32 NumSectorsOwned(const ETeam ForTeam, const bool bIncludeBaseSectors) const;
	void ResignAsArmyCommanderRole(class AShooterPlayerState* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameState">();
	}
	static class AShooterGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGameState>();
	}
};
static_assert(alignof(AShooterGameState) == 0x000008, "Wrong alignment on AShooterGameState");
static_assert(sizeof(AShooterGameState) == 0x0007B8, "Wrong size on AShooterGameState");
static_assert(offsetof(AShooterGameState, AllowMobileSpawnsInEnemyTerritory) == 0x0002A8, "Member 'AShooterGameState::AllowMobileSpawnsInEnemyTerritory' has a wrong offset!");
static_assert(offsetof(AShooterGameState, NumTeams) == 0x0002F8, "Member 'AShooterGameState::NumTeams' has a wrong offset!");
static_assert(offsetof(AShooterGameState, RemainingTime) == 0x0002FC, "Member 'AShooterGameState::RemainingTime' has a wrong offset!");
static_assert(offsetof(AShooterGameState, bTimerPaused) == 0x000300, "Member 'AShooterGameState::bTimerPaused' has a wrong offset!");
static_assert(offsetof(AShooterGameState, NumAxisPlayers) == 0x000301, "Member 'AShooterGameState::NumAxisPlayers' has a wrong offset!");
static_assert(offsetof(AShooterGameState, NumAlliedPlayers) == 0x000302, "Member 'AShooterGameState::NumAlliedPlayers' has a wrong offset!");
static_assert(offsetof(AShooterGameState, MaxPlayerCount) == 0x000303, "Member 'AShooterGameState::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(AShooterGameState, BaseWaveIntervalSeconds) == 0x000304, "Member 'AShooterGameState::BaseWaveIntervalSeconds' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AxisPlatoons) == 0x000308, "Member 'AShooterGameState::AxisPlatoons' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AlliesPlatoons) == 0x000318, "Member 'AShooterGameState::AlliesPlatoons' has a wrong offset!");
static_assert(offsetof(AShooterGameState, OnPlatoonsUpdated) == 0x000328, "Member 'AShooterGameState::OnPlatoonsUpdated' has a wrong offset!");
static_assert(offsetof(AShooterGameState, GameModeType) == 0x000338, "Member 'AShooterGameState::GameModeType' has a wrong offset!");
static_assert(offsetof(AShooterGameState, bIgnoreSectors) == 0x000339, "Member 'AShooterGameState::bIgnoreSectors' has a wrong offset!");
static_assert(offsetof(AShooterGameState, CachedMapMeta) == 0x000340, "Member 'AShooterGameState::CachedMapMeta' has a wrong offset!");
static_assert(offsetof(AShooterGameState, M_sectors) == 0x000348, "Member 'AShooterGameState::M_sectors' has a wrong offset!");
static_assert(offsetof(AShooterGameState, M_axisTeam) == 0x000358, "Member 'AShooterGameState::M_axisTeam' has a wrong offset!");
static_assert(offsetof(AShooterGameState, M_alliesTeam) == 0x000360, "Member 'AShooterGameState::M_alliesTeam' has a wrong offset!");
static_assert(offsetof(AShooterGameState, ObjectiveModeInitialSpawnHint) == 0x000369, "Member 'AShooterGameState::ObjectiveModeInitialSpawnHint' has a wrong offset!");
static_assert(offsetof(AShooterGameState, ObjectiveModeHQSpawnHint) == 0x00036A, "Member 'AShooterGameState::ObjectiveModeHQSpawnHint' has a wrong offset!");
static_assert(offsetof(AShooterGameState, bIsGameRunningOnMatchmakingServer) == 0x000380, "Member 'AShooterGameState::bIsGameRunningOnMatchmakingServer' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AllowedCheatRoles) == 0x000388, "Member 'AShooterGameState::AllowedCheatRoles' has a wrong offset!");
static_assert(offsetof(AShooterGameState, MapStateComponent) == 0x000398, "Member 'AShooterGameState::MapStateComponent' has a wrong offset!");
static_assert(offsetof(AShooterGameState, OffensiveGameStateComponent) == 0x0003A0, "Member 'AShooterGameState::OffensiveGameStateComponent' has a wrong offset!");
static_assert(offsetof(AShooterGameState, RegisteredSupplyComponents) == 0x0003C8, "Member 'AShooterGameState::RegisteredSupplyComponents' has a wrong offset!");
static_assert(offsetof(AShooterGameState, RegisteredSpawns) == 0x0003D8, "Member 'AShooterGameState::RegisteredSpawns' has a wrong offset!");
static_assert(offsetof(AShooterGameState, RegisteredNodes) == 0x0003E8, "Member 'AShooterGameState::RegisteredNodes' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AxisActorCounter) == 0x0003F8, "Member 'AShooterGameState::AxisActorCounter' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AlliesActorCounter) == 0x000510, "Member 'AShooterGameState::AlliesActorCounter' has a wrong offset!");
static_assert(offsetof(AShooterGameState, OnAbilitiesChanged) == 0x000628, "Member 'AShooterGameState::OnAbilitiesChanged' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AxisCommanderAbilities) == 0x000638, "Member 'AShooterGameState::AxisCommanderAbilities' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AlliedCommanderAbilities) == 0x000648, "Member 'AShooterGameState::AlliedCommanderAbilities' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AbilityVehicleSlots) == 0x000658, "Member 'AShooterGameState::AbilityVehicleSlots' has a wrong offset!");
static_assert(offsetof(AShooterGameState, bUsingMultiObjectiveConquestGameMode) == 0x000680, "Member 'AShooterGameState::bUsingMultiObjectiveConquestGameMode' has a wrong offset!");
static_assert(offsetof(AShooterGameState, MultiObjectiveConquestInitialTickets) == 0x000682, "Member 'AShooterGameState::MultiObjectiveConquestInitialTickets' has a wrong offset!");
static_assert(offsetof(AShooterGameState, RepCommanders) == 0x0006A8, "Member 'AShooterGameState::RepCommanders' has a wrong offset!");
static_assert(offsetof(AShooterGameState, M_nextBaseSpawnWaveTime) == 0x0006B8, "Member 'AShooterGameState::M_nextBaseSpawnWaveTime' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AxisHQSectorIndex) == 0x0006BC, "Member 'AShooterGameState::AxisHQSectorIndex' has a wrong offset!");
static_assert(offsetof(AShooterGameState, AlliedHQSectorIndex) == 0x0006BD, "Member 'AShooterGameState::AlliedHQSectorIndex' has a wrong offset!");
static_assert(offsetof(AShooterGameState, bHasHQSectors) == 0x0006C0, "Member 'AShooterGameState::bHasHQSectors' has a wrong offset!");
static_assert(offsetof(AShooterGameState, PlayerReplicatorClass) == 0x0006C8, "Member 'AShooterGameState::PlayerReplicatorClass' has a wrong offset!");
static_assert(offsetof(AShooterGameState, MapDataPlayerReplicatorArray) == 0x0006D0, "Member 'AShooterGameState::MapDataPlayerReplicatorArray' has a wrong offset!");
static_assert(offsetof(AShooterGameState, TeamAutoBalanceThreshold) == 0x0006ED, "Member 'AShooterGameState::TeamAutoBalanceThreshold' has a wrong offset!");
static_assert(offsetof(AShooterGameState, TeamSwitchingCooldownMinutes) == 0x0006EE, "Member 'AShooterGameState::TeamSwitchingCooldownMinutes' has a wrong offset!");
static_assert(offsetof(AShooterGameState, SectorIndicators) == 0x000708, "Member 'AShooterGameState::SectorIndicators' has a wrong offset!");
static_assert(offsetof(AShooterGameState, ReconDataComponent) == 0x000718, "Member 'AShooterGameState::ReconDataComponent' has a wrong offset!");
static_assert(offsetof(AShooterGameState, VoteDataComponent) == 0x000720, "Member 'AShooterGameState::VoteDataComponent' has a wrong offset!");
static_assert(offsetof(AShooterGameState, GameWarmupVolumeClass) == 0x000728, "Member 'AShooterGameState::GameWarmupVolumeClass' has a wrong offset!");
static_assert(offsetof(AShooterGameState, WarmupVolumeLifetime) == 0x000730, "Member 'AShooterGameState::WarmupVolumeLifetime' has a wrong offset!");
static_assert(offsetof(AShooterGameState, GameWarmupVolume) == 0x000750, "Member 'AShooterGameState::GameWarmupVolume' has a wrong offset!");
static_assert(offsetof(AShooterGameState, OnPlayerArrayUpdated) == 0x000770, "Member 'AShooterGameState::OnPlayerArrayUpdated' has a wrong offset!");
static_assert(offsetof(AShooterGameState, ServerWelcomeMessageOverride) == 0x000788, "Member 'AShooterGameState::ServerWelcomeMessageOverride' has a wrong offset!");
static_assert(offsetof(AShooterGameState, GameModifiers) == 0x0007A0, "Member 'AShooterGameState::GameModifiers' has a wrong offset!");

// Class HLL.TargetAssaultGameState
// 0x0020 (0x07D8 - 0x07B8)
class ATargetAssaultGameState : public AShooterGameState
{
public:
	uint8                                         Pad_145E[0x10];                                    // 0x07B8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class APlantObjectiveArea*>            OBJECTIVES;                                        // 0x07C8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastOnObjectiveAreaDestroyedEvent(class AActor* PlantObjectiveArea);
	void ObjectiveAreaDestroyed__DelegateSignature(class APlantObjectiveArea* ObjectiveArea);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetAssaultGameState">();
	}
	static class ATargetAssaultGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATargetAssaultGameState>();
	}
};
static_assert(alignof(ATargetAssaultGameState) == 0x000008, "Wrong alignment on ATargetAssaultGameState");
static_assert(sizeof(ATargetAssaultGameState) == 0x0007D8, "Wrong size on ATargetAssaultGameState");
static_assert(offsetof(ATargetAssaultGameState, OBJECTIVES) == 0x0007C8, "Member 'ATargetAssaultGameState::OBJECTIVES' has a wrong offset!");

// Class HLL.HLLUIStyleContainer
// 0x2368 (0x2398 - 0x0030)
class UHLLUIStyleContainer final : public USlateWidgetStyleContainerBase
{
public:
	struct FHLLUIStyle                            MapStyle;                                          // 0x0030(0x2368)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUIStyleContainer">();
	}
	static class UHLLUIStyleContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUIStyleContainer>();
	}
};
static_assert(alignof(UHLLUIStyleContainer) == 0x000008, "Wrong alignment on UHLLUIStyleContainer");
static_assert(sizeof(UHLLUIStyleContainer) == 0x002398, "Wrong size on UHLLUIStyleContainer");
static_assert(offsetof(UHLLUIStyleContainer, MapStyle) == 0x000030, "Member 'UHLLUIStyleContainer::MapStyle' has a wrong offset!");

// Class HLL.HLLUI_CosmeticItem
// 0x0048 (0x0278 - 0x0230)
class UHLLUI_CosmeticItem : public UUserWidget
{
public:
	TWeakObjectPtr<class UHLLUI_CosmeticCategory> ParentCategory;                                    // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemIcon;                                          // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RootButton;                                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_CosmeticItemTooltip> TooltipClass;                                      // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsSelected : 1;                                   // 0x0258(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsUnlocked : 1;                                   // 0x0258(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPreviewing : 1;                                 // 0x0258(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_145F[0x7];                                     // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDataTableRowHandle                    CosmeticItemHandle;                                // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UHLLUI_CosmeticItemTooltip*             CosmeticTooltip;                                   // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_InitItem(const struct FHLLCosmeticItemData& InItemData, const EHLLCosmeticType CosmeticType, const class FName InCosmeticItemID, const bool bInIsUnlocked);
	void K2_SetPreviewing(const bool bInIsPreviewing);
	void K2_SetSelected(const bool bInIsSelected);
	void OnApply();
	void OnApplyToAllRoles();
	void OnCosmeticApplied();
	void OnPreview();
	void OnStopPreview();
	void RefreshTooltip(const bool bAutoCreate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_CosmeticItem">();
	}
	static class UHLLUI_CosmeticItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_CosmeticItem>();
	}
};
static_assert(alignof(UHLLUI_CosmeticItem) == 0x000008, "Wrong alignment on UHLLUI_CosmeticItem");
static_assert(sizeof(UHLLUI_CosmeticItem) == 0x000278, "Wrong size on UHLLUI_CosmeticItem");
static_assert(offsetof(UHLLUI_CosmeticItem, ParentCategory) == 0x000230, "Member 'UHLLUI_CosmeticItem::ParentCategory' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItem, ItemIcon) == 0x000238, "Member 'UHLLUI_CosmeticItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItem, RootButton) == 0x000240, "Member 'UHLLUI_CosmeticItem::RootButton' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItem, ItemName) == 0x000248, "Member 'UHLLUI_CosmeticItem::ItemName' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItem, TooltipClass) == 0x000250, "Member 'UHLLUI_CosmeticItem::TooltipClass' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItem, CosmeticItemHandle) == 0x000260, "Member 'UHLLUI_CosmeticItem::CosmeticItemHandle' has a wrong offset!");
static_assert(offsetof(UHLLUI_CosmeticItem, CosmeticTooltip) == 0x000270, "Member 'UHLLUI_CosmeticItem::CosmeticTooltip' has a wrong offset!");

// Class HLL.HLLBleedDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLBleedDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLBleedDamage">();
	}
	static class UHLLBleedDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLBleedDamage>();
	}
};
static_assert(alignof(UHLLBleedDamage) == 0x000008, "Wrong alignment on UHLLBleedDamage");
static_assert(sizeof(UHLLBleedDamage) == 0x0001E8, "Wrong size on UHLLBleedDamage");

// Class HLL.HLLUI_Credits
// 0x0148 (0x0378 - 0x0230)
class UHLLUI_Credits : public UUserWidget
{
public:
	class UScrollBox*                             CreditsScroller;                                   // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoScrollSpeed;                                   // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1462[0x4];                                     // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         LeadEmptySpaceHeight;                              // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1463[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UStringTable*                           RolesStringTable;                                  // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStringTable*                           DepartmentsStringTable;                            // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CreditsInfo;                                       // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             OrganisationInfo;                                  // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_CreditsOrganisation> OrganisationWidget;                                // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_CreditsCategory_Department> DepartmentWidget;                                  // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_CreditsCategory_RoleAndMembers> RolesAndMembersWidget;                             // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, TSubclassOf<class UHLLUI_CreditsOrganisation>> OrganisationOverrides;                             // 0x0280(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, TSubclassOf<class UHLLUI_CreditsCategory_Department>> DepartmentOverrides;                               // 0x02D0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, TSubclassOf<class UHLLUI_CreditsCategory_RoleAndMembers>> RolesAndMembersOverrides;                          // 0x0320(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1464[0x8];                                     // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetAutoScroll(const bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_Credits">();
	}
	static class UHLLUI_Credits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_Credits>();
	}
};
static_assert(alignof(UHLLUI_Credits) == 0x000008, "Wrong alignment on UHLLUI_Credits");
static_assert(sizeof(UHLLUI_Credits) == 0x000378, "Wrong size on UHLLUI_Credits");
static_assert(offsetof(UHLLUI_Credits, CreditsScroller) == 0x000230, "Member 'UHLLUI_Credits::CreditsScroller' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, AutoScrollSpeed) == 0x000238, "Member 'UHLLUI_Credits::AutoScrollSpeed' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, LeadEmptySpaceHeight) == 0x000240, "Member 'UHLLUI_Credits::LeadEmptySpaceHeight' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, RolesStringTable) == 0x000248, "Member 'UHLLUI_Credits::RolesStringTable' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, DepartmentsStringTable) == 0x000250, "Member 'UHLLUI_Credits::DepartmentsStringTable' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, CreditsInfo) == 0x000258, "Member 'UHLLUI_Credits::CreditsInfo' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, OrganisationInfo) == 0x000260, "Member 'UHLLUI_Credits::OrganisationInfo' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, OrganisationWidget) == 0x000268, "Member 'UHLLUI_Credits::OrganisationWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, DepartmentWidget) == 0x000270, "Member 'UHLLUI_Credits::DepartmentWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, RolesAndMembersWidget) == 0x000278, "Member 'UHLLUI_Credits::RolesAndMembersWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, OrganisationOverrides) == 0x000280, "Member 'UHLLUI_Credits::OrganisationOverrides' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, DepartmentOverrides) == 0x0002D0, "Member 'UHLLUI_Credits::DepartmentOverrides' has a wrong offset!");
static_assert(offsetof(UHLLUI_Credits, RolesAndMembersOverrides) == 0x000320, "Member 'UHLLUI_Credits::RolesAndMembersOverrides' has a wrong offset!");

// Class HLL.ShooterSpectatorPawn
// 0x0008 (0x02B0 - 0x02A8)
class AShooterSpectatorPawn final : public ASpectatorPawn
{
public:
	uint8                                         Pad_1465[0x8];                                     // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterSpectatorPawn">();
	}
	static class AShooterSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterSpectatorPawn>();
	}
};
static_assert(alignof(AShooterSpectatorPawn) == 0x000008, "Wrong alignment on AShooterSpectatorPawn");
static_assert(sizeof(AShooterSpectatorPawn) == 0x0002B0, "Wrong size on AShooterSpectatorPawn");

// Class HLL.HLLUI_DivisionsContainer
// 0x0018 (0x0248 - 0x0230)
class UHLLUI_DivisionsContainer : public UUserWidget
{
public:
	TWeakObjectPtr<class UHLLUI_CharacterSelection> ParentPanel;                                       // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ItemScroller;                                      // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      ItemPanel;                                         // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<struct FDivisionCosmeticProfile> GetDivisionsForFaction(EFaction Faction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_DivisionsContainer">();
	}
	static class UHLLUI_DivisionsContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_DivisionsContainer>();
	}
};
static_assert(alignof(UHLLUI_DivisionsContainer) == 0x000008, "Wrong alignment on UHLLUI_DivisionsContainer");
static_assert(sizeof(UHLLUI_DivisionsContainer) == 0x000248, "Wrong size on UHLLUI_DivisionsContainer");
static_assert(offsetof(UHLLUI_DivisionsContainer, ParentPanel) == 0x000230, "Member 'UHLLUI_DivisionsContainer::ParentPanel' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsContainer, ItemScroller) == 0x000238, "Member 'UHLLUI_DivisionsContainer::ItemScroller' has a wrong offset!");
static_assert(offsetof(UHLLUI_DivisionsContainer, ItemPanel) == 0x000240, "Member 'UHLLUI_DivisionsContainer::ItemPanel' has a wrong offset!");

// Class HLL.HLLUI_FriendInviteItem
// 0x0028 (0x0258 - 0x0230)
class UHLLUI_FriendInviteItem : public UUserWidget
{
public:
	class UImage*                                 PlatformIcon;                                      // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FriendName;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                InviteButton;                                      // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1467[0x10];                                    // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InviteFriend();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_FriendInviteItem">();
	}
	static class UHLLUI_FriendInviteItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_FriendInviteItem>();
	}
};
static_assert(alignof(UHLLUI_FriendInviteItem) == 0x000008, "Wrong alignment on UHLLUI_FriendInviteItem");
static_assert(sizeof(UHLLUI_FriendInviteItem) == 0x000258, "Wrong size on UHLLUI_FriendInviteItem");
static_assert(offsetof(UHLLUI_FriendInviteItem, PlatformIcon) == 0x000230, "Member 'UHLLUI_FriendInviteItem::PlatformIcon' has a wrong offset!");
static_assert(offsetof(UHLLUI_FriendInviteItem, FriendName) == 0x000238, "Member 'UHLLUI_FriendInviteItem::FriendName' has a wrong offset!");
static_assert(offsetof(UHLLUI_FriendInviteItem, InviteButton) == 0x000240, "Member 'UHLLUI_FriendInviteItem::InviteButton' has a wrong offset!");

// Class HLL.SoundNodeHLLDistanceCrossFade
// 0x0010 (0x0058 - 0x0048)
class USoundNodeHLLDistanceCrossFade final : public USoundNode
{
public:
	TArray<struct FDistanceDatum>                 CrossFadeInput;                                    // 0x0048(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeHLLDistanceCrossFade">();
	}
	static class USoundNodeHLLDistanceCrossFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeHLLDistanceCrossFade>();
	}
};
static_assert(alignof(USoundNodeHLLDistanceCrossFade) == 0x000008, "Wrong alignment on USoundNodeHLLDistanceCrossFade");
static_assert(sizeof(USoundNodeHLLDistanceCrossFade) == 0x000058, "Wrong size on USoundNodeHLLDistanceCrossFade");
static_assert(offsetof(USoundNodeHLLDistanceCrossFade, CrossFadeInput) == 0x000048, "Member 'USoundNodeHLLDistanceCrossFade::CrossFadeInput' has a wrong offset!");

// Class HLL.HLLUI_InviteItem
// 0x0030 (0x0260 - 0x0230)
class UHLLUI_InviteItem : public UUserWidget
{
public:
	class UTextBlock*                             FriendName;                                        // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InviteInfo;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                AcceptInviteButton;                                // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RejectInviteButton;                                // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1468[0x10];                                    // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AcceptInvite();
	void RejectInvite();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_InviteItem">();
	}
	static class UHLLUI_InviteItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_InviteItem>();
	}
};
static_assert(alignof(UHLLUI_InviteItem) == 0x000008, "Wrong alignment on UHLLUI_InviteItem");
static_assert(sizeof(UHLLUI_InviteItem) == 0x000260, "Wrong size on UHLLUI_InviteItem");
static_assert(offsetof(UHLLUI_InviteItem, FriendName) == 0x000230, "Member 'UHLLUI_InviteItem::FriendName' has a wrong offset!");
static_assert(offsetof(UHLLUI_InviteItem, InviteInfo) == 0x000238, "Member 'UHLLUI_InviteItem::InviteInfo' has a wrong offset!");
static_assert(offsetof(UHLLUI_InviteItem, AcceptInviteButton) == 0x000240, "Member 'UHLLUI_InviteItem::AcceptInviteButton' has a wrong offset!");
static_assert(offsetof(UHLLUI_InviteItem, RejectInviteButton) == 0x000248, "Member 'UHLLUI_InviteItem::RejectInviteButton' has a wrong offset!");

// Class HLL.HLLUI_LoadoutSelector
// 0x0078 (0x02A8 - 0x0230)
class UHLLUI_LoadoutSelector : public UUserWidget
{
public:
	uint8                                         Pad_1469[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class UHLLUI_CharacterSelection> ParentPanel;                                       // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLoadoutColumns;                                 // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146A[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLUI_LoadoutEntry>        LargeItemWidget;                                   // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_LoadoutEntry>        SmallItemWidget;                                   // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLUI_LoadoutEntry*>            ActiveItems;                                       // 0x0258(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLUI_Loadout*>                 ActiveLoadouts;                                    // 0x0268(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLUI_LoadoutTooltip*                  TooltipItem;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      LoadoutPanel;                                      // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             LoadoutBox;                                        // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWrapBox*                               EntryPanel;                                        // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             UnlockedText;                                      // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LoadoutName;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_LoadoutSelector">();
	}
	static class UHLLUI_LoadoutSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_LoadoutSelector>();
	}
};
static_assert(alignof(UHLLUI_LoadoutSelector) == 0x000008, "Wrong alignment on UHLLUI_LoadoutSelector");
static_assert(sizeof(UHLLUI_LoadoutSelector) == 0x0002A8, "Wrong size on UHLLUI_LoadoutSelector");
static_assert(offsetof(UHLLUI_LoadoutSelector, ParentPanel) == 0x000238, "Member 'UHLLUI_LoadoutSelector::ParentPanel' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, MaxLoadoutColumns) == 0x000240, "Member 'UHLLUI_LoadoutSelector::MaxLoadoutColumns' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, LargeItemWidget) == 0x000248, "Member 'UHLLUI_LoadoutSelector::LargeItemWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, SmallItemWidget) == 0x000250, "Member 'UHLLUI_LoadoutSelector::SmallItemWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, ActiveItems) == 0x000258, "Member 'UHLLUI_LoadoutSelector::ActiveItems' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, ActiveLoadouts) == 0x000268, "Member 'UHLLUI_LoadoutSelector::ActiveLoadouts' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, TooltipItem) == 0x000278, "Member 'UHLLUI_LoadoutSelector::TooltipItem' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, LoadoutPanel) == 0x000280, "Member 'UHLLUI_LoadoutSelector::LoadoutPanel' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, LoadoutBox) == 0x000288, "Member 'UHLLUI_LoadoutSelector::LoadoutBox' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, EntryPanel) == 0x000290, "Member 'UHLLUI_LoadoutSelector::EntryPanel' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, UnlockedText) == 0x000298, "Member 'UHLLUI_LoadoutSelector::UnlockedText' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutSelector, LoadoutName) == 0x0002A0, "Member 'UHLLUI_LoadoutSelector::LoadoutName' has a wrong offset!");

// Class HLL.ShooterWeapon_Binoculars
// 0x0000 (0x0AB0 - 0x0AB0)
class AShooterWeapon_Binoculars : public AShooterWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Binoculars">();
	}
	static class AShooterWeapon_Binoculars* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Binoculars>();
	}
};
static_assert(alignof(AShooterWeapon_Binoculars) == 0x000010, "Wrong alignment on AShooterWeapon_Binoculars");
static_assert(sizeof(AShooterWeapon_Binoculars) == 0x000AB0, "Wrong size on AShooterWeapon_Binoculars");

// Class HLL.HLLUI_LoadoutEntry
// 0x0038 (0x0268 - 0x0230)
class UHLLUI_LoadoutEntry : public UUserWidget
{
public:
	struct FLoadoutEntry                          CachedEntry;                                       // 0x0230(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemAmmoCount;                                     // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemAmmoIcon;                                      // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemIcon;                                          // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_LoadoutEntry">();
	}
	static class UHLLUI_LoadoutEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_LoadoutEntry>();
	}
};
static_assert(alignof(UHLLUI_LoadoutEntry) == 0x000008, "Wrong alignment on UHLLUI_LoadoutEntry");
static_assert(sizeof(UHLLUI_LoadoutEntry) == 0x000268, "Wrong size on UHLLUI_LoadoutEntry");
static_assert(offsetof(UHLLUI_LoadoutEntry, CachedEntry) == 0x000230, "Member 'UHLLUI_LoadoutEntry::CachedEntry' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutEntry, ItemName) == 0x000248, "Member 'UHLLUI_LoadoutEntry::ItemName' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutEntry, ItemAmmoCount) == 0x000250, "Member 'UHLLUI_LoadoutEntry::ItemAmmoCount' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutEntry, ItemAmmoIcon) == 0x000258, "Member 'UHLLUI_LoadoutEntry::ItemAmmoIcon' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutEntry, ItemIcon) == 0x000260, "Member 'UHLLUI_LoadoutEntry::ItemIcon' has a wrong offset!");

// Class HLL.HLLUI_LoadoutEntryTooltip
// 0x0020 (0x0250 - 0x0230)
class UHLLUI_LoadoutEntryTooltip : public UUserWidget
{
public:
	class UTextBlock*                             ItemName;                                          // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemDescription;                                   // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemAmmoCount;                                     // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemAmmoIcon;                                      // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitInfo(const struct FLoadoutItem& LoadoutItem, const int32 LoadoutAmmoCount);
	void InitTooltip(class UHLLUI_LoadoutEntry* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_LoadoutEntryTooltip">();
	}
	static class UHLLUI_LoadoutEntryTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_LoadoutEntryTooltip>();
	}
};
static_assert(alignof(UHLLUI_LoadoutEntryTooltip) == 0x000008, "Wrong alignment on UHLLUI_LoadoutEntryTooltip");
static_assert(sizeof(UHLLUI_LoadoutEntryTooltip) == 0x000250, "Wrong size on UHLLUI_LoadoutEntryTooltip");
static_assert(offsetof(UHLLUI_LoadoutEntryTooltip, ItemName) == 0x000230, "Member 'UHLLUI_LoadoutEntryTooltip::ItemName' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutEntryTooltip, ItemDescription) == 0x000238, "Member 'UHLLUI_LoadoutEntryTooltip::ItemDescription' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutEntryTooltip, ItemAmmoCount) == 0x000240, "Member 'UHLLUI_LoadoutEntryTooltip::ItemAmmoCount' has a wrong offset!");
static_assert(offsetof(UHLLUI_LoadoutEntryTooltip, ItemAmmoIcon) == 0x000248, "Member 'UHLLUI_LoadoutEntryTooltip::ItemAmmoIcon' has a wrong offset!");

// Class HLL.SpeakingPlayersListItem
// 0x0028 (0x0258 - 0x0230)
class USpeakingPlayersListItem : public UUserWidget
{
public:
	class UTextBlock*                             PlayerName;                                        // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerClan;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlatoonText;                                       // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlatformIcon;                                      // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PlatformIconContainer;                             // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpeakingPlayersListItem">();
	}
	static class USpeakingPlayersListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpeakingPlayersListItem>();
	}
};
static_assert(alignof(USpeakingPlayersListItem) == 0x000008, "Wrong alignment on USpeakingPlayersListItem");
static_assert(sizeof(USpeakingPlayersListItem) == 0x000258, "Wrong size on USpeakingPlayersListItem");
static_assert(offsetof(USpeakingPlayersListItem, PlayerName) == 0x000230, "Member 'USpeakingPlayersListItem::PlayerName' has a wrong offset!");
static_assert(offsetof(USpeakingPlayersListItem, PlayerClan) == 0x000238, "Member 'USpeakingPlayersListItem::PlayerClan' has a wrong offset!");
static_assert(offsetof(USpeakingPlayersListItem, PlatoonText) == 0x000240, "Member 'USpeakingPlayersListItem::PlatoonText' has a wrong offset!");
static_assert(offsetof(USpeakingPlayersListItem, PlatformIcon) == 0x000248, "Member 'USpeakingPlayersListItem::PlatformIcon' has a wrong offset!");
static_assert(offsetof(USpeakingPlayersListItem, PlatformIconContainer) == 0x000250, "Member 'USpeakingPlayersListItem::PlatformIconContainer' has a wrong offset!");

// Class HLL.HLLUI_OptionSelection
// 0x0010 (0x0240 - 0x0230)
class UHLLUI_OptionSelection : public UUserWidget
{
public:
	int32                                         PlatformVisibility;                                // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146C[0x4];                                     // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindOnInputChangedDelegate();
	void OnInputDeviceChanged(bool NewValue);
	void RefreshShoulderButtons();
	void UnBindOnInputChangedDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_OptionSelection">();
	}
	static class UHLLUI_OptionSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_OptionSelection>();
	}
};
static_assert(alignof(UHLLUI_OptionSelection) == 0x000008, "Wrong alignment on UHLLUI_OptionSelection");
static_assert(sizeof(UHLLUI_OptionSelection) == 0x000240, "Wrong size on UHLLUI_OptionSelection");
static_assert(offsetof(UHLLUI_OptionSelection, PlatformVisibility) == 0x000230, "Member 'UHLLUI_OptionSelection::PlatformVisibility' has a wrong offset!");
static_assert(offsetof(UHLLUI_OptionSelection, ViewportClient) == 0x000238, "Member 'UHLLUI_OptionSelection::ViewportClient' has a wrong offset!");

// Class HLL.HLLUI_CharacterSelection
// 0x0140 (0x0370 - 0x0230)
class UHLLUI_CharacterSelection : public UUserWidget
{
public:
	bool                                          bIsStore;                                          // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bViewingDivisions;                                 // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERoleSelectionMode                            CurrentViewMode;                                   // 0x0232(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowFavourites : 1;                              // 0x0233(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EFaction                                      CurrentFaction;                                    // 0x0234(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerRole                                   CurrentRole;                                       // 0x0235(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         CurrentPreset;                                     // 0x0236(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDivision                                     CurrentDivision;                                   // 0x0237(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLCosmeticCharacter*                  CosmeticPreviewActor;                              // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146D[0x28];                                    // 0x0240(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetSwitcher*                        CosmeticPanelSwitcher;                             // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           LoadingOverlay;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLUI_LoadoutSelector*                 LoadoutSelector;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           CommandVBox;                                       // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           InfantryVBox;                                      // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ArmourVBox;                                        // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ReconVBox;                                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHLLUI_RoleItem>            RoleItemClass;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLUI_RoleItem*>                AllRoleItems;                                      // 0x02A8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLUI_CosmeticCategory*                HelmetCategory;                                    // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLUI_CosmeticCategory*                HeadCategory;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLUI_CosmeticCategory*                UniformCategory;                                   // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLUI_DivisionsContainer*              DivisionsContainer;                                // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        DLCStoreDataTablePath;                             // 0x02E0(0x0018)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146E[0x70];                                    // 0x02F8(0x0070)(Fixing Size After Last Property [ Dumper-69 ])
	class UDataTable*                             DLCStoreDataTable;                                 // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool DoesHeadCosmeticHaveDivisionRestriction(const struct FHLLCosmeticItemData_Head& Cosmetic);
	bool DoesHelmetCosmeticHaveDivisionRestriction(const struct FHLLCosmeticItemData_Helmet& Cosmetic);
	bool DoesUniformCosmeticHaveDivisionRestriction(const struct FHLLCosmeticItemData_Uniform& Cosmetic);
	void EquipCosmeticToAllRoles(const EHLLCosmeticType CosmeticType, const class FName CosmeticRowName);
	void FocusOnRoles();
	TArray<struct FDivisionCosmeticProfile> GetDivisionsForMapMeta();
	void GlobalOnCosmeticsUpdated();
	void GlobalOnPlayerStatsRefreshed(const struct FUniqueNetIdRepl& UserId);
	void InputChanged(bool NewValue);
	void K2_OnCosmeticListUpdated();
	void K2_OnFactionChanged();
	void K2_OnLoadoutListUpdated();
	void K2_OnPresetChanged();
	void K2_OnRoleChanged();
	void K2_OnViewModeChanged();
	void NextFaction();
	void OnCosmeticSelected(const EHLLCosmeticType CosmeticType, const class FName CosmeticRowName);
	void OnLeftSectionFocus();
	void OnLoadoutSelected(const uint8 InLoadoutID);
	void OnRightSectionFocus();
	void OnToolTipChanged(const class FText& NewValue);
	void OnUpdateInput();
	void OnUpdateToolTipText(const class FText& NewText);
	void PreviewCharacterCosmetics(const class FName HelmetID, const class FName UniformID, const class FName HeadID);
	void PreviewCosmetic(const EHLLCosmeticType CosmeticType, const class FName CosmeticRowName);
	void ResetView();
	void SetActivePreset(const uint8 Param_Index);
	void SetCosmeticPreviewActor(class AHLLCosmeticCharacter* InActor);
	void SetCurrentDivision(const EDivision Division);
	void SetFaction(const EFaction Faction);
	void SetRole(const EPlayerRole Role);
	void SetupForFavourites();
	void SetViewMode(const ERoleSelectionMode NewMode);
	void StopPreviewCharacterCosmetic();
	void StopPreviewCosmetic();
	void ToggleFavourite(const EPlayerRole Role);

	class UDataTable* GetDLCStoreDataTable() const;
	bool IsViewingDivisions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_CharacterSelection">();
	}
	static class UHLLUI_CharacterSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_CharacterSelection>();
	}
};
static_assert(alignof(UHLLUI_CharacterSelection) == 0x000008, "Wrong alignment on UHLLUI_CharacterSelection");
static_assert(sizeof(UHLLUI_CharacterSelection) == 0x000370, "Wrong size on UHLLUI_CharacterSelection");
static_assert(offsetof(UHLLUI_CharacterSelection, bIsStore) == 0x000230, "Member 'UHLLUI_CharacterSelection::bIsStore' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, bViewingDivisions) == 0x000231, "Member 'UHLLUI_CharacterSelection::bViewingDivisions' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, CurrentViewMode) == 0x000232, "Member 'UHLLUI_CharacterSelection::CurrentViewMode' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, CurrentFaction) == 0x000234, "Member 'UHLLUI_CharacterSelection::CurrentFaction' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, CurrentRole) == 0x000235, "Member 'UHLLUI_CharacterSelection::CurrentRole' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, CurrentPreset) == 0x000236, "Member 'UHLLUI_CharacterSelection::CurrentPreset' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, CurrentDivision) == 0x000237, "Member 'UHLLUI_CharacterSelection::CurrentDivision' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, CosmeticPreviewActor) == 0x000238, "Member 'UHLLUI_CharacterSelection::CosmeticPreviewActor' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, CosmeticPanelSwitcher) == 0x000268, "Member 'UHLLUI_CharacterSelection::CosmeticPanelSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, LoadingOverlay) == 0x000270, "Member 'UHLLUI_CharacterSelection::LoadingOverlay' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, LoadoutSelector) == 0x000278, "Member 'UHLLUI_CharacterSelection::LoadoutSelector' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, CommandVBox) == 0x000280, "Member 'UHLLUI_CharacterSelection::CommandVBox' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, InfantryVBox) == 0x000288, "Member 'UHLLUI_CharacterSelection::InfantryVBox' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, ArmourVBox) == 0x000290, "Member 'UHLLUI_CharacterSelection::ArmourVBox' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, ReconVBox) == 0x000298, "Member 'UHLLUI_CharacterSelection::ReconVBox' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, RoleItemClass) == 0x0002A0, "Member 'UHLLUI_CharacterSelection::RoleItemClass' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, AllRoleItems) == 0x0002A8, "Member 'UHLLUI_CharacterSelection::AllRoleItems' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, HelmetCategory) == 0x0002B8, "Member 'UHLLUI_CharacterSelection::HelmetCategory' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, HeadCategory) == 0x0002C0, "Member 'UHLLUI_CharacterSelection::HeadCategory' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, UniformCategory) == 0x0002C8, "Member 'UHLLUI_CharacterSelection::UniformCategory' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, DivisionsContainer) == 0x0002D0, "Member 'UHLLUI_CharacterSelection::DivisionsContainer' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, ViewportClient) == 0x0002D8, "Member 'UHLLUI_CharacterSelection::ViewportClient' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, DLCStoreDataTablePath) == 0x0002E0, "Member 'UHLLUI_CharacterSelection::DLCStoreDataTablePath' has a wrong offset!");
static_assert(offsetof(UHLLUI_CharacterSelection, DLCStoreDataTable) == 0x000368, "Member 'UHLLUI_CharacterSelection::DLCStoreDataTable' has a wrong offset!");

// Class HLL.ShooterWeapon_Melee
// 0x00E0 (0x0B90 - 0x0AB0)
class AShooterWeapon_Melee : public AShooterWeapon
{
public:
	float                                         MaxReachDistance;                                  // 0x0AA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepSphereRadius;                                 // 0x0AAC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CameraTargetBone;                                  // 0x0AB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraTrackingSpeed;                               // 0x0AB8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeAttackDamage;                                 // 0x0ABC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponBloodPerHit;                                 // 0x0AC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HandsBloodPerHit;                                  // 0x0AC4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSplatterPerHit;                              // 0x0AC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1475[0x4];                                     // 0x0ACC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLMeleeAttackDamage>      MeleeDamageType;                                   // 0x0AD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AShooterImpactEffect>       ImpactTemplate;                                    // 0x0AD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterCharacter*                      CurrentTarget;                                     // 0x0AE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHitResult                             ReplicatedHit;                                     // 0x0AE8(0x0088)(Net, IsPlainOldData, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	EReplicatedMeleeAttackState                   ReplicatedMeleeAttackState;                        // 0x0B70(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1476[0x1F];                                    // 0x0B71(0x001F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnMeleeAttackHitNotifyTriggered();
	void OnRep_AttackStateChanged();
	void OnRep_ReplicatedHit();
	void ServerNotifyHit(const struct FHitResult& Hit, class AShooterCharacter* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Melee">();
	}
	static class AShooterWeapon_Melee* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Melee>();
	}
};
static_assert(alignof(AShooterWeapon_Melee) == 0x000010, "Wrong alignment on AShooterWeapon_Melee");
static_assert(sizeof(AShooterWeapon_Melee) == 0x000B90, "Wrong size on AShooterWeapon_Melee");
static_assert(offsetof(AShooterWeapon_Melee, MaxReachDistance) == 0x000AA8, "Member 'AShooterWeapon_Melee::MaxReachDistance' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, SweepSphereRadius) == 0x000AAC, "Member 'AShooterWeapon_Melee::SweepSphereRadius' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, CameraTargetBone) == 0x000AB0, "Member 'AShooterWeapon_Melee::CameraTargetBone' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, CameraTrackingSpeed) == 0x000AB8, "Member 'AShooterWeapon_Melee::CameraTrackingSpeed' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, MeleeAttackDamage) == 0x000ABC, "Member 'AShooterWeapon_Melee::MeleeAttackDamage' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, WeaponBloodPerHit) == 0x000AC0, "Member 'AShooterWeapon_Melee::WeaponBloodPerHit' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, HandsBloodPerHit) == 0x000AC4, "Member 'AShooterWeapon_Melee::HandsBloodPerHit' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, ScreenSplatterPerHit) == 0x000AC8, "Member 'AShooterWeapon_Melee::ScreenSplatterPerHit' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, MeleeDamageType) == 0x000AD0, "Member 'AShooterWeapon_Melee::MeleeDamageType' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, ImpactTemplate) == 0x000AD8, "Member 'AShooterWeapon_Melee::ImpactTemplate' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, CurrentTarget) == 0x000AE0, "Member 'AShooterWeapon_Melee::CurrentTarget' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, ReplicatedHit) == 0x000AE8, "Member 'AShooterWeapon_Melee::ReplicatedHit' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Melee, ReplicatedMeleeAttackState) == 0x000B70, "Member 'AShooterWeapon_Melee::ReplicatedMeleeAttackState' has a wrong offset!");

// Class HLL.HLLUI_RoleSelection_InGame
// 0x0078 (0x03E8 - 0x0370)
class UHLLUI_RoleSelection_InGame : public UHLLUI_CharacterSelection
{
public:
	TSubclassOf<class AHLLCosmeticCharacterRenderer> CharacterRenderer;                                 // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnRoleChangeConfirmed;                             // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1477[0x28];                                    // 0x0388(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	class UButton*                                ConfirmButton;                                     // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ConfirmText;                                       // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                CancelButton;                                      // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CancelText;                                        // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                WaitDialog;                                        // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsForcedRoleChange : 1;                           // 0x03D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1478[0x3];                                     // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class AActor>                  LastViewTarget;                                    // 0x03DC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCreatedViewTarget : 1;                            // 0x03E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1479[0x3];                                     // 0x03E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindOnInputChangedDelegate();
	void K2_BindDeploymentLogicCallbacks();
	void K2_Close();
	void K2_Shown();
	void K2_UnbindDeploymentLogicCallbacks();
	void OnCancelClicked();
	void OnConfirmButtonChanged(const bool bEnabled, const class FText& ButtonText);
	void OnConfirmClicked();
	void OnFailedRoleChange();
	void OnInputChanged();
	void OnInputDeviceChanged(bool NewValue);
	void OnPlayerRoleChange(class AShooterPlayerState* Player, const EPlayerRole PreviousRole, const EPlayerRole NewRole);
	void OnPlayerRoleConfirmed__DelegateSignature(const EPlayerRole ConfirmedRole);
	void OnShown();
	void SetForcedRoleChange(const bool bValue);
	void SetInitialRole();
	void UnBindOnInputChangedDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_RoleSelection_InGame">();
	}
	static class UHLLUI_RoleSelection_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_RoleSelection_InGame>();
	}
};
static_assert(alignof(UHLLUI_RoleSelection_InGame) == 0x000008, "Wrong alignment on UHLLUI_RoleSelection_InGame");
static_assert(sizeof(UHLLUI_RoleSelection_InGame) == 0x0003E8, "Wrong size on UHLLUI_RoleSelection_InGame");
static_assert(offsetof(UHLLUI_RoleSelection_InGame, CharacterRenderer) == 0x000370, "Member 'UHLLUI_RoleSelection_InGame::CharacterRenderer' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleSelection_InGame, OnRoleChangeConfirmed) == 0x000378, "Member 'UHLLUI_RoleSelection_InGame::OnRoleChangeConfirmed' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleSelection_InGame, ConfirmButton) == 0x0003B0, "Member 'UHLLUI_RoleSelection_InGame::ConfirmButton' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleSelection_InGame, ConfirmText) == 0x0003B8, "Member 'UHLLUI_RoleSelection_InGame::ConfirmText' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleSelection_InGame, CancelButton) == 0x0003C0, "Member 'UHLLUI_RoleSelection_InGame::CancelButton' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleSelection_InGame, CancelText) == 0x0003C8, "Member 'UHLLUI_RoleSelection_InGame::CancelText' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleSelection_InGame, WaitDialog) == 0x0003D0, "Member 'UHLLUI_RoleSelection_InGame::WaitDialog' has a wrong offset!");
static_assert(offsetof(UHLLUI_RoleSelection_InGame, LastViewTarget) == 0x0003DC, "Member 'UHLLUI_RoleSelection_InGame::LastViewTarget' has a wrong offset!");

// Class HLL.HLLUI_ServerBrowser
// 0x0258 (0x0488 - 0x0230)
class UHLLUI_ServerBrowser : public UUserWidget
{
public:
	uint8                                         bRefreshQueued : 1;                                // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_147C[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   FavouritesLimitReachedMessage;                     // 0x0238(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ServerOfflineText;                                 // 0x0250(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ResetFiltersMessage;                               // 0x0268(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_147D[0x98];                                    // 0x0280(0x0098)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UHLLUI_ServerBrowserItem>   SearchResultWidget;                                // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLUI_ServerBrowserItem*>       SearchResultWidgets;                               // 0x0320(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedServerIndex;                               // 0x0330(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLSearchQueryType                           CurrentQueryType;                                  // 0x0334(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_147E[0x93];                                    // 0x0335(0x0093)(Fixing Size After Last Property [ Dumper-69 ])
	EHLLUI_ServerSortMode                         CurrentSortMode;                                   // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSortAscendingMode : 1;                            // 0x03C9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_147F[0x6];                                     // 0x03CA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FHLLUI_ServerResult>            SortedResults;                                     // 0x03D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowingPasswordEntry : 1;                         // 0x03E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1480[0x7];                                     // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UServerPasswordEntryWidget*             ActivePasswordEntryWidget;                         // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectedServerRefreshInterval;                     // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1481[0x14];                                    // 0x03F4(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	class UDataTable*                             MapBrowserInfo;                                    // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        ServerListSwitcher;                                // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        ServerDetailsSwitcher;                             // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ServerInfoImage;                                   // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ServerScrollBox;                                   // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        ServerListContentsSwitcher;                        // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MessageText;                                       // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ActivityText;                                      // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             JoinServerText;                                    // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerDetails_MapName;                             // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerDetails_PlayerCount;                         // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerDetails_GameMode;                            // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerDetails_OffensiveModeAttackingFaction;       // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerDetails_Ping;                                // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerDetails_ServerQueueData;                     // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ServerFoundText;                                   // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyFilters(const struct FServerBrowserFilters& Filters);
	void CancelRefreshQueue();
	void ClearFromHistory(const int32 InWidgetIndex);
	void ClearResultsAndSelection();
	void JoinSelectedServer();
	void K2_UpdateQuery();
	void K2_UpdateSorting(const EHLLUI_ServerSortMode NewSortMode, const bool bSortAsc);
	void OnFiltersResetDelegate__DelegateSignature();
	void OnRefreshComplete(bool bWasSuccessful);
	void OnSelectionChanged();
	void OnStreamerModeUpdated();
	void Refresh(const bool bQueueIfBusy, const bool bQueueIfRefreshing);
	void ServerItemPressed();
	bool SetQueryType(const EHLLSearchQueryType QueryType);
	bool SetQueryTypeFromTabIndex(int32 TabIndex);
	void SetSelectedServer(const int32 InWidgetIndex, const bool bForceUpdate);
	void SetSortType(const EHLLUI_ServerSortMode SortType, const bool bSortAscending, const bool bForce);
	void ShowResetFiltersDialogBox(TDelegate<void()> OnFiltersResetCallback);
	void ToggleFavourite(const int32 InWidgetIndex);
	void ToggleSortMode(const EHLLUI_ServerSortMode SortType);
	void UpdateCustomRulesUI(const struct FHLLUI_ServerResult& ServerResult);
	void UpdateFocus();

	bool AreDefaultFiltersApplied() const;
	bool CanJoinServer(const int32 InIndex) const;
	struct FServerBrowserFilters GetCurrentAppliedFilters() const;
	bool GetMapBrowserInfo(const class FString& MapName, struct FHLLUI_ServerBrowserMapInfo* OutInfo) const;
	TArray<class UServerBrowserMapFilterData*> GetMapFilterDatas() const;
	TArray<class UTimeOfDayUiData*> GetTimeOfDayUiDatas() const;
	TArray<class UWeatherUiData*> GetWeatherUiDatas() const;
	bool IsOnlineSysBusy() const;
	int32 NumCompatibleServers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUI_ServerBrowser">();
	}
	static class UHLLUI_ServerBrowser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUI_ServerBrowser>();
	}
};
static_assert(alignof(UHLLUI_ServerBrowser) == 0x000008, "Wrong alignment on UHLLUI_ServerBrowser");
static_assert(sizeof(UHLLUI_ServerBrowser) == 0x000488, "Wrong size on UHLLUI_ServerBrowser");
static_assert(offsetof(UHLLUI_ServerBrowser, FavouritesLimitReachedMessage) == 0x000238, "Member 'UHLLUI_ServerBrowser::FavouritesLimitReachedMessage' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerOfflineText) == 0x000250, "Member 'UHLLUI_ServerBrowser::ServerOfflineText' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ResetFiltersMessage) == 0x000268, "Member 'UHLLUI_ServerBrowser::ResetFiltersMessage' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, SearchResultWidget) == 0x000318, "Member 'UHLLUI_ServerBrowser::SearchResultWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, SearchResultWidgets) == 0x000320, "Member 'UHLLUI_ServerBrowser::SearchResultWidgets' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, SelectedServerIndex) == 0x000330, "Member 'UHLLUI_ServerBrowser::SelectedServerIndex' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, CurrentQueryType) == 0x000334, "Member 'UHLLUI_ServerBrowser::CurrentQueryType' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, CurrentSortMode) == 0x0003C8, "Member 'UHLLUI_ServerBrowser::CurrentSortMode' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, SortedResults) == 0x0003D0, "Member 'UHLLUI_ServerBrowser::SortedResults' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ActivePasswordEntryWidget) == 0x0003E8, "Member 'UHLLUI_ServerBrowser::ActivePasswordEntryWidget' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, SelectedServerRefreshInterval) == 0x0003F0, "Member 'UHLLUI_ServerBrowser::SelectedServerRefreshInterval' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, MapBrowserInfo) == 0x000408, "Member 'UHLLUI_ServerBrowser::MapBrowserInfo' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerListSwitcher) == 0x000410, "Member 'UHLLUI_ServerBrowser::ServerListSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerDetailsSwitcher) == 0x000418, "Member 'UHLLUI_ServerBrowser::ServerDetailsSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerInfoImage) == 0x000420, "Member 'UHLLUI_ServerBrowser::ServerInfoImage' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerScrollBox) == 0x000428, "Member 'UHLLUI_ServerBrowser::ServerScrollBox' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerListContentsSwitcher) == 0x000430, "Member 'UHLLUI_ServerBrowser::ServerListContentsSwitcher' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, MessageText) == 0x000438, "Member 'UHLLUI_ServerBrowser::MessageText' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ActivityText) == 0x000440, "Member 'UHLLUI_ServerBrowser::ActivityText' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, JoinServerText) == 0x000448, "Member 'UHLLUI_ServerBrowser::JoinServerText' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerDetails_MapName) == 0x000450, "Member 'UHLLUI_ServerBrowser::ServerDetails_MapName' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerDetails_PlayerCount) == 0x000458, "Member 'UHLLUI_ServerBrowser::ServerDetails_PlayerCount' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerDetails_GameMode) == 0x000460, "Member 'UHLLUI_ServerBrowser::ServerDetails_GameMode' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerDetails_OffensiveModeAttackingFaction) == 0x000468, "Member 'UHLLUI_ServerBrowser::ServerDetails_OffensiveModeAttackingFaction' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerDetails_Ping) == 0x000470, "Member 'UHLLUI_ServerBrowser::ServerDetails_Ping' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerDetails_ServerQueueData) == 0x000478, "Member 'UHLLUI_ServerBrowser::ServerDetails_ServerQueueData' has a wrong offset!");
static_assert(offsetof(UHLLUI_ServerBrowser, ServerFoundText) == 0x000480, "Member 'UHLLUI_ServerBrowser::ServerFoundText' has a wrong offset!");

// Class HLL.HLLUpgradeGhostComponent
// 0x00F0 (0x01A0 - 0x00B0)
class UHLLUpgradeGhostComponent final : public UActorComponent
{
public:
	uint8                                         bHideGhostFromEnemies : 1;                         // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCreateGhostBlocker : 1;                           // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1486[0xF];                                     // 0x00B1(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	struct FTransform                             BoxTransform;                                      // 0x00C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                BoxExtent;                                         // 0x00F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  GhostBoxProfile;                                   // 0x00FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         LeaveGhostTier;                                    // 0x0104(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1487[0x3];                                     // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FCollisionProfileName                  GhostProfile;                                      // 0x0108(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     GhostMaterial;                                     // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleLifespan;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1488[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class UPrimitiveComponent*, struct FGhostComponentDefaults> ModifiedComponents;                                // 0x0120(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBoxComponent>           GhostBlockerBox;                                   // 0x0170(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGhostComponent>                GhostComponents;                                   // 0x0178(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               GhostDMI;                                          // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGhostState                                   GhostState;                                        // 0x0190(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1489[0xF];                                     // 0x0191(0x000F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddGhostComponent(class UPrimitiveComponent* InPrimitive, const bool bForceBlocker);
	void CheckTeamVisibility();
	void OnRep_GhostState();
	void ResetIdleTimer();

	bool IsInGhostState() const;
	bool IsUpgradeBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUpgradeGhostComponent">();
	}
	static class UHLLUpgradeGhostComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUpgradeGhostComponent>();
	}
};
static_assert(alignof(UHLLUpgradeGhostComponent) == 0x000010, "Wrong alignment on UHLLUpgradeGhostComponent");
static_assert(sizeof(UHLLUpgradeGhostComponent) == 0x0001A0, "Wrong size on UHLLUpgradeGhostComponent");
static_assert(offsetof(UHLLUpgradeGhostComponent, BoxTransform) == 0x0000C0, "Member 'UHLLUpgradeGhostComponent::BoxTransform' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, BoxExtent) == 0x0000F0, "Member 'UHLLUpgradeGhostComponent::BoxExtent' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, GhostBoxProfile) == 0x0000FC, "Member 'UHLLUpgradeGhostComponent::GhostBoxProfile' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, LeaveGhostTier) == 0x000104, "Member 'UHLLUpgradeGhostComponent::LeaveGhostTier' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, GhostProfile) == 0x000108, "Member 'UHLLUpgradeGhostComponent::GhostProfile' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, GhostMaterial) == 0x000110, "Member 'UHLLUpgradeGhostComponent::GhostMaterial' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, IdleLifespan) == 0x000118, "Member 'UHLLUpgradeGhostComponent::IdleLifespan' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, ModifiedComponents) == 0x000120, "Member 'UHLLUpgradeGhostComponent::ModifiedComponents' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, GhostBlockerBox) == 0x000170, "Member 'UHLLUpgradeGhostComponent::GhostBlockerBox' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, GhostComponents) == 0x000178, "Member 'UHLLUpgradeGhostComponent::GhostComponents' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, GhostDMI) == 0x000188, "Member 'UHLLUpgradeGhostComponent::GhostDMI' has a wrong offset!");
static_assert(offsetof(UHLLUpgradeGhostComponent, GhostState) == 0x000190, "Member 'UHLLUpgradeGhostComponent::GhostState' has a wrong offset!");

// Class HLL.HLLUpgradeInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLUpgradeInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUpgradeInterface">();
	}
	static class IHLLUpgradeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLUpgradeInterface>();
	}
};
static_assert(alignof(IHLLUpgradeInterface) == 0x000008, "Wrong alignment on IHLLUpgradeInterface");
static_assert(sizeof(IHLLUpgradeInterface) == 0x000028, "Wrong size on IHLLUpgradeInterface");

// Class HLL.VoipTokenGenerationSubsystem
// 0x0068 (0x0098 - 0x0030)
class UVoipTokenGenerationSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_148B[0x68];                                    // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipTokenGenerationSubsystem">();
	}
	static class UVoipTokenGenerationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipTokenGenerationSubsystem>();
	}
};
static_assert(alignof(UVoipTokenGenerationSubsystem) == 0x000008, "Wrong alignment on UVoipTokenGenerationSubsystem");
static_assert(sizeof(UVoipTokenGenerationSubsystem) == 0x000098, "Wrong size on UVoipTokenGenerationSubsystem");

// Class HLL.HLLUpgrade_ATGun
// 0x0000 (0x0150 - 0x0150)
class UHLLUpgrade_ATGun final : public UHLLUpgradeData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUpgrade_ATGun">();
	}
	static class UHLLUpgrade_ATGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUpgrade_ATGun>();
	}
};
static_assert(alignof(UHLLUpgrade_ATGun) == 0x000010, "Wrong alignment on UHLLUpgrade_ATGun");
static_assert(sizeof(UHLLUpgrade_ATGun) == 0x000150, "Wrong size on UHLLUpgrade_ATGun");

// Class HLL.HLLUseContextBase
// 0x0008 (0x0238 - 0x0230)
class UHLLUseContextBase : public UUserWidget
{
public:
	uint8                                         bOverrideOffset : 1;                               // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_148C[0x3];                                     // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         OverrideOffset;                                    // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContextBase">();
	}
	static class UHLLUseContextBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContextBase>();
	}
};
static_assert(alignof(UHLLUseContextBase) == 0x000008, "Wrong alignment on UHLLUseContextBase");
static_assert(sizeof(UHLLUseContextBase) == 0x000238, "Wrong size on UHLLUseContextBase");
static_assert(offsetof(UHLLUseContextBase, OverrideOffset) == 0x000234, "Member 'UHLLUseContextBase::OverrideOffset' has a wrong offset!");

// Class HLL.HLLUseContextContainer
// 0x0070 (0x02A0 - 0x0230)
class UHLLUseContextContainer : public UUserWidget
{
public:
	TMap<EHLLUseContextType, TSubclassOf<class UHLLUseContextBase>> ContextWidgetClasses;                              // 0x0230(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         BaseViewportYOffset;                               // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLUseContextType                            CurrentActiveContext;                              // 0x0284(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148D[0x3];                                     // 0x0285(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UBorder*                                RootBorder;                                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLUseContextBase*>             ActiveContextWidgets;                              // 0x0290(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContextContainer">();
	}
	static class UHLLUseContextContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContextContainer>();
	}
};
static_assert(alignof(UHLLUseContextContainer) == 0x000008, "Wrong alignment on UHLLUseContextContainer");
static_assert(sizeof(UHLLUseContextContainer) == 0x0002A0, "Wrong size on UHLLUseContextContainer");
static_assert(offsetof(UHLLUseContextContainer, ContextWidgetClasses) == 0x000230, "Member 'UHLLUseContextContainer::ContextWidgetClasses' has a wrong offset!");
static_assert(offsetof(UHLLUseContextContainer, BaseViewportYOffset) == 0x000280, "Member 'UHLLUseContextContainer::BaseViewportYOffset' has a wrong offset!");
static_assert(offsetof(UHLLUseContextContainer, CurrentActiveContext) == 0x000284, "Member 'UHLLUseContextContainer::CurrentActiveContext' has a wrong offset!");
static_assert(offsetof(UHLLUseContextContainer, RootBorder) == 0x000288, "Member 'UHLLUseContextContainer::RootBorder' has a wrong offset!");
static_assert(offsetof(UHLLUseContextContainer, ActiveContextWidgets) == 0x000290, "Member 'UHLLUseContextContainer::ActiveContextWidgets' has a wrong offset!");

// Class HLL.HLLUseContext_Bandage
// 0x0128 (0x0360 - 0x0238)
class UHLLUseContext_Bandage : public UHLLUseContextBase
{
public:
	struct FSlateBrush                            CanBandageIcon;                                    // 0x0238(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CantBandageIcon;                                   // 0x02C0(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 RadialProg;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DisplayText;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_Bandage">();
	}
	static class UHLLUseContext_Bandage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_Bandage>();
	}
};
static_assert(alignof(UHLLUseContext_Bandage) == 0x000008, "Wrong alignment on UHLLUseContext_Bandage");
static_assert(sizeof(UHLLUseContext_Bandage) == 0x000360, "Wrong size on UHLLUseContext_Bandage");
static_assert(offsetof(UHLLUseContext_Bandage, CanBandageIcon) == 0x000238, "Member 'UHLLUseContext_Bandage::CanBandageIcon' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Bandage, CantBandageIcon) == 0x0002C0, "Member 'UHLLUseContext_Bandage::CantBandageIcon' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Bandage, RadialProg) == 0x000348, "Member 'UHLLUseContext_Bandage::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Bandage, IconImage) == 0x000350, "Member 'UHLLUseContext_Bandage::IconImage' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Bandage, DisplayText) == 0x000358, "Member 'UHLLUseContext_Bandage::DisplayText' has a wrong offset!");

// Class HLL.HLLUseContext_DismantleItem
// 0x0010 (0x0248 - 0x0238)
class UHLLUseContext_DismantleItem : public UHLLUseContextBase
{
public:
	class UImage*                                 RadialProg;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DismantleText;                                     // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_DismantleItem">();
	}
	static class UHLLUseContext_DismantleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_DismantleItem>();
	}
};
static_assert(alignof(UHLLUseContext_DismantleItem) == 0x000008, "Wrong alignment on UHLLUseContext_DismantleItem");
static_assert(sizeof(UHLLUseContext_DismantleItem) == 0x000248, "Wrong size on UHLLUseContext_DismantleItem");
static_assert(offsetof(UHLLUseContext_DismantleItem, RadialProg) == 0x000238, "Member 'UHLLUseContext_DismantleItem::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_DismantleItem, DismantleText) == 0x000240, "Member 'UHLLUseContext_DismantleItem::DismantleText' has a wrong offset!");

// Class HLL.HLLUseContext_Dispenser
// 0x0088 (0x02C0 - 0x0238)
class UHLLUseContext_Dispenser : public UHLLUseContextBase
{
public:
	uint8                                         Pad_148E[0x4];                                     // 0x0238(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FLinearColor                           CantDropTint;                                      // 0x023C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148F[0x4];                                     // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UVerticalBox*                           ItemList;                                          // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHLLDispenserListItem*>          ItemWidgets;                                       // 0x0258(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AShooterWeapon_Dispenser> CurrentListWeapon;                                 // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           RootVBox;                                          // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialProg;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DisplayText;                                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         SelectText;                                        // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         RotateHBox;                                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RotateLText;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RotateRText;                                       // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                SnapsContainer;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         SnapText;                                          // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_Dispenser">();
	}
	static class UHLLUseContext_Dispenser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_Dispenser>();
	}
};
static_assert(alignof(UHLLUseContext_Dispenser) == 0x000008, "Wrong alignment on UHLLUseContext_Dispenser");
static_assert(sizeof(UHLLUseContext_Dispenser) == 0x0002C0, "Wrong size on UHLLUseContext_Dispenser");
static_assert(offsetof(UHLLUseContext_Dispenser, CantDropTint) == 0x00023C, "Member 'UHLLUseContext_Dispenser::CantDropTint' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, ItemList) == 0x000250, "Member 'UHLLUseContext_Dispenser::ItemList' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, ItemWidgets) == 0x000258, "Member 'UHLLUseContext_Dispenser::ItemWidgets' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, CurrentListWeapon) == 0x000268, "Member 'UHLLUseContext_Dispenser::CurrentListWeapon' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, RootVBox) == 0x000270, "Member 'UHLLUseContext_Dispenser::RootVBox' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, RadialProg) == 0x000278, "Member 'UHLLUseContext_Dispenser::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, IconImage) == 0x000280, "Member 'UHLLUseContext_Dispenser::IconImage' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, DisplayText) == 0x000288, "Member 'UHLLUseContext_Dispenser::DisplayText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, SelectText) == 0x000290, "Member 'UHLLUseContext_Dispenser::SelectText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, RotateHBox) == 0x000298, "Member 'UHLLUseContext_Dispenser::RotateHBox' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, RotateLText) == 0x0002A0, "Member 'UHLLUseContext_Dispenser::RotateLText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, RotateRText) == 0x0002A8, "Member 'UHLLUseContext_Dispenser::RotateRText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, SnapsContainer) == 0x0002B0, "Member 'UHLLUseContext_Dispenser::SnapsContainer' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Dispenser, SnapText) == 0x0002B8, "Member 'UHLLUseContext_Dispenser::SnapText' has a wrong offset!");

// Class HLL.HLLDispenserListItem
// 0x0020 (0x0250 - 0x0230)
class UHLLDispenserListItem : public UUserWidget
{
public:
	class UBorder*                                RootBorder;                                        // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemIcon;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemLimits;                                        // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserListItem">();
	}
	static class UHLLDispenserListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDispenserListItem>();
	}
};
static_assert(alignof(UHLLDispenserListItem) == 0x000008, "Wrong alignment on UHLLDispenserListItem");
static_assert(sizeof(UHLLDispenserListItem) == 0x000250, "Wrong size on UHLLDispenserListItem");
static_assert(offsetof(UHLLDispenserListItem, RootBorder) == 0x000230, "Member 'UHLLDispenserListItem::RootBorder' has a wrong offset!");
static_assert(offsetof(UHLLDispenserListItem, ItemIcon) == 0x000238, "Member 'UHLLDispenserListItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(UHLLDispenserListItem, ItemName) == 0x000240, "Member 'UHLLDispenserListItem::ItemName' has a wrong offset!");
static_assert(offsetof(UHLLDispenserListItem, ItemLimits) == 0x000248, "Member 'UHLLDispenserListItem::ItemLimits' has a wrong offset!");

// Class HLL.HLLDispenserListItem_StructureBase
// 0x0008 (0x0258 - 0x0250)
class UHLLDispenserListItem_StructureBase : public UHLLDispenserListItem
{
public:
	class UTextBlock*                             ItemCost;                                          // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserListItem_StructureBase">();
	}
	static class UHLLDispenserListItem_StructureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDispenserListItem_StructureBase>();
	}
};
static_assert(alignof(UHLLDispenserListItem_StructureBase) == 0x000008, "Wrong alignment on UHLLDispenserListItem_StructureBase");
static_assert(sizeof(UHLLDispenserListItem_StructureBase) == 0x000258, "Wrong size on UHLLDispenserListItem_StructureBase");
static_assert(offsetof(UHLLDispenserListItem_StructureBase, ItemCost) == 0x000250, "Member 'UHLLDispenserListItem_StructureBase::ItemCost' has a wrong offset!");

// Class HLL.HLLDispenserListItem_Outpost
// 0x0008 (0x0260 - 0x0258)
class UHLLDispenserListItem_Outpost final : public UHLLDispenserListItem_StructureBase
{
public:
	class UTextBlock*                             PlatoonLimitText;                                  // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserListItem_Outpost">();
	}
	static class UHLLDispenserListItem_Outpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDispenserListItem_Outpost>();
	}
};
static_assert(alignof(UHLLDispenserListItem_Outpost) == 0x000008, "Wrong alignment on UHLLDispenserListItem_Outpost");
static_assert(sizeof(UHLLDispenserListItem_Outpost) == 0x000260, "Wrong size on UHLLDispenserListItem_Outpost");
static_assert(offsetof(UHLLDispenserListItem_Outpost, PlatoonLimitText) == 0x000258, "Member 'UHLLDispenserListItem_Outpost::PlatoonLimitText' has a wrong offset!");

// Class HLL.HLLDispenserListItem_Garrison
// 0x0008 (0x0260 - 0x0258)
class UHLLDispenserListItem_Garrison : public UHLLDispenserListItem_StructureBase
{
public:
	class UTextBlock*                             TeamLimitText;                                     // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserListItem_Garrison">();
	}
	static class UHLLDispenserListItem_Garrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDispenserListItem_Garrison>();
	}
};
static_assert(alignof(UHLLDispenserListItem_Garrison) == 0x000008, "Wrong alignment on UHLLDispenserListItem_Garrison");
static_assert(sizeof(UHLLDispenserListItem_Garrison) == 0x000260, "Wrong size on UHLLDispenserListItem_Garrison");
static_assert(offsetof(UHLLDispenserListItem_Garrison, TeamLimitText) == 0x000258, "Member 'UHLLDispenserListItem_Garrison::TeamLimitText' has a wrong offset!");

// Class HLL.HLLDispenserListItem_Satchel
// 0x0008 (0x0258 - 0x0250)
class UHLLDispenserListItem_Satchel : public UHLLDispenserListItem
{
public:
	class UTextBlock*                             TimeText;                                          // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDispenserListItem_Satchel">();
	}
	static class UHLLDispenserListItem_Satchel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDispenserListItem_Satchel>();
	}
};
static_assert(alignof(UHLLDispenserListItem_Satchel) == 0x000008, "Wrong alignment on UHLLDispenserListItem_Satchel");
static_assert(sizeof(UHLLDispenserListItem_Satchel) == 0x000258, "Wrong size on UHLLDispenserListItem_Satchel");
static_assert(offsetof(UHLLDispenserListItem_Satchel, TimeText) == 0x000250, "Member 'UHLLDispenserListItem_Satchel::TimeText' has a wrong offset!");

// Class HLL.RCONServerinfoVipPlayers
// 0x0000 (0x0028 - 0x0028)
class URCONServerinfoVipPlayers final : public URCONServerInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerinfoVipPlayers">();
	}
	static class URCONServerinfoVipPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerinfoVipPlayers>();
	}
};
static_assert(alignof(URCONServerinfoVipPlayers) == 0x000008, "Wrong alignment on URCONServerinfoVipPlayers");
static_assert(sizeof(URCONServerinfoVipPlayers) == 0x000028, "Wrong size on URCONServerinfoVipPlayers");

// Class HLL.HLLUseContext_EnterSeat
// 0x0018 (0x0250 - 0x0238)
class UHLLUseContext_EnterSeat : public UHLLUseContextBase
{
public:
	class UImage*                                 IconImage;                                         // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialProg;                                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DisplayText;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_EnterSeat">();
	}
	static class UHLLUseContext_EnterSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_EnterSeat>();
	}
};
static_assert(alignof(UHLLUseContext_EnterSeat) == 0x000008, "Wrong alignment on UHLLUseContext_EnterSeat");
static_assert(sizeof(UHLLUseContext_EnterSeat) == 0x000250, "Wrong size on UHLLUseContext_EnterSeat");
static_assert(offsetof(UHLLUseContext_EnterSeat, IconImage) == 0x000238, "Member 'UHLLUseContext_EnterSeat::IconImage' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_EnterSeat, RadialProg) == 0x000240, "Member 'UHLLUseContext_EnterSeat::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_EnterSeat, DisplayText) == 0x000248, "Member 'UHLLUseContext_EnterSeat::DisplayText' has a wrong offset!");

// Class HLL.TurretControllerComponent2
// 0x0058 (0x0500 - 0x04A8)
class UTurretControllerComponent2 final : public UPitchYawControllerComponent
{
public:
	class FName                                   TurretBoneName;                                    // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BarrelBoneName;                                    // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTurretRotationScale;                            // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1490[0xC];                                     // 0x04BC(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	class ATankGunnerSeat*                        GunnerSeat;                                        // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        YawAudio;                                          // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PitchAudio;                                        // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterMovementBarrierTurret;                    // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CharacterMovementBarrierBarrel;                    // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              YawVibrationController;                            // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              PitchVibrationController;                          // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurretControllerComponent2">();
	}
	static class UTurretControllerComponent2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurretControllerComponent2>();
	}
};
static_assert(alignof(UTurretControllerComponent2) == 0x000008, "Wrong alignment on UTurretControllerComponent2");
static_assert(sizeof(UTurretControllerComponent2) == 0x000500, "Wrong size on UTurretControllerComponent2");
static_assert(offsetof(UTurretControllerComponent2, TurretBoneName) == 0x0004A8, "Member 'UTurretControllerComponent2::TurretBoneName' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, BarrelBoneName) == 0x0004B0, "Member 'UTurretControllerComponent2::BarrelBoneName' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, MinTurretRotationScale) == 0x0004B8, "Member 'UTurretControllerComponent2::MinTurretRotationScale' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, GunnerSeat) == 0x0004C8, "Member 'UTurretControllerComponent2::GunnerSeat' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, YawAudio) == 0x0004D0, "Member 'UTurretControllerComponent2::YawAudio' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, PitchAudio) == 0x0004D8, "Member 'UTurretControllerComponent2::PitchAudio' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, CharacterMovementBarrierTurret) == 0x0004E0, "Member 'UTurretControllerComponent2::CharacterMovementBarrierTurret' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, CharacterMovementBarrierBarrel) == 0x0004E8, "Member 'UTurretControllerComponent2::CharacterMovementBarrierBarrel' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, YawVibrationController) == 0x0004F0, "Member 'UTurretControllerComponent2::YawVibrationController' has a wrong offset!");
static_assert(offsetof(UTurretControllerComponent2, PitchVibrationController) == 0x0004F8, "Member 'UTurretControllerComponent2::PitchVibrationController' has a wrong offset!");

// Class HLL.HLLUseContext_HealWeapon
// 0x0018 (0x0250 - 0x0238)
class UHLLUseContext_HealWeapon : public UHLLUseContextBase
{
public:
	class URichTextBlock*                         HealText;                                          // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialProg;                                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_HealWeapon">();
	}
	static class UHLLUseContext_HealWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_HealWeapon>();
	}
};
static_assert(alignof(UHLLUseContext_HealWeapon) == 0x000008, "Wrong alignment on UHLLUseContext_HealWeapon");
static_assert(sizeof(UHLLUseContext_HealWeapon) == 0x000250, "Wrong size on UHLLUseContext_HealWeapon");
static_assert(offsetof(UHLLUseContext_HealWeapon, HealText) == 0x000238, "Member 'UHLLUseContext_HealWeapon::HealText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_HealWeapon, RadialProg) == 0x000240, "Member 'UHLLUseContext_HealWeapon::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_HealWeapon, IconImage) == 0x000248, "Member 'UHLLUseContext_HealWeapon::IconImage' has a wrong offset!");

// Class HLL.HLLUseContext_LetGo
// 0x0070 (0x02A8 - 0x0238)
class UHLLUseContext_LetGo : public UHLLUseContextBase
{
public:
	class UTimelineComponent*                     AlphaFadeTimeline;                                 // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MedicFadeCurve;                                    // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1491[0x10];                                    // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetAnimation*                       PulseAnimation;                                    // 0x0258(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         HealText;                                          // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialProg;                                        // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RequestMedicText;                                  // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         MedicOnRouteText;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         MedicNameOnRouteText;                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         MedicCantMakeItText;                               // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         MedicNameCantMakeItText;                           // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1492[0x10];                                    // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_LetGo">();
	}
	static class UHLLUseContext_LetGo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_LetGo>();
	}
};
static_assert(alignof(UHLLUseContext_LetGo) == 0x000008, "Wrong alignment on UHLLUseContext_LetGo");
static_assert(sizeof(UHLLUseContext_LetGo) == 0x0002A8, "Wrong size on UHLLUseContext_LetGo");
static_assert(offsetof(UHLLUseContext_LetGo, AlphaFadeTimeline) == 0x000238, "Member 'UHLLUseContext_LetGo::AlphaFadeTimeline' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, MedicFadeCurve) == 0x000240, "Member 'UHLLUseContext_LetGo::MedicFadeCurve' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, PulseAnimation) == 0x000258, "Member 'UHLLUseContext_LetGo::PulseAnimation' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, HealText) == 0x000260, "Member 'UHLLUseContext_LetGo::HealText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, RadialProg) == 0x000268, "Member 'UHLLUseContext_LetGo::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, RequestMedicText) == 0x000270, "Member 'UHLLUseContext_LetGo::RequestMedicText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, MedicOnRouteText) == 0x000278, "Member 'UHLLUseContext_LetGo::MedicOnRouteText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, MedicNameOnRouteText) == 0x000280, "Member 'UHLLUseContext_LetGo::MedicNameOnRouteText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, MedicCantMakeItText) == 0x000288, "Member 'UHLLUseContext_LetGo::MedicCantMakeItText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_LetGo, MedicNameCantMakeItText) == 0x000290, "Member 'UHLLUseContext_LetGo::MedicNameCantMakeItText' has a wrong offset!");

// Class HLL.HLLUseContext_MountWeapon
// 0x0008 (0x0240 - 0x0238)
class UHLLUseContext_MountWeapon : public UHLLUseContextBase
{
public:
	class URichTextBlock*                         UseText;                                           // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_MountWeapon">();
	}
	static class UHLLUseContext_MountWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_MountWeapon>();
	}
};
static_assert(alignof(UHLLUseContext_MountWeapon) == 0x000008, "Wrong alignment on UHLLUseContext_MountWeapon");
static_assert(sizeof(UHLLUseContext_MountWeapon) == 0x000240, "Wrong size on UHLLUseContext_MountWeapon");
static_assert(offsetof(UHLLUseContext_MountWeapon, UseText) == 0x000238, "Member 'UHLLUseContext_MountWeapon::UseText' has a wrong offset!");

// Class HLL.HLLUseContext_PlantBombObjective
// 0x0040 (0x0278 - 0x0238)
class UHLLUseContext_PlantBombObjective : public UHLLUseContextBase
{
public:
	class UImage*                                 RadialProg;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DisplayText;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1493[0x28];                                    // 0x0250(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_PlantBombObjective">();
	}
	static class UHLLUseContext_PlantBombObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_PlantBombObjective>();
	}
};
static_assert(alignof(UHLLUseContext_PlantBombObjective) == 0x000008, "Wrong alignment on UHLLUseContext_PlantBombObjective");
static_assert(sizeof(UHLLUseContext_PlantBombObjective) == 0x000278, "Wrong size on UHLLUseContext_PlantBombObjective");
static_assert(offsetof(UHLLUseContext_PlantBombObjective, RadialProg) == 0x000238, "Member 'UHLLUseContext_PlantBombObjective::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_PlantBombObjective, IconImage) == 0x000240, "Member 'UHLLUseContext_PlantBombObjective::IconImage' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_PlantBombObjective, DisplayText) == 0x000248, "Member 'UHLLUseContext_PlantBombObjective::DisplayText' has a wrong offset!");

// Class HLL.HLLUseContext_Repair
// 0x0018 (0x0250 - 0x0238)
class UHLLUseContext_Repair : public UHLLUseContextBase
{
public:
	class UImage*                                 RadialProg;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RepairText;                                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSeatHealthStatus*                   HealthStatusPanel;                                 // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_Repair">();
	}
	static class UHLLUseContext_Repair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_Repair>();
	}
};
static_assert(alignof(UHLLUseContext_Repair) == 0x000008, "Wrong alignment on UHLLUseContext_Repair");
static_assert(sizeof(UHLLUseContext_Repair) == 0x000250, "Wrong size on UHLLUseContext_Repair");
static_assert(offsetof(UHLLUseContext_Repair, RadialProg) == 0x000238, "Member 'UHLLUseContext_Repair::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Repair, RepairText) == 0x000240, "Member 'UHLLUseContext_Repair::RepairText' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Repair, HealthStatusPanel) == 0x000248, "Member 'UHLLUseContext_Repair::HealthStatusPanel' has a wrong offset!");

// Class HLL.HLLUseContext_Supplies
// 0x0128 (0x0360 - 0x0238)
class UHLLUseContext_Supplies : public UHLLUseContextBase
{
public:
	struct FSlateBrush                            CanUseIcon;                                        // 0x0238(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CantUseIcon;                                       // 0x02C0(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 RadialProg;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DisplayText;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_Supplies">();
	}
	static class UHLLUseContext_Supplies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_Supplies>();
	}
};
static_assert(alignof(UHLLUseContext_Supplies) == 0x000008, "Wrong alignment on UHLLUseContext_Supplies");
static_assert(sizeof(UHLLUseContext_Supplies) == 0x000360, "Wrong size on UHLLUseContext_Supplies");
static_assert(offsetof(UHLLUseContext_Supplies, CanUseIcon) == 0x000238, "Member 'UHLLUseContext_Supplies::CanUseIcon' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Supplies, CantUseIcon) == 0x0002C0, "Member 'UHLLUseContext_Supplies::CantUseIcon' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Supplies, RadialProg) == 0x000348, "Member 'UHLLUseContext_Supplies::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Supplies, IconImage) == 0x000350, "Member 'UHLLUseContext_Supplies::IconImage' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Supplies, DisplayText) == 0x000358, "Member 'UHLLUseContext_Supplies::DisplayText' has a wrong offset!");

// Class HLL.HLLUseContext_SwitchOrExitSeat
// 0x0018 (0x0250 - 0x0238)
class UHLLUseContext_SwitchOrExitSeat : public UHLLUseContextBase
{
public:
	class UImage*                                 SwitchProgress;                                    // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         SwitchText;                                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1494[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_SwitchOrExitSeat">();
	}
	static class UHLLUseContext_SwitchOrExitSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_SwitchOrExitSeat>();
	}
};
static_assert(alignof(UHLLUseContext_SwitchOrExitSeat) == 0x000008, "Wrong alignment on UHLLUseContext_SwitchOrExitSeat");
static_assert(sizeof(UHLLUseContext_SwitchOrExitSeat) == 0x000250, "Wrong size on UHLLUseContext_SwitchOrExitSeat");
static_assert(offsetof(UHLLUseContext_SwitchOrExitSeat, SwitchProgress) == 0x000238, "Member 'UHLLUseContext_SwitchOrExitSeat::SwitchProgress' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_SwitchOrExitSeat, SwitchText) == 0x000240, "Member 'UHLLUseContext_SwitchOrExitSeat::SwitchText' has a wrong offset!");

// Class HLL.ReconVehicleCommanderSeat
// 0x0000 (0x09F0 - 0x09F0)
class AReconVehicleCommanderSeat final : public ATankCommanderSeat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReconVehicleCommanderSeat">();
	}
	static class AReconVehicleCommanderSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReconVehicleCommanderSeat>();
	}
};
static_assert(alignof(AReconVehicleCommanderSeat) == 0x000010, "Wrong alignment on AReconVehicleCommanderSeat");
static_assert(sizeof(AReconVehicleCommanderSeat) == 0x0009F0, "Wrong size on AReconVehicleCommanderSeat");

// Class HLL.HLLUseContext_Upgrade
// 0x0020 (0x0258 - 0x0238)
class UHLLUseContext_Upgrade : public UHLLUseContextBase
{
public:
	class UWidget*                                RootWidget;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialProg;                                        // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DisplayText;                                       // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_Upgrade">();
	}
	static class UHLLUseContext_Upgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_Upgrade>();
	}
};
static_assert(alignof(UHLLUseContext_Upgrade) == 0x000008, "Wrong alignment on UHLLUseContext_Upgrade");
static_assert(sizeof(UHLLUseContext_Upgrade) == 0x000258, "Wrong size on UHLLUseContext_Upgrade");
static_assert(offsetof(UHLLUseContext_Upgrade, RootWidget) == 0x000238, "Member 'UHLLUseContext_Upgrade::RootWidget' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Upgrade, IconImage) == 0x000240, "Member 'UHLLUseContext_Upgrade::IconImage' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Upgrade, RadialProg) == 0x000248, "Member 'UHLLUseContext_Upgrade::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_Upgrade, DisplayText) == 0x000250, "Member 'UHLLUseContext_Upgrade::DisplayText' has a wrong offset!");

// Class HLL.VaultingTestMovement
// 0x0000 (0x0730 - 0x0730)
class UVaultingTestMovement final : public UShooterCharacterMovement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultingTestMovement">();
	}
	static class UVaultingTestMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultingTestMovement>();
	}
};
static_assert(alignof(UVaultingTestMovement) == 0x000010, "Wrong alignment on UVaultingTestMovement");
static_assert(sizeof(UVaultingTestMovement) == 0x000730, "Wrong size on UVaultingTestMovement");

// Class HLL.HLLUseContext_WeaponBox
// 0x0040 (0x0278 - 0x0238)
class UHLLUseContext_WeaponBox : public UHLLUseContextBase
{
public:
	class UImage*                                 RadialProg;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DisplayText;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1495[0x28];                                    // 0x0250(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLUseContext_WeaponBox">();
	}
	static class UHLLUseContext_WeaponBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLUseContext_WeaponBox>();
	}
};
static_assert(alignof(UHLLUseContext_WeaponBox) == 0x000008, "Wrong alignment on UHLLUseContext_WeaponBox");
static_assert(sizeof(UHLLUseContext_WeaponBox) == 0x000278, "Wrong size on UHLLUseContext_WeaponBox");
static_assert(offsetof(UHLLUseContext_WeaponBox, RadialProg) == 0x000238, "Member 'UHLLUseContext_WeaponBox::RadialProg' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_WeaponBox, IconImage) == 0x000240, "Member 'UHLLUseContext_WeaponBox::IconImage' has a wrong offset!");
static_assert(offsetof(UHLLUseContext_WeaponBox, DisplayText) == 0x000248, "Member 'UHLLUseContext_WeaponBox::DisplayText' has a wrong offset!");

// Class HLL.HLLVehicleDamageFX
// 0x0110 (0x0140 - 0x0030)
class UHLLVehicleDamageFX final : public UDataAsset
{
public:
	TMap<class FName, struct FHLLArmourDamageFX>  DamageEffects;                                     // 0x0030(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FArmourDepletedSound                   DepletedSounds[0x4];                               // 0x0080(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleDamageFX">();
	}
	static class UHLLVehicleDamageFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVehicleDamageFX>();
	}
};
static_assert(alignof(UHLLVehicleDamageFX) == 0x000008, "Wrong alignment on UHLLVehicleDamageFX");
static_assert(sizeof(UHLLVehicleDamageFX) == 0x000140, "Wrong size on UHLLVehicleDamageFX");
static_assert(offsetof(UHLLVehicleDamageFX, DamageEffects) == 0x000030, "Member 'UHLLVehicleDamageFX::DamageEffects' has a wrong offset!");
static_assert(offsetof(UHLLVehicleDamageFX, DepletedSounds) == 0x000080, "Member 'UHLLVehicleDamageFX::DepletedSounds' has a wrong offset!");

// Class HLL.HLLDialCommon
// 0x0028 (0x0258 - 0x0230)
class UHLLDialCommon : public UUserWidget
{
public:
	struct FVector2D                              MinMaxInput;                                       // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinMaxAngle;                                       // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDialValue;                                   // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentDialValue;                                  // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DialInterpSpeed;                                   // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1496[0x4];                                     // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 Needle;                                            // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDialValue(const float InValue, const bool bInstant);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDialCommon">();
	}
	static class UHLLDialCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDialCommon>();
	}
};
static_assert(alignof(UHLLDialCommon) == 0x000008, "Wrong alignment on UHLLDialCommon");
static_assert(sizeof(UHLLDialCommon) == 0x000258, "Wrong size on UHLLDialCommon");
static_assert(offsetof(UHLLDialCommon, MinMaxInput) == 0x000230, "Member 'UHLLDialCommon::MinMaxInput' has a wrong offset!");
static_assert(offsetof(UHLLDialCommon, MinMaxAngle) == 0x000238, "Member 'UHLLDialCommon::MinMaxAngle' has a wrong offset!");
static_assert(offsetof(UHLLDialCommon, TargetDialValue) == 0x000240, "Member 'UHLLDialCommon::TargetDialValue' has a wrong offset!");
static_assert(offsetof(UHLLDialCommon, CurrentDialValue) == 0x000244, "Member 'UHLLDialCommon::CurrentDialValue' has a wrong offset!");
static_assert(offsetof(UHLLDialCommon, DialInterpSpeed) == 0x000248, "Member 'UHLLDialCommon::DialInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHLLDialCommon, Needle) == 0x000250, "Member 'UHLLDialCommon::Needle' has a wrong offset!");

// Class HLL.HLLDial_Speedometer
// 0x0010 (0x0268 - 0x0258)
class UHLLDial_Speedometer final : public UHLLDialCommon
{
public:
	class UTextBlock*                             DigitL;                                            // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DigitR;                                            // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDial_Speedometer">();
	}
	static class UHLLDial_Speedometer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDial_Speedometer>();
	}
};
static_assert(alignof(UHLLDial_Speedometer) == 0x000008, "Wrong alignment on UHLLDial_Speedometer");
static_assert(sizeof(UHLLDial_Speedometer) == 0x000268, "Wrong size on UHLLDial_Speedometer");
static_assert(offsetof(UHLLDial_Speedometer, DigitL) == 0x000258, "Member 'UHLLDial_Speedometer::DigitL' has a wrong offset!");
static_assert(offsetof(UHLLDial_Speedometer, DigitR) == 0x000260, "Member 'UHLLDial_Speedometer::DigitR' has a wrong offset!");

// Class HLL.HLLDial_Tachometer
// 0x0008 (0x0260 - 0x0258)
class UHLLDial_Tachometer final : public UHLLDialCommon
{
public:
	class UTextBlock*                             GearText;                                          // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetGear(const class FText& InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDial_Tachometer">();
	}
	static class UHLLDial_Tachometer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDial_Tachometer>();
	}
};
static_assert(alignof(UHLLDial_Tachometer) == 0x000008, "Wrong alignment on UHLLDial_Tachometer");
static_assert(sizeof(UHLLDial_Tachometer) == 0x000260, "Wrong size on UHLLDial_Tachometer");
static_assert(offsetof(UHLLDial_Tachometer, GearText) == 0x000258, "Member 'UHLLDial_Tachometer::GearText' has a wrong offset!");

// Class HLL.HLLVehicleFXComponent
// 0x0228 (0x02D8 - 0x00B0)
class UHLLVehicleFXComponent final : public UActorComponent
{
public:
	TMap<class FName, struct FActiveDustTrail>    ActiveDustTrails;                                  // 0x00B0(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 VehicleMesh;                                       // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1498[0x70];                                    // 0x0108(0x0070)(Fixing Size After Last Property [ Dumper-69 ])
	class UDataTable*                             DustTrailData;                                     // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class FName>                DustTrails;                                        // 0x0180(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TrailSearchDistance;                               // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailCullDistance;                                 // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailMinSpeed;                                     // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailProjectionDepth;                              // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             ExhaustSockets;                                    // 0x01E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ExhaustTemplate;                                   // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        BackfireTemplate;                                  // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             BackfireSound;                                     // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UParticleSystemComponent*>         ActiveExhaustFX;                                   // 0x0248(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         RPMDropForBackfire;                                // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackfireChance;                                    // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenBackfires;                           // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnMaxRPM;                                       // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnMaxRate;                                      // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1499[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterImpactEffect>       CollisionEffect;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeBetweenImpacts;                             // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinImpactEffectStrength;                           // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinVelocForImpactEffect;                           // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149A[0x14];                                    // 0x02C4(0x0014)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnVehicleImpact(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleFXComponent">();
	}
	static class UHLLVehicleFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVehicleFXComponent>();
	}
};
static_assert(alignof(UHLLVehicleFXComponent) == 0x000008, "Wrong alignment on UHLLVehicleFXComponent");
static_assert(sizeof(UHLLVehicleFXComponent) == 0x0002D8, "Wrong size on UHLLVehicleFXComponent");
static_assert(offsetof(UHLLVehicleFXComponent, ActiveDustTrails) == 0x0000B0, "Member 'UHLLVehicleFXComponent::ActiveDustTrails' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, VehicleMesh) == 0x000100, "Member 'UHLLVehicleFXComponent::VehicleMesh' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, DustTrailData) == 0x000178, "Member 'UHLLVehicleFXComponent::DustTrailData' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, DustTrails) == 0x000180, "Member 'UHLLVehicleFXComponent::DustTrails' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, TrailSearchDistance) == 0x0001D0, "Member 'UHLLVehicleFXComponent::TrailSearchDistance' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, TrailCullDistance) == 0x0001D4, "Member 'UHLLVehicleFXComponent::TrailCullDistance' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, TrailMinSpeed) == 0x0001D8, "Member 'UHLLVehicleFXComponent::TrailMinSpeed' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, TrailProjectionDepth) == 0x0001DC, "Member 'UHLLVehicleFXComponent::TrailProjectionDepth' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, ExhaustSockets) == 0x0001E0, "Member 'UHLLVehicleFXComponent::ExhaustSockets' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, ExhaustTemplate) == 0x000230, "Member 'UHLLVehicleFXComponent::ExhaustTemplate' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, BackfireTemplate) == 0x000238, "Member 'UHLLVehicleFXComponent::BackfireTemplate' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, BackfireSound) == 0x000240, "Member 'UHLLVehicleFXComponent::BackfireSound' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, ActiveExhaustFX) == 0x000248, "Member 'UHLLVehicleFXComponent::ActiveExhaustFX' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, RPMDropForBackfire) == 0x000298, "Member 'UHLLVehicleFXComponent::RPMDropForBackfire' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, BackfireChance) == 0x00029C, "Member 'UHLLVehicleFXComponent::BackfireChance' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, MinTimeBetweenBackfires) == 0x0002A0, "Member 'UHLLVehicleFXComponent::MinTimeBetweenBackfires' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, SpawnMaxRPM) == 0x0002A4, "Member 'UHLLVehicleFXComponent::SpawnMaxRPM' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, SpawnMaxRate) == 0x0002A8, "Member 'UHLLVehicleFXComponent::SpawnMaxRate' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, CollisionEffect) == 0x0002B0, "Member 'UHLLVehicleFXComponent::CollisionEffect' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, MinTimeBetweenImpacts) == 0x0002B8, "Member 'UHLLVehicleFXComponent::MinTimeBetweenImpacts' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, MinImpactEffectStrength) == 0x0002BC, "Member 'UHLLVehicleFXComponent::MinImpactEffectStrength' has a wrong offset!");
static_assert(offsetof(UHLLVehicleFXComponent, MinVelocForImpactEffect) == 0x0002C0, "Member 'UHLLVehicleFXComponent::MinVelocForImpactEffect' has a wrong offset!");

// Class HLL.HLLVehicleInactivityComponent
// 0x0018 (0x00C8 - 0x00B0)
class UHLLVehicleInactivityComponent final : public UActorComponent
{
public:
	int32                                         OutOfBoundsTimeout;                                // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UnoccupiedTimeout;                                 // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageToApply;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWorldBoundsCheck : 1;                             // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOccupancyCheck : 1;                               // 0x00BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_149C[0xB];                                     // 0x00BD(0x000B)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleInactivityComponent">();
	}
	static class UHLLVehicleInactivityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVehicleInactivityComponent>();
	}
};
static_assert(alignof(UHLLVehicleInactivityComponent) == 0x000008, "Wrong alignment on UHLLVehicleInactivityComponent");
static_assert(sizeof(UHLLVehicleInactivityComponent) == 0x0000C8, "Wrong size on UHLLVehicleInactivityComponent");
static_assert(offsetof(UHLLVehicleInactivityComponent, OutOfBoundsTimeout) == 0x0000B0, "Member 'UHLLVehicleInactivityComponent::OutOfBoundsTimeout' has a wrong offset!");
static_assert(offsetof(UHLLVehicleInactivityComponent, UnoccupiedTimeout) == 0x0000B4, "Member 'UHLLVehicleInactivityComponent::UnoccupiedTimeout' has a wrong offset!");
static_assert(offsetof(UHLLVehicleInactivityComponent, DamageToApply) == 0x0000B8, "Member 'UHLLVehicleInactivityComponent::DamageToApply' has a wrong offset!");

// Class HLL.HLLVehicleSpawnerBase
// 0x0038 (0x0258 - 0x0220)
class AHLLVehicleSpawnerBase : public AActor
{
public:
	class USceneComponent*                        DummyRoot;                                         // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SafeZone;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RetrySpawnDelay;                                   // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    SpawnBounds;                                       // 0x0234(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SafeZoneInflation;                                 // 0x0240(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149D[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FTimerHandle                           TH_RetrySpawn;                                     // 0x0248(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     RetrySpawnClass;                                   // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_SpawnBounds();
	void UpdateSafeZone(const struct FVector& Size);

	struct FVector GetDefaultSafeZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleSpawnerBase">();
	}
	static class AHLLVehicleSpawnerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLVehicleSpawnerBase>();
	}
};
static_assert(alignof(AHLLVehicleSpawnerBase) == 0x000008, "Wrong alignment on AHLLVehicleSpawnerBase");
static_assert(sizeof(AHLLVehicleSpawnerBase) == 0x000258, "Wrong size on AHLLVehicleSpawnerBase");
static_assert(offsetof(AHLLVehicleSpawnerBase, DummyRoot) == 0x000220, "Member 'AHLLVehicleSpawnerBase::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLVehicleSpawnerBase, SafeZone) == 0x000228, "Member 'AHLLVehicleSpawnerBase::SafeZone' has a wrong offset!");
static_assert(offsetof(AHLLVehicleSpawnerBase, RetrySpawnDelay) == 0x000230, "Member 'AHLLVehicleSpawnerBase::RetrySpawnDelay' has a wrong offset!");
static_assert(offsetof(AHLLVehicleSpawnerBase, SpawnBounds) == 0x000234, "Member 'AHLLVehicleSpawnerBase::SpawnBounds' has a wrong offset!");
static_assert(offsetof(AHLLVehicleSpawnerBase, SafeZoneInflation) == 0x000240, "Member 'AHLLVehicleSpawnerBase::SafeZoneInflation' has a wrong offset!");
static_assert(offsetof(AHLLVehicleSpawnerBase, TH_RetrySpawn) == 0x000248, "Member 'AHLLVehicleSpawnerBase::TH_RetrySpawn' has a wrong offset!");
static_assert(offsetof(AHLLVehicleSpawnerBase, RetrySpawnClass) == 0x000250, "Member 'AHLLVehicleSpawnerBase::RetrySpawnClass' has a wrong offset!");

// Class HLL.HLLVehicleSpawner_Ability
// 0x0008 (0x0260 - 0x0258)
class AHLLVehicleSpawner_Ability final : public AHLLVehicleSpawnerBase
{
public:
	uint8                                         Pad_149E[0x8];                                     // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleSpawner_Ability">();
	}
	static class AHLLVehicleSpawner_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLVehicleSpawner_Ability>();
	}
};
static_assert(alignof(AHLLVehicleSpawner_Ability) == 0x000008, "Wrong alignment on AHLLVehicleSpawner_Ability");
static_assert(sizeof(AHLLVehicleSpawner_Ability) == 0x000260, "Wrong size on AHLLVehicleSpawner_Ability");

// Class HLL.HLLVehicleSpawner_PrePlaced
// 0x0088 (0x02E0 - 0x0258)
class AHLLVehicleSpawner_PrePlaced final : public AHLLVehicleSpawnerBase
{
public:
	TMap<ETeam, struct FDataTableRowHandle>       SpawnData;                                         // 0x0258(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreSectorControl : 1;                          // 0x02A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_149F[0x3];                                     // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class AActor>                  MostRecentlySpawnedVehicle;                        // 0x02AC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14A0[0x2C];                                    // 0x02B4(0x002C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleSpawner_PrePlaced">();
	}
	static class AHLLVehicleSpawner_PrePlaced* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLVehicleSpawner_PrePlaced>();
	}
};
static_assert(alignof(AHLLVehicleSpawner_PrePlaced) == 0x000008, "Wrong alignment on AHLLVehicleSpawner_PrePlaced");
static_assert(sizeof(AHLLVehicleSpawner_PrePlaced) == 0x0002E0, "Wrong size on AHLLVehicleSpawner_PrePlaced");
static_assert(offsetof(AHLLVehicleSpawner_PrePlaced, SpawnData) == 0x000258, "Member 'AHLLVehicleSpawner_PrePlaced::SpawnData' has a wrong offset!");
static_assert(offsetof(AHLLVehicleSpawner_PrePlaced, MostRecentlySpawnedVehicle) == 0x0002AC, "Member 'AHLLVehicleSpawner_PrePlaced::MostRecentlySpawnedVehicle' has a wrong offset!");

// Class HLL.HLLVehicleWreck
// 0x0068 (0x0288 - 0x0220)
class AHLLVehicleWreck : public AActor
{
public:
	uint8                                         Pad_14A1[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        DummyRoot;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSimpleHealthComponent*              HealthComponent;                                   // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerSpawnedTime;                                 // 0x0250(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A2[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AActor*                                 ReplacedVehicleActor;                              // 0x0258(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x0260(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A3[0x7];                                     // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AShooterImpactEffect>       ExplosionEffect;                                   // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseLifespan;                                      // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WreckReplacementDelay;                             // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A4[0x10];                                    // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVehicleWreck">();
	}
	static class AHLLVehicleWreck* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLVehicleWreck>();
	}
};
static_assert(alignof(AHLLVehicleWreck) == 0x000008, "Wrong alignment on AHLLVehicleWreck");
static_assert(sizeof(AHLLVehicleWreck) == 0x000288, "Wrong size on AHLLVehicleWreck");
static_assert(offsetof(AHLLVehicleWreck, DummyRoot) == 0x000238, "Member 'AHLLVehicleWreck::DummyRoot' has a wrong offset!");
static_assert(offsetof(AHLLVehicleWreck, Mesh) == 0x000240, "Member 'AHLLVehicleWreck::Mesh' has a wrong offset!");
static_assert(offsetof(AHLLVehicleWreck, HealthComponent) == 0x000248, "Member 'AHLLVehicleWreck::HealthComponent' has a wrong offset!");
static_assert(offsetof(AHLLVehicleWreck, ServerSpawnedTime) == 0x000250, "Member 'AHLLVehicleWreck::ServerSpawnedTime' has a wrong offset!");
static_assert(offsetof(AHLLVehicleWreck, ReplacedVehicleActor) == 0x000258, "Member 'AHLLVehicleWreck::ReplacedVehicleActor' has a wrong offset!");
static_assert(offsetof(AHLLVehicleWreck, Team) == 0x000260, "Member 'AHLLVehicleWreck::Team' has a wrong offset!");
static_assert(offsetof(AHLLVehicleWreck, ExplosionEffect) == 0x000268, "Member 'AHLLVehicleWreck::ExplosionEffect' has a wrong offset!");
static_assert(offsetof(AHLLVehicleWreck, BaseLifespan) == 0x000270, "Member 'AHLLVehicleWreck::BaseLifespan' has a wrong offset!");
static_assert(offsetof(AHLLVehicleWreck, WreckReplacementDelay) == 0x000274, "Member 'AHLLVehicleWreck::WreckReplacementDelay' has a wrong offset!");

// Class HLL.HLLGlobalVibrationConfig
// 0x0010 (0x0040 - 0x0030)
class UHLLGlobalVibrationConfig final : public UDataAsset
{
public:
	float                                         LowVibrationIntensity;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumVibrationIntensity;                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighVibrationIntensity;                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A5[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLGlobalVibrationConfig">();
	}
	static class UHLLGlobalVibrationConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLGlobalVibrationConfig>();
	}
};
static_assert(alignof(UHLLGlobalVibrationConfig) == 0x000008, "Wrong alignment on UHLLGlobalVibrationConfig");
static_assert(sizeof(UHLLGlobalVibrationConfig) == 0x000040, "Wrong size on UHLLGlobalVibrationConfig");
static_assert(offsetof(UHLLGlobalVibrationConfig, LowVibrationIntensity) == 0x000030, "Member 'UHLLGlobalVibrationConfig::LowVibrationIntensity' has a wrong offset!");
static_assert(offsetof(UHLLGlobalVibrationConfig, MediumVibrationIntensity) == 0x000034, "Member 'UHLLGlobalVibrationConfig::MediumVibrationIntensity' has a wrong offset!");
static_assert(offsetof(UHLLGlobalVibrationConfig, HighVibrationIntensity) == 0x000038, "Member 'UHLLGlobalVibrationConfig::HighVibrationIntensity' has a wrong offset!");

// Class HLL.HLLVibrationWeapon
// 0x0000 (0x0028 - 0x0028)
class IHLLVibrationWeapon final : public IInterface
{
public:
	class UHLLWeaponVibrationData* GetSpecialVibrationData() const;
	class UHLLWeaponVibrationData* GetWeaponVibrationData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVibrationWeapon">();
	}
	static class IHLLVibrationWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLVibrationWeapon>();
	}
};
static_assert(alignof(IHLLVibrationWeapon) == 0x000008, "Wrong alignment on IHLLVibrationWeapon");
static_assert(sizeof(IHLLVibrationWeapon) == 0x000028, "Wrong size on IHLLVibrationWeapon");

// Class HLL.VibrationUtils
// 0x0000 (0x0028 - 0x0028)
class UVibrationUtils final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VibrationUtils">();
	}
	static class UVibrationUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVibrationUtils>();
	}
};
static_assert(alignof(UVibrationUtils) == 0x000008, "Wrong alignment on UVibrationUtils");
static_assert(sizeof(UVibrationUtils) == 0x000028, "Wrong size on UVibrationUtils");

// Class HLL.HLLVisiblePlayersBase
// 0x0000 (0x0230 - 0x0230)
class UHLLVisiblePlayersBase final : public UUserWidget
{
public:
	void ScreenToLocal(const struct FGeometry& Geometry, const struct FVector2D& ScreenPosition, struct FVector2D* LocalCoordinate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVisiblePlayersBase">();
	}
	static class UHLLVisiblePlayersBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVisiblePlayersBase>();
	}
};
static_assert(alignof(UHLLVisiblePlayersBase) == 0x000008, "Wrong alignment on UHLLVisiblePlayersBase");
static_assert(sizeof(UHLLVisiblePlayersBase) == 0x000230, "Wrong size on UHLLVisiblePlayersBase");

// Class HLL.HLLVoiceData
// 0x01E8 (0x0218 - 0x0030)
class UHLLVoiceData final : public UDataAsset
{
public:
	TMap<EHLLDamageType, TSoftObjectPtr<class USoundBase>> PainVoices;                                        // 0x0030(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         PainThreshold;                                     // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A6[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<EHLLDamageType, TSoftObjectPtr<class USoundBase>> CriticalVoices;                                    // 0x0088(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EHLLDamageType, TSoftObjectPtr<class USoundBase>> DeathVoices;                                       // 0x00D8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              DismemberedDeathVoice;                             // 0x0128(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              WoundedLoop;                                       // 0x0150(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              CriticalLoop;                                      // 0x0178(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              WeaponSteadyBreath;                                // 0x01A0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              WeaponUnsteadyBreath;                              // 0x01C8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              JumpSound;                                         // 0x01F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVoiceData">();
	}
	static class UHLLVoiceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVoiceData>();
	}
};
static_assert(alignof(UHLLVoiceData) == 0x000008, "Wrong alignment on UHLLVoiceData");
static_assert(sizeof(UHLLVoiceData) == 0x000218, "Wrong size on UHLLVoiceData");
static_assert(offsetof(UHLLVoiceData, PainVoices) == 0x000030, "Member 'UHLLVoiceData::PainVoices' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, PainThreshold) == 0x000080, "Member 'UHLLVoiceData::PainThreshold' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, CriticalVoices) == 0x000088, "Member 'UHLLVoiceData::CriticalVoices' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, DeathVoices) == 0x0000D8, "Member 'UHLLVoiceData::DeathVoices' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, DismemberedDeathVoice) == 0x000128, "Member 'UHLLVoiceData::DismemberedDeathVoice' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, WoundedLoop) == 0x000150, "Member 'UHLLVoiceData::WoundedLoop' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, CriticalLoop) == 0x000178, "Member 'UHLLVoiceData::CriticalLoop' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, WeaponSteadyBreath) == 0x0001A0, "Member 'UHLLVoiceData::WeaponSteadyBreath' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, WeaponUnsteadyBreath) == 0x0001C8, "Member 'UHLLVoiceData::WeaponUnsteadyBreath' has a wrong offset!");
static_assert(offsetof(UHLLVoiceData, JumpSound) == 0x0001F0, "Member 'UHLLVoiceData::JumpSound' has a wrong offset!");

// Class HLL.ShooterWeapon_Repair
// 0x0060 (0x0B10 - 0x0AB0)
class AShooterWeapon_Repair : public AShooterWeapon
{
public:
	float                                         TimeBetweenRepairs;                                // 0x0AA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RepairPerSecond;                                   // 0x0AAC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepairRange;                                       // 0x0AB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RepairActionScoreInterval;                         // 0x0AB4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A7[0x3];                                     // 0x0AB5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   RepairActionScore;                                 // 0x0AB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        SurfaceParticle;                                   // 0x0AC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SurfaceSound;                                      // 0x0AC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               RepairPSC;                                         // 0x0AD0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        RepairASC;                                         // 0x0AD8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHLLArmourHealthComponent> CurrentRepairTarget;                               // 0x0AE0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastRepairTime;                                    // 0x0AE8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RepairCounter;                                     // 0x0AEC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVibrationEventController*              WeldVibrationEventController;                      // 0x0AF0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SurfaceSound_PADOverride;                          // 0x0AF8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A8[0x10];                                    // 0x0B00(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnFreelookStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Repair">();
	}
	static class AShooterWeapon_Repair* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Repair>();
	}
};
static_assert(alignof(AShooterWeapon_Repair) == 0x000010, "Wrong alignment on AShooterWeapon_Repair");
static_assert(sizeof(AShooterWeapon_Repair) == 0x000B10, "Wrong size on AShooterWeapon_Repair");
static_assert(offsetof(AShooterWeapon_Repair, TimeBetweenRepairs) == 0x000AA8, "Member 'AShooterWeapon_Repair::TimeBetweenRepairs' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, RepairPerSecond) == 0x000AAC, "Member 'AShooterWeapon_Repair::RepairPerSecond' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, RepairRange) == 0x000AB0, "Member 'AShooterWeapon_Repair::RepairRange' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, RepairActionScoreInterval) == 0x000AB4, "Member 'AShooterWeapon_Repair::RepairActionScoreInterval' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, RepairActionScore) == 0x000AB8, "Member 'AShooterWeapon_Repair::RepairActionScore' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, SurfaceParticle) == 0x000AC0, "Member 'AShooterWeapon_Repair::SurfaceParticle' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, SurfaceSound) == 0x000AC8, "Member 'AShooterWeapon_Repair::SurfaceSound' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, RepairPSC) == 0x000AD0, "Member 'AShooterWeapon_Repair::RepairPSC' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, RepairASC) == 0x000AD8, "Member 'AShooterWeapon_Repair::RepairASC' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, CurrentRepairTarget) == 0x000AE0, "Member 'AShooterWeapon_Repair::CurrentRepairTarget' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, LastRepairTime) == 0x000AE8, "Member 'AShooterWeapon_Repair::LastRepairTime' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, RepairCounter) == 0x000AEC, "Member 'AShooterWeapon_Repair::RepairCounter' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, WeldVibrationEventController) == 0x000AF0, "Member 'AShooterWeapon_Repair::WeldVibrationEventController' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Repair, SurfaceSound_PADOverride) == 0x000AF8, "Member 'AShooterWeapon_Repair::SurfaceSound_PADOverride' has a wrong offset!");

// Class HLL.HLLVoteDataComponent
// 0x0260 (0x0310 - 0x00B0)
class UHLLVoteDataComponent final : public UActorComponent
{
public:
	uint8                                         Pad_14A9[0x8];                                     // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         VoteLifetime;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoteCompletionTime;                                // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVoteThreshold>                 DefaultThresholds;                                 // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoteTargetCooldown;                                // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoteInstigatorCooldown;                            // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bVoteKickEnabled : 1;                              // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_14AA[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVoteDataContainer_Static              StaticData;                                        // 0x00E0(0x0118)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FVoteDataContainer_Dynamic             DynamicData;                                       // 0x01F8(0x0118)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)

public:
	static class UHLLVoteDataComponent* GetVoteSystem(const class UObject* WorldContextObject);

	void OnRep_DynamicData();
	void OnRep_StaticData();

	bool CanEverVote(const class AShooterPlayerState* Player, const struct FVoteHandle& Vote) const;
	class FName CanStartVote(const class AShooterPlayerState* Instigator, const class AShooterPlayerState* Target, const EPlayerVoteType Type) const;
	struct FVoteHandle FindVoteKick(const ETeam ForTeam, const class AShooterPlayerState* Target) const;
	struct FVoteHandle GetHighestPriorityVote(class AShooterPlayerController* Player) const;
	EPlayerVote GetPlayerVote(const class AShooterPlayerController* Player, const struct FVoteHandle& Vote) const;
	bool GetVoteData(const struct FVoteHandle& Vote, struct FVoteData_Static* StaticVoteData, struct FVoteData_Dynamic* DynamicVoteData) const;
	bool IsPlayerRelevantForVoting(const class AShooterPlayerState* Player) const;
	bool IsValidVote(const struct FVoteHandle& Vote) const;
	bool IsVoteKickEnabled() const;
	int32 NumVotes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVoteDataComponent">();
	}
	static class UHLLVoteDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVoteDataComponent>();
	}
};
static_assert(alignof(UHLLVoteDataComponent) == 0x000008, "Wrong alignment on UHLLVoteDataComponent");
static_assert(sizeof(UHLLVoteDataComponent) == 0x000310, "Wrong size on UHLLVoteDataComponent");
static_assert(offsetof(UHLLVoteDataComponent, VoteLifetime) == 0x0000B8, "Member 'UHLLVoteDataComponent::VoteLifetime' has a wrong offset!");
static_assert(offsetof(UHLLVoteDataComponent, VoteCompletionTime) == 0x0000BC, "Member 'UHLLVoteDataComponent::VoteCompletionTime' has a wrong offset!");
static_assert(offsetof(UHLLVoteDataComponent, DefaultThresholds) == 0x0000C0, "Member 'UHLLVoteDataComponent::DefaultThresholds' has a wrong offset!");
static_assert(offsetof(UHLLVoteDataComponent, VoteTargetCooldown) == 0x0000D0, "Member 'UHLLVoteDataComponent::VoteTargetCooldown' has a wrong offset!");
static_assert(offsetof(UHLLVoteDataComponent, VoteInstigatorCooldown) == 0x0000D4, "Member 'UHLLVoteDataComponent::VoteInstigatorCooldown' has a wrong offset!");
static_assert(offsetof(UHLLVoteDataComponent, StaticData) == 0x0000E0, "Member 'UHLLVoteDataComponent::StaticData' has a wrong offset!");
static_assert(offsetof(UHLLVoteDataComponent, DynamicData) == 0x0001F8, "Member 'UHLLVoteDataComponent::DynamicData' has a wrong offset!");

// Class HLL.HLLVoteWidget
// 0x0030 (0x0260 - 0x0230)
class UHLLVoteWidget : public UUserWidget
{
public:
	bool                                          bIsVoting;                                         // 0x0230(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoteHandle                            Vote;                                              // 0x0231(0x0001)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B5[0x6];                                     // 0x0232(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class URichTextBlock*                         BodyText;                                          // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TitleText;                                         // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Countdown;                                         // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterPlayerController*               PlayerController;                                  // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InputChanged(bool NewValue);
	void OnUpdatePrompts();
	void OnVoteSet(const struct FVoteHandle& InVote, const struct FVoteData_Static& StaticVoteData, const struct FVoteData_Dynamic& DynamicVoteData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLVoteWidget">();
	}
	static class UHLLVoteWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLVoteWidget>();
	}
};
static_assert(alignof(UHLLVoteWidget) == 0x000008, "Wrong alignment on UHLLVoteWidget");
static_assert(sizeof(UHLLVoteWidget) == 0x000260, "Wrong size on UHLLVoteWidget");
static_assert(offsetof(UHLLVoteWidget, bIsVoting) == 0x000230, "Member 'UHLLVoteWidget::bIsVoting' has a wrong offset!");
static_assert(offsetof(UHLLVoteWidget, Vote) == 0x000231, "Member 'UHLLVoteWidget::Vote' has a wrong offset!");
static_assert(offsetof(UHLLVoteWidget, BodyText) == 0x000238, "Member 'UHLLVoteWidget::BodyText' has a wrong offset!");
static_assert(offsetof(UHLLVoteWidget, TitleText) == 0x000240, "Member 'UHLLVoteWidget::TitleText' has a wrong offset!");
static_assert(offsetof(UHLLVoteWidget, Countdown) == 0x000248, "Member 'UHLLVoteWidget::Countdown' has a wrong offset!");
static_assert(offsetof(UHLLVoteWidget, ViewportClient) == 0x000250, "Member 'UHLLVoteWidget::ViewportClient' has a wrong offset!");
static_assert(offsetof(UHLLVoteWidget, PlayerController) == 0x000258, "Member 'UHLLVoteWidget::PlayerController' has a wrong offset!");

// Class HLL.HLLWaterInteractionInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLWaterInteractionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWaterInteractionInterface">();
	}
	static class IHLLWaterInteractionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLWaterInteractionInterface>();
	}
};
static_assert(alignof(IHLLWaterInteractionInterface) == 0x000008, "Wrong alignment on IHLLWaterInteractionInterface");
static_assert(sizeof(IHLLWaterInteractionInterface) == 0x000028, "Wrong size on IHLLWaterInteractionInterface");

// Class HLL.HLLWaterVolume
// 0x0090 (0x0300 - 0x0270)
class AHLLWaterVolume final : public AHLLPhysicsVolume
{
public:
	class UBoxComponent*                          WaterVolume;                                       // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  WaterPostProcess;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SurfacePlane;                                      // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   UndersidePlane;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        UnderwaterSoundComponent;                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalMaterial*                      SurfacePhysMaterial;                               // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalMaterial*                      UndersidePhysMaterial;                             // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SurfaceMaterial;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     UndersideMaterial;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PPMaterial;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PostProcessDMI;                                    // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlockWeaponDeploymentDepth;                        // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildDepthOffset;                                  // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SpeedModifierCurve;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWaterType                                    WaterType;                                         // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowUndersidePlane : 1;                           // 0x02D9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableVehicleWading : 1;                          // 0x02D9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnablePlayerWading : 1;                           // 0x02D9(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableSplashes : 1;                               // 0x02D9(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDoCrouchCheck : 1;                                // 0x02D9(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDoProneCheck : 1;                                 // 0x02D9(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShouldDrown : 1;                                  // 0x02D9(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_14B8[0x2];                                     // 0x02DA(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         PlayerWadeDepth;                                   // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             UnderwaterSound;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterVolumeOffset;                                 // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B9[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FHLLWaterVolumeOverlap>         ActiveWaterEffects;                                // 0x02F0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWaterVolume">();
	}
	static class AHLLWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLWaterVolume>();
	}
};
static_assert(alignof(AHLLWaterVolume) == 0x000008, "Wrong alignment on AHLLWaterVolume");
static_assert(sizeof(AHLLWaterVolume) == 0x000300, "Wrong size on AHLLWaterVolume");
static_assert(offsetof(AHLLWaterVolume, WaterVolume) == 0x000270, "Member 'AHLLWaterVolume::WaterVolume' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, WaterPostProcess) == 0x000278, "Member 'AHLLWaterVolume::WaterPostProcess' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, SurfacePlane) == 0x000280, "Member 'AHLLWaterVolume::SurfacePlane' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, UndersidePlane) == 0x000288, "Member 'AHLLWaterVolume::UndersidePlane' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, UnderwaterSoundComponent) == 0x000290, "Member 'AHLLWaterVolume::UnderwaterSoundComponent' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, SurfacePhysMaterial) == 0x000298, "Member 'AHLLWaterVolume::SurfacePhysMaterial' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, UndersidePhysMaterial) == 0x0002A0, "Member 'AHLLWaterVolume::UndersidePhysMaterial' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, SurfaceMaterial) == 0x0002A8, "Member 'AHLLWaterVolume::SurfaceMaterial' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, UndersideMaterial) == 0x0002B0, "Member 'AHLLWaterVolume::UndersideMaterial' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, PPMaterial) == 0x0002B8, "Member 'AHLLWaterVolume::PPMaterial' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, PostProcessDMI) == 0x0002C0, "Member 'AHLLWaterVolume::PostProcessDMI' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, BlockWeaponDeploymentDepth) == 0x0002C8, "Member 'AHLLWaterVolume::BlockWeaponDeploymentDepth' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, BuildDepthOffset) == 0x0002CC, "Member 'AHLLWaterVolume::BuildDepthOffset' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, SpeedModifierCurve) == 0x0002D0, "Member 'AHLLWaterVolume::SpeedModifierCurve' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, WaterType) == 0x0002D8, "Member 'AHLLWaterVolume::WaterType' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, PlayerWadeDepth) == 0x0002DC, "Member 'AHLLWaterVolume::PlayerWadeDepth' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, UnderwaterSound) == 0x0002E0, "Member 'AHLLWaterVolume::UnderwaterSound' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, WaterVolumeOffset) == 0x0002E8, "Member 'AHLLWaterVolume::WaterVolumeOffset' has a wrong offset!");
static_assert(offsetof(AHLLWaterVolume, ActiveWaterEffects) == 0x0002F0, "Member 'AHLLWaterVolume::ActiveWaterEffects' has a wrong offset!");

// Class HLL.UserEngagementFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUserEngagementFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClientChangeActiveUser(const class UObject* WorldContextObject);
	static class FText ClientDisplayName(const class UObject* WorldContextObject);
	static class FText ClientDisplayNameFull();
	static class FText ClientGlobalId();
	static bool ClientIsCrossPlatformPlayRestricted();
	static int32 GetPlayerCurrentLevelXP(const class UObject* WorldContextObject);
	static void OnReturnToIIS();
	static void ShowGenericNetworkError(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserEngagementFunctionLibrary">();
	}
	static class UUserEngagementFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserEngagementFunctionLibrary>();
	}
};
static_assert(alignof(UUserEngagementFunctionLibrary) == 0x000008, "Wrong alignment on UUserEngagementFunctionLibrary");
static_assert(sizeof(UUserEngagementFunctionLibrary) == 0x000028, "Wrong size on UUserEngagementFunctionLibrary");

// Class HLL.HLLWeaponCasingSettings
// 0x0190 (0x01C0 - 0x0030)
class UHLLWeaponCasingSettings final : public UDataAsset
{
public:
	struct FSurfaceSounds                         CasingEjectSounds;                                 // 0x0030(0x0160)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CasingEjectSoundOffset;                            // 0x0190(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CasingEjectDelay_Prone;                            // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CasingEjectDelay_Crouched;                         // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CasingEjectDelay_Standing;                         // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenCasingEjectSound;                    // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CasingEjectCullDistance;                           // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxSimultaneousCasings;                            // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14BB[0x3];                                     // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         SimultaneousCasingMaxRandomDelay;                  // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimultaneousCasingMaxRandomOffset;                 // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14BC[0x4];                                     // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeaponCasingSettings">();
	}
	static class UHLLWeaponCasingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeaponCasingSettings>();
	}
};
static_assert(alignof(UHLLWeaponCasingSettings) == 0x000008, "Wrong alignment on UHLLWeaponCasingSettings");
static_assert(sizeof(UHLLWeaponCasingSettings) == 0x0001C0, "Wrong size on UHLLWeaponCasingSettings");
static_assert(offsetof(UHLLWeaponCasingSettings, CasingEjectSounds) == 0x000030, "Member 'UHLLWeaponCasingSettings::CasingEjectSounds' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, CasingEjectSoundOffset) == 0x000190, "Member 'UHLLWeaponCasingSettings::CasingEjectSoundOffset' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, CasingEjectDelay_Prone) == 0x00019C, "Member 'UHLLWeaponCasingSettings::CasingEjectDelay_Prone' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, CasingEjectDelay_Crouched) == 0x0001A0, "Member 'UHLLWeaponCasingSettings::CasingEjectDelay_Crouched' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, CasingEjectDelay_Standing) == 0x0001A4, "Member 'UHLLWeaponCasingSettings::CasingEjectDelay_Standing' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, MinTimeBetweenCasingEjectSound) == 0x0001A8, "Member 'UHLLWeaponCasingSettings::MinTimeBetweenCasingEjectSound' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, CasingEjectCullDistance) == 0x0001AC, "Member 'UHLLWeaponCasingSettings::CasingEjectCullDistance' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, MaxSimultaneousCasings) == 0x0001B0, "Member 'UHLLWeaponCasingSettings::MaxSimultaneousCasings' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, SimultaneousCasingMaxRandomDelay) == 0x0001B4, "Member 'UHLLWeaponCasingSettings::SimultaneousCasingMaxRandomDelay' has a wrong offset!");
static_assert(offsetof(UHLLWeaponCasingSettings, SimultaneousCasingMaxRandomOffset) == 0x0001B8, "Member 'UHLLWeaponCasingSettings::SimultaneousCasingMaxRandomOffset' has a wrong offset!");

// Class HLL.HLLWeaponContainerIndicator
// 0x0000 (0x02B0 - 0x02B0)
class UHLLWeaponContainerIndicator final : public UHLLIndicatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeaponContainerIndicator">();
	}
	static class UHLLWeaponContainerIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeaponContainerIndicator>();
	}
};
static_assert(alignof(UHLLWeaponContainerIndicator) == 0x000008, "Wrong alignment on UHLLWeaponContainerIndicator");
static_assert(sizeof(UHLLWeaponContainerIndicator) == 0x0002B0, "Wrong size on UHLLWeaponContainerIndicator");

// Class HLL.HLLWeaponListItem
// 0x0070 (0x02A0 - 0x0230)
class UHLLWeaponListItem : public UUserWidget
{
public:
	class UBorder*                                RootBorder;                                        // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLKeyText*                            WeaponKeyName;                                     // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponName;                                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           WeaponIcon;                                        // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14BD[0x50];                                    // 0x0250(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeaponListItem">();
	}
	static class UHLLWeaponListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeaponListItem>();
	}
};
static_assert(alignof(UHLLWeaponListItem) == 0x000008, "Wrong alignment on UHLLWeaponListItem");
static_assert(sizeof(UHLLWeaponListItem) == 0x0002A0, "Wrong size on UHLLWeaponListItem");
static_assert(offsetof(UHLLWeaponListItem, RootBorder) == 0x000230, "Member 'UHLLWeaponListItem::RootBorder' has a wrong offset!");
static_assert(offsetof(UHLLWeaponListItem, WeaponKeyName) == 0x000238, "Member 'UHLLWeaponListItem::WeaponKeyName' has a wrong offset!");
static_assert(offsetof(UHLLWeaponListItem, WeaponName) == 0x000240, "Member 'UHLLWeaponListItem::WeaponName' has a wrong offset!");
static_assert(offsetof(UHLLWeaponListItem, WeaponIcon) == 0x000248, "Member 'UHLLWeaponListItem::WeaponIcon' has a wrong offset!");

// Class HLL.WarfareStart
// 0x0010 (0x0260 - 0x0250)
class AWarfareStart final : public APlayerStart
{
public:
	uint8                                         Pad_14BE[0x8];                                     // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	ETeam                                         Team;                                              // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14BF[0x3];                                     // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         Group;                                             // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WarfareStart">();
	}
	static class AWarfareStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWarfareStart>();
	}
};
static_assert(alignof(AWarfareStart) == 0x000008, "Wrong alignment on AWarfareStart");
static_assert(sizeof(AWarfareStart) == 0x000260, "Wrong size on AWarfareStart");
static_assert(offsetof(AWarfareStart, Team) == 0x000258, "Member 'AWarfareStart::Team' has a wrong offset!");
static_assert(offsetof(AWarfareStart, Group) == 0x00025C, "Member 'AWarfareStart::Group' has a wrong offset!");

// Class HLL.RecoilCurve
// 0x0100 (0x0130 - 0x0030)
class URecoilCurve final : public UCurveBase
{
public:
	struct FRichCurve                             Vertical;                                          // 0x0030(0x0080)(NativeAccessSpecifierPublic)
	struct FRichCurve                             Horizontal;                                        // 0x00B0(0x0080)(NativeAccessSpecifierPublic)

public:
	struct FVector2D GetValue(const float ControlValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecoilCurve">();
	}
	static class URecoilCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecoilCurve>();
	}
};
static_assert(alignof(URecoilCurve) == 0x000008, "Wrong alignment on URecoilCurve");
static_assert(sizeof(URecoilCurve) == 0x000130, "Wrong size on URecoilCurve");
static_assert(offsetof(URecoilCurve, Vertical) == 0x000030, "Member 'URecoilCurve::Vertical' has a wrong offset!");
static_assert(offsetof(URecoilCurve, Horizontal) == 0x0000B0, "Member 'URecoilCurve::Horizontal' has a wrong offset!");

// Class HLL.WeaponTPPAnimationSet
// 0x0308 (0x0330 - 0x0028)
class UWeaponTPPAnimationSet : public UObject
{
public:
	class UAnimSequence*                          StandIdle;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandIdleBreak01;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandIdleBreak02;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchIdle;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchIdleBreak01;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchIdleBreak02;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ProneIdle;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandRotateRight;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandRotateLeft;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchRotateRight;                                 // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchRotateLeft;                                  // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ProneRotateRight;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ProneRotateLeft;                                   // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpEnter;                                         // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpLoop;                                          // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpExit;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandSprint;                                       // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchSprint;                                      // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseInheritanceStand;                              // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseInheritanceCrouch;                             // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseInheritanceProne;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseIdleStand;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseIdleCrouch;                                    // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseIdleProne;                                     // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseAdsStand;                                      // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseAdsCrouch;                                     // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseAdsProne;                                      // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandToCrouch;                                     // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandToProne;                                      // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchToStand;                                     // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchToProne;                                     // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ProneToStand;                                      // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ProneToCrouch;                                     // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          DeployInheritPose;                                 // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandDeployPivot;                                  // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandBipodDeploy;                                  // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StandBipodUndeploy;                                // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchBipodDeploy;                                 // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CrouchBipodUndeploy;                               // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ProneBipodDeploy;                                  // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ProneBipodUndeploy;                                // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandBipodIdle;                                    // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchBipodIdle;                                   // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ProneBipodIdle;                                    // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceStandEnter;                                   // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceStandIdle;                                    // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceStandExit;                                    // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceCrouchEnter;                                  // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceCrouchIdle;                                   // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceCrouchExit;                                   // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceProneEnter;                                   // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceProneIdle;                                    // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BraceProneExit;                                    // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BracePivotStand_R;                                 // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BracePivotStand_L;                                 // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BracePivotCrouch_R;                                // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BracePivotCrouch_L;                                // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BracePivotProne_R;                                 // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BracePivotProne_L;                                 // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandLocomotion;                                   // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandLocomotionADS;                                // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchLocomotion;                                  // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchLocomotionADS;                               // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            ProneLocomotion;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandWalkStart;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandWalkStop;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandJogStart;                                     // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandJogStop;                                      // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandSprintStop;                                   // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchWalkStart;                                   // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchWalkStop;                                    // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchJogStart;                                    // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchJogStop;                                     // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchSprintStop;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            ProneToJog;                                        // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            ProneToSprint;                                     // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandSprintStopToProne;                            // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandJogStopToProne;                               // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchSprintStopToProne;                           // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CrouchJogStopToProne;                              // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandVault;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StandClimb;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StandLeft;                                         // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StandRight;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CrouchLeft;                                        // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CrouchRight;                                       // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ProneLeft;                                         // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ProneRight;                                        // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Stand;                                          // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Crouch;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Crouch_Moving;                                  // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Prone;                                          // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Stand_ADS;                                      // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Crouch_ADS;                                     // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Prone_ADS;                                      // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Stand_Sprint;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AO_Crouch_Sprint;                                  // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponTPPAnimationSet">();
	}
	static class UWeaponTPPAnimationSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponTPPAnimationSet>();
	}
};
static_assert(alignof(UWeaponTPPAnimationSet) == 0x000008, "Wrong alignment on UWeaponTPPAnimationSet");
static_assert(sizeof(UWeaponTPPAnimationSet) == 0x000330, "Wrong size on UWeaponTPPAnimationSet");
static_assert(offsetof(UWeaponTPPAnimationSet, StandIdle) == 0x000028, "Member 'UWeaponTPPAnimationSet::StandIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandIdleBreak01) == 0x000030, "Member 'UWeaponTPPAnimationSet::StandIdleBreak01' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandIdleBreak02) == 0x000038, "Member 'UWeaponTPPAnimationSet::StandIdleBreak02' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchIdle) == 0x000040, "Member 'UWeaponTPPAnimationSet::CrouchIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchIdleBreak01) == 0x000048, "Member 'UWeaponTPPAnimationSet::CrouchIdleBreak01' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchIdleBreak02) == 0x000050, "Member 'UWeaponTPPAnimationSet::CrouchIdleBreak02' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneIdle) == 0x000058, "Member 'UWeaponTPPAnimationSet::ProneIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandRotateRight) == 0x000060, "Member 'UWeaponTPPAnimationSet::StandRotateRight' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandRotateLeft) == 0x000068, "Member 'UWeaponTPPAnimationSet::StandRotateLeft' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchRotateRight) == 0x000070, "Member 'UWeaponTPPAnimationSet::CrouchRotateRight' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchRotateLeft) == 0x000078, "Member 'UWeaponTPPAnimationSet::CrouchRotateLeft' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneRotateRight) == 0x000080, "Member 'UWeaponTPPAnimationSet::ProneRotateRight' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneRotateLeft) == 0x000088, "Member 'UWeaponTPPAnimationSet::ProneRotateLeft' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, JumpEnter) == 0x000090, "Member 'UWeaponTPPAnimationSet::JumpEnter' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, JumpLoop) == 0x000098, "Member 'UWeaponTPPAnimationSet::JumpLoop' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, JumpExit) == 0x0000A0, "Member 'UWeaponTPPAnimationSet::JumpExit' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandSprint) == 0x0000A8, "Member 'UWeaponTPPAnimationSet::StandSprint' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchSprint) == 0x0000B0, "Member 'UWeaponTPPAnimationSet::CrouchSprint' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseInheritanceStand) == 0x0000B8, "Member 'UWeaponTPPAnimationSet::PoseInheritanceStand' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseInheritanceCrouch) == 0x0000C0, "Member 'UWeaponTPPAnimationSet::PoseInheritanceCrouch' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseInheritanceProne) == 0x0000C8, "Member 'UWeaponTPPAnimationSet::PoseInheritanceProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseIdleStand) == 0x0000D0, "Member 'UWeaponTPPAnimationSet::PoseIdleStand' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseIdleCrouch) == 0x0000D8, "Member 'UWeaponTPPAnimationSet::PoseIdleCrouch' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseIdleProne) == 0x0000E0, "Member 'UWeaponTPPAnimationSet::PoseIdleProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseAdsStand) == 0x0000E8, "Member 'UWeaponTPPAnimationSet::PoseAdsStand' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseAdsCrouch) == 0x0000F0, "Member 'UWeaponTPPAnimationSet::PoseAdsCrouch' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, PoseAdsProne) == 0x0000F8, "Member 'UWeaponTPPAnimationSet::PoseAdsProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandToCrouch) == 0x000100, "Member 'UWeaponTPPAnimationSet::StandToCrouch' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandToProne) == 0x000108, "Member 'UWeaponTPPAnimationSet::StandToProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchToStand) == 0x000110, "Member 'UWeaponTPPAnimationSet::CrouchToStand' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchToProne) == 0x000118, "Member 'UWeaponTPPAnimationSet::CrouchToProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneToStand) == 0x000120, "Member 'UWeaponTPPAnimationSet::ProneToStand' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneToCrouch) == 0x000128, "Member 'UWeaponTPPAnimationSet::ProneToCrouch' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, DeployInheritPose) == 0x000130, "Member 'UWeaponTPPAnimationSet::DeployInheritPose' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandDeployPivot) == 0x000138, "Member 'UWeaponTPPAnimationSet::StandDeployPivot' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandBipodDeploy) == 0x000140, "Member 'UWeaponTPPAnimationSet::StandBipodDeploy' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandBipodUndeploy) == 0x000148, "Member 'UWeaponTPPAnimationSet::StandBipodUndeploy' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchBipodDeploy) == 0x000150, "Member 'UWeaponTPPAnimationSet::CrouchBipodDeploy' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchBipodUndeploy) == 0x000158, "Member 'UWeaponTPPAnimationSet::CrouchBipodUndeploy' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneBipodDeploy) == 0x000160, "Member 'UWeaponTPPAnimationSet::ProneBipodDeploy' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneBipodUndeploy) == 0x000168, "Member 'UWeaponTPPAnimationSet::ProneBipodUndeploy' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandBipodIdle) == 0x000170, "Member 'UWeaponTPPAnimationSet::StandBipodIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchBipodIdle) == 0x000178, "Member 'UWeaponTPPAnimationSet::CrouchBipodIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneBipodIdle) == 0x000180, "Member 'UWeaponTPPAnimationSet::ProneBipodIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceStandEnter) == 0x000188, "Member 'UWeaponTPPAnimationSet::BraceStandEnter' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceStandIdle) == 0x000190, "Member 'UWeaponTPPAnimationSet::BraceStandIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceStandExit) == 0x000198, "Member 'UWeaponTPPAnimationSet::BraceStandExit' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceCrouchEnter) == 0x0001A0, "Member 'UWeaponTPPAnimationSet::BraceCrouchEnter' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceCrouchIdle) == 0x0001A8, "Member 'UWeaponTPPAnimationSet::BraceCrouchIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceCrouchExit) == 0x0001B0, "Member 'UWeaponTPPAnimationSet::BraceCrouchExit' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceProneEnter) == 0x0001B8, "Member 'UWeaponTPPAnimationSet::BraceProneEnter' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceProneIdle) == 0x0001C0, "Member 'UWeaponTPPAnimationSet::BraceProneIdle' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BraceProneExit) == 0x0001C8, "Member 'UWeaponTPPAnimationSet::BraceProneExit' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BracePivotStand_R) == 0x0001D0, "Member 'UWeaponTPPAnimationSet::BracePivotStand_R' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BracePivotStand_L) == 0x0001D8, "Member 'UWeaponTPPAnimationSet::BracePivotStand_L' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BracePivotCrouch_R) == 0x0001E0, "Member 'UWeaponTPPAnimationSet::BracePivotCrouch_R' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BracePivotCrouch_L) == 0x0001E8, "Member 'UWeaponTPPAnimationSet::BracePivotCrouch_L' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BracePivotProne_R) == 0x0001F0, "Member 'UWeaponTPPAnimationSet::BracePivotProne_R' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, BracePivotProne_L) == 0x0001F8, "Member 'UWeaponTPPAnimationSet::BracePivotProne_L' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandLocomotion) == 0x000200, "Member 'UWeaponTPPAnimationSet::StandLocomotion' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandLocomotionADS) == 0x000208, "Member 'UWeaponTPPAnimationSet::StandLocomotionADS' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchLocomotion) == 0x000210, "Member 'UWeaponTPPAnimationSet::CrouchLocomotion' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchLocomotionADS) == 0x000218, "Member 'UWeaponTPPAnimationSet::CrouchLocomotionADS' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneLocomotion) == 0x000220, "Member 'UWeaponTPPAnimationSet::ProneLocomotion' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandWalkStart) == 0x000228, "Member 'UWeaponTPPAnimationSet::StandWalkStart' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandWalkStop) == 0x000230, "Member 'UWeaponTPPAnimationSet::StandWalkStop' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandJogStart) == 0x000238, "Member 'UWeaponTPPAnimationSet::StandJogStart' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandJogStop) == 0x000240, "Member 'UWeaponTPPAnimationSet::StandJogStop' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandSprintStop) == 0x000248, "Member 'UWeaponTPPAnimationSet::StandSprintStop' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchWalkStart) == 0x000250, "Member 'UWeaponTPPAnimationSet::CrouchWalkStart' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchWalkStop) == 0x000258, "Member 'UWeaponTPPAnimationSet::CrouchWalkStop' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchJogStart) == 0x000260, "Member 'UWeaponTPPAnimationSet::CrouchJogStart' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchJogStop) == 0x000268, "Member 'UWeaponTPPAnimationSet::CrouchJogStop' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchSprintStop) == 0x000270, "Member 'UWeaponTPPAnimationSet::CrouchSprintStop' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneToJog) == 0x000278, "Member 'UWeaponTPPAnimationSet::ProneToJog' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneToSprint) == 0x000280, "Member 'UWeaponTPPAnimationSet::ProneToSprint' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandSprintStopToProne) == 0x000288, "Member 'UWeaponTPPAnimationSet::StandSprintStopToProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandJogStopToProne) == 0x000290, "Member 'UWeaponTPPAnimationSet::StandJogStopToProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchSprintStopToProne) == 0x000298, "Member 'UWeaponTPPAnimationSet::CrouchSprintStopToProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchJogStopToProne) == 0x0002A0, "Member 'UWeaponTPPAnimationSet::CrouchJogStopToProne' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandVault) == 0x0002A8, "Member 'UWeaponTPPAnimationSet::StandVault' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandClimb) == 0x0002B0, "Member 'UWeaponTPPAnimationSet::StandClimb' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandLeft) == 0x0002B8, "Member 'UWeaponTPPAnimationSet::StandLeft' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, StandRight) == 0x0002C0, "Member 'UWeaponTPPAnimationSet::StandRight' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchLeft) == 0x0002C8, "Member 'UWeaponTPPAnimationSet::CrouchLeft' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, CrouchRight) == 0x0002D0, "Member 'UWeaponTPPAnimationSet::CrouchRight' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneLeft) == 0x0002D8, "Member 'UWeaponTPPAnimationSet::ProneLeft' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, ProneRight) == 0x0002E0, "Member 'UWeaponTPPAnimationSet::ProneRight' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Stand) == 0x0002E8, "Member 'UWeaponTPPAnimationSet::AO_Stand' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Crouch) == 0x0002F0, "Member 'UWeaponTPPAnimationSet::AO_Crouch' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Crouch_Moving) == 0x0002F8, "Member 'UWeaponTPPAnimationSet::AO_Crouch_Moving' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Prone) == 0x000300, "Member 'UWeaponTPPAnimationSet::AO_Prone' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Stand_ADS) == 0x000308, "Member 'UWeaponTPPAnimationSet::AO_Stand_ADS' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Crouch_ADS) == 0x000310, "Member 'UWeaponTPPAnimationSet::AO_Crouch_ADS' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Prone_ADS) == 0x000318, "Member 'UWeaponTPPAnimationSet::AO_Prone_ADS' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Stand_Sprint) == 0x000320, "Member 'UWeaponTPPAnimationSet::AO_Stand_Sprint' has a wrong offset!");
static_assert(offsetof(UWeaponTPPAnimationSet, AO_Crouch_Sprint) == 0x000328, "Member 'UWeaponTPPAnimationSet::AO_Crouch_Sprint' has a wrong offset!");

// Class HLL.WeaponFPPAnimationSet
// 0x02F8 (0x0320 - 0x0028)
class UWeaponFPPAnimationSet : public UObject
{
public:
	class UAnimSequence*                          PoseInheritance;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseIdle;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseADS;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Equip;                                             // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Fire;                                              // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Bolt;                                              // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload;                                            // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadEmpty;                                       // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ChangeBarrel;                                      // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadEnter;                                       // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadEnterWet;                                    // 0x0158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadLoop;                                        // 0x0180(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadLoopWet;                                     // 0x01A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadExit;                                        // 0x01D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadExitEmpty;                                   // 0x01F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Deploy;                                            // 0x0220(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Undeploy;                                          // 0x0248(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadDeployed;                                    // 0x0270(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadDeployedEmpty;                               // 0x0298(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ChangeBarrelDeployed;                              // 0x02C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Jump;                                              // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Vault;                                             // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Climb;                                             // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StandToProne;                                      // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ProneToStand;                                      // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Sprint;                                            // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Crawl;                                             // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponFPPAnimationSet">();
	}
	static class UWeaponFPPAnimationSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponFPPAnimationSet>();
	}
};
static_assert(alignof(UWeaponFPPAnimationSet) == 0x000008, "Wrong alignment on UWeaponFPPAnimationSet");
static_assert(sizeof(UWeaponFPPAnimationSet) == 0x000320, "Wrong size on UWeaponFPPAnimationSet");
static_assert(offsetof(UWeaponFPPAnimationSet, PoseInheritance) == 0x000028, "Member 'UWeaponFPPAnimationSet::PoseInheritance' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, PoseIdle) == 0x000030, "Member 'UWeaponFPPAnimationSet::PoseIdle' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, PoseADS) == 0x000038, "Member 'UWeaponFPPAnimationSet::PoseADS' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Equip) == 0x000040, "Member 'UWeaponFPPAnimationSet::Equip' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Fire) == 0x000068, "Member 'UWeaponFPPAnimationSet::Fire' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Bolt) == 0x000090, "Member 'UWeaponFPPAnimationSet::Bolt' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Reload) == 0x0000B8, "Member 'UWeaponFPPAnimationSet::Reload' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadEmpty) == 0x0000E0, "Member 'UWeaponFPPAnimationSet::ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ChangeBarrel) == 0x000108, "Member 'UWeaponFPPAnimationSet::ChangeBarrel' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadEnter) == 0x000130, "Member 'UWeaponFPPAnimationSet::ReloadEnter' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadEnterWet) == 0x000158, "Member 'UWeaponFPPAnimationSet::ReloadEnterWet' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadLoop) == 0x000180, "Member 'UWeaponFPPAnimationSet::ReloadLoop' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadLoopWet) == 0x0001A8, "Member 'UWeaponFPPAnimationSet::ReloadLoopWet' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadExit) == 0x0001D0, "Member 'UWeaponFPPAnimationSet::ReloadExit' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadExitEmpty) == 0x0001F8, "Member 'UWeaponFPPAnimationSet::ReloadExitEmpty' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Deploy) == 0x000220, "Member 'UWeaponFPPAnimationSet::Deploy' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Undeploy) == 0x000248, "Member 'UWeaponFPPAnimationSet::Undeploy' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadDeployed) == 0x000270, "Member 'UWeaponFPPAnimationSet::ReloadDeployed' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ReloadDeployedEmpty) == 0x000298, "Member 'UWeaponFPPAnimationSet::ReloadDeployedEmpty' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ChangeBarrelDeployed) == 0x0002C0, "Member 'UWeaponFPPAnimationSet::ChangeBarrelDeployed' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Jump) == 0x0002E8, "Member 'UWeaponFPPAnimationSet::Jump' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Vault) == 0x0002F0, "Member 'UWeaponFPPAnimationSet::Vault' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Climb) == 0x0002F8, "Member 'UWeaponFPPAnimationSet::Climb' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, StandToProne) == 0x000300, "Member 'UWeaponFPPAnimationSet::StandToProne' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, ProneToStand) == 0x000308, "Member 'UWeaponFPPAnimationSet::ProneToStand' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Sprint) == 0x000310, "Member 'UWeaponFPPAnimationSet::Sprint' has a wrong offset!");
static_assert(offsetof(UWeaponFPPAnimationSet, Crawl) == 0x000318, "Member 'UWeaponFPPAnimationSet::Crawl' has a wrong offset!");

// Class HLL.UseableWeaponFPPAnimationSet
// 0x00A8 (0x03C8 - 0x0320)
class UUseableWeaponFPPAnimationSet : public UWeaponFPPAnimationSet
{
public:
	uint8                                         bUseLoopSections : 1;                              // 0x0320(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDontWaitForLoopedSectionToEnd : 1;                // 0x0320(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_14C0[0x7];                                     // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FWeaponAnim                            Use;                                               // 0x0328(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            UseExit;                                           // 0x0350(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            UseOther;                                          // 0x0378(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            UseOtherExit;                                      // 0x03A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseableWeaponFPPAnimationSet">();
	}
	static class UUseableWeaponFPPAnimationSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUseableWeaponFPPAnimationSet>();
	}
};
static_assert(alignof(UUseableWeaponFPPAnimationSet) == 0x000008, "Wrong alignment on UUseableWeaponFPPAnimationSet");
static_assert(sizeof(UUseableWeaponFPPAnimationSet) == 0x0003C8, "Wrong size on UUseableWeaponFPPAnimationSet");
static_assert(offsetof(UUseableWeaponFPPAnimationSet, Use) == 0x000328, "Member 'UUseableWeaponFPPAnimationSet::Use' has a wrong offset!");
static_assert(offsetof(UUseableWeaponFPPAnimationSet, UseExit) == 0x000350, "Member 'UUseableWeaponFPPAnimationSet::UseExit' has a wrong offset!");
static_assert(offsetof(UUseableWeaponFPPAnimationSet, UseOther) == 0x000378, "Member 'UUseableWeaponFPPAnimationSet::UseOther' has a wrong offset!");
static_assert(offsetof(UUseableWeaponFPPAnimationSet, UseOtherExit) == 0x0003A0, "Member 'UUseableWeaponFPPAnimationSet::UseOtherExit' has a wrong offset!");

// Class HLL.VehicleDropsComponent
// 0x0068 (0x0118 - 0x00B0)
class UVehicleDropsComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSuppliesAdded;                                   // 0x00B0(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	EHint                                         OnDropsDepletedHint;                               // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C1[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         TimeToDrop;                                        // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialDropCount;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C2[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AVehicleDrop>               DropActorClass;                                    // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESupplyType                                   SupplyType;                                        // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLAchievementStat                           IncrementStat;                                     // 0x00D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C3[0x6];                                     // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             StartDroppingSound;                                // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             StoppedDroppingSound;                              // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        InputComponent;                                    // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UAudioComponent>         DroppingASC;                                       // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumRemainingDrops;                                 // 0x0100(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C4[0x14];                                    // 0x0104(0x0014)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_NumDrops(const int32 PreviousValue);
	void OnSuppliesAdded__DelegateSignature();
	void ServerDropPayload();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleDropsComponent">();
	}
	static class UVehicleDropsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleDropsComponent>();
	}
};
static_assert(alignof(UVehicleDropsComponent) == 0x000008, "Wrong alignment on UVehicleDropsComponent");
static_assert(sizeof(UVehicleDropsComponent) == 0x000118, "Wrong size on UVehicleDropsComponent");
static_assert(offsetof(UVehicleDropsComponent, OnSuppliesAdded) == 0x0000B0, "Member 'UVehicleDropsComponent::OnSuppliesAdded' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, OnDropsDepletedHint) == 0x0000C0, "Member 'UVehicleDropsComponent::OnDropsDepletedHint' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, TimeToDrop) == 0x0000C4, "Member 'UVehicleDropsComponent::TimeToDrop' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, InitialDropCount) == 0x0000C8, "Member 'UVehicleDropsComponent::InitialDropCount' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, DropActorClass) == 0x0000D0, "Member 'UVehicleDropsComponent::DropActorClass' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, SupplyType) == 0x0000D8, "Member 'UVehicleDropsComponent::SupplyType' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, IncrementStat) == 0x0000D9, "Member 'UVehicleDropsComponent::IncrementStat' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, StartDroppingSound) == 0x0000E0, "Member 'UVehicleDropsComponent::StartDroppingSound' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, StoppedDroppingSound) == 0x0000E8, "Member 'UVehicleDropsComponent::StoppedDroppingSound' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, InputComponent) == 0x0000F0, "Member 'UVehicleDropsComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, DroppingASC) == 0x0000F8, "Member 'UVehicleDropsComponent::DroppingASC' has a wrong offset!");
static_assert(offsetof(UVehicleDropsComponent, NumRemainingDrops) == 0x000100, "Member 'UVehicleDropsComponent::NumRemainingDrops' has a wrong offset!");

// Class HLL.HLLWeatherEffectInterface
// 0x0000 (0x0028 - 0x0028)
class IHLLWeatherEffectInterface final : public IInterface
{
public:
	void SetWeatherData(class UHLLWeatherScenarioData* WeatherScenarioData);
	void SetWeatherState(EWeatherIntensity WeatherIntensity);
	void SetWeatherVisibility(bool bVisible);
	void StartWeatherTransition(EWeatherIntensity CurrentIntensity, EWeatherIntensity PendingIntensity, float TransitionDuration, float StartAlpha);
	void TriggerEffectAtPosition(const struct FVector& Position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherEffectInterface">();
	}
	static class IHLLWeatherEffectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHLLWeatherEffectInterface>();
	}
};
static_assert(alignof(IHLLWeatherEffectInterface) == 0x000008, "Wrong alignment on IHLLWeatherEffectInterface");
static_assert(sizeof(IHLLWeatherEffectInterface) == 0x000028, "Wrong size on IHLLWeatherEffectInterface");

// Class HLL.HLLWeatherManagerActor
// 0x00D8 (0x02F8 - 0x0220)
class AHLLWeatherManagerActor final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             WeatherManagerInitDelegate;                        // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHLLWeatherLightningActor*              WeatherLightningActor;                             // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLWeatherManagerData*                 WeatherManagerData;                                // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeatherIntensity                             CurrentWeatherIntensity;                           // 0x0240(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C6[0xB7];                                    // 0x0241(0x00B7)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Debug_OnSimulationFinished();
	void OnCooldownFinished();
	void OnExtremeWeatherCooldownFinished();
	void OnTransitionFinished();
	void OnWarmupFinished();

	void Multicast_OnWeatherManagerInit(EWeatherIntensity InWeatherIntensity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherManagerActor">();
	}
	static class AHLLWeatherManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLWeatherManagerActor>();
	}
};
static_assert(alignof(AHLLWeatherManagerActor) == 0x000008, "Wrong alignment on AHLLWeatherManagerActor");
static_assert(sizeof(AHLLWeatherManagerActor) == 0x0002F8, "Wrong size on AHLLWeatherManagerActor");
static_assert(offsetof(AHLLWeatherManagerActor, WeatherManagerInitDelegate) == 0x000220, "Member 'AHLLWeatherManagerActor::WeatherManagerInitDelegate' has a wrong offset!");
static_assert(offsetof(AHLLWeatherManagerActor, WeatherLightningActor) == 0x000230, "Member 'AHLLWeatherManagerActor::WeatherLightningActor' has a wrong offset!");
static_assert(offsetof(AHLLWeatherManagerActor, WeatherManagerData) == 0x000238, "Member 'AHLLWeatherManagerActor::WeatherManagerData' has a wrong offset!");
static_assert(offsetof(AHLLWeatherManagerActor, CurrentWeatherIntensity) == 0x000240, "Member 'AHLLWeatherManagerActor::CurrentWeatherIntensity' has a wrong offset!");

// Class HLL.HLLWeatherScenarioData
// 0x0050 (0x0080 - 0x0030)
class UHLLWeatherScenarioData final : public UDataAsset
{
public:
	TMap<EWeatherIntensity, struct FSoftObjectPath> WeatherEffects;                                    // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherScenarioData">();
	}
	static class UHLLWeatherScenarioData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeatherScenarioData>();
	}
};
static_assert(alignof(UHLLWeatherScenarioData) == 0x000008, "Wrong alignment on UHLLWeatherScenarioData");
static_assert(sizeof(UHLLWeatherScenarioData) == 0x000080, "Wrong size on UHLLWeatherScenarioData");
static_assert(offsetof(UHLLWeatherScenarioData, WeatherEffects) == 0x000030, "Member 'UHLLWeatherScenarioData::WeatherEffects' has a wrong offset!");

// Class HLL.HLLWeatherManagerData
// 0x0230 (0x0260 - 0x0030)
class UHLLWeatherManagerData final : public UDataAsset
{
public:
	TMap<class FName, TSoftObjectPtr<class UHLLWeatherScenarioData>> WeatherEffects;                                    // 0x0030(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ParticleOcclusion;                                 // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeatherTransitionType                        TransitionType;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTransitions;                                 // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionPostWarmup;                             // 0x00AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C7[0x1];                                     // 0x00AB(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	struct FFloatRange                            TransitionTimeRange;                               // 0x00AC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            CooldownTimeRange;                                 // 0x00BC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionWeight;                                  // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHLLWeatherTransitionOverrideData      TransitionOverrideData;                            // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxExtremeWeatherOccurrances;                      // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowExtremeWeatherInWarmup;                       // 0x0124(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C8[0x3];                                     // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FFloatRange                            ExtremeWeatherCooldownTimeRange;                   // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           BaseProbabilityOverMatchTime;                      // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           DowntimeMultiplier;                                // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FFloatRange>               MultiplierForOccurrances;                          // 0x0148(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EWeatherIntensity, struct FFloatRange>   MultiplierForWeatherIntensity;                     // 0x0198(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EWeatherIntensity, struct FFloatRange>   LightningTimingForWeatherIntensity;                // 0x01E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFloatRange                            LightningInnerOuterBoundsOffsets;                  // 0x0238(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningHeightOffset;                             // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomiseStartWeatherIntensity;                   // 0x024C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeatherIntensity                             StartingWeatherIntensity;                          // 0x024D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C9[0x2];                                     // 0x024E(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FInt32Range                            IntensityStepRange;                                // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherManagerData">();
	}
	static class UHLLWeatherManagerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeatherManagerData>();
	}
};
static_assert(alignof(UHLLWeatherManagerData) == 0x000008, "Wrong alignment on UHLLWeatherManagerData");
static_assert(sizeof(UHLLWeatherManagerData) == 0x000260, "Wrong size on UHLLWeatherManagerData");
static_assert(offsetof(UHLLWeatherManagerData, WeatherEffects) == 0x000030, "Member 'UHLLWeatherManagerData::WeatherEffects' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, ParticleOcclusion) == 0x000080, "Member 'UHLLWeatherManagerData::ParticleOcclusion' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, TransitionType) == 0x0000A8, "Member 'UHLLWeatherManagerData::TransitionType' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, bAllowTransitions) == 0x0000A9, "Member 'UHLLWeatherManagerData::bAllowTransitions' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, bTransitionPostWarmup) == 0x0000AA, "Member 'UHLLWeatherManagerData::bTransitionPostWarmup' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, TransitionTimeRange) == 0x0000AC, "Member 'UHLLWeatherManagerData::TransitionTimeRange' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, CooldownTimeRange) == 0x0000BC, "Member 'UHLLWeatherManagerData::CooldownTimeRange' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, TransitionWeight) == 0x0000CC, "Member 'UHLLWeatherManagerData::TransitionWeight' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, TransitionOverrideData) == 0x0000D0, "Member 'UHLLWeatherManagerData::TransitionOverrideData' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, MaxExtremeWeatherOccurrances) == 0x000120, "Member 'UHLLWeatherManagerData::MaxExtremeWeatherOccurrances' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, AllowExtremeWeatherInWarmup) == 0x000124, "Member 'UHLLWeatherManagerData::AllowExtremeWeatherInWarmup' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, ExtremeWeatherCooldownTimeRange) == 0x000128, "Member 'UHLLWeatherManagerData::ExtremeWeatherCooldownTimeRange' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, BaseProbabilityOverMatchTime) == 0x000138, "Member 'UHLLWeatherManagerData::BaseProbabilityOverMatchTime' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, DowntimeMultiplier) == 0x000140, "Member 'UHLLWeatherManagerData::DowntimeMultiplier' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, MultiplierForOccurrances) == 0x000148, "Member 'UHLLWeatherManagerData::MultiplierForOccurrances' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, MultiplierForWeatherIntensity) == 0x000198, "Member 'UHLLWeatherManagerData::MultiplierForWeatherIntensity' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, LightningTimingForWeatherIntensity) == 0x0001E8, "Member 'UHLLWeatherManagerData::LightningTimingForWeatherIntensity' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, LightningInnerOuterBoundsOffsets) == 0x000238, "Member 'UHLLWeatherManagerData::LightningInnerOuterBoundsOffsets' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, LightningHeightOffset) == 0x000248, "Member 'UHLLWeatherManagerData::LightningHeightOffset' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, bRandomiseStartWeatherIntensity) == 0x00024C, "Member 'UHLLWeatherManagerData::bRandomiseStartWeatherIntensity' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, StartingWeatherIntensity) == 0x00024D, "Member 'UHLLWeatherManagerData::StartingWeatherIntensity' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerData, IntensityStepRange) == 0x000250, "Member 'UHLLWeatherManagerData::IntensityStepRange' has a wrong offset!");

// Class HLL.WorldMPCManagerSubsystem
// 0x0038 (0x0068 - 0x0030)
class UWorldMPCManagerSubsystem final : public UWorldSubsystem
{
public:
	TSoftObjectPtr<class UMaterialParameterCollection> RVTMPC;                                            // 0x0030(0x0028)(Transient, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollectionInstance*   RVTMPCInstance;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14CA[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMPCManagerSubsystem">();
	}
	static class UWorldMPCManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMPCManagerSubsystem>();
	}
};
static_assert(alignof(UWorldMPCManagerSubsystem) == 0x000008, "Wrong alignment on UWorldMPCManagerSubsystem");
static_assert(sizeof(UWorldMPCManagerSubsystem) == 0x000068, "Wrong size on UWorldMPCManagerSubsystem");
static_assert(offsetof(UWorldMPCManagerSubsystem, RVTMPC) == 0x000030, "Member 'UWorldMPCManagerSubsystem::RVTMPC' has a wrong offset!");
static_assert(offsetof(UWorldMPCManagerSubsystem, RVTMPCInstance) == 0x000058, "Member 'UWorldMPCManagerSubsystem::RVTMPCInstance' has a wrong offset!");

// Class HLL.HLLWeatherManagerDebugComponent
// 0x0008 (0x00B8 - 0x00B0)
class UHLLWeatherManagerDebugComponent final : public UActorComponent
{
public:
	uint8                                         Pad_14CB[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Multicast_DisplayLightningStrikeDebugPos(bool bEnable);
	void Multicast_DrawDebugForLightningArea(float LifeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherManagerDebugComponent">();
	}
	static class UHLLWeatherManagerDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeatherManagerDebugComponent>();
	}
};
static_assert(alignof(UHLLWeatherManagerDebugComponent) == 0x000008, "Wrong alignment on UHLLWeatherManagerDebugComponent");
static_assert(sizeof(UHLLWeatherManagerDebugComponent) == 0x0000B8, "Wrong size on UHLLWeatherManagerDebugComponent");

// Class HLL.HLLWeatherManagerSubsystem
// 0x0040 (0x0070 - 0x0030)
class UHLLWeatherManagerSubsystem final : public UWorldSubsystem
{
public:
	class UHLLWeatherManagerData*                 WeatherManagerData;                                // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHLLWeatherManagerActor*                WeatherManagerActor;                               // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHLLWeatherLightningActor*              WeatherLightningActor;                             // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             WeatherStateUpdatedEvent;                          // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             WeatherTransitionStartedEvent;                     // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_14CC[0x8];                                     // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherManagerSubsystem">();
	}
	static class UHLLWeatherManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeatherManagerSubsystem>();
	}
};
static_assert(alignof(UHLLWeatherManagerSubsystem) == 0x000008, "Wrong alignment on UHLLWeatherManagerSubsystem");
static_assert(sizeof(UHLLWeatherManagerSubsystem) == 0x000070, "Wrong size on UHLLWeatherManagerSubsystem");
static_assert(offsetof(UHLLWeatherManagerSubsystem, WeatherManagerData) == 0x000030, "Member 'UHLLWeatherManagerSubsystem::WeatherManagerData' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerSubsystem, WeatherManagerActor) == 0x000038, "Member 'UHLLWeatherManagerSubsystem::WeatherManagerActor' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerSubsystem, WeatherLightningActor) == 0x000040, "Member 'UHLLWeatherManagerSubsystem::WeatherLightningActor' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerSubsystem, WeatherStateUpdatedEvent) == 0x000048, "Member 'UHLLWeatherManagerSubsystem::WeatherStateUpdatedEvent' has a wrong offset!");
static_assert(offsetof(UHLLWeatherManagerSubsystem, WeatherTransitionStartedEvent) == 0x000058, "Member 'UHLLWeatherManagerSubsystem::WeatherTransitionStartedEvent' has a wrong offset!");

// Class HLL.HLLWeatherEffectsData
// 0x0050 (0x0080 - 0x0030)
class UHLLWeatherEffectsData final : public UDataAsset
{
public:
	TMap<class FName, TSubclassOf<class UObject>> WeatherEffectInterface;                            // 0x0030(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherEffectsData">();
	}
	static class UHLLWeatherEffectsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeatherEffectsData>();
	}
};
static_assert(alignof(UHLLWeatherEffectsData) == 0x000008, "Wrong alignment on UHLLWeatherEffectsData");
static_assert(sizeof(UHLLWeatherEffectsData) == 0x000080, "Wrong size on UHLLWeatherEffectsData");
static_assert(offsetof(UHLLWeatherEffectsData, WeatherEffectInterface) == 0x000030, "Member 'UHLLWeatherEffectsData::WeatherEffectInterface' has a wrong offset!");

// Class HLL.HLLWeatherVFXComponent
// 0x0040 (0x00F0 - 0x00B0)
class UHLLWeatherVFXComponent final : public UActorComponent
{
public:
	TSoftObjectPtr<class UHLLWeatherEffectsData>  WeatherEffectsData;                                // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        WeatherEffect;                                     // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14CD[0x8];                                     // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Client_OnWeatherStateUpdated(EWeatherType WeatherType, EWeatherIntensity Intensity);
	void Client_OnWeatherTransitionStarted(EWeatherIntensity CurrentIntensity, EWeatherIntensity PendingIntensity, float TransitionDuration, float StartAlpha);
	void Client_SetWeatherVisibility(const bool bVisible);
	void Multicast_InitWeatherEffects(const bool bIsTransition, const EWeatherIntensity InIntensity, const EWeatherIntensity InPendingIntensity, const float TransitionDuration, const float InAlpha);
	void Multicast_StrikeLightning(const struct FVector& LightningPosition);
	void Server_OnWeatherStateUpdated(EWeatherType WeatherType, EWeatherIntensity Intensity);
	void Server_OnWeatherTransitionStarted(EWeatherIntensity CurrentIntensity, EWeatherIntensity PendingIntensity, float TransitionDuration, float StartAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWeatherVFXComponent">();
	}
	static class UHLLWeatherVFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLWeatherVFXComponent>();
	}
};
static_assert(alignof(UHLLWeatherVFXComponent) == 0x000008, "Wrong alignment on UHLLWeatherVFXComponent");
static_assert(sizeof(UHLLWeatherVFXComponent) == 0x0000F0, "Wrong size on UHLLWeatherVFXComponent");
static_assert(offsetof(UHLLWeatherVFXComponent, WeatherEffectsData) == 0x0000B0, "Member 'UHLLWeatherVFXComponent::WeatherEffectsData' has a wrong offset!");
static_assert(offsetof(UHLLWeatherVFXComponent, WeatherEffect) == 0x0000D8, "Member 'UHLLWeatherVFXComponent::WeatherEffect' has a wrong offset!");

// Class HLL.HLLWorldSettings
// 0x0040 (0x03E0 - 0x03A0)
class AHLLWorldSettings final : public AWorldSettings
{
public:
	TSubclassOf<class UHLLMapMetaTemplate>        MapMetaData;                                       // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ScenarioToPlayInEditor;                            // 0x03A8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHLLBarbedWireVolume*                   DefaultBarbedWireVolume;                           // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AShooterWeapon>>     LoadedAxisWeapons;                                 // 0x03C0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AShooterWeapon>>     LoadedAlliedWeapons;                               // 0x03D0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	TArray<class FString> GetScenarioOptionsForWorld() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLWorldSettings">();
	}
	static class AHLLWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHLLWorldSettings>();
	}
};
static_assert(alignof(AHLLWorldSettings) == 0x000008, "Wrong alignment on AHLLWorldSettings");
static_assert(sizeof(AHLLWorldSettings) == 0x0003E0, "Wrong size on AHLLWorldSettings");
static_assert(offsetof(AHLLWorldSettings, MapMetaData) == 0x0003A0, "Member 'AHLLWorldSettings::MapMetaData' has a wrong offset!");
static_assert(offsetof(AHLLWorldSettings, ScenarioToPlayInEditor) == 0x0003A8, "Member 'AHLLWorldSettings::ScenarioToPlayInEditor' has a wrong offset!");
static_assert(offsetof(AHLLWorldSettings, DefaultBarbedWireVolume) == 0x0003B8, "Member 'AHLLWorldSettings::DefaultBarbedWireVolume' has a wrong offset!");
static_assert(offsetof(AHLLWorldSettings, LoadedAxisWeapons) == 0x0003C0, "Member 'AHLLWorldSettings::LoadedAxisWeapons' has a wrong offset!");
static_assert(offsetof(AHLLWorldSettings, LoadedAlliedWeapons) == 0x0003D0, "Member 'AHLLWorldSettings::LoadedAlliedWeapons' has a wrong offset!");

// Class HLL.HorizontalPlusFOV
// 0x0000 (0x0028 - 0x0028)
class UHorizontalPlusFOV final : public UBlueprintFunctionLibrary
{
public:
	static float CalculateAdjustedFocalLength(const float OriginalFocalLength, const float NewAspectRatio, const float NewResolutionWidth);
	static float HorFovToHorPlus(float TargetHorizontalFov, float TargetWidth, float TargetHeight, float CurrentWidth, float CurrentHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HorizontalPlusFOV">();
	}
	static class UHorizontalPlusFOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHorizontalPlusFOV>();
	}
};
static_assert(alignof(UHorizontalPlusFOV) == 0x000008, "Wrong alignment on UHorizontalPlusFOV");
static_assert(sizeof(UHorizontalPlusFOV) == 0x000028, "Wrong size on UHorizontalPlusFOV");

// Class HLL.RCONCommandSetVoteKick
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetVoteKick final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetVoteKick">();
	}
	static class URCONCommandSetVoteKick* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetVoteKick>();
	}
};
static_assert(alignof(URCONCommandSetVoteKick) == 0x000008, "Wrong alignment on URCONCommandSetVoteKick");
static_assert(sizeof(URCONCommandSetVoteKick) == 0x000028, "Wrong size on URCONCommandSetVoteKick");

// Class HLL.HoverTintedImageButton
// 0x0000 (0x0230 - 0x0230)
class UHoverTintedImageButton : public UUserWidget
{
public:
	class UButton* GetButtonWidget();
	void SetNormalContentTint(const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoverTintedImageButton">();
	}
	static class UHoverTintedImageButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoverTintedImageButton>();
	}
};
static_assert(alignof(UHoverTintedImageButton) == 0x000008, "Wrong alignment on UHoverTintedImageButton");
static_assert(sizeof(UHoverTintedImageButton) == 0x000230, "Wrong size on UHoverTintedImageButton");

// Class HLL.HTPUniformGridPanel
// 0x0018 (0x0160 - 0x0148)
class UHTPUniformGridPanel final : public UUniformGridPanel
{
public:
	uint8                                         Pad_14D1[0x8];                                     // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnAttemptToNavigatePastLeftMost;                   // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UWidget* GetChildAtRowColumn(int32 Row, int32 Column);
	void GetGridSize(int32* OutRows, int32* OutColumns);
	void NavigateGrid(int32 RowDelta, int32 ColumnDelta, class UWidget** OutWidget);
	void ResetNavigation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HTPUniformGridPanel">();
	}
	static class UHTPUniformGridPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHTPUniformGridPanel>();
	}
};
static_assert(alignof(UHTPUniformGridPanel) == 0x000008, "Wrong alignment on UHTPUniformGridPanel");
static_assert(sizeof(UHTPUniformGridPanel) == 0x000160, "Wrong size on UHTPUniformGridPanel");
static_assert(offsetof(UHTPUniformGridPanel, OnAttemptToNavigatePastLeftMost) == 0x000150, "Member 'UHTPUniformGridPanel::OnAttemptToNavigatePastLeftMost' has a wrong offset!");

// Class HLL.InfantryCarrierBoat
// 0x00E8 (0x0308 - 0x0220)
class AInfantryCarrierBoat final : public AActor
{
public:
	uint8                                         Pad_14D2[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   DriverAttachmentSocket;                            // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DriverHelmetAttachmentSocket;                      // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DoorOpeningAnimation;                              // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DoorClosingAnimation;                              // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SceneRoot;                                         // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 DriverMesh;                                        // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DriverHelmetMesh;                                  // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USmoothNetworkedMovement*               SmoothNetworkedMovement;                           // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               WaterEffectFrontLeft;                              // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               WaterEffectFrontRight;                             // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               WaterEffectMidLeft;                                // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               WaterEffectMidRight;                               // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               WaterEffectBackLeft;                               // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               WaterEffectBackRight;                              // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        EngineSound;                                       // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          VehicleBlockerAndCharacterKiller;                  // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       Path;                                              // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D3[0x20];                                    // 0x02C8(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         BoatTravelSpeed;                                   // 0x02E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentState;                                      // 0x02EC(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D4[0x4];                                     // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class ACharacter*>                     CarriedCharacters;                                 // 0x02F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_CurrentState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfantryCarrierBoat">();
	}
	static class AInfantryCarrierBoat* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInfantryCarrierBoat>();
	}
};
static_assert(alignof(AInfantryCarrierBoat) == 0x000008, "Wrong alignment on AInfantryCarrierBoat");
static_assert(sizeof(AInfantryCarrierBoat) == 0x000308, "Wrong size on AInfantryCarrierBoat");
static_assert(offsetof(AInfantryCarrierBoat, DriverAttachmentSocket) == 0x000238, "Member 'AInfantryCarrierBoat::DriverAttachmentSocket' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, DriverHelmetAttachmentSocket) == 0x000240, "Member 'AInfantryCarrierBoat::DriverHelmetAttachmentSocket' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, DoorOpeningAnimation) == 0x000248, "Member 'AInfantryCarrierBoat::DoorOpeningAnimation' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, DoorClosingAnimation) == 0x000250, "Member 'AInfantryCarrierBoat::DoorClosingAnimation' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, SceneRoot) == 0x000258, "Member 'AInfantryCarrierBoat::SceneRoot' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, Mesh) == 0x000260, "Member 'AInfantryCarrierBoat::Mesh' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, DriverMesh) == 0x000268, "Member 'AInfantryCarrierBoat::DriverMesh' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, DriverHelmetMesh) == 0x000270, "Member 'AInfantryCarrierBoat::DriverHelmetMesh' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, SmoothNetworkedMovement) == 0x000278, "Member 'AInfantryCarrierBoat::SmoothNetworkedMovement' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, WaterEffectFrontLeft) == 0x000280, "Member 'AInfantryCarrierBoat::WaterEffectFrontLeft' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, WaterEffectFrontRight) == 0x000288, "Member 'AInfantryCarrierBoat::WaterEffectFrontRight' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, WaterEffectMidLeft) == 0x000290, "Member 'AInfantryCarrierBoat::WaterEffectMidLeft' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, WaterEffectMidRight) == 0x000298, "Member 'AInfantryCarrierBoat::WaterEffectMidRight' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, WaterEffectBackLeft) == 0x0002A0, "Member 'AInfantryCarrierBoat::WaterEffectBackLeft' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, WaterEffectBackRight) == 0x0002A8, "Member 'AInfantryCarrierBoat::WaterEffectBackRight' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, EngineSound) == 0x0002B0, "Member 'AInfantryCarrierBoat::EngineSound' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, VehicleBlockerAndCharacterKiller) == 0x0002B8, "Member 'AInfantryCarrierBoat::VehicleBlockerAndCharacterKiller' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, Path) == 0x0002C0, "Member 'AInfantryCarrierBoat::Path' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, BoatTravelSpeed) == 0x0002E8, "Member 'AInfantryCarrierBoat::BoatTravelSpeed' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, CurrentState) == 0x0002EC, "Member 'AInfantryCarrierBoat::CurrentState' has a wrong offset!");
static_assert(offsetof(AInfantryCarrierBoat, CarriedCharacters) == 0x0002F8, "Member 'AInfantryCarrierBoat::CarriedCharacters' has a wrong offset!");

// Class HLL.ResourceNodeSpawner
// 0x0050 (0x0270 - 0x0220)
class AResourceNodeSpawner final : public AActor
{
public:
	struct FDataTableRowHandle                    SpawnData;                                         // 0x0220(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        DummyRoot;                                         // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SafeZone;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    SpawnBounds;                                       // 0x0240(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SafeZoneInflation;                                 // 0x024C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_RetrySpawn;                                     // 0x0250(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     RetrySpawnClass;                                   // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D5[0x10];                                    // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_SpawnBounds();
	void UpdateSafeZone(const struct FVector& Size);

	struct FVector GetDefaultSafeZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceNodeSpawner">();
	}
	static class AResourceNodeSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AResourceNodeSpawner>();
	}
};
static_assert(alignof(AResourceNodeSpawner) == 0x000008, "Wrong alignment on AResourceNodeSpawner");
static_assert(sizeof(AResourceNodeSpawner) == 0x000270, "Wrong size on AResourceNodeSpawner");
static_assert(offsetof(AResourceNodeSpawner, SpawnData) == 0x000220, "Member 'AResourceNodeSpawner::SpawnData' has a wrong offset!");
static_assert(offsetof(AResourceNodeSpawner, DummyRoot) == 0x000230, "Member 'AResourceNodeSpawner::DummyRoot' has a wrong offset!");
static_assert(offsetof(AResourceNodeSpawner, SafeZone) == 0x000238, "Member 'AResourceNodeSpawner::SafeZone' has a wrong offset!");
static_assert(offsetof(AResourceNodeSpawner, SpawnBounds) == 0x000240, "Member 'AResourceNodeSpawner::SpawnBounds' has a wrong offset!");
static_assert(offsetof(AResourceNodeSpawner, SafeZoneInflation) == 0x00024C, "Member 'AResourceNodeSpawner::SafeZoneInflation' has a wrong offset!");
static_assert(offsetof(AResourceNodeSpawner, TH_RetrySpawn) == 0x000250, "Member 'AResourceNodeSpawner::TH_RetrySpawn' has a wrong offset!");
static_assert(offsetof(AResourceNodeSpawner, RetrySpawnClass) == 0x000258, "Member 'AResourceNodeSpawner::RetrySpawnClass' has a wrong offset!");

// Class HLL.IngameCompass
// 0x0048 (0x0278 - 0x0230)
class UIngameCompass : public UUserWidget
{
public:
	uint8                                         Pad_14D6[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class USectorCompassIndicator>    SectorIndicatorClass;                              // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UObjectiveCompassIndicator> ObjectiveIndicatorClass;                           // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBaseCompassIndicator*>          ActiveIndicators;                                  // 0x0248(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           IconPanel;                                         // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CompassImage;                                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DialValue;                                         // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousPhaseID;                                   // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D7[0x4];                                     // 0x0274(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IngameCompass">();
	}
	static class UIngameCompass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIngameCompass>();
	}
};
static_assert(alignof(UIngameCompass) == 0x000008, "Wrong alignment on UIngameCompass");
static_assert(sizeof(UIngameCompass) == 0x000278, "Wrong size on UIngameCompass");
static_assert(offsetof(UIngameCompass, SectorIndicatorClass) == 0x000238, "Member 'UIngameCompass::SectorIndicatorClass' has a wrong offset!");
static_assert(offsetof(UIngameCompass, ObjectiveIndicatorClass) == 0x000240, "Member 'UIngameCompass::ObjectiveIndicatorClass' has a wrong offset!");
static_assert(offsetof(UIngameCompass, ActiveIndicators) == 0x000248, "Member 'UIngameCompass::ActiveIndicators' has a wrong offset!");
static_assert(offsetof(UIngameCompass, IconPanel) == 0x000258, "Member 'UIngameCompass::IconPanel' has a wrong offset!");
static_assert(offsetof(UIngameCompass, CompassImage) == 0x000260, "Member 'UIngameCompass::CompassImage' has a wrong offset!");
static_assert(offsetof(UIngameCompass, DialValue) == 0x000268, "Member 'UIngameCompass::DialValue' has a wrong offset!");
static_assert(offsetof(UIngameCompass, PreviousPhaseID) == 0x000270, "Member 'UIngameCompass::PreviousPhaseID' has a wrong offset!");

// Class HLL.IntenseWarfareGameMode
// 0x00B0 (0x0648 - 0x0598)
class AIntenseWarfareGameMode : public AShooterGameMode
{
public:
	uint8                                         Pad_14D8[0xB0];                                    // 0x0598(0x00B0)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntenseWarfareGameMode">();
	}
	static class AIntenseWarfareGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIntenseWarfareGameMode>();
	}
};
static_assert(alignof(AIntenseWarfareGameMode) == 0x000008, "Wrong alignment on AIntenseWarfareGameMode");
static_assert(sizeof(AIntenseWarfareGameMode) == 0x000648, "Wrong size on AIntenseWarfareGameMode");

// Class HLL.KeyBindingInputProviderListener
// 0x0000 (0x0028 - 0x0028)
class IKeyBindingInputProviderListener final : public IInterface
{
public:
	void OnKeyPressed(const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyBindingInputProviderListener">();
	}
	static class IKeyBindingInputProviderListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKeyBindingInputProviderListener>();
	}
};
static_assert(alignof(IKeyBindingInputProviderListener) == 0x000008, "Wrong alignment on IKeyBindingInputProviderListener");
static_assert(sizeof(IKeyBindingInputProviderListener) == 0x000028, "Wrong size on IKeyBindingInputProviderListener");

// Class HLL.KeyBindingInputProvider
// 0x0000 (0x0028 - 0x0028)
class IKeyBindingInputProvider final : public IInterface
{
public:
	void AddListener(const TScriptInterface<class IKeyBindingInputProviderListener>& Listener);
	void RemoveListener(const TScriptInterface<class IKeyBindingInputProviderListener>& Listener);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyBindingInputProvider">();
	}
	static class IKeyBindingInputProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKeyBindingInputProvider>();
	}
};
static_assert(alignof(IKeyBindingInputProvider) == 0x000008, "Wrong alignment on IKeyBindingInputProvider");
static_assert(sizeof(IKeyBindingInputProvider) == 0x000028, "Wrong size on IKeyBindingInputProvider");

// Class HLL.KilledInFreelookAchievement
// 0x0008 (0x0038 - 0x0030)
class UKilledInFreelookAchievement final : public UPlayerDownedAchievement
{
public:
	EHLLAchievement                               UnlockAchievement;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D9[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KilledInFreelookAchievement">();
	}
	static class UKilledInFreelookAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKilledInFreelookAchievement>();
	}
};
static_assert(alignof(UKilledInFreelookAchievement) == 0x000008, "Wrong alignment on UKilledInFreelookAchievement");
static_assert(sizeof(UKilledInFreelookAchievement) == 0x000038, "Wrong size on UKilledInFreelookAchievement");
static_assert(offsetof(UKilledInFreelookAchievement, UnlockAchievement) == 0x000030, "Member 'UKilledInFreelookAchievement::UnlockAchievement' has a wrong offset!");

// Class HLL.KillPlayerPlantingObjectiveAchievement
// 0x0008 (0x0038 - 0x0030)
class UKillPlayerPlantingObjectiveAchievement final : public UPlayerDownedAchievement
{
public:
	EHLLAchievement                               AchievementToUnlock;                               // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14DA[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillPlayerPlantingObjectiveAchievement">();
	}
	static class UKillPlayerPlantingObjectiveAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillPlayerPlantingObjectiveAchievement>();
	}
};
static_assert(alignof(UKillPlayerPlantingObjectiveAchievement) == 0x000008, "Wrong alignment on UKillPlayerPlantingObjectiveAchievement");
static_assert(sizeof(UKillPlayerPlantingObjectiveAchievement) == 0x000038, "Wrong size on UKillPlayerPlantingObjectiveAchievement");
static_assert(offsetof(UKillPlayerPlantingObjectiveAchievement, AchievementToUnlock) == 0x000030, "Member 'UKillPlayerPlantingObjectiveAchievement::AchievementToUnlock' has a wrong offset!");

// Class HLL.LeaningComponent
// 0x0018 (0x00C8 - 0x00B0)
class ULeaningComponent final : public UActorComponent
{
public:
	float                                         AngleDegrees;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanTime;                                          // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToPivot;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELeanDirection                                CurrentLeanDirection;                              // 0x00BC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14DB[0xB];                                     // 0x00BD(0x000B)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ServerStartLeaning(ELeanDirection Direction);
	void ServerStopLeaning();

	float GetCurrentAngleDegrees() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaningComponent">();
	}
	static class ULeaningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaningComponent>();
	}
};
static_assert(alignof(ULeaningComponent) == 0x000008, "Wrong alignment on ULeaningComponent");
static_assert(sizeof(ULeaningComponent) == 0x0000C8, "Wrong size on ULeaningComponent");
static_assert(offsetof(ULeaningComponent, AngleDegrees) == 0x0000B0, "Member 'ULeaningComponent::AngleDegrees' has a wrong offset!");
static_assert(offsetof(ULeaningComponent, LeanTime) == 0x0000B4, "Member 'ULeaningComponent::LeanTime' has a wrong offset!");
static_assert(offsetof(ULeaningComponent, DistanceToPivot) == 0x0000B8, "Member 'ULeaningComponent::DistanceToPivot' has a wrong offset!");
static_assert(offsetof(ULeaningComponent, CurrentLeanDirection) == 0x0000BC, "Member 'ULeaningComponent::CurrentLeanDirection' has a wrong offset!");

// Class HLL.SeedingControlPoint
// 0x00A8 (0x02E0 - 0x0238)
class ASeedingControlPoint : public AGameObjectiveBase
{
public:
	TArray<class ASeedingSubControlPoint*>        OwnedSubControlPoints;                             // 0x0238(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14DC[0x8];                                     // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   ObjectiveName;                                     // 0x0260(0x0018)(Edit, NativeAccessSpecifierPrivate)
	int32                                         SectorCaptureTime;                                 // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          SectorHoldTime;                                    // 0x027C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14DD[0x3];                                     // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         SoftCaptureControlPoints;                          // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HardCaptureControlPoints;                          // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         DefaultOwner;                                      // 0x0288(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LockDownOnCapture;                                 // 0x0289(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14DE[0x6];                                     // 0x028A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UBoxComponent*                          SoftCapturePointShape;                             // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       HardCapturePointShape;                             // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         ControllingTeam;                                   // 0x02A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         SectorCaptureTeam;                                 // 0x02A1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14DF[0x2];                                     // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         AlliedControlPoints;                               // 0x02A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AxisControlPoints;                                 // 0x02A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AlliedPopulation;                                  // 0x02AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AxisPopulation;                                    // 0x02B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AlliedProgression;                                 // 0x02B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AxisProgression;                                   // 0x02B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          CaptureHoldCompleted;                              // 0x02BC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14E0[0x3];                                     // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FPawnBoundsData>                PawnsWithinCapturePoint;                           // 0x02C0(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14E1[0x10];                                    // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CapturePointCountPopulation(int32* FriendlyCount, int32* EnemyCount);
	void MulticastObjectiveCaptured(const ETeam ObjectiveCaptureTeam);

	bool ControlPointIsBeingCaptured(ETeam* CaptureTeam) const;
	bool ControlPointIsContested() const;
	bool ControlPointIsLockedDown() const;
	float GetAlliedProgression() const;
	int32 GetAlliesControlPoints() const;
	int32 GetAxisControlPoints() const;
	float GetAxisProgression() const;
	ETeam GetDefaultOwner() const;
	int32 GetHardCaptureControlPoints() const;
	float GetHardCapturePointExtent() const;
	struct FVector GetHardCapturePointLocation() const;
	bool GetLockDownOnCapture() const;
	class FText GetObjectiveName() const;
	class FText GetPlayersCaptureStateText(const ETeam PlayersTeam) const;
	ETeam GetSectorCaptureTeam() const;
	ETeam GetSectorControllingTeam() const;
	int32 GetSoftCaptureControlPoints() const;
	struct FVector GetSoftCapturePointExtent() const;
	struct FVector GetSoftCapturePointLocation() const;
	bool IsUsingHardCapturePoint() const;
	bool IsUsingSoftcaptureArea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeedingControlPoint">();
	}
	static class ASeedingControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASeedingControlPoint>();
	}
};
static_assert(alignof(ASeedingControlPoint) == 0x000008, "Wrong alignment on ASeedingControlPoint");
static_assert(sizeof(ASeedingControlPoint) == 0x0002E0, "Wrong size on ASeedingControlPoint");
static_assert(offsetof(ASeedingControlPoint, OwnedSubControlPoints) == 0x000238, "Member 'ASeedingControlPoint::OwnedSubControlPoints' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, IndicatorComponent) == 0x000248, "Member 'ASeedingControlPoint::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, MapComponent) == 0x000250, "Member 'ASeedingControlPoint::MapComponent' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, ObjectiveName) == 0x000260, "Member 'ASeedingControlPoint::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, SectorCaptureTime) == 0x000278, "Member 'ASeedingControlPoint::SectorCaptureTime' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, SectorHoldTime) == 0x00027C, "Member 'ASeedingControlPoint::SectorHoldTime' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, SoftCaptureControlPoints) == 0x000280, "Member 'ASeedingControlPoint::SoftCaptureControlPoints' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, HardCaptureControlPoints) == 0x000284, "Member 'ASeedingControlPoint::HardCaptureControlPoints' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, DefaultOwner) == 0x000288, "Member 'ASeedingControlPoint::DefaultOwner' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, LockDownOnCapture) == 0x000289, "Member 'ASeedingControlPoint::LockDownOnCapture' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, SoftCapturePointShape) == 0x000290, "Member 'ASeedingControlPoint::SoftCapturePointShape' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, HardCapturePointShape) == 0x000298, "Member 'ASeedingControlPoint::HardCapturePointShape' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, ControllingTeam) == 0x0002A0, "Member 'ASeedingControlPoint::ControllingTeam' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, SectorCaptureTeam) == 0x0002A1, "Member 'ASeedingControlPoint::SectorCaptureTeam' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, AlliedControlPoints) == 0x0002A4, "Member 'ASeedingControlPoint::AlliedControlPoints' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, AxisControlPoints) == 0x0002A8, "Member 'ASeedingControlPoint::AxisControlPoints' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, AlliedPopulation) == 0x0002AC, "Member 'ASeedingControlPoint::AlliedPopulation' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, AxisPopulation) == 0x0002B0, "Member 'ASeedingControlPoint::AxisPopulation' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, AlliedProgression) == 0x0002B4, "Member 'ASeedingControlPoint::AlliedProgression' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, AxisProgression) == 0x0002B8, "Member 'ASeedingControlPoint::AxisProgression' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, CaptureHoldCompleted) == 0x0002BC, "Member 'ASeedingControlPoint::CaptureHoldCompleted' has a wrong offset!");
static_assert(offsetof(ASeedingControlPoint, PawnsWithinCapturePoint) == 0x0002C0, "Member 'ASeedingControlPoint::PawnsWithinCapturePoint' has a wrong offset!");

// Class HLL.LoadoutBlackList
// 0x0010 (0x0040 - 0x0030)
class ULoadoutBlackList final : public UDataAsset
{
public:
	TArray<struct FRoleBlackListData>             RoleBlackList;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutBlackList">();
	}
	static class ULoadoutBlackList* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutBlackList>();
	}
};
static_assert(alignof(ULoadoutBlackList) == 0x000008, "Wrong alignment on ULoadoutBlackList");
static_assert(sizeof(ULoadoutBlackList) == 0x000040, "Wrong size on ULoadoutBlackList");
static_assert(offsetof(ULoadoutBlackList, RoleBlackList) == 0x000030, "Member 'ULoadoutBlackList::RoleBlackList' has a wrong offset!");

// Class HLL.Luchs
// 0x0000 (0x05F8 - 0x05F8)
class ALuchs final : public ABaseTank
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Luchs">();
	}
	static class ALuchs* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALuchs>();
	}
};
static_assert(alignof(ALuchs) == 0x000008, "Wrong alignment on ALuchs");
static_assert(sizeof(ALuchs) == 0x0005F8, "Wrong size on ALuchs");

// Class HLL.M3Halftrack
// 0x0018 (0x05D0 - 0x05B8)
class AM3Halftrack final : public ABaseHalftrack
{
public:
	class UM3SuspensionComponent*                 Suspension;                                        // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHalftrackWheelsComponent*              HalftrackWheels;                                   // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTracksComponent*                       Tracks;                                            // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M3Halftrack">();
	}
	static class AM3Halftrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM3Halftrack>();
	}
};
static_assert(alignof(AM3Halftrack) == 0x000008, "Wrong alignment on AM3Halftrack");
static_assert(sizeof(AM3Halftrack) == 0x0005D0, "Wrong size on AM3Halftrack");
static_assert(offsetof(AM3Halftrack, Suspension) == 0x0005B8, "Member 'AM3Halftrack::Suspension' has a wrong offset!");
static_assert(offsetof(AM3Halftrack, HalftrackWheels) == 0x0005C0, "Member 'AM3Halftrack::HalftrackWheels' has a wrong offset!");
static_assert(offsetof(AM3Halftrack, Tracks) == 0x0005C8, "Member 'AM3Halftrack::Tracks' has a wrong offset!");

// Class HLL.M3HalftrackAnimInstance
// 0x0780 (0x1860 - 0x10E0)
class UM3HalftrackAnimInstance final : public UHalftrackAnimInstance
{
public:
	uint8                                         Pad_14E3[0x780];                                   // 0x10E0(0x0780)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M3HalftrackAnimInstance">();
	}
	static class UM3HalftrackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UM3HalftrackAnimInstance>();
	}
};
static_assert(alignof(UM3HalftrackAnimInstance) == 0x000010, "Wrong alignment on UM3HalftrackAnimInstance");
static_assert(sizeof(UM3HalftrackAnimInstance) == 0x001860, "Wrong size on UM3HalftrackAnimInstance");

// Class HLL.HLLSuicideDamage_FastRedeploy
// 0x0000 (0x01E8 - 0x01E8)
class UHLLSuicideDamage_FastRedeploy final : public UHLLSuicideDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLSuicideDamage_FastRedeploy">();
	}
	static class UHLLSuicideDamage_FastRedeploy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLSuicideDamage_FastRedeploy>();
	}
};
static_assert(alignof(UHLLSuicideDamage_FastRedeploy) == 0x000008, "Wrong alignment on UHLLSuicideDamage_FastRedeploy");
static_assert(sizeof(UHLLSuicideDamage_FastRedeploy) == 0x0001E8, "Wrong size on UHLLSuicideDamage_FastRedeploy");

// Class HLL.M3SuspensionComponent
// 0x00F0 (0x01A0 - 0x00B0)
class UM3SuspensionComponent final : public UActorComponent
{
public:
	uint8                                         bEnabled : 1;                                      // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_14E4[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FM3SuspensionSideSetup                 LeftSideSetup;                                     // 0x00B4(0x0060)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FM3SuspensionSideSetup                 RightSideSetup;                                    // 0x0114(0x0060)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BogieArmLength;                                    // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BogieWheelRadius;                                  // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BogieFrameHalfLength;                              // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E5[0x20];                                    // 0x0180(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M3SuspensionComponent">();
	}
	static class UM3SuspensionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UM3SuspensionComponent>();
	}
};
static_assert(alignof(UM3SuspensionComponent) == 0x000008, "Wrong alignment on UM3SuspensionComponent");
static_assert(sizeof(UM3SuspensionComponent) == 0x0001A0, "Wrong size on UM3SuspensionComponent");
static_assert(offsetof(UM3SuspensionComponent, LeftSideSetup) == 0x0000B4, "Member 'UM3SuspensionComponent::LeftSideSetup' has a wrong offset!");
static_assert(offsetof(UM3SuspensionComponent, RightSideSetup) == 0x000114, "Member 'UM3SuspensionComponent::RightSideSetup' has a wrong offset!");
static_assert(offsetof(UM3SuspensionComponent, BogieArmLength) == 0x000174, "Member 'UM3SuspensionComponent::BogieArmLength' has a wrong offset!");
static_assert(offsetof(UM3SuspensionComponent, BogieWheelRadius) == 0x000178, "Member 'UM3SuspensionComponent::BogieWheelRadius' has a wrong offset!");
static_assert(offsetof(UM3SuspensionComponent, BogieFrameHalfLength) == 0x00017C, "Member 'UM3SuspensionComponent::BogieFrameHalfLength' has a wrong offset!");

// Class HLL.MachineGunTripod
// 0x0078 (0x0298 - 0x0220)
class AMachineGunTripod final : public AActor
{
public:
	uint8                                         Pad_14E6[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AMachineGunTripodGunnerSeat> GunnerSeatClass;                                   // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHLLArmourMetaData                     ArmourMetaData;                                    // 0x0240(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14E7[0x7];                                     // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourInventory*                    ArmourInventoryComponent;                          // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLArmourHealthComponent*              ArmourHealthComponent;                             // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehicleMGController*                   MachineGunControllerComponent;                     // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMachineGunTripodGunnerSeat*            GunnerSeat;                                        // 0x0290(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_GunnerSeat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MachineGunTripod">();
	}
	static class AMachineGunTripod* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMachineGunTripod>();
	}
};
static_assert(alignof(AMachineGunTripod) == 0x000008, "Wrong alignment on AMachineGunTripod");
static_assert(sizeof(AMachineGunTripod) == 0x000298, "Wrong size on AMachineGunTripod");
static_assert(offsetof(AMachineGunTripod, GunnerSeatClass) == 0x000238, "Member 'AMachineGunTripod::GunnerSeatClass' has a wrong offset!");
static_assert(offsetof(AMachineGunTripod, ArmourMetaData) == 0x000240, "Member 'AMachineGunTripod::ArmourMetaData' has a wrong offset!");
static_assert(offsetof(AMachineGunTripod, Team) == 0x000268, "Member 'AMachineGunTripod::Team' has a wrong offset!");
static_assert(offsetof(AMachineGunTripod, SkeletalMeshComponent) == 0x000270, "Member 'AMachineGunTripod::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AMachineGunTripod, ArmourInventoryComponent) == 0x000278, "Member 'AMachineGunTripod::ArmourInventoryComponent' has a wrong offset!");
static_assert(offsetof(AMachineGunTripod, ArmourHealthComponent) == 0x000280, "Member 'AMachineGunTripod::ArmourHealthComponent' has a wrong offset!");
static_assert(offsetof(AMachineGunTripod, MachineGunControllerComponent) == 0x000288, "Member 'AMachineGunTripod::MachineGunControllerComponent' has a wrong offset!");
static_assert(offsetof(AMachineGunTripod, GunnerSeat) == 0x000290, "Member 'AMachineGunTripod::GunnerSeat' has a wrong offset!");

// Class HLL.MachineGunTripodAnimInstance
// 0x0710 (0x0980 - 0x0270)
class UMachineGunTripodAnimInstance final : public UAnimInstance
{
public:
	uint8                                         Pad_14E8[0x710];                                   // 0x0270(0x0710)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MachineGunTripodAnimInstance">();
	}
	static class UMachineGunTripodAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMachineGunTripodAnimInstance>();
	}
};
static_assert(alignof(UMachineGunTripodAnimInstance) == 0x000010, "Wrong alignment on UMachineGunTripodAnimInstance");
static_assert(sizeof(UMachineGunTripodAnimInstance) == 0x000980, "Wrong size on UMachineGunTripodAnimInstance");

// Class HLL.MachineGunTripodGunnerSeat
// 0x0020 (0x09F0 - 0x09D0)
class AMachineGunTripodGunnerSeat final : public AVehicleSeatBase
{
public:
	uint8                                         Pad_14E9[0x8];                                     // 0x09C8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<TSubclassOf<class AShooterWeapon>>     SupportedWeapons;                                  // 0x09D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehicleMGController*                   MachineGunController;                              // 0x09E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14EA[0x8];                                     // 0x09E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Server_UpdateMachineGunRotation(const uint16 PackedRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MachineGunTripodGunnerSeat">();
	}
	static class AMachineGunTripodGunnerSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMachineGunTripodGunnerSeat>();
	}
};
static_assert(alignof(AMachineGunTripodGunnerSeat) == 0x000010, "Wrong alignment on AMachineGunTripodGunnerSeat");
static_assert(sizeof(AMachineGunTripodGunnerSeat) == 0x0009F0, "Wrong size on AMachineGunTripodGunnerSeat");
static_assert(offsetof(AMachineGunTripodGunnerSeat, SupportedWeapons) == 0x0009D0, "Member 'AMachineGunTripodGunnerSeat::SupportedWeapons' has a wrong offset!");
static_assert(offsetof(AMachineGunTripodGunnerSeat, MachineGunController) == 0x0009E0, "Member 'AMachineGunTripodGunnerSeat::MachineGunController' has a wrong offset!");

// Class HLL.ServerClientTestComponent
// 0x0000 (0x00B0 - 0x00B0)
class UServerClientTestComponent final : public UActorComponent
{
public:
	void ServerReportBoolResult(const class FString& Param_Name, bool Result);
	void ServerReportFloatResult(const class FString& Param_Name, float Result);
	void ServerReportStringResult(const class FString& Param_Name, const class FString& Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerClientTestComponent">();
	}
	static class UServerClientTestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerClientTestComponent>();
	}
};
static_assert(alignof(UServerClientTestComponent) == 0x000008, "Wrong alignment on UServerClientTestComponent");
static_assert(sizeof(UServerClientTestComponent) == 0x0000B0, "Wrong size on UServerClientTestComponent");

// Class HLL.MapExplorerSubsystem
// 0x0028 (0x0058 - 0x0030)
class UMapExplorerSubsystem final : public UGameInstanceSubsystem
{
public:
	struct FSoftObjectPath                        ServerBrowserInfoTablePath;                        // 0x0030(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FMapExplorerData>               ExplorerMaps;                                      // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapExplorerSubsystem">();
	}
	static class UMapExplorerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapExplorerSubsystem>();
	}
};
static_assert(alignof(UMapExplorerSubsystem) == 0x000008, "Wrong alignment on UMapExplorerSubsystem");
static_assert(sizeof(UMapExplorerSubsystem) == 0x000058, "Wrong size on UMapExplorerSubsystem");
static_assert(offsetof(UMapExplorerSubsystem, ServerBrowserInfoTablePath) == 0x000030, "Member 'UMapExplorerSubsystem::ServerBrowserInfoTablePath' has a wrong offset!");
static_assert(offsetof(UMapExplorerSubsystem, ExplorerMaps) == 0x000048, "Member 'UMapExplorerSubsystem::ExplorerMaps' has a wrong offset!");

// Class HLL.MapIconButton
// 0x0020 (0x0458 - 0x0438)
class UMapIconButton final : public UButton
{
public:
	uint8                                         Pad_14ED[0x20];                                    // 0x0438(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconButton">();
	}
	static class UMapIconButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapIconButton>();
	}
};
static_assert(alignof(UMapIconButton) == 0x000008, "Wrong alignment on UMapIconButton");
static_assert(sizeof(UMapIconButton) == 0x000458, "Wrong size on UMapIconButton");

// Class HLL.ShooterGameInstance
// 0x0610 (0x07C0 - 0x01B0)
class UShooterGameInstance : public UGameInstance
{
public:
	FMulticastInlineDelegateProperty_             RconStatePostInitialisedEvent;                     // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUserEntitlementsQueried;                         // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPendingReceivedInvitesUpdated_BP;                // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPendingReceivedInvitesReceivedNew_BP;            // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_14EE[0x8];                                     // 0x01F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnServerQueueFrontendCreated;                      // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_14EF[0x8];                                     // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 WelcomeScreenMap;                                  // 0x0210(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MainMenuMap;                                       // 0x0220(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 WarRoomMap;                                        // 0x0230(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MainMenuMap_Pre_EF;                                // 0x0240(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F0[0x190];                                   // 0x0250(0x0190)(Fixing Size After Last Property [ Dumper-69 ])
	class UEosPlatformSession*                    PendingInviteEosPlatformSession;                   // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEosNativeSession*                      PendingInviteEosNativeSession;                     // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F1[0x100];                                   // 0x03F0(0x0100)(Fixing Size After Last Property [ Dumper-69 ])
	class UServerPasswordEntryWidget*             InviteServerPasswordEntryWidget;                   // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FPurchaseContentInfo> CachedPurchaseReceipts;                            // 0x04F8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F2[0x8];                                     // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class AServerQueueFrontend*                   CurrentServerQueueFrontend;                        // 0x0550(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F3[0x118];                                   // 0x0558(0x0118)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnLeaveServerQueuePrompt;                          // 0x0670(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMapLoadingScreenData*                  MapLoadingData;                                    // 0x0680(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadingScreensData*                    LoadingScreensData;                                // 0x0688(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F4[0x60];                                    // 0x0690(0x0060)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FNewRconConnectionData>         M_pendingRconActors;                               // 0x06F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F5[0x18];                                    // 0x0700(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLOnlineStatsManager*                 StatManager;                                       // 0x0718(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLCosmeticManager*                    CosmeticManager;                                   // 0x0720(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UServerQueue*                           ServerQueue;                                       // 0x0728(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHintsAndTips*                          HintsAndTips;                                      // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F6[0x18];                                    // 0x0738(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TSoftClassPtr<class UClass>                   MaterialManagerClass;                              // 0x0750(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMaterialManager*                    MaterialManager;                                   // 0x0778(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F7[0x18];                                    // 0x0780(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLConsoleUIManager*                   UIManager;                                         // 0x0798(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F8[0x20];                                    // 0x07A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static void AddInputDeviceChangedDelegate(const class UObject* WorldContextObject, TDelegate<void(bool bIsGamepad)> Delegate);
	static void CreateHapticFeedbackAsset(const class FString& Folder, const class FString& Param_Name);
	static bool GamepadScroll(const struct FAnalogInputEvent& InAnalogInputEvent, class UScrollBox* ScrollBox);
	static bool HasPassedWelcomeScreen(const class UObject* WorldContextObject);
	static bool IsAllContentDisabled(const struct FConsoleRequiredContentFlag& Contents);
	static bool IsAnyContentDisabled(const struct FConsoleRequiredContentFlag& Contents);
	static bool IsUsingGamepad(const class UObject* WorldContextObject);
	static bool IsUsingNewUISystem();
	static void PassWelcomeScreen(const class UObject* WorldContextObject);
	static void RemoveInputDeviceChangedDelegate(const class UObject* WorldContextObject, TDelegate<void(bool bIsGamepad)> Delegate);

	void CallLeaveServerQueue();
	void ConfirmLeavingQueue();
	void DisplayIsUserOnline();
	class FString GetMainMenuMap();
	void JACH_END();
	void JACH_Increment(const class FString& String);
	void JACH_Reset();
	void JACH_Set(const class FString& String);
	void JACH_Unlock(const class FString& String);
	void JPAD_GREEN();
	void JPAD_RED();
	void LeaveServer(class ULocalPlayer* Quitter);
	void OnControllerConnectionChange(bool bIsConnection, int32 GameUserIndex);
	void OnPendingReceivedInvitesReceivedNew_BP__DelegateSignature();
	void OnPendingReceivedInvitesUpdated_BP__DelegateSignature();
	void OnUserEntitlementsQueried__DelegateSignature();
	void OpenLevelWithLoadingScreen(const class FString& LevelUrl);
	void RconStatePostInitialisedHandler__DelegateSignature(class AHLLRconState* RconState);
	void ServerQueueFrontendCreated__DelegateSignature();
	void SetLoadingScreenVisibleBool(bool bVisibleOrRecent);
	void StartListenServer(const class FString& LevelUrl);

	class AServerQueueFrontend* GetServerQueueFrontend() const;
	class FString GetWarRoomMapPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameInstance">();
	}
	static class UShooterGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameInstance>();
	}
};
static_assert(alignof(UShooterGameInstance) == 0x000008, "Wrong alignment on UShooterGameInstance");
static_assert(sizeof(UShooterGameInstance) == 0x0007C0, "Wrong size on UShooterGameInstance");
static_assert(offsetof(UShooterGameInstance, RconStatePostInitialisedEvent) == 0x0001B0, "Member 'UShooterGameInstance::RconStatePostInitialisedEvent' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, OnUserEntitlementsQueried) == 0x0001C0, "Member 'UShooterGameInstance::OnUserEntitlementsQueried' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, OnPendingReceivedInvitesUpdated_BP) == 0x0001D0, "Member 'UShooterGameInstance::OnPendingReceivedInvitesUpdated_BP' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, OnPendingReceivedInvitesReceivedNew_BP) == 0x0001E0, "Member 'UShooterGameInstance::OnPendingReceivedInvitesReceivedNew_BP' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, OnServerQueueFrontendCreated) == 0x0001F8, "Member 'UShooterGameInstance::OnServerQueueFrontendCreated' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, WelcomeScreenMap) == 0x000210, "Member 'UShooterGameInstance::WelcomeScreenMap' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, MainMenuMap) == 0x000220, "Member 'UShooterGameInstance::MainMenuMap' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, WarRoomMap) == 0x000230, "Member 'UShooterGameInstance::WarRoomMap' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, MainMenuMap_Pre_EF) == 0x000240, "Member 'UShooterGameInstance::MainMenuMap_Pre_EF' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, PendingInviteEosPlatformSession) == 0x0003E0, "Member 'UShooterGameInstance::PendingInviteEosPlatformSession' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, PendingInviteEosNativeSession) == 0x0003E8, "Member 'UShooterGameInstance::PendingInviteEosNativeSession' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, InviteServerPasswordEntryWidget) == 0x0004F0, "Member 'UShooterGameInstance::InviteServerPasswordEntryWidget' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, CachedPurchaseReceipts) == 0x0004F8, "Member 'UShooterGameInstance::CachedPurchaseReceipts' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, CurrentServerQueueFrontend) == 0x000550, "Member 'UShooterGameInstance::CurrentServerQueueFrontend' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, OnLeaveServerQueuePrompt) == 0x000670, "Member 'UShooterGameInstance::OnLeaveServerQueuePrompt' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, MapLoadingData) == 0x000680, "Member 'UShooterGameInstance::MapLoadingData' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, LoadingScreensData) == 0x000688, "Member 'UShooterGameInstance::LoadingScreensData' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, M_pendingRconActors) == 0x0006F0, "Member 'UShooterGameInstance::M_pendingRconActors' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, StatManager) == 0x000718, "Member 'UShooterGameInstance::StatManager' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, CosmeticManager) == 0x000720, "Member 'UShooterGameInstance::CosmeticManager' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, ServerQueue) == 0x000728, "Member 'UShooterGameInstance::ServerQueue' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, HintsAndTips) == 0x000730, "Member 'UShooterGameInstance::HintsAndTips' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, MaterialManagerClass) == 0x000750, "Member 'UShooterGameInstance::MaterialManagerClass' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, MaterialManager) == 0x000778, "Member 'UShooterGameInstance::MaterialManager' has a wrong offset!");
static_assert(offsetof(UShooterGameInstance, UIManager) == 0x000798, "Member 'UShooterGameInstance::UIManager' has a wrong offset!");

// Class HLL.MapLayoutMetaDataAsset
// 0x0068 (0x0098 - 0x0030)
class UMapLayoutMetaDataAsset final : public UDataAsset
{
public:
	struct FVector2D                              MapCentre;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorWidth;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorHeight;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MapWidth;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MapHeight;                                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInitialMapZoomLevel;                           // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14FF[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         InitialMapZoomLevel;                               // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMapOrientation                               AlliesOrientation;                                 // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideWarmUpBoundsVolume;                       // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1500[0x2];                                     // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              WarmUpVolumeSize;                                  // 0x0054(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              WarmUpVolumePosition;                              // 0x005C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1501[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSoftObjectPtr<class UTexture2D>              OverviewImage;                                     // 0x0068(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CompassOffset;                                     // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1502[0x4];                                     // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	EMapOrientation GetAlliesOrientation() const;
	float GetCompassOffset() const;
	int32 GetInitialMapZoomLevel() const;
	struct FVector2D GetMapCentre() const;
	int32 GetMapHeight() const;
	int32 GetMapWidth() const;
	bool GetOverrideWarmUpBoundsVolume() const;
	TSoftObjectPtr<class UTexture2D> GetOverviewImage() const;
	float GetSectorHeight() const;
	float GetSectorWidth() const;
	bool GetUseInitialMapZoomLevel() const;
	struct FVector2D GetWarmUpVolumePosition() const;
	struct FVector2D GetWarmUpVolumeSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapLayoutMetaDataAsset">();
	}
	static class UMapLayoutMetaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapLayoutMetaDataAsset>();
	}
};
static_assert(alignof(UMapLayoutMetaDataAsset) == 0x000008, "Wrong alignment on UMapLayoutMetaDataAsset");
static_assert(sizeof(UMapLayoutMetaDataAsset) == 0x000098, "Wrong size on UMapLayoutMetaDataAsset");
static_assert(offsetof(UMapLayoutMetaDataAsset, MapCentre) == 0x000030, "Member 'UMapLayoutMetaDataAsset::MapCentre' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, SectorWidth) == 0x000038, "Member 'UMapLayoutMetaDataAsset::SectorWidth' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, SectorHeight) == 0x00003C, "Member 'UMapLayoutMetaDataAsset::SectorHeight' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, MapWidth) == 0x000040, "Member 'UMapLayoutMetaDataAsset::MapWidth' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, MapHeight) == 0x000044, "Member 'UMapLayoutMetaDataAsset::MapHeight' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, bUseInitialMapZoomLevel) == 0x000048, "Member 'UMapLayoutMetaDataAsset::bUseInitialMapZoomLevel' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, InitialMapZoomLevel) == 0x00004C, "Member 'UMapLayoutMetaDataAsset::InitialMapZoomLevel' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, AlliesOrientation) == 0x000050, "Member 'UMapLayoutMetaDataAsset::AlliesOrientation' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, bOverrideWarmUpBoundsVolume) == 0x000051, "Member 'UMapLayoutMetaDataAsset::bOverrideWarmUpBoundsVolume' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, WarmUpVolumeSize) == 0x000054, "Member 'UMapLayoutMetaDataAsset::WarmUpVolumeSize' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, WarmUpVolumePosition) == 0x00005C, "Member 'UMapLayoutMetaDataAsset::WarmUpVolumePosition' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, OverviewImage) == 0x000068, "Member 'UMapLayoutMetaDataAsset::OverviewImage' has a wrong offset!");
static_assert(offsetof(UMapLayoutMetaDataAsset, CompassOffset) == 0x000090, "Member 'UMapLayoutMetaDataAsset::CompassOffset' has a wrong offset!");

// Class HLL.MapLoadingScreenData
// 0x0130 (0x0160 - 0x0030)
class UMapLoadingScreenData final : public UDataAsset
{
public:
	class FText                                   MapName;                                           // 0x0030(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Date;                                              // 0x0048(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Location;                                          // 0x0060(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Coordinates;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   TimeOfDay;                                         // 0x0090(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TimeOfDayIcon;                                     // 0x00A8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Weather;                                           // 0x00D0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              WeatherIcon;                                       // 0x00E8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           Hints;                                             // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   GameMode;                                          // 0x0120(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BackgroundImage;                                   // 0x0138(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapLoadingScreenData">();
	}
	static class UMapLoadingScreenData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapLoadingScreenData>();
	}
};
static_assert(alignof(UMapLoadingScreenData) == 0x000008, "Wrong alignment on UMapLoadingScreenData");
static_assert(sizeof(UMapLoadingScreenData) == 0x000160, "Wrong size on UMapLoadingScreenData");
static_assert(offsetof(UMapLoadingScreenData, MapName) == 0x000030, "Member 'UMapLoadingScreenData::MapName' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, Date) == 0x000048, "Member 'UMapLoadingScreenData::Date' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, Location) == 0x000060, "Member 'UMapLoadingScreenData::Location' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, Coordinates) == 0x000078, "Member 'UMapLoadingScreenData::Coordinates' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, TimeOfDay) == 0x000090, "Member 'UMapLoadingScreenData::TimeOfDay' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, TimeOfDayIcon) == 0x0000A8, "Member 'UMapLoadingScreenData::TimeOfDayIcon' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, Weather) == 0x0000D0, "Member 'UMapLoadingScreenData::Weather' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, WeatherIcon) == 0x0000E8, "Member 'UMapLoadingScreenData::WeatherIcon' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, Hints) == 0x000110, "Member 'UMapLoadingScreenData::Hints' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, GameMode) == 0x000120, "Member 'UMapLoadingScreenData::GameMode' has a wrong offset!");
static_assert(offsetof(UMapLoadingScreenData, BackgroundImage) == 0x000138, "Member 'UMapLoadingScreenData::BackgroundImage' has a wrong offset!");

// Class HLL.LoadingScreensData
// 0x0308 (0x0338 - 0x0030)
class ULoadingScreensData final : public UDataAsset
{
public:
	struct FSlateColor                            BackgroundBrushColor;                              // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ImagePannerMaterial;                               // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ImageDarkeningBrushColor;                          // 0x0060(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     VignetteMaterial;                                  // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            VignetteImageColor;                                // 0x0090(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TextGritMaterial;                                  // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            TextGritColor;                                     // 0x00C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ScratchesMaterial;                                 // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ScratchesColor;                                    // 0x00F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            GameModeColor;                                     // 0x0118(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         GameModeFont;                                      // 0x0140(0x0050)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            MapNameColor;                                      // 0x0190(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         MapNameFont;                                       // 0x01B8(0x0050)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            DateColor;                                         // 0x0208(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         DateFont;                                          // 0x0230(0x0050)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            LocationColor;                                     // 0x0280(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         LocationFont;                                      // 0x02A8(0x0050)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            DateLocationSeparatorLineColor;                    // 0x02F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             ThrobberImage;                                     // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MapDataTable;                                      // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             NonMapDataTable;                                   // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreensData">();
	}
	static class ULoadingScreensData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreensData>();
	}
};
static_assert(alignof(ULoadingScreensData) == 0x000008, "Wrong alignment on ULoadingScreensData");
static_assert(sizeof(ULoadingScreensData) == 0x000338, "Wrong size on ULoadingScreensData");
static_assert(offsetof(ULoadingScreensData, BackgroundBrushColor) == 0x000030, "Member 'ULoadingScreensData::BackgroundBrushColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, ImagePannerMaterial) == 0x000058, "Member 'ULoadingScreensData::ImagePannerMaterial' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, ImageDarkeningBrushColor) == 0x000060, "Member 'ULoadingScreensData::ImageDarkeningBrushColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, VignetteMaterial) == 0x000088, "Member 'ULoadingScreensData::VignetteMaterial' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, VignetteImageColor) == 0x000090, "Member 'ULoadingScreensData::VignetteImageColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, TextGritMaterial) == 0x0000B8, "Member 'ULoadingScreensData::TextGritMaterial' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, TextGritColor) == 0x0000C0, "Member 'ULoadingScreensData::TextGritColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, ScratchesMaterial) == 0x0000E8, "Member 'ULoadingScreensData::ScratchesMaterial' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, ScratchesColor) == 0x0000F0, "Member 'ULoadingScreensData::ScratchesColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, GameModeColor) == 0x000118, "Member 'ULoadingScreensData::GameModeColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, GameModeFont) == 0x000140, "Member 'ULoadingScreensData::GameModeFont' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, MapNameColor) == 0x000190, "Member 'ULoadingScreensData::MapNameColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, MapNameFont) == 0x0001B8, "Member 'ULoadingScreensData::MapNameFont' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, DateColor) == 0x000208, "Member 'ULoadingScreensData::DateColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, DateFont) == 0x000230, "Member 'ULoadingScreensData::DateFont' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, LocationColor) == 0x000280, "Member 'ULoadingScreensData::LocationColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, LocationFont) == 0x0002A8, "Member 'ULoadingScreensData::LocationFont' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, DateLocationSeparatorLineColor) == 0x0002F8, "Member 'ULoadingScreensData::DateLocationSeparatorLineColor' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, ThrobberImage) == 0x000320, "Member 'ULoadingScreensData::ThrobberImage' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, MapDataTable) == 0x000328, "Member 'ULoadingScreensData::MapDataTable' has a wrong offset!");
static_assert(offsetof(ULoadingScreensData, NonMapDataTable) == 0x000330, "Member 'ULoadingScreensData::NonMapDataTable' has a wrong offset!");

// Class HLL.MapLoadingSubsystem
// 0x00E0 (0x0110 - 0x0030)
class UMapLoadingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_1503[0xB0];                                    // 0x0030(0x00B0)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UMapMetaDataAsset*>              LoadedMapMetas;                                    // 0x00E0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1504[0x20];                                    // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void LoadAdditionalLevelsForCurrentMap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapLoadingSubsystem">();
	}
	static class UMapLoadingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapLoadingSubsystem>();
	}
};
static_assert(alignof(UMapLoadingSubsystem) == 0x000008, "Wrong alignment on UMapLoadingSubsystem");
static_assert(sizeof(UMapLoadingSubsystem) == 0x000110, "Wrong size on UMapLoadingSubsystem");
static_assert(offsetof(UMapLoadingSubsystem, LoadedMapMetas) == 0x0000E0, "Member 'UMapLoadingSubsystem::LoadedMapMetas' has a wrong offset!");

// Class HLL.RCONCommandSetAllowCheats
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetAllowCheats final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetAllowCheats">();
	}
	static class URCONCommandSetAllowCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetAllowCheats>();
	}
};
static_assert(alignof(URCONCommandSetAllowCheats) == 0x000008, "Wrong alignment on URCONCommandSetAllowCheats");
static_assert(sizeof(URCONCommandSetAllowCheats) == 0x000028, "Wrong size on URCONCommandSetAllowCheats");

// Class HLL.MapMeta
// 0x0048 (0x0070 - 0x0028)
class UMapMeta final : public UObject
{
public:
	uint8                                         Pad_1505[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TScriptInterface<class IMapMetaSetupData>     SetupData;                                         // 0x0030(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1506[0x30];                                    // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UHLLWeatherManagerData* GetWeatherManagerData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMeta">();
	}
	static class UMapMeta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMeta>();
	}
};
static_assert(alignof(UMapMeta) == 0x000008, "Wrong alignment on UMapMeta");
static_assert(sizeof(UMapMeta) == 0x000070, "Wrong size on UMapMeta");
static_assert(offsetof(UMapMeta, SetupData) == 0x000030, "Member 'UMapMeta::SetupData' has a wrong offset!");

// Class HLL.MapMetaDataAsset
// 0x0080 (0x00B0 - 0x0030)
class UMapMetaDataAsset final : public UDataAsset
{
public:
	uint8                                         Pad_1507[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   MapFriendlyName;                                   // 0x0038(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FString                                 MapId;                                             // 0x0050(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFaction                                      AxisFaction;                                       // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFaction                                      AlliesFaction;                                     // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIncrementMapAchievement;                          // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHLLAchievementStat                           AchievementStat;                                   // 0x0063(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1508[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UMapSpecificAchievements*               MapSpecificAchievements;                           // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProhibitedAchievementsData*            ProhibitedAchievementsData;                        // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UScenarioMetaDataAsset*>         Scenarios;                                         // 0x0078(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScenarioMetaDataAsset*                 CurrentScenario;                                   // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1509[0x20];                                    // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMetaDataAsset">();
	}
	static class UMapMetaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMetaDataAsset>();
	}
};
static_assert(alignof(UMapMetaDataAsset) == 0x000008, "Wrong alignment on UMapMetaDataAsset");
static_assert(sizeof(UMapMetaDataAsset) == 0x0000B0, "Wrong size on UMapMetaDataAsset");
static_assert(offsetof(UMapMetaDataAsset, MapFriendlyName) == 0x000038, "Member 'UMapMetaDataAsset::MapFriendlyName' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, MapId) == 0x000050, "Member 'UMapMetaDataAsset::MapId' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, AxisFaction) == 0x000060, "Member 'UMapMetaDataAsset::AxisFaction' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, AlliesFaction) == 0x000061, "Member 'UMapMetaDataAsset::AlliesFaction' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, bIncrementMapAchievement) == 0x000062, "Member 'UMapMetaDataAsset::bIncrementMapAchievement' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, AchievementStat) == 0x000063, "Member 'UMapMetaDataAsset::AchievementStat' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, MapSpecificAchievements) == 0x000068, "Member 'UMapMetaDataAsset::MapSpecificAchievements' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, ProhibitedAchievementsData) == 0x000070, "Member 'UMapMetaDataAsset::ProhibitedAchievementsData' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, Scenarios) == 0x000078, "Member 'UMapMetaDataAsset::Scenarios' has a wrong offset!");
static_assert(offsetof(UMapMetaDataAsset, CurrentScenario) == 0x000088, "Member 'UMapMetaDataAsset::CurrentScenario' has a wrong offset!");

// Class HLL.MapMetaSetupData
// 0x0000 (0x0028 - 0x0028)
class IMapMetaSetupData final : public IInterface
{
public:
	const class FText GetMapFriendlyName() const;
	class FString GetMapId() const;
	class USoundCue* GetMapMetaDataAmbientSound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMetaSetupData">();
	}
	static class IMapMetaSetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMapMetaSetupData>();
	}
};
static_assert(alignof(IMapMetaSetupData) == 0x000008, "Wrong alignment on IMapMetaSetupData");
static_assert(sizeof(IMapMetaSetupData) == 0x000028, "Wrong size on IMapMetaSetupData");

// Class HLL.MapMetaSubsystem
// 0x0020 (0x0050 - 0x0030)
class UMapMetaSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_150A[0x18];                                    // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UMapMeta*                               MapMeta;                                           // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMetaSubsystem">();
	}
	static class UMapMetaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMetaSubsystem>();
	}
};
static_assert(alignof(UMapMetaSubsystem) == 0x000008, "Wrong alignment on UMapMetaSubsystem");
static_assert(sizeof(UMapMetaSubsystem) == 0x000050, "Wrong size on UMapMetaSubsystem");
static_assert(offsetof(UMapMetaSubsystem, MapMeta) == 0x000048, "Member 'UMapMetaSubsystem::MapMeta' has a wrong offset!");

// Class HLL.SdKfz251Halftrack
// 0x0018 (0x05D0 - 0x05B8)
class ASdKfz251Halftrack final : public ABaseHalftrack
{
public:
	class USuspensionsComponent*                  Suspension;                                        // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHalftrackWheelsComponent*              HalftrackWheels;                                   // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTracksComponent*                       Tracks;                                            // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SdKfz251Halftrack">();
	}
	static class ASdKfz251Halftrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASdKfz251Halftrack>();
	}
};
static_assert(alignof(ASdKfz251Halftrack) == 0x000008, "Wrong alignment on ASdKfz251Halftrack");
static_assert(sizeof(ASdKfz251Halftrack) == 0x0005D0, "Wrong size on ASdKfz251Halftrack");
static_assert(offsetof(ASdKfz251Halftrack, Suspension) == 0x0005B8, "Member 'ASdKfz251Halftrack::Suspension' has a wrong offset!");
static_assert(offsetof(ASdKfz251Halftrack, HalftrackWheels) == 0x0005C0, "Member 'ASdKfz251Halftrack::HalftrackWheels' has a wrong offset!");
static_assert(offsetof(ASdKfz251Halftrack, Tracks) == 0x0005C8, "Member 'ASdKfz251Halftrack::Tracks' has a wrong offset!");

// Class HLL.MapSpecificAchievements
// 0x0090 (0x00C0 - 0x0030)
class UMapSpecificAchievements final : public UDataAsset
{
public:
	TArray<class UEndMatchAchievement*>           EndMatchAchievements;                              // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGameStateEventAchievement*>     GameStateEventAchievements;                        // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPlayerDownedAchievement*>       PlayerDownedAchievements;                          // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObjectDestroyedAchievement*>    ObjectDestroyedAchievements;                       // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UItemDispensedAchievement*>      ItemDispensedAchievements;                         // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPlayerRevivedAchievement*>      PlayerRevivedAchievements;                         // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UVehicleTickAchievement*>        VehicleTickAchievements;                           // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URepairAchievement*>             RepairAchievements;                                // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUpgradeStructureAchievement*>   StructureUpgradeAchievements;                      // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSpecificAchievements">();
	}
	static class UMapSpecificAchievements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSpecificAchievements>();
	}
};
static_assert(alignof(UMapSpecificAchievements) == 0x000008, "Wrong alignment on UMapSpecificAchievements");
static_assert(sizeof(UMapSpecificAchievements) == 0x0000C0, "Wrong size on UMapSpecificAchievements");
static_assert(offsetof(UMapSpecificAchievements, EndMatchAchievements) == 0x000030, "Member 'UMapSpecificAchievements::EndMatchAchievements' has a wrong offset!");
static_assert(offsetof(UMapSpecificAchievements, GameStateEventAchievements) == 0x000040, "Member 'UMapSpecificAchievements::GameStateEventAchievements' has a wrong offset!");
static_assert(offsetof(UMapSpecificAchievements, PlayerDownedAchievements) == 0x000050, "Member 'UMapSpecificAchievements::PlayerDownedAchievements' has a wrong offset!");
static_assert(offsetof(UMapSpecificAchievements, ObjectDestroyedAchievements) == 0x000060, "Member 'UMapSpecificAchievements::ObjectDestroyedAchievements' has a wrong offset!");
static_assert(offsetof(UMapSpecificAchievements, ItemDispensedAchievements) == 0x000070, "Member 'UMapSpecificAchievements::ItemDispensedAchievements' has a wrong offset!");
static_assert(offsetof(UMapSpecificAchievements, PlayerRevivedAchievements) == 0x000080, "Member 'UMapSpecificAchievements::PlayerRevivedAchievements' has a wrong offset!");
static_assert(offsetof(UMapSpecificAchievements, VehicleTickAchievements) == 0x000090, "Member 'UMapSpecificAchievements::VehicleTickAchievements' has a wrong offset!");
static_assert(offsetof(UMapSpecificAchievements, RepairAchievements) == 0x0000A0, "Member 'UMapSpecificAchievements::RepairAchievements' has a wrong offset!");
static_assert(offsetof(UMapSpecificAchievements, StructureUpgradeAchievements) == 0x0000B0, "Member 'UMapSpecificAchievements::StructureUpgradeAchievements' has a wrong offset!");

// Class HLL.MapStartCameraManager
// 0x0000 (0x2740 - 0x2740)
class AMapStartCameraManager final : public APlayerCameraManager
{
public:
	class ACameraActor*                           MapStartCamera;                                    // 0x2738(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapStartCameraManager">();
	}
	static class AMapStartCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapStartCameraManager>();
	}
};
static_assert(alignof(AMapStartCameraManager) == 0x000010, "Wrong alignment on AMapStartCameraManager");
static_assert(sizeof(AMapStartCameraManager) == 0x002740, "Wrong size on AMapStartCameraManager");
static_assert(offsetof(AMapStartCameraManager, MapStartCamera) == 0x002738, "Member 'AMapStartCameraManager::MapStartCamera' has a wrong offset!");

// Class HLL.MapStartPlayerController
// 0x0000 (0x0580 - 0x0580)
class AMapStartPlayerController final : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapStartPlayerController">();
	}
	static class AMapStartPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapStartPlayerController>();
	}
};
static_assert(alignof(AMapStartPlayerController) == 0x000008, "Wrong alignment on AMapStartPlayerController");
static_assert(sizeof(AMapStartPlayerController) == 0x000580, "Wrong size on AMapStartPlayerController");

// Class HLL.MapVariantMetaDataAsset
// 0x0018 (0x0048 - 0x0030)
class UMapVariantMetaDataAsset final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          LevelsToLoad;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNightMap;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150B[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapVariantMetaDataAsset">();
	}
	static class UMapVariantMetaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapVariantMetaDataAsset>();
	}
};
static_assert(alignof(UMapVariantMetaDataAsset) == 0x000008, "Wrong alignment on UMapVariantMetaDataAsset");
static_assert(sizeof(UMapVariantMetaDataAsset) == 0x000048, "Wrong size on UMapVariantMetaDataAsset");
static_assert(offsetof(UMapVariantMetaDataAsset, LevelsToLoad) == 0x000030, "Member 'UMapVariantMetaDataAsset::LevelsToLoad' has a wrong offset!");
static_assert(offsetof(UMapVariantMetaDataAsset, bIsNightMap) == 0x000040, "Member 'UMapVariantMetaDataAsset::bIsNightMap' has a wrong offset!");

// Class HLL.MeshMergeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMeshMergeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class USkeletalMesh* MergeMeshes(const struct FSkeletalMeshMergeParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshMergeFunctionLibrary">();
	}
	static class UMeshMergeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshMergeFunctionLibrary>();
	}
};
static_assert(alignof(UMeshMergeFunctionLibrary) == 0x000008, "Wrong alignment on UMeshMergeFunctionLibrary");
static_assert(sizeof(UMeshMergeFunctionLibrary) == 0x000028, "Wrong size on UMeshMergeFunctionLibrary");

// Class HLL.SeedingGameState
// 0x0020 (0x07D8 - 0x07B8)
class ASeedingGameState final : public AShooterGameState
{
public:
	TArray<class ASeedingControlPoint*>           SeedingControlPoints;                              // 0x07B8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ASeedingSubControlPoint*>        SeedingSubControlPoints;                           // 0x07C8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeedingGameState">();
	}
	static class ASeedingGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASeedingGameState>();
	}
};
static_assert(alignof(ASeedingGameState) == 0x000008, "Wrong alignment on ASeedingGameState");
static_assert(sizeof(ASeedingGameState) == 0x0007D8, "Wrong size on ASeedingGameState");
static_assert(offsetof(ASeedingGameState, SeedingControlPoints) == 0x0007B8, "Member 'ASeedingGameState::SeedingControlPoints' has a wrong offset!");
static_assert(offsetof(ASeedingGameState, SeedingSubControlPoints) == 0x0007C8, "Member 'ASeedingGameState::SeedingSubControlPoints' has a wrong offset!");

// Class HLL.MobileSpawn
// 0x00A8 (0x02C8 - 0x0220)
class AMobileSpawn final : public AActor
{
public:
	uint8                                         Pad_150C[0x10];                                    // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         WaveIntervalSeconds;                               // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimalWaveIntervalSeconds;                        // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDynamicSpawnGatherParams              SpawnGatherParams;                                 // 0x0238(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          LockSpawningInEnemyTerritory;                      // 0x024C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150D[0x1B];                                    // 0x024D(0x001B)(Fixing Size After Last Property [ Dumper-69 ])
	class UNearbySpawnEnemyDetection*             NearbySpawnEnemyDetection;                         // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHLLMapComponent*                       SpawnMapComponent;                                 // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NextSpawnWaveTime;                                 // 0x0278(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAllowedToDeploy : 1;                              // 0x027C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsDrowning : 1;                                   // 0x027C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsMoving : 1;                                     // 0x027C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         NumAvailableSpawnLocations;                        // 0x027D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         Team;                                              // 0x027E(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150E[0x49];                                    // 0x027F(0x0049)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_AllowedToDeploy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobileSpawn">();
	}
	static class AMobileSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMobileSpawn>();
	}
};
static_assert(alignof(AMobileSpawn) == 0x000008, "Wrong alignment on AMobileSpawn");
static_assert(sizeof(AMobileSpawn) == 0x0002C8, "Wrong size on AMobileSpawn");
static_assert(offsetof(AMobileSpawn, WaveIntervalSeconds) == 0x000230, "Member 'AMobileSpawn::WaveIntervalSeconds' has a wrong offset!");
static_assert(offsetof(AMobileSpawn, MinimalWaveIntervalSeconds) == 0x000234, "Member 'AMobileSpawn::MinimalWaveIntervalSeconds' has a wrong offset!");
static_assert(offsetof(AMobileSpawn, SpawnGatherParams) == 0x000238, "Member 'AMobileSpawn::SpawnGatherParams' has a wrong offset!");
static_assert(offsetof(AMobileSpawn, LockSpawningInEnemyTerritory) == 0x00024C, "Member 'AMobileSpawn::LockSpawningInEnemyTerritory' has a wrong offset!");
static_assert(offsetof(AMobileSpawn, NearbySpawnEnemyDetection) == 0x000268, "Member 'AMobileSpawn::NearbySpawnEnemyDetection' has a wrong offset!");
static_assert(offsetof(AMobileSpawn, SpawnMapComponent) == 0x000270, "Member 'AMobileSpawn::SpawnMapComponent' has a wrong offset!");
static_assert(offsetof(AMobileSpawn, NextSpawnWaveTime) == 0x000278, "Member 'AMobileSpawn::NextSpawnWaveTime' has a wrong offset!");
static_assert(offsetof(AMobileSpawn, NumAvailableSpawnLocations) == 0x00027D, "Member 'AMobileSpawn::NumAvailableSpawnLocations' has a wrong offset!");
static_assert(offsetof(AMobileSpawn, Team) == 0x00027E, "Member 'AMobileSpawn::Team' has a wrong offset!");

// Class HLL.VoiceSoundNode
// 0x0010 (0x0058 - 0x0048)
class UVoiceSoundNode final : public USoundNodeAssetReferencer
{
public:
	EVOIPChannel                                  Channel;                                           // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150F[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundWaveProcedural*                   SoundStream;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceSoundNode">();
	}
	static class UVoiceSoundNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceSoundNode>();
	}
};
static_assert(alignof(UVoiceSoundNode) == 0x000008, "Wrong alignment on UVoiceSoundNode");
static_assert(sizeof(UVoiceSoundNode) == 0x000058, "Wrong size on UVoiceSoundNode");
static_assert(offsetof(UVoiceSoundNode, Channel) == 0x000048, "Member 'UVoiceSoundNode::Channel' has a wrong offset!");
static_assert(offsetof(UVoiceSoundNode, SoundStream) == 0x000050, "Member 'UVoiceSoundNode::SoundStream' has a wrong offset!");

// Class HLL.MountableWeaponDataAsset
// 0x0198 (0x01C8 - 0x0030)
class UMountableWeaponDataAsset final : public UDataAsset
{
public:
	struct FMountableWeaponData                   ProneProperties;                                   // 0x0030(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMountableWeaponData                   CrouchedProperties;                                // 0x00B8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMountableWeaponData                   StandingProperties;                                // 0x0140(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MountableWeaponDataAsset">();
	}
	static class UMountableWeaponDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMountableWeaponDataAsset>();
	}
};
static_assert(alignof(UMountableWeaponDataAsset) == 0x000008, "Wrong alignment on UMountableWeaponDataAsset");
static_assert(sizeof(UMountableWeaponDataAsset) == 0x0001C8, "Wrong size on UMountableWeaponDataAsset");
static_assert(offsetof(UMountableWeaponDataAsset, ProneProperties) == 0x000030, "Member 'UMountableWeaponDataAsset::ProneProperties' has a wrong offset!");
static_assert(offsetof(UMountableWeaponDataAsset, CrouchedProperties) == 0x0000B8, "Member 'UMountableWeaponDataAsset::CrouchedProperties' has a wrong offset!");
static_assert(offsetof(UMountableWeaponDataAsset, StandingProperties) == 0x000140, "Member 'UMountableWeaponDataAsset::StandingProperties' has a wrong offset!");

// Class HLL.MountedBipodRotationComponent
// 0x0008 (0x00B8 - 0x00B0)
class UMountedBipodRotationComponent final : public UActorComponent
{
public:
	class UPlayerMountedBipodSettings*            MountedBipodSettings;                              // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MountedBipodRotationComponent">();
	}
	static class UMountedBipodRotationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMountedBipodRotationComponent>();
	}
};
static_assert(alignof(UMountedBipodRotationComponent) == 0x000008, "Wrong alignment on UMountedBipodRotationComponent");
static_assert(sizeof(UMountedBipodRotationComponent) == 0x0000B8, "Wrong size on UMountedBipodRotationComponent");
static_assert(offsetof(UMountedBipodRotationComponent, MountedBipodSettings) == 0x0000B0, "Member 'UMountedBipodRotationComponent::MountedBipodSettings' has a wrong offset!");

// Class HLL.MultiObjectiveGameMode
// 0x0010 (0x05A8 - 0x0598)
class AMultiObjectiveGameMode : public AShooterGameMode
{
public:
	ESkirmishVariant                              SkirmishVariantType;                               // 0x0598(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsMatchInOvertime;                                 // 0x0599(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         OvertimeAttackingTeam;                             // 0x059A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1510[0x5];                                     // 0x059B(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UGameModeObjectivesData*                ObjectiveData;                                     // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiObjectiveGameMode">();
	}
	static class AMultiObjectiveGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultiObjectiveGameMode>();
	}
};
static_assert(alignof(AMultiObjectiveGameMode) == 0x000008, "Wrong alignment on AMultiObjectiveGameMode");
static_assert(sizeof(AMultiObjectiveGameMode) == 0x0005A8, "Wrong size on AMultiObjectiveGameMode");
static_assert(offsetof(AMultiObjectiveGameMode, SkirmishVariantType) == 0x000598, "Member 'AMultiObjectiveGameMode::SkirmishVariantType' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameMode, IsMatchInOvertime) == 0x000599, "Member 'AMultiObjectiveGameMode::IsMatchInOvertime' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameMode, OvertimeAttackingTeam) == 0x00059A, "Member 'AMultiObjectiveGameMode::OvertimeAttackingTeam' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameMode, ObjectiveData) == 0x0005A0, "Member 'AMultiObjectiveGameMode::ObjectiveData' has a wrong offset!");

// Class HLL.MultiObjectiveConquestGameMode
// 0x0018 (0x05C0 - 0x05A8)
class AMultiObjectiveConquestGameMode final : public AMultiObjectiveGameMode
{
public:
	uint16                                        InitialConquestTickets;                            // 0x05A8(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1511[0x6];                                     // 0x05AA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FResourceDrops>                 MidMatchResourceDrops;                             // 0x05B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiObjectiveConquestGameMode">();
	}
	static class AMultiObjectiveConquestGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultiObjectiveConquestGameMode>();
	}
};
static_assert(alignof(AMultiObjectiveConquestGameMode) == 0x000008, "Wrong alignment on AMultiObjectiveConquestGameMode");
static_assert(sizeof(AMultiObjectiveConquestGameMode) == 0x0005C0, "Wrong size on AMultiObjectiveConquestGameMode");
static_assert(offsetof(AMultiObjectiveConquestGameMode, InitialConquestTickets) == 0x0005A8, "Member 'AMultiObjectiveConquestGameMode::InitialConquestTickets' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveConquestGameMode, MidMatchResourceDrops) == 0x0005B0, "Member 'AMultiObjectiveConquestGameMode::MidMatchResourceDrops' has a wrong offset!");

// Class HLL.MultiObjectiveGameModeHUD
// 0x0028 (0x0258 - 0x0230)
class UMultiObjectiveGameModeHUD : public UUserWidget
{
public:
	TSubclassOf<class UObjectivePhaseHUD>         ObjectivePhaseHUDClass;                            // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObjectivePhaseHUD*>             ObjectivePhaseHUDList;                             // 0x0238(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         ObjectivePhaseBox;                                 // 0x0248(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           GameDetails;                                       // 0x0250(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetObjectivePhaseDescriptionHUD(const class FText& Title);
	void SetObjectivePhaseTitleHUD(const class FText& Title);
	void SetupObjectiveHUD();
	void UpdateBannerStatus(const int32& PhaseID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiObjectiveGameModeHUD">();
	}
	static class UMultiObjectiveGameModeHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiObjectiveGameModeHUD>();
	}
};
static_assert(alignof(UMultiObjectiveGameModeHUD) == 0x000008, "Wrong alignment on UMultiObjectiveGameModeHUD");
static_assert(sizeof(UMultiObjectiveGameModeHUD) == 0x000258, "Wrong size on UMultiObjectiveGameModeHUD");
static_assert(offsetof(UMultiObjectiveGameModeHUD, ObjectivePhaseHUDClass) == 0x000230, "Member 'UMultiObjectiveGameModeHUD::ObjectivePhaseHUDClass' has a wrong offset!");
static_assert(offsetof(UMultiObjectiveGameModeHUD, ObjectivePhaseHUDList) == 0x000238, "Member 'UMultiObjectiveGameModeHUD::ObjectivePhaseHUDList' has a wrong offset!");
static_assert(offsetof(UMultiObjectiveGameModeHUD, ObjectivePhaseBox) == 0x000248, "Member 'UMultiObjectiveGameModeHUD::ObjectivePhaseBox' has a wrong offset!");
static_assert(offsetof(UMultiObjectiveGameModeHUD, GameDetails) == 0x000250, "Member 'UMultiObjectiveGameModeHUD::GameDetails' has a wrong offset!");

// Class HLL.RCONCommandRemoveWarmupTimer
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveWarmupTimer final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveWarmupTimer">();
	}
	static class URCONCommandRemoveWarmupTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveWarmupTimer>();
	}
};
static_assert(alignof(URCONCommandRemoveWarmupTimer) == 0x000008, "Wrong alignment on URCONCommandRemoveWarmupTimer");
static_assert(sizeof(URCONCommandRemoveWarmupTimer) == 0x000028, "Wrong size on URCONCommandRemoveWarmupTimer");

// Class HLL.MultiObjectiveGameState
// 0x0040 (0x07F8 - 0x07B8)
class AMultiObjectiveGameState : public AShooterGameState
{
public:
	uint8                                         Pad_1512[0x18];                                    // 0x07B8(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          DisplayMapSectors;                                 // 0x07D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1513[0x7];                                     // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AGameObjectivePhaseContainer*>   GameObjectivePhases;                               // 0x07D8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameObjectivePhaseContainer*           CurrentPhase;                                      // 0x07E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        CurrentPhaseID;                                    // 0x07F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESkirmishVariant                              SkirmishVariant;                                   // 0x07F4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MatchIsInOvertime;                                 // 0x07F5(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         AttackingOvertimeTeam;                             // 0x07F6(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1514[0x1];                                     // 0x07F7(0x0001)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Multi_UpdatePhaseHUDText(const uint32 PhaseID);

	class FText GetCurrentPhaseDescription(const ETeam& Team) const;
	class FText GetCurrentPhaseTitle(const ETeam& Team) const;
	class FText GetPhaseDescription(const int32& Param_Index, const ETeam& Team) const;
	class FText GetPhaseTitle(const int32& Param_Index, const ETeam& Team) const;
	ESkirmishVariant GetSkirmishVariant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiObjectiveGameState">();
	}
	static class AMultiObjectiveGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultiObjectiveGameState>();
	}
};
static_assert(alignof(AMultiObjectiveGameState) == 0x000008, "Wrong alignment on AMultiObjectiveGameState");
static_assert(sizeof(AMultiObjectiveGameState) == 0x0007F8, "Wrong size on AMultiObjectiveGameState");
static_assert(offsetof(AMultiObjectiveGameState, DisplayMapSectors) == 0x0007D0, "Member 'AMultiObjectiveGameState::DisplayMapSectors' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameState, GameObjectivePhases) == 0x0007D8, "Member 'AMultiObjectiveGameState::GameObjectivePhases' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameState, CurrentPhase) == 0x0007E8, "Member 'AMultiObjectiveGameState::CurrentPhase' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameState, CurrentPhaseID) == 0x0007F0, "Member 'AMultiObjectiveGameState::CurrentPhaseID' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameState, SkirmishVariant) == 0x0007F4, "Member 'AMultiObjectiveGameState::SkirmishVariant' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameState, MatchIsInOvertime) == 0x0007F5, "Member 'AMultiObjectiveGameState::MatchIsInOvertime' has a wrong offset!");
static_assert(offsetof(AMultiObjectiveGameState, AttackingOvertimeTeam) == 0x0007F6, "Member 'AMultiObjectiveGameState::AttackingOvertimeTeam' has a wrong offset!");

// Class HLL.MultiplayBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMultiplayBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddMultiplayPartyMember(const struct FMultiplayPartyMember& PartyMember);
	static void CancelMatchmaking();
	static bool CompletedMatchMaking();
	static void DisableQOS();
	static void EnableQOS();
	static bool ErroredMatchMaking();
	static class FString GetClientConnectionStringAsString();
	static EMatchMakingState GetMatchmakingState();
	static class FString GetStatusAsString();
	static class FString GetTimeSpentMatchmakingAsString();
	static float GetTimeSpentMatchmakingInSeconds();
	static bool HasConnectionDetails();
	static bool HasPerformedQOS();
	static bool IsMatchmaking();
	static bool IsMultiplayAssignmentSet();
	static bool IsPerformingQOS();
	static void ResetQOS();
	static bool SetMatchmakingPreferences(const class FString& InRegionName, const TArray<class FString>& Region, bool bPrivateLobby, bool bCrossplatform, bool bSearchStarted);
	static bool ShowGameMatchFeedbackSystemUI(class UObject* WorldContextObject);
	static EMatchMakeResult StartMatchmaking();
	static bool StartQOS();
	static bool TravelToMultiplayServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiplayBlueprintFunctionLibrary">();
	}
	static class UMultiplayBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiplayBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UMultiplayBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UMultiplayBlueprintFunctionLibrary");
static_assert(sizeof(UMultiplayBlueprintFunctionLibrary) == 0x000028, "Wrong size on UMultiplayBlueprintFunctionLibrary");

// Class HLL.MultiplayGameSession
// 0x0000 (0x0238 - 0x0238)
class AMultiplayGameSession final : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiplayGameSession">();
	}
	static class AMultiplayGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultiplayGameSession>();
	}
};
static_assert(alignof(AMultiplayGameSession) == 0x000008, "Wrong alignment on AMultiplayGameSession");
static_assert(sizeof(AMultiplayGameSession) == 0x000238, "Wrong size on AMultiplayGameSession");

// Class HLL.MultiplayServerLobbyGameMode
// 0x0078 (0x0380 - 0x0308)
class AMultiplayServerLobbyGameMode final : public AGameMode
{
public:
	uint8                                         Pad_151C[0x28];                                    // 0x0308(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<TWeakObjectPtr<class APlayerController>, class FString> M_TicketMap;                                       // 0x0330(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiplayServerLobbyGameMode">();
	}
	static class AMultiplayServerLobbyGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultiplayServerLobbyGameMode>();
	}
};
static_assert(alignof(AMultiplayServerLobbyGameMode) == 0x000008, "Wrong alignment on AMultiplayServerLobbyGameMode");
static_assert(sizeof(AMultiplayServerLobbyGameMode) == 0x000380, "Wrong size on AMultiplayServerLobbyGameMode");
static_assert(offsetof(AMultiplayServerLobbyGameMode, M_TicketMap) == 0x000330, "Member 'AMultiplayServerLobbyGameMode::M_TicketMap' has a wrong offset!");

// Class HLL.NearbySpawnEnemyDetection
// 0x0040 (0x00F0 - 0x00B0)
class UNearbySpawnEnemyDetection final : public UActorComponent
{
public:
	uint8                                         Pad_151D[0x18];                                    // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bDetectNearbyEnemies : 1;                          // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151E[0x3];                                     // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         EnemyDetectionDistance;                            // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyBlockingDistance;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFriendlySectorBlockingDistance;                 // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnBlockingCooldown;                             // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpawnEnemyInfo                        SpawnEnemyInfo;                                    // 0x00DC(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_151F[0x8];                                     // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_SpawnEnemyInfo(const struct FSpawnEnemyInfo& PreviousValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearbySpawnEnemyDetection">();
	}
	static class UNearbySpawnEnemyDetection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearbySpawnEnemyDetection>();
	}
};
static_assert(alignof(UNearbySpawnEnemyDetection) == 0x000008, "Wrong alignment on UNearbySpawnEnemyDetection");
static_assert(sizeof(UNearbySpawnEnemyDetection) == 0x0000F0, "Wrong size on UNearbySpawnEnemyDetection");
static_assert(offsetof(UNearbySpawnEnemyDetection, EnemyDetectionDistance) == 0x0000CC, "Member 'UNearbySpawnEnemyDetection::EnemyDetectionDistance' has a wrong offset!");
static_assert(offsetof(UNearbySpawnEnemyDetection, EnemyBlockingDistance) == 0x0000D0, "Member 'UNearbySpawnEnemyDetection::EnemyBlockingDistance' has a wrong offset!");
static_assert(offsetof(UNearbySpawnEnemyDetection, NonFriendlySectorBlockingDistance) == 0x0000D4, "Member 'UNearbySpawnEnemyDetection::NonFriendlySectorBlockingDistance' has a wrong offset!");
static_assert(offsetof(UNearbySpawnEnemyDetection, SpawnBlockingCooldown) == 0x0000D8, "Member 'UNearbySpawnEnemyDetection::SpawnBlockingCooldown' has a wrong offset!");
static_assert(offsetof(UNearbySpawnEnemyDetection, SpawnEnemyInfo) == 0x0000DC, "Member 'UNearbySpawnEnemyDetection::SpawnEnemyInfo' has a wrong offset!");

// Class HLL.NetworkDisconnectErrorReporting
// 0x0018 (0x0048 - 0x0030)
class UNetworkDisconnectErrorReporting final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_1520[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkDisconnectErrorReporting">();
	}
	static class UNetworkDisconnectErrorReporting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkDisconnectErrorReporting>();
	}
};
static_assert(alignof(UNetworkDisconnectErrorReporting) == 0x000008, "Wrong alignment on UNetworkDisconnectErrorReporting");
static_assert(sizeof(UNetworkDisconnectErrorReporting) == 0x000048, "Wrong size on UNetworkDisconnectErrorReporting");

// Class HLL.RCONCommandSetInitialResources
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetInitialResources final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetInitialResources">();
	}
	static class URCONCommandSetInitialResources* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetInitialResources>();
	}
};
static_assert(alignof(URCONCommandSetInitialResources) == 0x000008, "Wrong alignment on URCONCommandSetInitialResources");
static_assert(sizeof(URCONCommandSetInitialResources) == 0x000028, "Wrong size on URCONCommandSetInitialResources");

// Class HLL.NotificationWidget
// 0x0048 (0x0278 - 0x0230)
class UNotificationWidget : public UUserWidget
{
public:
	uint8                                         Pad_1521[0x48];                                    // 0x0230(0x0048)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void FinishedDisplayingNotification();
	void OnNotificationRecieved(const EPopupNotificationType& NotificationType, const class FString& PlayerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationWidget">();
	}
	static class UNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationWidget>();
	}
};
static_assert(alignof(UNotificationWidget) == 0x000008, "Wrong alignment on UNotificationWidget");
static_assert(sizeof(UNotificationWidget) == 0x000278, "Wrong size on UNotificationWidget");

// Class HLL.ObjectiveCompassIndicator
// 0x0008 (0x0258 - 0x0250)
class UObjectiveCompassIndicator : public UBaseCompassIndicator
{
public:
	class AGameObjectiveBase*                     GameObjectiveBase;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveCompassIndicator">();
	}
	static class UObjectiveCompassIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveCompassIndicator>();
	}
};
static_assert(alignof(UObjectiveCompassIndicator) == 0x000008, "Wrong alignment on UObjectiveCompassIndicator");
static_assert(sizeof(UObjectiveCompassIndicator) == 0x000258, "Wrong size on UObjectiveCompassIndicator");
static_assert(offsetof(UObjectiveCompassIndicator, GameObjectiveBase) == 0x000250, "Member 'UObjectiveCompassIndicator::GameObjectiveBase' has a wrong offset!");

// Class HLL.ObjectiveGameMode
// 0x0008 (0x05A0 - 0x0598)
class AObjectiveGameMode : public AShooterGameMode
{
public:
	EHint                                         HintWhenSpawnedIn;                                 // 0x0598(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHint                                         HintWhenSpawnedOnHQ;                               // 0x0599(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1523[0x6];                                     // 0x059A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveGameMode">();
	}
	static class AObjectiveGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjectiveGameMode>();
	}
};
static_assert(alignof(AObjectiveGameMode) == 0x000008, "Wrong alignment on AObjectiveGameMode");
static_assert(sizeof(AObjectiveGameMode) == 0x0005A0, "Wrong size on AObjectiveGameMode");
static_assert(offsetof(AObjectiveGameMode, HintWhenSpawnedIn) == 0x000598, "Member 'AObjectiveGameMode::HintWhenSpawnedIn' has a wrong offset!");
static_assert(offsetof(AObjectiveGameMode, HintWhenSpawnedOnHQ) == 0x000599, "Member 'AObjectiveGameMode::HintWhenSpawnedOnHQ' has a wrong offset!");

// Class HLL.ObjectivePhaseHUD
// 0x0030 (0x0260 - 0x0230)
class UObjectivePhaseHUD : public UUserWidget
{
public:
	class USizeBox*                               SizeBoxContainer;                                  // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ObjectivePhaseNumberText;                          // 0x0238(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                ObjectivePhaseBanner;                              // 0x0240(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsActive;                                          // 0x0248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         DefensiveTeam;                                     // 0x0249(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1524[0x2];                                     // 0x024A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         PhaseID;                                           // 0x024C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinSizeBoxWidth;                                   // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxSizeBoxWidth;                                   // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InActiveOpacity;                                   // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActiveOpacity;                                     // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectivePhaseHUD">();
	}
	static class UObjectivePhaseHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectivePhaseHUD>();
	}
};
static_assert(alignof(UObjectivePhaseHUD) == 0x000008, "Wrong alignment on UObjectivePhaseHUD");
static_assert(sizeof(UObjectivePhaseHUD) == 0x000260, "Wrong size on UObjectivePhaseHUD");
static_assert(offsetof(UObjectivePhaseHUD, SizeBoxContainer) == 0x000230, "Member 'UObjectivePhaseHUD::SizeBoxContainer' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, ObjectivePhaseNumberText) == 0x000238, "Member 'UObjectivePhaseHUD::ObjectivePhaseNumberText' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, ObjectivePhaseBanner) == 0x000240, "Member 'UObjectivePhaseHUD::ObjectivePhaseBanner' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, IsActive) == 0x000248, "Member 'UObjectivePhaseHUD::IsActive' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, DefensiveTeam) == 0x000249, "Member 'UObjectivePhaseHUD::DefensiveTeam' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, PhaseID) == 0x00024C, "Member 'UObjectivePhaseHUD::PhaseID' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, MinSizeBoxWidth) == 0x000250, "Member 'UObjectivePhaseHUD::MinSizeBoxWidth' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, MaxSizeBoxWidth) == 0x000254, "Member 'UObjectivePhaseHUD::MaxSizeBoxWidth' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, InActiveOpacity) == 0x000258, "Member 'UObjectivePhaseHUD::InActiveOpacity' has a wrong offset!");
static_assert(offsetof(UObjectivePhaseHUD, ActiveOpacity) == 0x00025C, "Member 'UObjectivePhaseHUD::ActiveOpacity' has a wrong offset!");

// Class HLL.ReconDriverSeatUI
// 0x0008 (0x02D8 - 0x02D0)
class UReconDriverSeatUI final : public UVehicleDriverSeatUI
{
public:
	class UImage*                                 TankTurretImage;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReconDriverSeatUI">();
	}
	static class UReconDriverSeatUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReconDriverSeatUI>();
	}
};
static_assert(alignof(UReconDriverSeatUI) == 0x000008, "Wrong alignment on UReconDriverSeatUI");
static_assert(sizeof(UReconDriverSeatUI) == 0x0002D8, "Wrong size on UReconDriverSeatUI");
static_assert(offsetof(UReconDriverSeatUI, TankTurretImage) == 0x0002D0, "Member 'UReconDriverSeatUI::TankTurretImage' has a wrong offset!");

// Class HLL.OffensiveWarfareGameMode
// 0x0070 (0x0608 - 0x0598)
class AOffensiveWarfareGameMode : public AShooterGameMode
{
public:
	uint8                                         Pad_1525[0x70];                                    // 0x0598(0x0070)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffensiveWarfareGameMode">();
	}
	static class AOffensiveWarfareGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOffensiveWarfareGameMode>();
	}
};
static_assert(alignof(AOffensiveWarfareGameMode) == 0x000008, "Wrong alignment on AOffensiveWarfareGameMode");
static_assert(sizeof(AOffensiveWarfareGameMode) == 0x000608, "Wrong size on AOffensiveWarfareGameMode");

// Class HLL.OffensiveWarfareGameProgressWidget
// 0x0000 (0x0230 - 0x0230)
class UOffensiveWarfareGameProgressWidget : public UUserWidget
{
public:
	void UpdateFrontlines(const TArray<struct FOffensiveWarfareHUDFrontline>& Frontlines);
	void UpdateObjectives(const TArray<struct FOffensiveWarfareHUDObjective>& OBJECTIVES);
	void UpdateSectors(const TArray<struct FDisplayedSectorState>& Sectors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffensiveWarfareGameProgressWidget">();
	}
	static class UOffensiveWarfareGameProgressWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffensiveWarfareGameProgressWidget>();
	}
};
static_assert(alignof(UOffensiveWarfareGameProgressWidget) == 0x000008, "Wrong alignment on UOffensiveWarfareGameProgressWidget");
static_assert(sizeof(UOffensiveWarfareGameProgressWidget) == 0x000230, "Wrong size on UOffensiveWarfareGameProgressWidget");

// Class HLL.OffensiveWarfareGameStateComponent
// 0x0008 (0x00B8 - 0x00B0)
class UOffensiveWarfareGameStateComponent final : public UActorComponent
{
public:
	ETeam                                         AttackingTeam;                                     // 0x00B0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInOffensiveOvertime : 1;                          // 0x00B1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1526[0x6];                                     // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_OffensiveOvertime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffensiveWarfareGameStateComponent">();
	}
	static class UOffensiveWarfareGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffensiveWarfareGameStateComponent>();
	}
};
static_assert(alignof(UOffensiveWarfareGameStateComponent) == 0x000008, "Wrong alignment on UOffensiveWarfareGameStateComponent");
static_assert(sizeof(UOffensiveWarfareGameStateComponent) == 0x0000B8, "Wrong size on UOffensiveWarfareGameStateComponent");
static_assert(offsetof(UOffensiveWarfareGameStateComponent, AttackingTeam) == 0x0000B0, "Member 'UOffensiveWarfareGameStateComponent::AttackingTeam' has a wrong offset!");

// Class HLL.OnlinePartyFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOnlinePartyFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AreRemotePlayersReady();
	static TArray<struct FOnlinePartyRemotePlayer> GetAllPlayersInParty();
	static TArray<class FString> GetAllRemotePlayersGlobalIDs();
	static int32 GetLocalPlayerXpLevel();
	static int32 GetMaxPartySize();
	static EPartySessionRole GetPartySessionRole();
	static struct FOnlinePartyRemotePlayer GetRemotePlayerDetails(const int32 Param_Index);
	static class FString GetSessionID();
	static bool IsCrossplayEnabledForPlatforms(EPlatforms InPlatform);
	static bool IsHost();
	static bool IsLocalPlayerReady();
	static bool IsPlatformBlockedPlayer(const class FString& PlatformPlayerId);
	static bool IsPlayerGlobalPlayerIdBlocked(const class FString& InGlobalPlayerId);
	static bool IsPlayerInSession(const class FString& GlobalPlayerId, const class FString& PlatformPlayerId);
	static bool IsPlayerMuted(const class FString& InGlobalPlayerId, class UObject* WorldContextObject);
	static bool IsPlayerSessionHost(const class FString& InGlobalPlayerId);
	static bool IsRunning();
	static void KickPlayer(const class FString& GlobalPlayerId);
	static void Leave();
	static bool SetLocalPlayerReady(bool IsReady);
	static void SetMutePlayer(const class FString& InGlobalPlayerId, bool bMute, class UObject* WorldContextObject);
	static void ShowProfileUI(const class FString& PlatformPlayerId);
	static void SyncLocalPlayersLatestCustomisationData();
	static void UpdateLocalPlayerXpLevel(const int32 XPLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlinePartyFunctionLibrary">();
	}
	static class UOnlinePartyFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlinePartyFunctionLibrary>();
	}
};
static_assert(alignof(UOnlinePartyFunctionLibrary) == 0x000008, "Wrong alignment on UOnlinePartyFunctionLibrary");
static_assert(sizeof(UOnlinePartyFunctionLibrary) == 0x000028, "Wrong size on UOnlinePartyFunctionLibrary");

// Class HLL.ShooterCharacterT1
// 0x0000 (0x1480 - 0x1480)
class AShooterCharacterT1 final : public AShooterCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCharacterT1">();
	}
	static class AShooterCharacterT1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterCharacterT1>();
	}
};
static_assert(alignof(AShooterCharacterT1) == 0x000010, "Wrong alignment on AShooterCharacterT1");
static_assert(sizeof(AShooterCharacterT1) == 0x001480, "Wrong size on AShooterCharacterT1");

// Class HLL.OnlinePurchaseSubsystem
// 0x0148 (0x0178 - 0x0030)
class UOnlinePurchaseSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             StoreRequestPurchase;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StoreItemDataUpdated;                              // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StorePurchaseComplete;                             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamOverlayActivated;                             // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_152E[0x108];                                   // 0x0070(0x0108)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CategoriesQueryCallback(bool bWasSuccessful, const class FString& Error);
	bool DoesPlatformIdMatch(const class FString& InId, const TMap<class FName, class FString>& InPlatformKeys);
	void OnRequestPurchase(const class FString& OfferId);
	bool RetrieveStoreData(const class APlayerController* InPlayerController);

	struct FDLCCosmeticStoreData GetDLCCosmeticData(const class FName& InDLCName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlinePurchaseSubsystem">();
	}
	static class UOnlinePurchaseSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlinePurchaseSubsystem>();
	}
};
static_assert(alignof(UOnlinePurchaseSubsystem) == 0x000008, "Wrong alignment on UOnlinePurchaseSubsystem");
static_assert(sizeof(UOnlinePurchaseSubsystem) == 0x000178, "Wrong size on UOnlinePurchaseSubsystem");
static_assert(offsetof(UOnlinePurchaseSubsystem, StoreRequestPurchase) == 0x000030, "Member 'UOnlinePurchaseSubsystem::StoreRequestPurchase' has a wrong offset!");
static_assert(offsetof(UOnlinePurchaseSubsystem, StoreItemDataUpdated) == 0x000040, "Member 'UOnlinePurchaseSubsystem::StoreItemDataUpdated' has a wrong offset!");
static_assert(offsetof(UOnlinePurchaseSubsystem, StorePurchaseComplete) == 0x000050, "Member 'UOnlinePurchaseSubsystem::StorePurchaseComplete' has a wrong offset!");
static_assert(offsetof(UOnlinePurchaseSubsystem, SteamOverlayActivated) == 0x000060, "Member 'UOnlinePurchaseSubsystem::SteamOverlayActivated' has a wrong offset!");

// Class HLL.OnlineSubsystemFunctionLib
// 0x0000 (0x0028 - 0x0028)
class UOnlineSubsystemFunctionLib final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSubsystemFunctionLib">();
	}
	static class UOnlineSubsystemFunctionLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSubsystemFunctionLib>();
	}
};
static_assert(alignof(UOnlineSubsystemFunctionLib) == 0x000008, "Wrong alignment on UOnlineSubsystemFunctionLib");
static_assert(sizeof(UOnlineSubsystemFunctionLib) == 0x000028, "Wrong size on UOnlineSubsystemFunctionLib");

// Class HLL.OptionCarousel
// 0x0020 (0x0250 - 0x0230)
class UOptionCarousel : public UUserWidget
{
public:
	class FName                                   NextTabAction;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PreviousTabAction;                                 // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1532[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindOnInputChangedDelegate();
	bool IsUsingGamepad();
	void NextTabPressed();
	void OnInputDeviceChanged(bool NewValue);
	void OnMenuClose();
	void OnMenuOpen();
	void OnNextTab();
	void OnPreviousTab();
	void PreviousTabPressed();
	void RefreshShoulderButtons();
	void UnBindOnInputChangedDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionCarousel">();
	}
	static class UOptionCarousel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionCarousel>();
	}
};
static_assert(alignof(UOptionCarousel) == 0x000008, "Wrong alignment on UOptionCarousel");
static_assert(sizeof(UOptionCarousel) == 0x000250, "Wrong size on UOptionCarousel");
static_assert(offsetof(UOptionCarousel, NextTabAction) == 0x000230, "Member 'UOptionCarousel::NextTabAction' has a wrong offset!");
static_assert(offsetof(UOptionCarousel, PreviousTabAction) == 0x000238, "Member 'UOptionCarousel::PreviousTabAction' has a wrong offset!");
static_assert(offsetof(UOptionCarousel, ViewportClient) == 0x000240, "Member 'UOptionCarousel::ViewportClient' has a wrong offset!");

// Class HLL.Outpost
// 0x0000 (0x0408 - 0x0408)
class AOutpost : public ADynamicSpawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Outpost">();
	}
	static class AOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutpost>();
	}
};
static_assert(alignof(AOutpost) == 0x000008, "Wrong alignment on AOutpost");
static_assert(sizeof(AOutpost) == 0x000408, "Wrong size on AOutpost");

// Class HLL.ShooterGameSession
// 0x0318 (0x0550 - 0x0238)
class AShooterGameSession final : public AGameSession
{
public:
	uint8                                         Pad_1533[0x2F8];                                   // 0x0238(0x02F8)(Fixing Size After Last Property [ Dumper-69 ])
	class AOnlineBeaconHost*                      BeaconHost;                                        // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AServerQueueBeaconHostObject*           ServerQueueBeaconHostObject;                       // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEosPlatformSession*                    EosPlatformGameSession;                            // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEosNativeSession*                      EosNativeSession;                                  // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameSession">();
	}
	static class AShooterGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterGameSession>();
	}
};
static_assert(alignof(AShooterGameSession) == 0x000008, "Wrong alignment on AShooterGameSession");
static_assert(sizeof(AShooterGameSession) == 0x000550, "Wrong size on AShooterGameSession");
static_assert(offsetof(AShooterGameSession, BeaconHost) == 0x000530, "Member 'AShooterGameSession::BeaconHost' has a wrong offset!");
static_assert(offsetof(AShooterGameSession, ServerQueueBeaconHostObject) == 0x000538, "Member 'AShooterGameSession::ServerQueueBeaconHostObject' has a wrong offset!");
static_assert(offsetof(AShooterGameSession, EosPlatformGameSession) == 0x000540, "Member 'AShooterGameSession::EosPlatformGameSession' has a wrong offset!");
static_assert(offsetof(AShooterGameSession, EosNativeSession) == 0x000548, "Member 'AShooterGameSession::EosNativeSession' has a wrong offset!");

// Class HLL.Panther
// 0x0000 (0x05F8 - 0x05F8)
class APanther final : public ABaseTank
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Panther">();
	}
	static class APanther* GetDefaultObj()
	{
		return GetDefaultObjImpl<APanther>();
	}
};
static_assert(alignof(APanther) == 0x000008, "Wrong alignment on APanther");
static_assert(sizeof(APanther) == 0x0005F8, "Wrong size on APanther");

// Class HLL.PersonalStatsListDataAsset
// 0x0010 (0x0040 - 0x0030)
class UPersonalStatsListDataAsset final : public UDataAsset
{
public:
	TArray<EHLLPlayerStat>                        BlacklistedStats;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonalStatsListDataAsset">();
	}
	static class UPersonalStatsListDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonalStatsListDataAsset>();
	}
};
static_assert(alignof(UPersonalStatsListDataAsset) == 0x000008, "Wrong alignment on UPersonalStatsListDataAsset");
static_assert(sizeof(UPersonalStatsListDataAsset) == 0x000040, "Wrong size on UPersonalStatsListDataAsset");
static_assert(offsetof(UPersonalStatsListDataAsset, BlacklistedStats) == 0x000030, "Member 'UPersonalStatsListDataAsset::BlacklistedStats' has a wrong offset!");

// Class HLL.PingableComponent
// 0x0008 (0x00B8 - 0x00B0)
class UPingableComponent final : public UActorComponent
{
public:
	EHLLMarker                                    Marker;                                            // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1534[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingableComponent">();
	}
	static class UPingableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingableComponent>();
	}
};
static_assert(alignof(UPingableComponent) == 0x000008, "Wrong alignment on UPingableComponent");
static_assert(sizeof(UPingableComponent) == 0x0000B8, "Wrong size on UPingableComponent");
static_assert(offsetof(UPingableComponent, Marker) == 0x0000B0, "Member 'UPingableComponent::Marker' has a wrong offset!");

// Class HLL.PlaceAPorATMinesProgressionAchievement
// 0x0008 (0x0038 - 0x0030)
class UPlaceAPorATMinesProgressionAchievement final : public UItemDispensedAchievement
{
public:
	EHLLAchievementStat                           AchievementStat;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1535[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceAPorATMinesProgressionAchievement">();
	}
	static class UPlaceAPorATMinesProgressionAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceAPorATMinesProgressionAchievement>();
	}
};
static_assert(alignof(UPlaceAPorATMinesProgressionAchievement) == 0x000008, "Wrong alignment on UPlaceAPorATMinesProgressionAchievement");
static_assert(sizeof(UPlaceAPorATMinesProgressionAchievement) == 0x000038, "Wrong size on UPlaceAPorATMinesProgressionAchievement");
static_assert(offsetof(UPlaceAPorATMinesProgressionAchievement, AchievementStat) == 0x000030, "Member 'UPlaceAPorATMinesProgressionAchievement::AchievementStat' has a wrong offset!");

// Class HLL.HLLFallOutOfWorldDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLFallOutOfWorldDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLFallOutOfWorldDamage">();
	}
	static class UHLLFallOutOfWorldDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLFallOutOfWorldDamage>();
	}
};
static_assert(alignof(UHLLFallOutOfWorldDamage) == 0x000008, "Wrong alignment on UHLLFallOutOfWorldDamage");
static_assert(sizeof(UHLLFallOutOfWorldDamage) == 0x0001E8, "Wrong size on UHLLFallOutOfWorldDamage");

// Class HLL.PlantedObjectiveExplosive
// 0x0000 (0x0220 - 0x0220)
class APlantedObjectiveExplosive final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlantedObjectiveExplosive">();
	}
	static class APlantedObjectiveExplosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlantedObjectiveExplosive>();
	}
};
static_assert(alignof(APlantedObjectiveExplosive) == 0x000008, "Wrong alignment on APlantedObjectiveExplosive");
static_assert(sizeof(APlantedObjectiveExplosive) == 0x000220, "Wrong size on APlantedObjectiveExplosive");

// Class HLL.PlantObjectiveArea
// 0x0100 (0x0338 - 0x0238)
class APlantObjectiveArea final : public AGameObjectiveBase
{
public:
	class FText                                   ObjectiveName;                                     // 0x0238(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         ObjectivePlantTime;                                // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ExplosiveTimer;                                    // 0x0251(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDisarmExplosive;                               // 0x0252(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DisarmExplosiveTime;                               // 0x0253(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeam                                         PlantingTeam;                                      // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1536[0x3];                                     // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   ActionScoreNameDispenseCharge;                     // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionScoreNameDisarmingCharge;                    // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionScoreNameDestroyedEnemyGun;                  // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       TriggerShape;                                      // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ObjectiveAreaDestroyed;                            // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ObjectiveAreaDestroyedMulti;                       // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1537[0x18];                                    // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMapComponent*                       MapComponent;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1538[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterCharacter*                      PlantingPlayer;                                    // 0x02C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterCharacter*                      DisarmingPlayer;                                   // 0x02D0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ExplosiveHasBeenPlanted;                           // 0x02D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsObjectiveDestroyed;                             // 0x02DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         EnemyIsNear;                                       // 0x02DD(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1539[0x2];                                     // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class UPlantObjectivePointComponent*          PlantedObjectivePoint;                             // 0x02E0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlantedObjectiveExplosive*             PlantedExplosive;                                  // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlantObjectivePointComponent*          CurrentInteractablePoint;                          // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPlantObjectivePointComponent*>  ObjectivePointComponents;                          // 0x02F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShooterPlayerState*                    PlayerThatPlantedExplosive;                        // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseExplosiveDamage;                               // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosiveRange;                                    // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosiveDamageFalloff;                            // 0x0318(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_153A[0x4];                                     // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UDamageType>                ExplosiveDamageType;                               // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ExplosionIgnore;                                   // 0x0328(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MulticastExplosiveBeenPlanted();
	void MulticastExplosiveDisarmed();
	void MulticastOnObjectiveDestroyed();
	void OnRep_HasExplosiveBeenPlanted();
	void OnRep_IsObjectiveDestroyed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlantObjectiveArea">();
	}
	static class APlantObjectiveArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlantObjectiveArea>();
	}
};
static_assert(alignof(APlantObjectiveArea) == 0x000008, "Wrong alignment on APlantObjectiveArea");
static_assert(sizeof(APlantObjectiveArea) == 0x000338, "Wrong size on APlantObjectiveArea");
static_assert(offsetof(APlantObjectiveArea, ObjectiveName) == 0x000238, "Member 'APlantObjectiveArea::ObjectiveName' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ObjectivePlantTime) == 0x000250, "Member 'APlantObjectiveArea::ObjectivePlantTime' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ExplosiveTimer) == 0x000251, "Member 'APlantObjectiveArea::ExplosiveTimer' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, bCanDisarmExplosive) == 0x000252, "Member 'APlantObjectiveArea::bCanDisarmExplosive' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, DisarmExplosiveTime) == 0x000253, "Member 'APlantObjectiveArea::DisarmExplosiveTime' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, PlantingTeam) == 0x000254, "Member 'APlantObjectiveArea::PlantingTeam' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ActionScoreNameDispenseCharge) == 0x000258, "Member 'APlantObjectiveArea::ActionScoreNameDispenseCharge' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ActionScoreNameDisarmingCharge) == 0x000260, "Member 'APlantObjectiveArea::ActionScoreNameDisarmingCharge' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ActionScoreNameDestroyedEnemyGun) == 0x000268, "Member 'APlantObjectiveArea::ActionScoreNameDestroyedEnemyGun' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, TriggerShape) == 0x000270, "Member 'APlantObjectiveArea::TriggerShape' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ObjectiveAreaDestroyed) == 0x000278, "Member 'APlantObjectiveArea::ObjectiveAreaDestroyed' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ObjectiveAreaDestroyedMulti) == 0x000288, "Member 'APlantObjectiveArea::ObjectiveAreaDestroyedMulti' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, MapComponent) == 0x0002B0, "Member 'APlantObjectiveArea::MapComponent' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, IndicatorComponent) == 0x0002B8, "Member 'APlantObjectiveArea::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, PlantingPlayer) == 0x0002C8, "Member 'APlantObjectiveArea::PlantingPlayer' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, DisarmingPlayer) == 0x0002D0, "Member 'APlantObjectiveArea::DisarmingPlayer' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ExplosiveHasBeenPlanted) == 0x0002D8, "Member 'APlantObjectiveArea::ExplosiveHasBeenPlanted' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, bIsObjectiveDestroyed) == 0x0002DC, "Member 'APlantObjectiveArea::bIsObjectiveDestroyed' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, EnemyIsNear) == 0x0002DD, "Member 'APlantObjectiveArea::EnemyIsNear' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, PlantedObjectivePoint) == 0x0002E0, "Member 'APlantObjectiveArea::PlantedObjectivePoint' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, PlantedExplosive) == 0x0002E8, "Member 'APlantObjectiveArea::PlantedExplosive' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, CurrentInteractablePoint) == 0x0002F0, "Member 'APlantObjectiveArea::CurrentInteractablePoint' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ObjectivePointComponents) == 0x0002F8, "Member 'APlantObjectiveArea::ObjectivePointComponents' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, PlayerThatPlantedExplosive) == 0x000308, "Member 'APlantObjectiveArea::PlayerThatPlantedExplosive' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, BaseExplosiveDamage) == 0x000310, "Member 'APlantObjectiveArea::BaseExplosiveDamage' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ExplosiveRange) == 0x000314, "Member 'APlantObjectiveArea::ExplosiveRange' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ExplosiveDamageFalloff) == 0x000318, "Member 'APlantObjectiveArea::ExplosiveDamageFalloff' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ExplosiveDamageType) == 0x000320, "Member 'APlantObjectiveArea::ExplosiveDamageType' has a wrong offset!");
static_assert(offsetof(APlantObjectiveArea, ExplosionIgnore) == 0x000328, "Member 'APlantObjectiveArea::ExplosionIgnore' has a wrong offset!");

// Class HLL.PlantObjectiveExplosive
// 0x0000 (0x0028 - 0x0028)
class IPlantObjectiveExplosive final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlantObjectiveExplosive">();
	}
	static class IPlantObjectiveExplosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlantObjectiveExplosive>();
	}
};
static_assert(alignof(IPlantObjectiveExplosive) == 0x000008, "Wrong alignment on IPlantObjectiveExplosive");
static_assert(sizeof(IPlantObjectiveExplosive) == 0x000028, "Wrong size on IPlantObjectiveExplosive");

// Class HLL.PlantObjectivePointComponent
// 0x0020 (0x04B0 - 0x0490)
class UPlantObjectivePointComponent final : public UStaticMeshComponent
{
public:
	class UMaterial*                              PlacementPreviewMaterial;                          // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxInteractableDistance;                           // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxInteractableAngle;                              // 0x0494(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PlacementPreviewMaterialInstanceDynamic;           // 0x0498(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_153B[0x10];                                    // 0x04A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlantObjectivePointComponent">();
	}
	static class UPlantObjectivePointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlantObjectivePointComponent>();
	}
};
static_assert(alignof(UPlantObjectivePointComponent) == 0x000010, "Wrong alignment on UPlantObjectivePointComponent");
static_assert(sizeof(UPlantObjectivePointComponent) == 0x0004B0, "Wrong size on UPlantObjectivePointComponent");
static_assert(offsetof(UPlantObjectivePointComponent, PlacementPreviewMaterial) == 0x000488, "Member 'UPlantObjectivePointComponent::PlacementPreviewMaterial' has a wrong offset!");
static_assert(offsetof(UPlantObjectivePointComponent, MaxInteractableDistance) == 0x000490, "Member 'UPlantObjectivePointComponent::MaxInteractableDistance' has a wrong offset!");
static_assert(offsetof(UPlantObjectivePointComponent, MaxInteractableAngle) == 0x000494, "Member 'UPlantObjectivePointComponent::MaxInteractableAngle' has a wrong offset!");
static_assert(offsetof(UPlantObjectivePointComponent, PlacementPreviewMaterialInstanceDynamic) == 0x000498, "Member 'UPlantObjectivePointComponent::PlacementPreviewMaterialInstanceDynamic' has a wrong offset!");

// Class HLL.PlatoonInvitationDialogPlayer
// 0x0018 (0x0248 - 0x0230)
class UPlatoonInvitationDialogPlayer : public UUserWidget
{
public:
	class UTextBlock*                             PlayerName;                                        // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              Invited;                                           // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_153C[0x8];                                     // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnPlayerRemovedFromList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonInvitationDialogPlayer">();
	}
	static class UPlatoonInvitationDialogPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonInvitationDialogPlayer>();
	}
};
static_assert(alignof(UPlatoonInvitationDialogPlayer) == 0x000008, "Wrong alignment on UPlatoonInvitationDialogPlayer");
static_assert(sizeof(UPlatoonInvitationDialogPlayer) == 0x000248, "Wrong size on UPlatoonInvitationDialogPlayer");
static_assert(offsetof(UPlatoonInvitationDialogPlayer, PlayerName) == 0x000230, "Member 'UPlatoonInvitationDialogPlayer::PlayerName' has a wrong offset!");
static_assert(offsetof(UPlatoonInvitationDialogPlayer, Invited) == 0x000238, "Member 'UPlatoonInvitationDialogPlayer::Invited' has a wrong offset!");

// Class HLL.PlatoonInvitationDialog
// 0x0028 (0x0258 - 0x0230)
class UPlatoonInvitationDialog : public UUserWidget
{
public:
	class UPanelWidget*                           Playerlist;                                        // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Invite;                                            // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Cancel;                                            // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlatoonInvitationDialogPlayer> PlayerListItemWidgetClass;                         // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_153D[0x8];                                     // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UUserWidget* GetWidgetFrom();
	void OnCancelClicked();
	void OnInviteClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonInvitationDialog">();
	}
	static class UPlatoonInvitationDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonInvitationDialog>();
	}
};
static_assert(alignof(UPlatoonInvitationDialog) == 0x000008, "Wrong alignment on UPlatoonInvitationDialog");
static_assert(sizeof(UPlatoonInvitationDialog) == 0x000258, "Wrong size on UPlatoonInvitationDialog");
static_assert(offsetof(UPlatoonInvitationDialog, Playerlist) == 0x000230, "Member 'UPlatoonInvitationDialog::Playerlist' has a wrong offset!");
static_assert(offsetof(UPlatoonInvitationDialog, Invite) == 0x000238, "Member 'UPlatoonInvitationDialog::Invite' has a wrong offset!");
static_assert(offsetof(UPlatoonInvitationDialog, Cancel) == 0x000240, "Member 'UPlatoonInvitationDialog::Cancel' has a wrong offset!");
static_assert(offsetof(UPlatoonInvitationDialog, PlayerListItemWidgetClass) == 0x000248, "Member 'UPlatoonInvitationDialog::PlayerListItemWidgetClass' has a wrong offset!");

// Class HLL.PlatoonList
// 0x0078 (0x02A8 - 0x0230)
class UPlatoonList : public UUserWidget
{
public:
	uint8                                         Pad_153E[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             TitleText;                                         // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlatoonCount;                                      // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           PlatoonListPanel;                                  // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            btn_CreateNew;                                     // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReadOnly : 1;                                     // 0x0268(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInfiniteUnitCount : 1;                            // 0x0268(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_153F[0x7];                                     // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   Title;                                             // 0x0270(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	EPlatoonType                                  PlatoonType;                                       // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1540[0x7];                                     // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UPlatoonListItem>           PlatoonListItemWidgetClass;                        // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHLLPlatoon*                            LastKnownPlayerPlatoon;                            // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         LastPlayerTeam;                                    // 0x02A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1541[0x7];                                     // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnPlatoonListChanged();
	void QueueRebuildList();
	void RebuildPlatoonList();

	TArray<class UPlatoonListItem*> GetPlatoonListItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonList">();
	}
	static class UPlatoonList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonList>();
	}
};
static_assert(alignof(UPlatoonList) == 0x000008, "Wrong alignment on UPlatoonList");
static_assert(sizeof(UPlatoonList) == 0x0002A8, "Wrong size on UPlatoonList");
static_assert(offsetof(UPlatoonList, TitleText) == 0x000248, "Member 'UPlatoonList::TitleText' has a wrong offset!");
static_assert(offsetof(UPlatoonList, PlatoonCount) == 0x000250, "Member 'UPlatoonList::PlatoonCount' has a wrong offset!");
static_assert(offsetof(UPlatoonList, PlatoonListPanel) == 0x000258, "Member 'UPlatoonList::PlatoonListPanel' has a wrong offset!");
static_assert(offsetof(UPlatoonList, btn_CreateNew) == 0x000260, "Member 'UPlatoonList::btn_CreateNew' has a wrong offset!");
static_assert(offsetof(UPlatoonList, Title) == 0x000270, "Member 'UPlatoonList::Title' has a wrong offset!");
static_assert(offsetof(UPlatoonList, PlatoonType) == 0x000288, "Member 'UPlatoonList::PlatoonType' has a wrong offset!");
static_assert(offsetof(UPlatoonList, PlatoonListItemWidgetClass) == 0x000290, "Member 'UPlatoonList::PlatoonListItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlatoonList, LastKnownPlayerPlatoon) == 0x000298, "Member 'UPlatoonList::LastKnownPlayerPlatoon' has a wrong offset!");
static_assert(offsetof(UPlatoonList, LastPlayerTeam) == 0x0002A0, "Member 'UPlatoonList::LastPlayerTeam' has a wrong offset!");

// Class HLL.PlatoonListItem
// 0x0078 (0x02A8 - 0x0230)
class UPlatoonListItem : public UUserWidget
{
public:
	uint8                                         Pad_1542[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnPlatoonMemberCountChange;                        // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlatoonName;                                       // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MemberCount;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                WrapperButton;                                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           PlatoonMembers;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                MainBorder;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                ButtonPanel;                                       // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                SpectatorIcon;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReadOnly : 1;                                     // 0x0290(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bExpanded : 1;                                     // 0x0290(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1543[0x7];                                     // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AHLLPlatoon*                            Platoon;                                           // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlatoonMemberWidget>       PlatoonMemberWidgetClass;                          // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleHeaderClicked();
	void OnInviteClicked();
	void OnJoinButtonClicked();
	void OnLeaveButtonClicked();
	void OnPlatoonInit(class AHLLPlatoon* InPlatoon, bool ReadOnly);
	void OnPlatoonMemberCountChange__DelegateSignature();

	bool CanInvite() const;
	bool IsPlatoonOfficer() const;
	bool IsSelected() const;
	bool ShowingPlayersPlatoon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonListItem">();
	}
	static class UPlatoonListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonListItem>();
	}
};
static_assert(alignof(UPlatoonListItem) == 0x000008, "Wrong alignment on UPlatoonListItem");
static_assert(sizeof(UPlatoonListItem) == 0x0002A8, "Wrong size on UPlatoonListItem");
static_assert(offsetof(UPlatoonListItem, OnPlatoonMemberCountChange) == 0x000248, "Member 'UPlatoonListItem::OnPlatoonMemberCountChange' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, PlatoonName) == 0x000258, "Member 'UPlatoonListItem::PlatoonName' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, MemberCount) == 0x000260, "Member 'UPlatoonListItem::MemberCount' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, WrapperButton) == 0x000268, "Member 'UPlatoonListItem::WrapperButton' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, PlatoonMembers) == 0x000270, "Member 'UPlatoonListItem::PlatoonMembers' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, MainBorder) == 0x000278, "Member 'UPlatoonListItem::MainBorder' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, ButtonPanel) == 0x000280, "Member 'UPlatoonListItem::ButtonPanel' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, SpectatorIcon) == 0x000288, "Member 'UPlatoonListItem::SpectatorIcon' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, Platoon) == 0x000298, "Member 'UPlatoonListItem::Platoon' has a wrong offset!");
static_assert(offsetof(UPlatoonListItem, PlatoonMemberWidgetClass) == 0x0002A0, "Member 'UPlatoonListItem::PlatoonMemberWidgetClass' has a wrong offset!");

// Class HLL.SoundNodeLocalPlayer
// 0x0000 (0x0048 - 0x0048)
class USoundNodeLocalPlayer final : public USoundNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeLocalPlayer">();
	}
	static class USoundNodeLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeLocalPlayer>();
	}
};
static_assert(alignof(USoundNodeLocalPlayer) == 0x000008, "Wrong alignment on USoundNodeLocalPlayer");
static_assert(sizeof(USoundNodeLocalPlayer) == 0x000048, "Wrong size on USoundNodeLocalPlayer");

// Class HLL.PlatoonManagementStackNotification
// 0x0030 (0x0260 - 0x0230)
class UPlatoonManagementStackNotification : public UUserWidget
{
public:
	uint8                                         Pad_1545[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             Title;                                             // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Message;                                           // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisplayTime;                                       // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1546[0x4];                                     // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonManagementStackNotification">();
	}
	static class UPlatoonManagementStackNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonManagementStackNotification>();
	}
};
static_assert(alignof(UPlatoonManagementStackNotification) == 0x000008, "Wrong alignment on UPlatoonManagementStackNotification");
static_assert(sizeof(UPlatoonManagementStackNotification) == 0x000260, "Wrong size on UPlatoonManagementStackNotification");
static_assert(offsetof(UPlatoonManagementStackNotification, Title) == 0x000248, "Member 'UPlatoonManagementStackNotification::Title' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStackNotification, Message) == 0x000250, "Member 'UPlatoonManagementStackNotification::Message' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStackNotification, DisplayTime) == 0x000258, "Member 'UPlatoonManagementStackNotification::DisplayTime' has a wrong offset!");

// Class HLL.PlatoonManagementStackInvite
// 0x0040 (0x0270 - 0x0230)
class UPlatoonManagementStackInvite : public UUserWidget
{
public:
	class UTextBlock*                             Title;                                             // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Message;                                           // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1547[0x28];                                    // 0x0248(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InputChanged(bool NewValue);
	void OnAccepted();
	void OnClose();
	void OnRejected();
	void OnUpdatePrompts();

	bool IsPendingRequests() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonManagementStackInvite">();
	}
	static class UPlatoonManagementStackInvite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonManagementStackInvite>();
	}
};
static_assert(alignof(UPlatoonManagementStackInvite) == 0x000008, "Wrong alignment on UPlatoonManagementStackInvite");
static_assert(sizeof(UPlatoonManagementStackInvite) == 0x000270, "Wrong size on UPlatoonManagementStackInvite");
static_assert(offsetof(UPlatoonManagementStackInvite, Title) == 0x000230, "Member 'UPlatoonManagementStackInvite::Title' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStackInvite, Message) == 0x000238, "Member 'UPlatoonManagementStackInvite::Message' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStackInvite, ViewportClient) == 0x000240, "Member 'UPlatoonManagementStackInvite::ViewportClient' has a wrong offset!");

// Class HLL.PlatoonManagementStackKickRequest
// 0x0020 (0x0290 - 0x0270)
class UPlatoonManagementStackKickRequest : public UPlatoonManagementStackInvite
{
public:
	class UButton*                                NotWithOfficer;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NotCommunicating;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                MakingRoomForFriend;                               // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Cancel;                                            // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CancelKickRequestIfPlayerLeft();
	void FocusOnDeploymentMenu();
	void OnCancelClicked();
	void OnMakingRoomForFriendClicked();
	void OnNotCommunicatingClicked();
	void OnNotWithOfficerClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonManagementStackKickRequest">();
	}
	static class UPlatoonManagementStackKickRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonManagementStackKickRequest>();
	}
};
static_assert(alignof(UPlatoonManagementStackKickRequest) == 0x000008, "Wrong alignment on UPlatoonManagementStackKickRequest");
static_assert(sizeof(UPlatoonManagementStackKickRequest) == 0x000290, "Wrong size on UPlatoonManagementStackKickRequest");
static_assert(offsetof(UPlatoonManagementStackKickRequest, NotWithOfficer) == 0x000270, "Member 'UPlatoonManagementStackKickRequest::NotWithOfficer' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStackKickRequest, NotCommunicating) == 0x000278, "Member 'UPlatoonManagementStackKickRequest::NotCommunicating' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStackKickRequest, MakingRoomForFriend) == 0x000280, "Member 'UPlatoonManagementStackKickRequest::MakingRoomForFriend' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStackKickRequest, Cancel) == 0x000288, "Member 'UPlatoonManagementStackKickRequest::Cancel' has a wrong offset!");

// Class HLL.PlatoonManagementStack
// 0x0038 (0x0268 - 0x0230)
class UPlatoonManagementStack : public UUserWidget
{
public:
	class UBorder*                                RequestsContainer;                                 // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1548[0x10];                                    // 0x0238(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UBorder*                                NotificationsContainer;                            // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlatoonManagementStackNotification> NotificationWidget;                                // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPlatoonManagementNotification> PendingNotifications;                              // 0x0258(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonManagementStack">();
	}
	static class UPlatoonManagementStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonManagementStack>();
	}
};
static_assert(alignof(UPlatoonManagementStack) == 0x000008, "Wrong alignment on UPlatoonManagementStack");
static_assert(sizeof(UPlatoonManagementStack) == 0x000268, "Wrong size on UPlatoonManagementStack");
static_assert(offsetof(UPlatoonManagementStack, RequestsContainer) == 0x000230, "Member 'UPlatoonManagementStack::RequestsContainer' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStack, NotificationsContainer) == 0x000248, "Member 'UPlatoonManagementStack::NotificationsContainer' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStack, NotificationWidget) == 0x000250, "Member 'UPlatoonManagementStack::NotificationWidget' has a wrong offset!");
static_assert(offsetof(UPlatoonManagementStack, PendingNotifications) == 0x000258, "Member 'UPlatoonManagementStack::PendingNotifications' has a wrong offset!");

// Class HLL.ShooterPlayerControllerActivityComponent
// 0x0018 (0x00C8 - 0x00B0)
class UShooterPlayerControllerActivityComponent final : public UActorComponent
{
public:
	class AShooterPlayerController*               ShooterPlayerController;                           // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1549[0x10];                                    // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void RPC_Client_ActivityCancelMatch(const class FString& MatchID);
	void RPC_Client_ActivityCreateMatch(EGameModeType GameMode, const TArray<struct FPlayerActivityData>& Players);
	void RPC_Client_ActivityEndMatch(const class FString& MatchID, const TArray<struct FPlayerActivityData>& Players, const int32 Team0, const int32 Team1);
	void RPC_Client_ActivityRemovePlayerFromMatch(const class FString& MatchID, const struct FUniqueNetIdRepl& RemovedPlayerID);
	void RPC_Client_ActivityStartMatch(const class FString& MatchID);
	void RPC_Client_ActivityUpdateDetailsOfMatch(const class FString& MatchID, const TArray<struct FPlayerActivityData>& Players, const int32 NumPS5Players, const int32 Team0, const int32 Team1);
	void RPC_Client_ActivityUpdateDetailsOfMatchAfterRepPlayerInfo(const class FString& MatchID, const int32 NumPS5Players, const int32 Team0, const int32 Team1);
	void RPC_Server_ActivityForceCancelled();
	void RPC_Server_OnActivityCreateMatchCompleted(const class FString& MatchID, bool Success);
	void RPC_Server_OnActivityEndMatchCompleted(bool Success);
	void RPC_Server_OnActivityRemovePlayerCompleted(bool Success);
	void RPC_Server_OnActivityStartMatchCompleted(bool Success);
	void RPC_Server_OnActivityUpdateMatchCompleted(bool Success);
	void RPC_Server_RegisterAsMatchActivityAgent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerControllerActivityComponent">();
	}
	static class UShooterPlayerControllerActivityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterPlayerControllerActivityComponent>();
	}
};
static_assert(alignof(UShooterPlayerControllerActivityComponent) == 0x000008, "Wrong alignment on UShooterPlayerControllerActivityComponent");
static_assert(sizeof(UShooterPlayerControllerActivityComponent) == 0x0000C8, "Wrong size on UShooterPlayerControllerActivityComponent");
static_assert(offsetof(UShooterPlayerControllerActivityComponent, ShooterPlayerController) == 0x0000B0, "Member 'UShooterPlayerControllerActivityComponent::ShooterPlayerController' has a wrong offset!");

// Class HLL.PlatoonMemberBase
// 0x0048 (0x0278 - 0x0230)
class UPlatoonMemberBase : public UUserWidget
{
public:
	class UTextBlock*                             RoleGlyph;                                         // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerName;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 POIIcon;                                           // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_PingMarker;                                   // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterPlayerState*                    AssignedPlayer;                                    // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         POIFadeTime;                                       // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         POIPulseSpeed;                                     // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           POIPulseColour;                                    // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154E[0x8];                                     // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnPlayerMarkerAdded(class AShooterPlayerState* InPlayer, const struct FRepMarkerItem& MarkerInfo);
	void OnPlayerRoleChanged(class AShooterPlayerState* InPlayer, const EPlayerRole PreviousRole, const EPlayerRole NewRole);
	void PlayerUpdated();
	void SetAssignedPlayer(class AShooterPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonMemberBase">();
	}
	static class UPlatoonMemberBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonMemberBase>();
	}
};
static_assert(alignof(UPlatoonMemberBase) == 0x000008, "Wrong alignment on UPlatoonMemberBase");
static_assert(sizeof(UPlatoonMemberBase) == 0x000278, "Wrong size on UPlatoonMemberBase");
static_assert(offsetof(UPlatoonMemberBase, RoleGlyph) == 0x000230, "Member 'UPlatoonMemberBase::RoleGlyph' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberBase, PlayerName) == 0x000238, "Member 'UPlatoonMemberBase::PlayerName' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberBase, POIIcon) == 0x000240, "Member 'UPlatoonMemberBase::POIIcon' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberBase, Anim_PingMarker) == 0x000248, "Member 'UPlatoonMemberBase::Anim_PingMarker' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberBase, AssignedPlayer) == 0x000250, "Member 'UPlatoonMemberBase::AssignedPlayer' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberBase, POIFadeTime) == 0x000258, "Member 'UPlatoonMemberBase::POIFadeTime' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberBase, POIPulseSpeed) == 0x00025C, "Member 'UPlatoonMemberBase::POIPulseSpeed' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberBase, POIPulseColour) == 0x000260, "Member 'UPlatoonMemberBase::POIPulseColour' has a wrong offset!");

// Class HLL.PlatoonMemberCommander
// 0x0020 (0x0298 - 0x0278)
class UPlatoonMemberCommander : public UPlatoonMemberBase
{
public:
	class UBorder*                                Colouriser;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_NoCommander;                                  // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           WarningColour;                                     // 0x0288(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonMemberCommander">();
	}
	static class UPlatoonMemberCommander* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonMemberCommander>();
	}
};
static_assert(alignof(UPlatoonMemberCommander) == 0x000008, "Wrong alignment on UPlatoonMemberCommander");
static_assert(sizeof(UPlatoonMemberCommander) == 0x000298, "Wrong size on UPlatoonMemberCommander");
static_assert(offsetof(UPlatoonMemberCommander, Colouriser) == 0x000278, "Member 'UPlatoonMemberCommander::Colouriser' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberCommander, Anim_NoCommander) == 0x000280, "Member 'UPlatoonMemberCommander::Anim_NoCommander' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberCommander, WarningColour) == 0x000288, "Member 'UPlatoonMemberCommander::WarningColour' has a wrong offset!");

// Class HLL.PlatoonMemberWidget
// 0x0040 (0x0270 - 0x0230)
class UPlatoonMemberWidget : public UUserWidget
{
public:
	class UImage*                                 PlatformIcon;                                      // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PlatformIconContainer;                             // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                Colouriser;                                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RoleGlyph;                                         // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerName;                                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerClan;                                        // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Kick;                                              // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AShooterPlayerState*                    PlatoonMemberPlayerState;                          // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnKickClicked();
	void OnKickPressedGamepad();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonMemberWidget">();
	}
	static class UPlatoonMemberWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonMemberWidget>();
	}
};
static_assert(alignof(UPlatoonMemberWidget) == 0x000008, "Wrong alignment on UPlatoonMemberWidget");
static_assert(sizeof(UPlatoonMemberWidget) == 0x000270, "Wrong size on UPlatoonMemberWidget");
static_assert(offsetof(UPlatoonMemberWidget, PlatformIcon) == 0x000230, "Member 'UPlatoonMemberWidget::PlatformIcon' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberWidget, PlatformIconContainer) == 0x000238, "Member 'UPlatoonMemberWidget::PlatformIconContainer' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberWidget, Colouriser) == 0x000240, "Member 'UPlatoonMemberWidget::Colouriser' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberWidget, RoleGlyph) == 0x000248, "Member 'UPlatoonMemberWidget::RoleGlyph' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberWidget, PlayerName) == 0x000250, "Member 'UPlatoonMemberWidget::PlayerName' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberWidget, PlayerClan) == 0x000258, "Member 'UPlatoonMemberWidget::PlayerClan' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberWidget, Kick) == 0x000260, "Member 'UPlatoonMemberWidget::Kick' has a wrong offset!");
static_assert(offsetof(UPlatoonMemberWidget, PlatoonMemberPlayerState) == 0x000268, "Member 'UPlatoonMemberWidget::PlatoonMemberPlayerState' has a wrong offset!");

// Class HLL.PlatoonOverrideData
// 0x0030 (0x0060 - 0x0030)
class UPlatoonOverrideData final : public UDataAsset
{
public:
	TArray<EPlatoonType>                          BlacklistedPlatoons;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           BlacklistedRoles;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfantryCount;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorCount;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReconCount;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1551[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonOverrideData">();
	}
	static class UPlatoonOverrideData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonOverrideData>();
	}
};
static_assert(alignof(UPlatoonOverrideData) == 0x000008, "Wrong alignment on UPlatoonOverrideData");
static_assert(sizeof(UPlatoonOverrideData) == 0x000060, "Wrong size on UPlatoonOverrideData");
static_assert(offsetof(UPlatoonOverrideData, BlacklistedPlatoons) == 0x000030, "Member 'UPlatoonOverrideData::BlacklistedPlatoons' has a wrong offset!");
static_assert(offsetof(UPlatoonOverrideData, BlacklistedRoles) == 0x000040, "Member 'UPlatoonOverrideData::BlacklistedRoles' has a wrong offset!");
static_assert(offsetof(UPlatoonOverrideData, InfantryCount) == 0x000050, "Member 'UPlatoonOverrideData::InfantryCount' has a wrong offset!");
static_assert(offsetof(UPlatoonOverrideData, ArmorCount) == 0x000054, "Member 'UPlatoonOverrideData::ArmorCount' has a wrong offset!");
static_assert(offsetof(UPlatoonOverrideData, ReconCount) == 0x000058, "Member 'UPlatoonOverrideData::ReconCount' has a wrong offset!");

// Class HLL.SphereSectorCaptureBooster
// 0x0008 (0x0288 - 0x0280)
class ASphereSectorCaptureBooster final : public ASectorCaptureBooster
{
public:
	class USphereComponent*                       TriggerShape;                                      // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SphereSectorCaptureBooster">();
	}
	static class ASphereSectorCaptureBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASphereSectorCaptureBooster>();
	}
};
static_assert(alignof(ASphereSectorCaptureBooster) == 0x000008, "Wrong alignment on ASphereSectorCaptureBooster");
static_assert(sizeof(ASphereSectorCaptureBooster) == 0x000288, "Wrong size on ASphereSectorCaptureBooster");
static_assert(offsetof(ASphereSectorCaptureBooster, TriggerShape) == 0x000280, "Member 'ASphereSectorCaptureBooster::TriggerShape' has a wrong offset!");

// Class HLL.PlayerMountedBipodSettings
// 0x0038 (0x0068 - 0x0030)
class UPlayerMountedBipodSettings final : public UDataAsset
{
public:
	struct FPerStanceBipodSettings                StandingSettings;                                  // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerStanceBipodSettings                CrouchedSettings;                                  // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerStanceBipodSettings                ProneSettings;                                     // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ObstructionQueryRadius;                            // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleOfObstructionTraceLeft;                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleOfObstructionTraceRight;                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetFromObstructionLeft;                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetFromObstructionRight;                        // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMountedBipodSettings">();
	}
	static class UPlayerMountedBipodSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMountedBipodSettings>();
	}
};
static_assert(alignof(UPlayerMountedBipodSettings) == 0x000008, "Wrong alignment on UPlayerMountedBipodSettings");
static_assert(sizeof(UPlayerMountedBipodSettings) == 0x000068, "Wrong size on UPlayerMountedBipodSettings");
static_assert(offsetof(UPlayerMountedBipodSettings, StandingSettings) == 0x000030, "Member 'UPlayerMountedBipodSettings::StandingSettings' has a wrong offset!");
static_assert(offsetof(UPlayerMountedBipodSettings, CrouchedSettings) == 0x00003C, "Member 'UPlayerMountedBipodSettings::CrouchedSettings' has a wrong offset!");
static_assert(offsetof(UPlayerMountedBipodSettings, ProneSettings) == 0x000048, "Member 'UPlayerMountedBipodSettings::ProneSettings' has a wrong offset!");
static_assert(offsetof(UPlayerMountedBipodSettings, ObstructionQueryRadius) == 0x000054, "Member 'UPlayerMountedBipodSettings::ObstructionQueryRadius' has a wrong offset!");
static_assert(offsetof(UPlayerMountedBipodSettings, ScaleOfObstructionTraceLeft) == 0x000058, "Member 'UPlayerMountedBipodSettings::ScaleOfObstructionTraceLeft' has a wrong offset!");
static_assert(offsetof(UPlayerMountedBipodSettings, ScaleOfObstructionTraceRight) == 0x00005C, "Member 'UPlayerMountedBipodSettings::ScaleOfObstructionTraceRight' has a wrong offset!");
static_assert(offsetof(UPlayerMountedBipodSettings, OffsetFromObstructionLeft) == 0x000060, "Member 'UPlayerMountedBipodSettings::OffsetFromObstructionLeft' has a wrong offset!");
static_assert(offsetof(UPlayerMountedBipodSettings, OffsetFromObstructionRight) == 0x000064, "Member 'UPlayerMountedBipodSettings::OffsetFromObstructionRight' has a wrong offset!");

// Class HLL.PlayerRevivedAchievement
// 0x0000 (0x0030 - 0x0030)
class UPlayerRevivedAchievement : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerRevivedAchievement">();
	}
	static class UPlayerRevivedAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerRevivedAchievement>();
	}
};
static_assert(alignof(UPlayerRevivedAchievement) == 0x000008, "Wrong alignment on UPlayerRevivedAchievement");
static_assert(sizeof(UPlayerRevivedAchievement) == 0x000030, "Wrong size on UPlayerRevivedAchievement");

// Class HLL.PlayerRevivedProgressionTrackAchievement
// 0x0008 (0x0038 - 0x0030)
class UPlayerRevivedProgressionTrackAchievement final : public UPlayerRevivedAchievement
{
public:
	EHLLAchievementStat                           AchievementStat;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1552[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerRevivedProgressionTrackAchievement">();
	}
	static class UPlayerRevivedProgressionTrackAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerRevivedProgressionTrackAchievement>();
	}
};
static_assert(alignof(UPlayerRevivedProgressionTrackAchievement) == 0x000008, "Wrong alignment on UPlayerRevivedProgressionTrackAchievement");
static_assert(sizeof(UPlayerRevivedProgressionTrackAchievement) == 0x000038, "Wrong size on UPlayerRevivedProgressionTrackAchievement");
static_assert(offsetof(UPlayerRevivedProgressionTrackAchievement, AchievementStat) == 0x000030, "Member 'UPlayerRevivedProgressionTrackAchievement::AchievementStat' has a wrong offset!");

// Class HLL.PlayerRoleSelection
// 0x0050 (0x0280 - 0x0230)
class UPlayerRoleSelection final : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerRoleSelected;                              // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UAvailableRole>             AvailableRoleWidgetClass;                          // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           AvailableRolesList;                                // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SelectButton;                                      // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                CancelButton;                                      // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAvailableRole*>                 M_availableRoles;                                  // 0x0260(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAvailableRole*>                 M_availableRoles2;                                 // 0x0270(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BindCallbacks();
	void DisplayErrorMessage(const class FText& Message);
	void FinishLoading();
	void HandlePlatoonMembersChanged(class AHLLPlatoon* Platoon);
	void OnCancelClicked();
	void OnFailedRoleChange();
	void OnPlayerRoleChanged(class AShooterPlayerState* Player, const EPlayerRole PrevRole, const EPlayerRole NewRole);
	void OnPlayerRoleSelected__DelegateSignature(EPlayerRole PlayerRole);
	void OnSelectClicked();
	void OnShow();
	void OnSuccessfulRoleChange(class AShooterPlayerState* Player, const EPlayerRole PreviousRole, const EPlayerRole NewRole);
	void OnWindowClose();
	void StartLoading();
	void UnbindCallbacks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerRoleSelection">();
	}
	static class UPlayerRoleSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerRoleSelection>();
	}
};
static_assert(alignof(UPlayerRoleSelection) == 0x000008, "Wrong alignment on UPlayerRoleSelection");
static_assert(sizeof(UPlayerRoleSelection) == 0x000280, "Wrong size on UPlayerRoleSelection");
static_assert(offsetof(UPlayerRoleSelection, OnPlayerRoleSelected) == 0x000230, "Member 'UPlayerRoleSelection::OnPlayerRoleSelected' has a wrong offset!");
static_assert(offsetof(UPlayerRoleSelection, AvailableRoleWidgetClass) == 0x000240, "Member 'UPlayerRoleSelection::AvailableRoleWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerRoleSelection, AvailableRolesList) == 0x000248, "Member 'UPlayerRoleSelection::AvailableRolesList' has a wrong offset!");
static_assert(offsetof(UPlayerRoleSelection, SelectButton) == 0x000250, "Member 'UPlayerRoleSelection::SelectButton' has a wrong offset!");
static_assert(offsetof(UPlayerRoleSelection, CancelButton) == 0x000258, "Member 'UPlayerRoleSelection::CancelButton' has a wrong offset!");
static_assert(offsetof(UPlayerRoleSelection, M_availableRoles) == 0x000260, "Member 'UPlayerRoleSelection::M_availableRoles' has a wrong offset!");
static_assert(offsetof(UPlayerRoleSelection, M_availableRoles2) == 0x000270, "Member 'UPlayerRoleSelection::M_availableRoles2' has a wrong offset!");

// Class HLL.ServerQueueFrontend
// 0x0170 (0x0390 - 0x0220)
class AServerQueueFrontend final : public AInfo
{
public:
	FMulticastInlineDelegateProperty_             OnConfirmLeavingQueue;                             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1555[0x10];                                    // 0x0238(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UServerQueuePopup>          ProgressWidgetClass;                               // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ProgressWidgetZOrder;                              // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1556[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AServerQueueBeaconClient*               BeaconClient;                                      // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UServerQueuePopup*                      ProgressWidget;                                    // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1557[0x128];                                   // 0x0268(0x0128)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void DisplayLeavingServerQueueDialog();
	void OnBeaconClientDestroyed(class AActor* Actor);

	class UServerQueuePopup* GetServerQueuePopup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerQueueFrontend">();
	}
	static class AServerQueueFrontend* GetDefaultObj()
	{
		return GetDefaultObjImpl<AServerQueueFrontend>();
	}
};
static_assert(alignof(AServerQueueFrontend) == 0x000008, "Wrong alignment on AServerQueueFrontend");
static_assert(sizeof(AServerQueueFrontend) == 0x000390, "Wrong size on AServerQueueFrontend");
static_assert(offsetof(AServerQueueFrontend, OnConfirmLeavingQueue) == 0x000220, "Member 'AServerQueueFrontend::OnConfirmLeavingQueue' has a wrong offset!");
static_assert(offsetof(AServerQueueFrontend, ViewportClient) == 0x000230, "Member 'AServerQueueFrontend::ViewportClient' has a wrong offset!");
static_assert(offsetof(AServerQueueFrontend, ProgressWidgetClass) == 0x000248, "Member 'AServerQueueFrontend::ProgressWidgetClass' has a wrong offset!");
static_assert(offsetof(AServerQueueFrontend, ProgressWidgetZOrder) == 0x000250, "Member 'AServerQueueFrontend::ProgressWidgetZOrder' has a wrong offset!");
static_assert(offsetof(AServerQueueFrontend, BeaconClient) == 0x000258, "Member 'AServerQueueFrontend::BeaconClient' has a wrong offset!");
static_assert(offsetof(AServerQueueFrontend, ProgressWidget) == 0x000260, "Member 'AServerQueueFrontend::ProgressWidget' has a wrong offset!");

// Class HLL.PlaylistSubsystem
// 0x0020 (0x0050 - 0x0030)
class UPlaylistSubsystem final : public UGameInstanceSubsystem
{
public:
	struct FSoftObjectPath                        PlaylistDataTablePath;                             // 0x0030(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PlaylistDataTable;                                 // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetMatchmakingPlaylist(const class FName& PlaylistRowName);

	class FText GetPlaylistLocalisedDescription(const class FName& PlaylistRowName) const;
	class FText GetPlaylistLocalisedText(const class FName& PlaylistRowName) const;
	bool IsPlaylistValid(const class FName& PlaylistRowName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaylistSubsystem">();
	}
	static class UPlaylistSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaylistSubsystem>();
	}
};
static_assert(alignof(UPlaylistSubsystem) == 0x000008, "Wrong alignment on UPlaylistSubsystem");
static_assert(sizeof(UPlaylistSubsystem) == 0x000050, "Wrong size on UPlaylistSubsystem");
static_assert(offsetof(UPlaylistSubsystem, PlaylistDataTablePath) == 0x000030, "Member 'UPlaylistSubsystem::PlaylistDataTablePath' has a wrong offset!");
static_assert(offsetof(UPlaylistSubsystem, PlaylistDataTable) == 0x000048, "Member 'UPlaylistSubsystem::PlaylistDataTable' has a wrong offset!");

// Class HLL.PracticeRangeAllRolesAchievement
// 0x0010 (0x0040 - 0x0030)
class UPracticeRangeAllRolesAchievement final : public UGameStateEventAchievement
{
public:
	TArray<EPlayerRole>                           RequiredRolesToPlay;                               // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PracticeRangeAllRolesAchievement">();
	}
	static class UPracticeRangeAllRolesAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPracticeRangeAllRolesAchievement>();
	}
};
static_assert(alignof(UPracticeRangeAllRolesAchievement) == 0x000008, "Wrong alignment on UPracticeRangeAllRolesAchievement");
static_assert(sizeof(UPracticeRangeAllRolesAchievement) == 0x000040, "Wrong size on UPracticeRangeAllRolesAchievement");
static_assert(offsetof(UPracticeRangeAllRolesAchievement, RequiredRolesToPlay) == 0x000030, "Member 'UPracticeRangeAllRolesAchievement::RequiredRolesToPlay' has a wrong offset!");

// Class HLL.PracticeRangeScarecrow
// 0x0008 (0x0228 - 0x0220)
class APracticeRangeScarecrow final : public AActor
{
public:
	class UStaticMeshComponent*                   ScarecrowHelmetMesh;                               // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CheckHeadShotEvent(const struct FVector& Direction, const struct FVector& Location, class UPrimitiveComponent* HitMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PracticeRangeScarecrow">();
	}
	static class APracticeRangeScarecrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<APracticeRangeScarecrow>();
	}
};
static_assert(alignof(APracticeRangeScarecrow) == 0x000008, "Wrong alignment on APracticeRangeScarecrow");
static_assert(sizeof(APracticeRangeScarecrow) == 0x000228, "Wrong size on APracticeRangeScarecrow");
static_assert(offsetof(APracticeRangeScarecrow, ScarecrowHelmetMesh) == 0x000220, "Member 'APracticeRangeScarecrow::ScarecrowHelmetMesh' has a wrong offset!");

// Class HLL.PreplacedGarrison
// 0x0000 (0x0410 - 0x0410)
class APreplacedGarrison final : public AGarrison
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreplacedGarrison">();
	}
	static class APreplacedGarrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreplacedGarrison>();
	}
};
static_assert(alignof(APreplacedGarrison) == 0x000008, "Wrong alignment on APreplacedGarrison");
static_assert(sizeof(APreplacedGarrison) == 0x000410, "Wrong size on APreplacedGarrison");

// Class HLL.PreplacedGarrisonSpawn
// 0x0008 (0x0228 - 0x0220)
class APreplacedGarrisonSpawn final : public AActor
{
public:
	TSubclassOf<class APreplacedGarrison>         GarrisonToSpawn;                                   // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreplacedGarrisonSpawn">();
	}
	static class APreplacedGarrisonSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreplacedGarrisonSpawn>();
	}
};
static_assert(alignof(APreplacedGarrisonSpawn) == 0x000008, "Wrong alignment on APreplacedGarrisonSpawn");
static_assert(sizeof(APreplacedGarrisonSpawn) == 0x000228, "Wrong size on APreplacedGarrisonSpawn");
static_assert(offsetof(APreplacedGarrisonSpawn, GarrisonToSpawn) == 0x000220, "Member 'APreplacedGarrisonSpawn::GarrisonToSpawn' has a wrong offset!");

// Class HLL.PreplacedSpawnVolume
// 0x0028 (0x0280 - 0x0258)
class APreplacedSpawnVolume final : public AVolume
{
public:
	class APreplacedSpawn*                        PreplacedSpawn;                                    // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepDistance;                                      // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinNumberOfSpawnPointsToGenerate;                  // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnPointZOffset;                                 // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1559[0x4];                                     // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AWarfareStart*>                  GeneratedSpawnPoints;                              // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreplacedSpawnVolume">();
	}
	static class APreplacedSpawnVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreplacedSpawnVolume>();
	}
};
static_assert(alignof(APreplacedSpawnVolume) == 0x000008, "Wrong alignment on APreplacedSpawnVolume");
static_assert(sizeof(APreplacedSpawnVolume) == 0x000280, "Wrong size on APreplacedSpawnVolume");
static_assert(offsetof(APreplacedSpawnVolume, PreplacedSpawn) == 0x000258, "Member 'APreplacedSpawnVolume::PreplacedSpawn' has a wrong offset!");
static_assert(offsetof(APreplacedSpawnVolume, StepDistance) == 0x000260, "Member 'APreplacedSpawnVolume::StepDistance' has a wrong offset!");
static_assert(offsetof(APreplacedSpawnVolume, MinNumberOfSpawnPointsToGenerate) == 0x000264, "Member 'APreplacedSpawnVolume::MinNumberOfSpawnPointsToGenerate' has a wrong offset!");
static_assert(offsetof(APreplacedSpawnVolume, SpawnPointZOffset) == 0x000268, "Member 'APreplacedSpawnVolume::SpawnPointZOffset' has a wrong offset!");
static_assert(offsetof(APreplacedSpawnVolume, GeneratedSpawnPoints) == 0x000270, "Member 'APreplacedSpawnVolume::GeneratedSpawnPoints' has a wrong offset!");

// Class HLL.ProgressionSaveData
// 0x0010 (0x0038 - 0x0028)
class UProgressionSaveData final : public USaveGame
{
public:
	TArray<EPlayerRole>                           PracticeRangeDeployedRoles;                        // 0x0028(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionSaveData">();
	}
	static class UProgressionSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionSaveData>();
	}
};
static_assert(alignof(UProgressionSaveData) == 0x000008, "Wrong alignment on UProgressionSaveData");
static_assert(sizeof(UProgressionSaveData) == 0x000038, "Wrong size on UProgressionSaveData");
static_assert(offsetof(UProgressionSaveData, PracticeRangeDeployedRoles) == 0x000028, "Member 'UProgressionSaveData::PracticeRangeDeployedRoles' has a wrong offset!");

// Class HLL.ProgressionSaveSubsystem
// 0x0010 (0x0040 - 0x0030)
class UProgressionSaveSubsystem final : public UGameInstanceSubsystem
{
public:
	class UProgressionSaveData*                   SaveData;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_155A[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionSaveSubsystem">();
	}
	static class UProgressionSaveSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionSaveSubsystem>();
	}
};
static_assert(alignof(UProgressionSaveSubsystem) == 0x000008, "Wrong alignment on UProgressionSaveSubsystem");
static_assert(sizeof(UProgressionSaveSubsystem) == 0x000040, "Wrong size on UProgressionSaveSubsystem");
static_assert(offsetof(UProgressionSaveSubsystem, SaveData) == 0x000030, "Member 'UProgressionSaveSubsystem::SaveData' has a wrong offset!");

// Class HLL.RCONCommandSetMaxQueuedPlayers
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetMaxQueuedPlayers final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetMaxQueuedPlayers">();
	}
	static class URCONCommandSetMaxQueuedPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetMaxQueuedPlayers>();
	}
};
static_assert(alignof(URCONCommandSetMaxQueuedPlayers) == 0x000008, "Wrong alignment on URCONCommandSetMaxQueuedPlayers");
static_assert(sizeof(URCONCommandSetMaxQueuedPlayers) == 0x000028, "Wrong size on URCONCommandSetMaxQueuedPlayers");

// Class HLL.ProhibitedAchievementsData
// 0x0020 (0x0050 - 0x0030)
class UProhibitedAchievementsData final : public UDataAsset
{
public:
	TArray<EHLLAchievement>                       ProhibitedAchievements;                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EHLLAchievementStat>                   ProhibitedAchievementsStats;                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProhibitedAchievementsData">();
	}
	static class UProhibitedAchievementsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProhibitedAchievementsData>();
	}
};
static_assert(alignof(UProhibitedAchievementsData) == 0x000008, "Wrong alignment on UProhibitedAchievementsData");
static_assert(sizeof(UProhibitedAchievementsData) == 0x000050, "Wrong size on UProhibitedAchievementsData");
static_assert(offsetof(UProhibitedAchievementsData, ProhibitedAchievements) == 0x000030, "Member 'UProhibitedAchievementsData::ProhibitedAchievements' has a wrong offset!");
static_assert(offsetof(UProhibitedAchievementsData, ProhibitedAchievementsStats) == 0x000040, "Member 'UProhibitedAchievementsData::ProhibitedAchievementsStats' has a wrong offset!");

// Class HLL.ProneMechanicsTestLogic
// 0x0040 (0x0260 - 0x0220)
class AProneMechanicsTestLogic final : public AActor
{
public:
	class AShooterCharacterT1*                    StandToCrouchChar;                                 // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AShooterCharacterT1*                    ProneToStandChar;                                  // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AShooterCharacterT1*                    ProneToCrouchChar;                                 // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AShooterCharacterT1*                    CantLeaveProneChar;                                // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AShooterCharacterT1*                    CanLeaveProneToCrouchChar;                         // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AShooterCharacterT1*                    ProneToSlopeChar;                                  // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AShooterCharacterT1*                    CrawlSlopeChar;                                    // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155B[0x8];                                     // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProneMechanicsTestLogic">();
	}
	static class AProneMechanicsTestLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProneMechanicsTestLogic>();
	}
};
static_assert(alignof(AProneMechanicsTestLogic) == 0x000008, "Wrong alignment on AProneMechanicsTestLogic");
static_assert(sizeof(AProneMechanicsTestLogic) == 0x000260, "Wrong size on AProneMechanicsTestLogic");
static_assert(offsetof(AProneMechanicsTestLogic, StandToCrouchChar) == 0x000220, "Member 'AProneMechanicsTestLogic::StandToCrouchChar' has a wrong offset!");
static_assert(offsetof(AProneMechanicsTestLogic, ProneToStandChar) == 0x000228, "Member 'AProneMechanicsTestLogic::ProneToStandChar' has a wrong offset!");
static_assert(offsetof(AProneMechanicsTestLogic, ProneToCrouchChar) == 0x000230, "Member 'AProneMechanicsTestLogic::ProneToCrouchChar' has a wrong offset!");
static_assert(offsetof(AProneMechanicsTestLogic, CantLeaveProneChar) == 0x000238, "Member 'AProneMechanicsTestLogic::CantLeaveProneChar' has a wrong offset!");
static_assert(offsetof(AProneMechanicsTestLogic, CanLeaveProneToCrouchChar) == 0x000240, "Member 'AProneMechanicsTestLogic::CanLeaveProneToCrouchChar' has a wrong offset!");
static_assert(offsetof(AProneMechanicsTestLogic, ProneToSlopeChar) == 0x000248, "Member 'AProneMechanicsTestLogic::ProneToSlopeChar' has a wrong offset!");
static_assert(offsetof(AProneMechanicsTestLogic, CrawlSlopeChar) == 0x000250, "Member 'AProneMechanicsTestLogic::CrawlSlopeChar' has a wrong offset!");

// Class HLL.Puma
// 0x0000 (0x05C0 - 0x05C0)
class APuma final : public ABaseReconVehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Puma">();
	}
	static class APuma* GetDefaultObj()
	{
		return GetDefaultObjImpl<APuma>();
	}
};
static_assert(alignof(APuma) == 0x000008, "Wrong alignment on APuma");
static_assert(sizeof(APuma) == 0x0005C0, "Wrong size on APuma");

// Class HLL.RCONCommandAddAdmin
// 0x0000 (0x0028 - 0x0028)
class URCONCommandAddAdmin final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandAddAdmin">();
	}
	static class URCONCommandAddAdmin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandAddAdmin>();
	}
};
static_assert(alignof(URCONCommandAddAdmin) == 0x000008, "Wrong alignment on URCONCommandAddAdmin");
static_assert(sizeof(URCONCommandAddAdmin) == 0x000028, "Wrong size on URCONCommandAddAdmin");

// Class HLL.RCONCommandAddBannedWords
// 0x0000 (0x0028 - 0x0028)
class URCONCommandAddBannedWords final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandAddBannedWords">();
	}
	static class URCONCommandAddBannedWords* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandAddBannedWords>();
	}
};
static_assert(alignof(URCONCommandAddBannedWords) == 0x000008, "Wrong alignment on URCONCommandAddBannedWords");
static_assert(sizeof(URCONCommandAddBannedWords) == 0x000028, "Wrong size on URCONCommandAddBannedWords");

// Class HLL.RCONCommandAddMapToRotation
// 0x0000 (0x0028 - 0x0028)
class URCONCommandAddMapToRotation final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandAddMapToRotation">();
	}
	static class URCONCommandAddMapToRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandAddMapToRotation>();
	}
};
static_assert(alignof(URCONCommandAddMapToRotation) == 0x000008, "Wrong alignment on URCONCommandAddMapToRotation");
static_assert(sizeof(URCONCommandAddMapToRotation) == 0x000028, "Wrong size on URCONCommandAddMapToRotation");

// Class HLL.RCONCommandAddMapToSequence
// 0x0000 (0x0028 - 0x0028)
class URCONCommandAddMapToSequence final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandAddMapToSequence">();
	}
	static class URCONCommandAddMapToSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandAddMapToSequence>();
	}
};
static_assert(alignof(URCONCommandAddMapToSequence) == 0x000008, "Wrong alignment on URCONCommandAddMapToSequence");
static_assert(sizeof(URCONCommandAddMapToSequence) == 0x000028, "Wrong size on URCONCommandAddMapToSequence");

// Class HLL.RCONJsonReader
// 0x0000 (0x0028 - 0x0028)
class URCONJsonReader final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONJsonReader">();
	}
	static class URCONJsonReader* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONJsonReader>();
	}
};
static_assert(alignof(URCONJsonReader) == 0x000008, "Wrong alignment on URCONJsonReader");
static_assert(sizeof(URCONJsonReader) == 0x000028, "Wrong size on URCONJsonReader");

// Class HLL.RCONCommandAddVipPlayer
// 0x0000 (0x0028 - 0x0028)
class URCONCommandAddVipPlayer final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandAddVipPlayer">();
	}
	static class URCONCommandAddVipPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandAddVipPlayer>();
	}
};
static_assert(alignof(URCONCommandAddVipPlayer) == 0x000008, "Wrong alignment on URCONCommandAddVipPlayer");
static_assert(sizeof(URCONCommandAddVipPlayer) == 0x000028, "Wrong size on URCONCommandAddVipPlayer");

// Class HLL.RCONCommandChangeMap
// 0x0000 (0x0028 - 0x0028)
class URCONCommandChangeMap final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandChangeMap">();
	}
	static class URCONCommandChangeMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandChangeMap>();
	}
};
static_assert(alignof(URCONCommandChangeMap) == 0x000008, "Wrong alignment on URCONCommandChangeMap");
static_assert(sizeof(URCONCommandChangeMap) == 0x000028, "Wrong size on URCONCommandChangeMap");

// Class HLL.RCONCommandGetAdminLog
// 0x0000 (0x0028 - 0x0028)
class URCONCommandGetAdminLog final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandGetAdminLog">();
	}
	static class URCONCommandGetAdminLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandGetAdminLog>();
	}
};
static_assert(alignof(URCONCommandGetAdminLog) == 0x000008, "Wrong alignment on URCONCommandGetAdminLog");
static_assert(sizeof(URCONCommandGetAdminLog) == 0x000028, "Wrong size on URCONCommandGetAdminLog");

// Class HLL.RCONCommandGetClientData
// 0x0000 (0x0028 - 0x0028)
class URCONCommandGetClientData final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandGetClientData">();
	}
	static class URCONCommandGetClientData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandGetClientData>();
	}
};
static_assert(alignof(URCONCommandGetClientData) == 0x000008, "Wrong alignment on URCONCommandGetClientData");
static_assert(sizeof(URCONCommandGetClientData) == 0x000028, "Wrong size on URCONCommandGetClientData");

// Class HLL.ServerPingSubsystem
// 0x0020 (0x0050 - 0x0030)
class UServerPingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_155C[0x20];                                    // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerPingSubsystem">();
	}
	static class UServerPingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerPingSubsystem>();
	}
};
static_assert(alignof(UServerPingSubsystem) == 0x000008, "Wrong alignment on UServerPingSubsystem");
static_assert(sizeof(UServerPingSubsystem) == 0x000050, "Wrong size on UServerPingSubsystem");

// Class HLL.RCONCommandGetDisplayableCommands
// 0x0000 (0x0028 - 0x0028)
class URCONCommandGetDisplayableCommands final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandGetDisplayableCommands">();
	}
	static class URCONCommandGetDisplayableCommands* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandGetDisplayableCommands>();
	}
};
static_assert(alignof(URCONCommandGetDisplayableCommands) == 0x000008, "Wrong alignment on URCONCommandGetDisplayableCommands");
static_assert(sizeof(URCONCommandGetDisplayableCommands) == 0x000028, "Wrong size on URCONCommandGetDisplayableCommands");

// Class HLL.RCONCommandGetServerInfo
// 0x0000 (0x0028 - 0x0028)
class URCONCommandGetServerInfo final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandGetServerInfo">();
	}
	static class URCONCommandGetServerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandGetServerInfo>();
	}
};
static_assert(alignof(URCONCommandGetServerInfo) == 0x000008, "Wrong alignment on URCONCommandGetServerInfo");
static_assert(sizeof(URCONCommandGetServerInfo) == 0x000028, "Wrong size on URCONCommandGetServerInfo");

// Class HLL.RCONCommandKickPlayer
// 0x0000 (0x0028 - 0x0028)
class URCONCommandKickPlayer final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandKickPlayer">();
	}
	static class URCONCommandKickPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandKickPlayer>();
	}
};
static_assert(alignof(URCONCommandKickPlayer) == 0x000008, "Wrong alignment on URCONCommandKickPlayer");
static_assert(sizeof(URCONCommandKickPlayer) == 0x000028, "Wrong size on URCONCommandKickPlayer");

// Class HLL.RCONCommandLogin
// 0x0000 (0x0028 - 0x0028)
class URCONCommandLogin final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandLogin">();
	}
	static class URCONCommandLogin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandLogin>();
	}
};
static_assert(alignof(URCONCommandLogin) == 0x000008, "Wrong alignment on URCONCommandLogin");
static_assert(sizeof(URCONCommandLogin) == 0x000028, "Wrong size on URCONCommandLogin");

// Class HLL.RCONServerInfoPlayer
// 0x0000 (0x0028 - 0x0028)
class URCONServerInfoPlayer final : public URCONServerInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerInfoPlayer">();
	}
	static class URCONServerInfoPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerInfoPlayer>();
	}
};
static_assert(alignof(URCONServerInfoPlayer) == 0x000008, "Wrong alignment on URCONServerInfoPlayer");
static_assert(sizeof(URCONServerInfoPlayer) == 0x000028, "Wrong size on URCONServerInfoPlayer");

// Class HLL.RCONCommandMessagePlayer
// 0x0000 (0x0028 - 0x0028)
class URCONCommandMessagePlayer final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandMessagePlayer">();
	}
	static class URCONCommandMessagePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandMessagePlayer>();
	}
};
static_assert(alignof(URCONCommandMessagePlayer) == 0x000008, "Wrong alignment on URCONCommandMessagePlayer");
static_assert(sizeof(URCONCommandMessagePlayer) == 0x000028, "Wrong size on URCONCommandMessagePlayer");

// Class HLL.RCONCommandMoveMapInSequence
// 0x0000 (0x0028 - 0x0028)
class URCONCommandMoveMapInSequence final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandMoveMapInSequence">();
	}
	static class URCONCommandMoveMapInSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandMoveMapInSequence>();
	}
};
static_assert(alignof(URCONCommandMoveMapInSequence) == 0x000008, "Wrong alignment on URCONCommandMoveMapInSequence");
static_assert(sizeof(URCONCommandMoveMapInSequence) == 0x000028, "Wrong size on URCONCommandMoveMapInSequence");

// Class HLL.RCONCommandPermanentBan
// 0x0000 (0x0028 - 0x0028)
class URCONCommandPermanentBan final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandPermanentBan">();
	}
	static class URCONCommandPermanentBan* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandPermanentBan>();
	}
};
static_assert(alignof(URCONCommandPermanentBan) == 0x000008, "Wrong alignment on URCONCommandPermanentBan");
static_assert(sizeof(URCONCommandPermanentBan) == 0x000028, "Wrong size on URCONCommandPermanentBan");

// Class HLL.RCONCommandPunishPlayer
// 0x0000 (0x0028 - 0x0028)
class URCONCommandPunishPlayer final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandPunishPlayer">();
	}
	static class URCONCommandPunishPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandPunishPlayer>();
	}
};
static_assert(alignof(URCONCommandPunishPlayer) == 0x000008, "Wrong alignment on URCONCommandPunishPlayer");
static_assert(sizeof(URCONCommandPunishPlayer) == 0x000028, "Wrong size on URCONCommandPunishPlayer");

// Class HLL.RCONCommandRemoveAdmin
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveAdmin final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveAdmin">();
	}
	static class URCONCommandRemoveAdmin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveAdmin>();
	}
};
static_assert(alignof(URCONCommandRemoveAdmin) == 0x000008, "Wrong alignment on URCONCommandRemoveAdmin");
static_assert(sizeof(URCONCommandRemoveAdmin) == 0x000028, "Wrong size on URCONCommandRemoveAdmin");

// Class HLL.RCONCommandRemoveBannedWords
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveBannedWords final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveBannedWords">();
	}
	static class URCONCommandRemoveBannedWords* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveBannedWords>();
	}
};
static_assert(alignof(URCONCommandRemoveBannedWords) == 0x000008, "Wrong alignment on URCONCommandRemoveBannedWords");
static_assert(sizeof(URCONCommandRemoveBannedWords) == 0x000028, "Wrong size on URCONCommandRemoveBannedWords");

// Class HLL.RCONCommandRemoveInitialResourceEntry
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveInitialResourceEntry final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveInitialResourceEntry">();
	}
	static class URCONCommandRemoveInitialResourceEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveInitialResourceEntry>();
	}
};
static_assert(alignof(URCONCommandRemoveInitialResourceEntry) == 0x000008, "Wrong alignment on URCONCommandRemoveInitialResourceEntry");
static_assert(sizeof(URCONCommandRemoveInitialResourceEntry) == 0x000028, "Wrong size on URCONCommandRemoveInitialResourceEntry");

// Class HLL.RCONCommandRemoveMapFromRotation
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveMapFromRotation final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveMapFromRotation">();
	}
	static class URCONCommandRemoveMapFromRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveMapFromRotation>();
	}
};
static_assert(alignof(URCONCommandRemoveMapFromRotation) == 0x000008, "Wrong alignment on URCONCommandRemoveMapFromRotation");
static_assert(sizeof(URCONCommandRemoveMapFromRotation) == 0x000028, "Wrong size on URCONCommandRemoveMapFromRotation");

// Class HLL.HLLOverrunDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLOverrunDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLOverrunDamage">();
	}
	static class UHLLOverrunDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLOverrunDamage>();
	}
};
static_assert(alignof(UHLLOverrunDamage) == 0x000008, "Wrong alignment on UHLLOverrunDamage");
static_assert(sizeof(UHLLOverrunDamage) == 0x0001E8, "Wrong size on UHLLOverrunDamage");

// Class HLL.RCONCommandRemoveMapFromSequence
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveMapFromSequence final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveMapFromSequence">();
	}
	static class URCONCommandRemoveMapFromSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveMapFromSequence>();
	}
};
static_assert(alignof(URCONCommandRemoveMapFromSequence) == 0x000008, "Wrong alignment on URCONCommandRemoveMapFromSequence");
static_assert(sizeof(URCONCommandRemoveMapFromSequence) == 0x000028, "Wrong size on URCONCommandRemoveMapFromSequence");

// Class HLL.RCONCommandRemoveMatchTimer
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveMatchTimer final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveMatchTimer">();
	}
	static class URCONCommandRemoveMatchTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveMatchTimer>();
	}
};
static_assert(alignof(URCONCommandRemoveMatchTimer) == 0x000008, "Wrong alignment on URCONCommandRemoveMatchTimer");
static_assert(sizeof(URCONCommandRemoveMatchTimer) == 0x000028, "Wrong size on URCONCommandRemoveMatchTimer");

// Class HLL.RCONCommandRemoveTempBan
// 0x0000 (0x0028 - 0x0028)
class URCONCommandRemoveTempBan final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandRemoveTempBan">();
	}
	static class URCONCommandRemoveTempBan* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandRemoveTempBan>();
	}
};
static_assert(alignof(URCONCommandRemoveTempBan) == 0x000008, "Wrong alignment on URCONCommandRemoveTempBan");
static_assert(sizeof(URCONCommandRemoveTempBan) == 0x000028, "Wrong size on URCONCommandRemoveTempBan");

// Class HLL.RCONCommandServerBroadcast
// 0x0000 (0x0028 - 0x0028)
class URCONCommandServerBroadcast final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandServerBroadcast">();
	}
	static class URCONCommandServerBroadcast* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandServerBroadcast>();
	}
};
static_assert(alignof(URCONCommandServerBroadcast) == 0x000008, "Wrong alignment on URCONCommandServerBroadcast");
static_assert(sizeof(URCONCommandServerBroadcast) == 0x000028, "Wrong size on URCONCommandServerBroadcast");

// Class HLL.RCONCommandSetAutoBalanceThreshold
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetAutoBalanceThreshold final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetAutoBalanceThreshold">();
	}
	static class URCONCommandSetAutoBalanceThreshold* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetAutoBalanceThreshold>();
	}
};
static_assert(alignof(URCONCommandSetAutoBalanceThreshold) == 0x000008, "Wrong alignment on URCONCommandSetAutoBalanceThreshold");
static_assert(sizeof(URCONCommandSetAutoBalanceThreshold) == 0x000028, "Wrong size on URCONCommandSetAutoBalanceThreshold");

// Class HLL.RCONCommandSetMapWeatherToggle
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetMapWeatherToggle final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetMapWeatherToggle">();
	}
	static class URCONCommandSetMapWeatherToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetMapWeatherToggle>();
	}
};
static_assert(alignof(URCONCommandSetMapWeatherToggle) == 0x000008, "Wrong alignment on URCONCommandSetMapWeatherToggle");
static_assert(sizeof(URCONCommandSetMapWeatherToggle) == 0x000028, "Wrong size on URCONCommandSetMapWeatherToggle");

// Class HLL.RCONCommandSetShuffleMapSequence
// 0x0000 (0x0028 - 0x0028)
class URCONCommandSetShuffleMapSequence final : public URCONCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetShuffleMapSequence">();
	}
	static class URCONCommandSetShuffleMapSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetShuffleMapSequence>();
	}
};
static_assert(alignof(URCONCommandSetShuffleMapSequence) == 0x000008, "Wrong alignment on URCONCommandSetShuffleMapSequence");
static_assert(sizeof(URCONCommandSetShuffleMapSequence) == 0x000028, "Wrong size on URCONCommandSetShuffleMapSequence");

// Class HLL.RCONCommandSetWarmupTimer
// 0x0008 (0x0030 - 0x0028)
class URCONCommandSetWarmupTimer final : public URCONCommand
{
public:
	uint8                                         Pad_155D[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONCommandSetWarmupTimer">();
	}
	static class URCONCommandSetWarmupTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONCommandSetWarmupTimer>();
	}
};
static_assert(alignof(URCONCommandSetWarmupTimer) == 0x000008, "Wrong alignment on URCONCommandSetWarmupTimer");
static_assert(sizeof(URCONCommandSetWarmupTimer) == 0x000030, "Wrong size on URCONCommandSetWarmupTimer");

// Class HLL.RCONManagerSubsystem
// 0x00A0 (0x00D0 - 0x0030)
class URCONManagerSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, class URCONCommand*>      RconCommands;                                      // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, class URCONServerInfo*>   RCONServerInfo;                                    // 0x0080(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONManagerSubsystem">();
	}
	static class URCONManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONManagerSubsystem>();
	}
};
static_assert(alignof(URCONManagerSubsystem) == 0x000008, "Wrong alignment on URCONManagerSubsystem");
static_assert(sizeof(URCONManagerSubsystem) == 0x0000D0, "Wrong size on URCONManagerSubsystem");
static_assert(offsetof(URCONManagerSubsystem, RconCommands) == 0x000030, "Member 'URCONManagerSubsystem::RconCommands' has a wrong offset!");
static_assert(offsetof(URCONManagerSubsystem, RCONServerInfo) == 0x000080, "Member 'URCONManagerSubsystem::RCONServerInfo' has a wrong offset!");

// Class HLL.RCONServerInfoMapRotation
// 0x0000 (0x0028 - 0x0028)
class URCONServerInfoMapRotation final : public URCONServerInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerInfoMapRotation">();
	}
	static class URCONServerInfoMapRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerInfoMapRotation>();
	}
};
static_assert(alignof(URCONServerInfoMapRotation) == 0x000008, "Wrong alignment on URCONServerInfoMapRotation");
static_assert(sizeof(URCONServerInfoMapRotation) == 0x000028, "Wrong size on URCONServerInfoMapRotation");

// Class HLL.RCONServerInfoServerConfig
// 0x0000 (0x0028 - 0x0028)
class URCONServerInfoServerConfig final : public URCONServerInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCONServerInfoServerConfig">();
	}
	static class URCONServerInfoServerConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCONServerInfoServerConfig>();
	}
};
static_assert(alignof(URCONServerInfoServerConfig) == 0x000008, "Wrong alignment on URCONServerInfoServerConfig");
static_assert(sizeof(URCONServerInfoServerConfig) == 0x000028, "Wrong size on URCONServerInfoServerConfig");

// Class HLL.RifleProjectile
// 0x0000 (0x0470 - 0x0470)
class ARifleProjectile final : public AShooterProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RifleProjectile">();
	}
	static class ARifleProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARifleProjectile>();
	}
};
static_assert(alignof(ARifleProjectile) == 0x000008, "Wrong alignment on ARifleProjectile");
static_assert(sizeof(ARifleProjectile) == 0x000470, "Wrong size on ARifleProjectile");

// Class HLL.SeedingGameMode
// 0x0008 (0x05A0 - 0x0598)
class ASeedingGameMode final : public AShooterGameMode
{
public:
	ESeedingTimeoutVictoryCondition               TimeoutVictoryCondition;                           // 0x0598(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeam                                         DefendingTeam;                                     // 0x0599(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          VictoryOnCompleteControl;                          // 0x059A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_155E[0x5];                                     // 0x059B(0x0005)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeedingGameMode">();
	}
	static class ASeedingGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASeedingGameMode>();
	}
};
static_assert(alignof(ASeedingGameMode) == 0x000008, "Wrong alignment on ASeedingGameMode");
static_assert(sizeof(ASeedingGameMode) == 0x0005A0, "Wrong size on ASeedingGameMode");
static_assert(offsetof(ASeedingGameMode, TimeoutVictoryCondition) == 0x000598, "Member 'ASeedingGameMode::TimeoutVictoryCondition' has a wrong offset!");
static_assert(offsetof(ASeedingGameMode, DefendingTeam) == 0x000599, "Member 'ASeedingGameMode::DefendingTeam' has a wrong offset!");
static_assert(offsetof(ASeedingGameMode, VictoryOnCompleteControl) == 0x00059A, "Member 'ASeedingGameMode::VictoryOnCompleteControl' has a wrong offset!");

// Class HLL.SeedingSubControlPoint
// 0x0008 (0x02E8 - 0x02E0)
class ASeedingSubControlPoint final : public ASeedingControlPoint
{
public:
	TSubclassOf<class ASeedingControlPoint>       ParentControlPoint;                                // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeedingSubControlPoint">();
	}
	static class ASeedingSubControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASeedingSubControlPoint>();
	}
};
static_assert(alignof(ASeedingSubControlPoint) == 0x000008, "Wrong alignment on ASeedingSubControlPoint");
static_assert(sizeof(ASeedingSubControlPoint) == 0x0002E8, "Wrong size on ASeedingSubControlPoint");
static_assert(offsetof(ASeedingSubControlPoint, ParentControlPoint) == 0x0002E0, "Member 'ASeedingSubControlPoint::ParentControlPoint' has a wrong offset!");

// Class HLL.ServerMessage
// 0x0000 (0x0028 - 0x0028)
class UServerMessage final : public ULocalMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerMessage">();
	}
	static class UServerMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerMessage>();
	}
};
static_assert(alignof(UServerMessage) == 0x000008, "Wrong alignment on UServerMessage");
static_assert(sizeof(UServerMessage) == 0x000028, "Wrong size on UServerMessage");

// Class HLL.ServerPasswordEntryWidget
// 0x0048 (0x0278 - 0x0230)
class UServerPasswordEntryWidget : public UUserWidget
{
public:
	uint8                                         Pad_155F[0x40];                                    // 0x0230(0x0040)(Fixing Size After Last Property [ Dumper-69 ])
	class UInputComponent*                        PopupInput;                                        // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CancelButtonPressed() const;
	void JoinButtonPressed(const class FString& Password) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerPasswordEntryWidget">();
	}
	static class UServerPasswordEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerPasswordEntryWidget>();
	}
};
static_assert(alignof(UServerPasswordEntryWidget) == 0x000008, "Wrong alignment on UServerPasswordEntryWidget");
static_assert(sizeof(UServerPasswordEntryWidget) == 0x000278, "Wrong size on UServerPasswordEntryWidget");
static_assert(offsetof(UServerPasswordEntryWidget, PopupInput) == 0x000270, "Member 'UServerPasswordEntryWidget::PopupInput' has a wrong offset!");

// Class HLL.ServerQueueBeaconClient
// 0x0208 (0x04B8 - 0x02B0)
class AServerQueueBeaconClient final : public AOnlineBeaconClient
{
public:
	uint8                                         Pad_1560[0x138];                                   // 0x02B0(0x0138)(Fixing Size After Last Property [ Dumper-69 ])
	class ULocalPlayer*                           LocalPlayer;                                       // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1561[0xC8];                                    // 0x03F0(0x00C8)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClientNotifyApproval();
	void ClientOnBeforeMapTravel();
	void ClientOnCouldntJoinVipOnlyQueue();
	void ClientOnCrossplaySettingNotSupported();
	void ClientOnPartyChecked(const EPartyQueueResult Result);
	void ClientOnPasswordIsIncorrect();
	void ClientOnPlatformIsNotSupported();
	void ClientOnQueueIsFull();
	void ClientRejectBannedUser(bool BannedPermanently, const struct FTimespan& TimeRemaining);
	void ClientUpdateMatchEndedState(bool MatchEnded);
	void ClientUpdatePositionInQueue(int32 NewPosition);
	void ServerSetClientConnectInfo(const struct FClientConnectInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerQueueBeaconClient">();
	}
	static class AServerQueueBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AServerQueueBeaconClient>();
	}
};
static_assert(alignof(AServerQueueBeaconClient) == 0x000008, "Wrong alignment on AServerQueueBeaconClient");
static_assert(sizeof(AServerQueueBeaconClient) == 0x0004B8, "Wrong size on AServerQueueBeaconClient");
static_assert(offsetof(AServerQueueBeaconClient, LocalPlayer) == 0x0003E8, "Member 'AServerQueueBeaconClient::LocalPlayer' has a wrong offset!");

// Class HLL.ServerQueuePopup
// 0x0080 (0x02B0 - 0x0230)
class UServerQueuePopup : public UUserWidget
{
public:
	uint8                                         Pad_1563[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             ServerName;                                        // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             MapName;                                           // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                QueueWidget;                                       // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             QueuePosition;                                     // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                CancelWidget;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                CancelButton;                                      // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ButtonText;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ProcessingIndicator;                               // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MapBrowserInfo;                                    // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1564[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class AServerQueueBeaconClient*               BeaconClient;                                      // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentQueuePosition;                              // 0x02A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1565[0x4];                                     // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void HandleReleased();
	void OnCancelClicked();

	bool GetMapBrowserInfo(const class FString& MapId, struct FHLLUI_ServerBrowserMapInfo* OutInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerQueuePopup">();
	}
	static class UServerQueuePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerQueuePopup>();
	}
};
static_assert(alignof(UServerQueuePopup) == 0x000008, "Wrong alignment on UServerQueuePopup");
static_assert(sizeof(UServerQueuePopup) == 0x0002B0, "Wrong size on UServerQueuePopup");
static_assert(offsetof(UServerQueuePopup, ServerName) == 0x000248, "Member 'UServerQueuePopup::ServerName' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, MapName) == 0x000250, "Member 'UServerQueuePopup::MapName' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, QueueWidget) == 0x000258, "Member 'UServerQueuePopup::QueueWidget' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, QueuePosition) == 0x000260, "Member 'UServerQueuePopup::QueuePosition' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, CancelWidget) == 0x000268, "Member 'UServerQueuePopup::CancelWidget' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, CancelButton) == 0x000270, "Member 'UServerQueuePopup::CancelButton' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, ButtonText) == 0x000278, "Member 'UServerQueuePopup::ButtonText' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, ProcessingIndicator) == 0x000280, "Member 'UServerQueuePopup::ProcessingIndicator' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, MapBrowserInfo) == 0x000288, "Member 'UServerQueuePopup::MapBrowserInfo' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, BeaconClient) == 0x000298, "Member 'UServerQueuePopup::BeaconClient' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, ViewportClient) == 0x0002A0, "Member 'UServerQueuePopup::ViewportClient' has a wrong offset!");
static_assert(offsetof(UServerQueuePopup, CurrentQueuePosition) == 0x0002A8, "Member 'UServerQueuePopup::CurrentQueuePosition' has a wrong offset!");

// Class HLL.ServerQueueProgressWidget
// 0x0030 (0x0350 - 0x0320)
class UServerQueueProgressWidget final : public UHLLDialogBox
{
public:
	uint8                                         Pad_1567[0x18];                                    // 0x0320(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLDialogButton*                       CancelButton;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MatchOverIndicator;                                // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AServerQueueBeaconClient*               BeaconClient;                                      // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancelClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerQueueProgressWidget">();
	}
	static class UServerQueueProgressWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerQueueProgressWidget>();
	}
};
static_assert(alignof(UServerQueueProgressWidget) == 0x000008, "Wrong alignment on UServerQueueProgressWidget");
static_assert(sizeof(UServerQueueProgressWidget) == 0x000350, "Wrong size on UServerQueueProgressWidget");
static_assert(offsetof(UServerQueueProgressWidget, CancelButton) == 0x000338, "Member 'UServerQueueProgressWidget::CancelButton' has a wrong offset!");
static_assert(offsetof(UServerQueueProgressWidget, MatchOverIndicator) == 0x000340, "Member 'UServerQueueProgressWidget::MatchOverIndicator' has a wrong offset!");
static_assert(offsetof(UServerQueueProgressWidget, BeaconClient) == 0x000348, "Member 'UServerQueueProgressWidget::BeaconClient' has a wrong offset!");

// Class HLL.ShermanJumbo
// 0x0008 (0x0600 - 0x05F8)
class AShermanJumbo final : public ABaseTank
{
public:
	class UTracksComponent*                       Tracks2;                                           // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShermanJumbo">();
	}
	static class AShermanJumbo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShermanJumbo>();
	}
};
static_assert(alignof(AShermanJumbo) == 0x000008, "Wrong alignment on AShermanJumbo");
static_assert(sizeof(AShermanJumbo) == 0x000600, "Wrong size on AShermanJumbo");
static_assert(offsetof(AShermanJumbo, Tracks2) == 0x0005F8, "Member 'AShermanJumbo::Tracks2' has a wrong offset!");

// Class HLL.ShooterCharacterAnimInstance2
// 0x0000 (0x0270 - 0x0270)
class UShooterCharacterAnimInstance2 : public UAnimInstance
{
public:
	void OnFinishedVaulting();
	void OnStartedVaulting(float ObstacleDistance, float ObstacleHeight, EVaultingMoveType MoveType);
	void OnWeaponFired();

	struct FRotator GetPermanentADSRotationOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCharacterAnimInstance2">();
	}
	static class UShooterCharacterAnimInstance2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterCharacterAnimInstance2>();
	}
};
static_assert(alignof(UShooterCharacterAnimInstance2) == 0x000010, "Wrong alignment on UShooterCharacterAnimInstance2");
static_assert(sizeof(UShooterCharacterAnimInstance2) == 0x000270, "Wrong size on UShooterCharacterAnimInstance2");

// Class HLL.ShooterCharacterMarkersComponent
// 0x0008 (0x00B8 - 0x00B0)
class UShooterCharacterMarkersComponent final : public UActorComponent
{
public:
	uint8                                         Pad_1569[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCharacterMarkersComponent">();
	}
	static class UShooterCharacterMarkersComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterCharacterMarkersComponent>();
	}
};
static_assert(alignof(UShooterCharacterMarkersComponent) == 0x000008, "Wrong alignment on UShooterCharacterMarkersComponent");
static_assert(sizeof(UShooterCharacterMarkersComponent) == 0x0000B8, "Wrong size on UShooterCharacterMarkersComponent");

// Class HLL.ShooterPlayerController
// 0x0528 (0x0AE8 - 0x05C0)
class AShooterPlayerController : public AShooterPlayerController_Base
{
public:
	uint8                                         Pad_156A[0x1C];                                    // 0x05C0(0x001C)(Fixing Size After Last Property [ Dumper-69 ])
	EPlayerRole                                   DebugRole;                                         // 0x05DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeam                                         DebugTeam;                                         // 0x05DD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_156B[0x1A];                                    // 0x05DE(0x001A)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bInfiniteAmmo : 1;                                 // 0x05F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInfiniteClip : 1;                                 // 0x05F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInvincible : 1;                                   // 0x05F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_156C[0x7];                                     // 0x05F9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UActorComponent>            DeploymentLogicClass;                              // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeploymentLogic*                       DeploymentLogicComponent;                          // 0x0608(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_156D[0x28];                                    // 0x0610(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	TSoftObjectPtr<class USoundBase>              RadioSound;                                        // 0x0638(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        RadioAudioComponent;                               // 0x0660(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_156E[0x8];                                     // 0x0668(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UPostProcessComponent*                  FatalStatePostProcess;                             // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  CriticalStatePostProcess;                          // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVoipPlayerComponent*                   VoipPlayerComponent;                               // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_156F[0x30];                                    // 0x0688(0x0030)(Fixing Size After Last Property [ Dumper-69 ])
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x06B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_WeaponInput;                                     // 0x06C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_WeaponScopeInput;                                // 0x06C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScopedGamepadSensitivity;                          // 0x06D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1570[0x4];                                     // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UInputComponent*                        M_keyBindingInputComponent;                        // 0x06D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1571[0x48];                                    // 0x06E0(0x0048)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class AActor>                  M_laserTaggedActor;                                // 0x0728(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_roundSummaryInput;                               // 0x0730(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_gameMenuInput;                                   // 0x0738(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_votingMenuInput;                                 // 0x0740(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_voiceInput;                                      // 0x0748(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_chatRadialInput;                                 // 0x0750(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_inventoryRadialInput;                            // 0x0758(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputComponent*                        M_markerRadialInput;                               // 0x0760(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1572[0x10];                                    // 0x0768(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UInputComponent*                        CurrentSeatInput;                                  // 0x0778(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           PostProcessParameterCollection;                    // 0x0780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     MasterSharpeningMaterial;                          // 0x0788(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1573[0x90];                                    // 0x0790(0x0090)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         MinutesToShowGarrisonOutpostPlacementHint;         // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1574[0x14];                                    // 0x0824(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             HeadshotNotifySound;                               // 0x0838(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             HeadshotSound;                                     // 0x0840(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             BodyNotifySound;                                   // 0x0848(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyNotifyMaxDist;                                 // 0x0850(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SFXVolumeFadeOutSpeed;                             // 0x0854(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1575[0x4];                                     // 0x0858(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class AShooterPlayerState>     CommendedPlayer;                                   // 0x085C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1576[0x4];                                     // 0x0864(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AShooterPlayerState*>            PlayersWhoCommendedMe;                             // 0x0868(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1577[0x18];                                    // 0x0878(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class ADeathCamera>               DeathCameraClass;                                  // 0x0890(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1578[0x40];                                    // 0x0898(0x0040)(Fixing Size After Last Property [ Dumper-69 ])
	struct FReconID                               PlayerReconID;                                     // 0x08D8(0x0002)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1579[0x6];                                     // 0x08DA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FPlayerVoteContainer                   PlayerVoteData;                                    // 0x08E0(0x0118)(Net, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          bIsAdminUser;                                      // 0x09F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_157A[0x7];                                     // 0x09F9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AHLLAdminCamera*                        CurrentAdminCamera;                                // 0x0A00(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_157B[0x18];                                    // 0x0A08(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TSoftObjectPtr<class USoundBase>              MatchCountdownSound;                               // 0x0A20(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchCountdownTimeSeconds;                         // 0x0A48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_157C[0x4];                                     // 0x0A4C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UAudioComponent*                        MatchCountdownAC;                                  // 0x0A50(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_157D[0x20];                                    // 0x0A58(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	class UVibrationEventController*              HeadshotNotifyVibrationController;                 // 0x0A78(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVibrationEventController*              HeadshotSelfVibrationController;                   // 0x0A80(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_157E[0x8];                                     // 0x0A88(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundBase*                             DeploySFX;                                         // 0x0A90(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_157F[0x50];                                    // 0x0A98(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddXp(const class FString& StatType, int32 XP);
	void ApplyGamepadSettings();
	void ApplyMouseSettings();
	void CancelDeploy();
	void CastVote(const struct FVoteHandle& Handle, const EPlayerVote Voted);
	void CinematicUI(const int32 Value);
	void Client_CheckFreelookAchievement(const EHLLAchievement Achievement);
	void Client_DisplayControlPointState(const class ASeedingControlPoint* ControlPoint, const bool IsWithinHardCap);
	void Client_IncrementAchievementStat(const EHLLAchievementStat AchievementStat, const uint32 Amount);
	void Client_NotifyCommended(class AShooterPlayerState* InCommendedPlayer);
	void Client_NotifyCommendFailed();
	void Client_NotifyDidHeadshot(bool bIsEnemyPlayer);
	void Client_NotifyEnemyStartedCapturingSector(bool bCriticalSector);
	void Client_NotifyReceivedCommendation(class AShooterPlayerState* InSourcePlayer);
	void Client_NotifyStatsWritten(const bool bSuccessful, const bool bCanRetry);
	void Client_NotifyTookHeadshot();
	void Client_OnEnterControlPoint(const class ASeedingControlPoint* ControlPoint);
	void Client_OnExitControlPoint(const class ASeedingControlPoint* ControlPoint);
	void Client_OnMapChangingStartedByRCon(float Delay);
	void Client_ResendDeployOptions();
	void Client_ShowCommendations();
	void Client_ShowMatchEnd(const struct FHLLMatchEndInfo& MatchData);
	void Client_ShowProgressionOrGroupPhoto(const struct FHLLMatchProgressionInfo& ProgressionData);
	void Client_UnlockAchievement(const EHLLAchievement Achievement);
	void Client_UpdateGameHUDOnSpawn();
	void Client_UpdateObjectivePhaseText(const uint32 CurrentPhaseID);
	void Client_UpdateStatAchievements(const struct FPackedOnlineStats& WrittenStats);
	void ClientDisplayAdminBroadcastMessage(const class FString& Message);
	void ClientDisplayGameplayMessage(const class FText& Message, float LifeSpan);
	void ClientDisplayRconAdminMessage(const class FString& Message);
	void ClientDisplayWoundedMessage(const class AShooterPlayerState* Killer);
	void ClientEndOnlineGame();
	void ClientFlushPressedKeys();
	void ClientGameStarted();
	void ClientHintCompleted(const EHint Hint);
	void ClientIgnoreGameInput(const bool bNewValue);
	void ClientOnDeploymentFailedOnDeletedDynamicSpawn();
	void ClientSetSpectatorCamera(const struct FVector& CameraLocationZeroOrigin, const struct FRotator& CameraRotation);
	void ClientShowDeathScreen(const struct FDeathInfo& DeathInfo);
	void ClientShowHint(const EHint Hint);
	void ClientSimulateInputKey(const struct FKey& Key, bool bPressed);
	void ClientStartOnlineGame();
	void CommendPlayer(class AShooterPlayerState* OtherPlayer);
	void Debug_AddXP(const EHLLOnlinePlayerStat StatType, const int32 XP);
	void Debug_ResetXP();
	void Debug_WriteXP();
	void DeployAtSpawn(const TScriptInterface<class IDynamicSpawnInterface>& Spawn, float SpawnWaveTime);
	void DismissDisplayedVote();
	void FastAbilityCooldowns();
	void FastSprint(const int32 Mode);
	void ForceWin(const int32 InTeamIndex);
	void GamepadOnPingMarkersToggleHUD_Pressed();
	void GamepadOnPingMarkersToggleHUD_Released();
	void GamepadScoreboardStrategicMap_Pressed();
	void GamepadScoreboardStrategicMap_Released();
	bool GetIsAdminUser();
	void HideStatsUI();
	void HurtMe(const float HurtAmount);
	void NotifyAbilityUse(TSubclassOf<class AHLLCommanderAbility> AbilityClass, const int32 SectorIndex);
	void OnPlayerDeployed();
	void OnPlayerEnterInDeploymentScreen();
	void OnPlayerPlatoonChanged(class AShooterPlayerState* InPlayerState, const int32 PreviousIndex, const int32 NewIndex, class AHLLPlatoon* PreviousPlatoon, class AHLLPlatoon* NewPlatoon);
	void OnPlayerRoleChanged(class AShooterPlayerState* InPlayerState, const EPlayerRole PreviousRole, const EPlayerRole NewRole);
	void OnPlayerTeamChanged(class AShooterPlayerState* InPlayerState, const ETeam PreviousTeam, const ETeam NewTeam);
	void OnRep_AdminCamera();
	void OnRep_PlayerVoteData();
	void OnServerProfileTimerComplete();
	void OnStartServerStatFileTimerComplete();
	void OnToggleRoundSummary();
	void OnWindowFocusChanged(bool bIsFocused);
	void PlayBodyShot(const class AActor* ActorTarget);
	void ResetXp();
	void ReticleDamage(const float Amount);
	void RPC_Server_RequestDeleteOurRconClient();
	void RPC_Server_RequestRconClient();
	void Say(EChatChannel Channel, const class FString& Msg);
	void Server_AddXP(const EHLLOnlinePlayerStat StatType, const int32 XP);
	void Server_AdminCamera(const bool bWantsCamera);
	void Server_CommendPlayer(class AShooterPlayerState* InPlayer);
	void Server_HLLBugItGo(const struct FVector& TheLocation, const struct FRotator& TheRotation);
	void Server_HurtMe(const float Amount);
	void Server_RequestLeaveServer();
	void Server_ResetXP();
	void Server_ValidateDeployOptions(const struct FClientDeployOptions& Options);
	void Server_WeatherDrawLightningZone(float LifeTime);
	void Server_WeatherEnabled(bool bEnabled);
	void Server_WeatherEnableLightningPosition(bool bEnabled);
	void Server_WeatherFast(int32 InMultiplier);
	void Server_WeatherPaused(bool bPaused);
	void Server_WeatherSetState(int32 InIntensity);
	void Server_WeatherSimulate(float SimulationSpeed);
	void Server_WeatherSkipState();
	void Server_WeatherStopSimulation();
	void Server_WriteXP();
	void ServerCancelDeploy();
	void ServerCastVote(const struct FVoteHandle& Handle, const EPlayerVote Vote);
	void ServerCheat(const class FString& Msg);
	void ServerDeploy(EPlayerRole InRole, ETeam InTeam, float SpawnWaveTime);
	void ServerDeployAtSpawn(class UObject* InSpawn, float SpawnWaveTime, const struct FClientDeployOptions& DeployOptions);
	void ServerFastAbilityCooldowns();
	void ServerFastSprint(const int32 Mode);
	void ServerForceWin(const int32 InTeamIndex);
	void ServerReticleDamage(const float Amount);
	void ServerRPCSetXStatAuthToken(const class FString& NewAuthToken);
	void ServerSay(EChatChannel Channel, const class FString& Msg);
	void ServerSetClientBotRestrictMovementPos();
	void ServerSetGodMode();
	void ServerSetObjectivePhaseDebugCommand(const int32 PhaseID);
	void ServerSetPlayerInfo(const struct FShooterPlayerInfo& PlayerInfoIn);
	void ServerSetPlayerRole(EPlayerRole PlayerRole);
	void ServerSetTeam(ETeam NewTeam);
	void ServerSetTeleport();
	void ServerStartServerLLM();
	void ServerStartServerMemReport();
	void ServerStartServerNetProfile();
	void ServerStartServerStatFile();
	void ServerStartVote(class AShooterPlayerState* Target, const EPlayerVoteType VoteType);
	void ServerTeleport();
	void ServerTeleportAllToLocation(float X, float Y, float Z);
	void ServerTeleportPlayerToLocation(float X, float Y, float Z, float Yaw, float Pitch);
	void ServerTeleportToMarker();
	void SetClientBotRestrictMovementPos();
	void SetGodMode();
	void SetTeleport();
	void SetXStatAuthToken(const class FString& NewAuthToken);
	void ShowCurrentPos();
	void ShowStatsUI();
	void SimulateInputKey(const struct FKey& Key, bool bPressed);
	void StartGamepadChatTimerComplete();
	void StartServerLLM();
	void StartServerMemReport();
	void StartServerNetProfile();
	void StartServerStatFile();
	void StartVote(class AShooterPlayerState* Target, const EPlayerVoteType VoteType);
	void Suicide();
	void TagLocationForTesting(const class FString& LocationTag);
	void Teleport();
	void TeleportAllToLocation(float X, float Y, float Z);
	void TeleportPlayerToLocation(float X, float Y, float Z, float Yaw, float Pitch);
	void TeleportPlayerToTag(const class FString& LocationTag);
	void TeleportToMarker();
	void ToggleAdminCam();
	void WeatherDrawLightningZone(float LifeTime);
	void WeatherEnabled(bool bEnabled);
	void WeatherEnableLightningPosition(bool bEnabled);
	void WeatherFast(int32 InMultiplier);
	void WeatherPaused(bool bPaused);
	void WeatherSetState(int32 InIntensity);
	void WeatherSimulate(float SimulationTime);
	void WeatherSkipState();
	void WeatherStopSimulation();
	void WindowGainedFocus();
	void WriteXp();

	bool CanCommend(const class AShooterPlayerState* OtherPlayer) const;
	bool CanEverCommend(const class AShooterPlayerState* OtherPlayer) const;
	bool CanPlayerUseAdminCamera() const;
	class FName GetCanPlayerUseAdminCamera() const;
	class AShooterPlayerState* GetCommendedPlayer() const;
	class AHLLAdminCamera* GetCurrentAdminCamera() const;
	bool IsDeploymentScreenVisible() const;
	bool IsInAdminCamera() const;
	bool IsLoggedIntoRCON() const;
	void SetIsAdminUser() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerController">();
	}
	static class AShooterPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerController>();
	}
};
static_assert(alignof(AShooterPlayerController) == 0x000008, "Wrong alignment on AShooterPlayerController");
static_assert(sizeof(AShooterPlayerController) == 0x000AE8, "Wrong size on AShooterPlayerController");
static_assert(offsetof(AShooterPlayerController, DebugRole) == 0x0005DC, "Member 'AShooterPlayerController::DebugRole' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, DebugTeam) == 0x0005DD, "Member 'AShooterPlayerController::DebugTeam' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, DeploymentLogicClass) == 0x000600, "Member 'AShooterPlayerController::DeploymentLogicClass' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, DeploymentLogicComponent) == 0x000608, "Member 'AShooterPlayerController::DeploymentLogicComponent' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, RadioSound) == 0x000638, "Member 'AShooterPlayerController::RadioSound' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, RadioAudioComponent) == 0x000660, "Member 'AShooterPlayerController::RadioAudioComponent' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, FatalStatePostProcess) == 0x000670, "Member 'AShooterPlayerController::FatalStatePostProcess' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, CriticalStatePostProcess) == 0x000678, "Member 'AShooterPlayerController::CriticalStatePostProcess' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, VoipPlayerComponent) == 0x000680, "Member 'AShooterPlayerController::VoipPlayerComponent' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, ViewportClient) == 0x0006B8, "Member 'AShooterPlayerController::ViewportClient' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_WeaponInput) == 0x0006C0, "Member 'AShooterPlayerController::M_WeaponInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_WeaponScopeInput) == 0x0006C8, "Member 'AShooterPlayerController::M_WeaponScopeInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, ScopedGamepadSensitivity) == 0x0006D0, "Member 'AShooterPlayerController::ScopedGamepadSensitivity' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_keyBindingInputComponent) == 0x0006D8, "Member 'AShooterPlayerController::M_keyBindingInputComponent' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_laserTaggedActor) == 0x000728, "Member 'AShooterPlayerController::M_laserTaggedActor' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_roundSummaryInput) == 0x000730, "Member 'AShooterPlayerController::M_roundSummaryInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_gameMenuInput) == 0x000738, "Member 'AShooterPlayerController::M_gameMenuInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_votingMenuInput) == 0x000740, "Member 'AShooterPlayerController::M_votingMenuInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_voiceInput) == 0x000748, "Member 'AShooterPlayerController::M_voiceInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_chatRadialInput) == 0x000750, "Member 'AShooterPlayerController::M_chatRadialInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_inventoryRadialInput) == 0x000758, "Member 'AShooterPlayerController::M_inventoryRadialInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, M_markerRadialInput) == 0x000760, "Member 'AShooterPlayerController::M_markerRadialInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, CurrentSeatInput) == 0x000778, "Member 'AShooterPlayerController::CurrentSeatInput' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, PostProcessParameterCollection) == 0x000780, "Member 'AShooterPlayerController::PostProcessParameterCollection' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, MasterSharpeningMaterial) == 0x000788, "Member 'AShooterPlayerController::MasterSharpeningMaterial' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, MinutesToShowGarrisonOutpostPlacementHint) == 0x000820, "Member 'AShooterPlayerController::MinutesToShowGarrisonOutpostPlacementHint' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, HeadshotNotifySound) == 0x000838, "Member 'AShooterPlayerController::HeadshotNotifySound' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, HeadshotSound) == 0x000840, "Member 'AShooterPlayerController::HeadshotSound' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, BodyNotifySound) == 0x000848, "Member 'AShooterPlayerController::BodyNotifySound' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, BodyNotifyMaxDist) == 0x000850, "Member 'AShooterPlayerController::BodyNotifyMaxDist' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, SFXVolumeFadeOutSpeed) == 0x000854, "Member 'AShooterPlayerController::SFXVolumeFadeOutSpeed' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, CommendedPlayer) == 0x00085C, "Member 'AShooterPlayerController::CommendedPlayer' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, PlayersWhoCommendedMe) == 0x000868, "Member 'AShooterPlayerController::PlayersWhoCommendedMe' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, DeathCameraClass) == 0x000890, "Member 'AShooterPlayerController::DeathCameraClass' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, PlayerReconID) == 0x0008D8, "Member 'AShooterPlayerController::PlayerReconID' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, PlayerVoteData) == 0x0008E0, "Member 'AShooterPlayerController::PlayerVoteData' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, bIsAdminUser) == 0x0009F8, "Member 'AShooterPlayerController::bIsAdminUser' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, CurrentAdminCamera) == 0x000A00, "Member 'AShooterPlayerController::CurrentAdminCamera' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, MatchCountdownSound) == 0x000A20, "Member 'AShooterPlayerController::MatchCountdownSound' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, MatchCountdownTimeSeconds) == 0x000A48, "Member 'AShooterPlayerController::MatchCountdownTimeSeconds' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, MatchCountdownAC) == 0x000A50, "Member 'AShooterPlayerController::MatchCountdownAC' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, HeadshotNotifyVibrationController) == 0x000A78, "Member 'AShooterPlayerController::HeadshotNotifyVibrationController' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, HeadshotSelfVibrationController) == 0x000A80, "Member 'AShooterPlayerController::HeadshotSelfVibrationController' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController, DeploySFX) == 0x000A90, "Member 'AShooterPlayerController::DeploySFX' has a wrong offset!");

// Class HLL.ShooterCheatManager
// 0x0010 (0x0088 - 0x0078)
class UShooterCheatManager final : public UCheatManager
{
public:
	uint8                                         bGodMode : 1;                                      // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1594[0x3];                                     // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         HealSelfBaseTimeOverride;                          // 0x007C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealOtherBaseTimeOverride;                         // 0x0080(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MedicTimeMultiplierOverride;                       // 0x0084(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CaptureSector(int32 SectorIndex, ETeam Owner);
	void ChangeTeam(int32 NewTeamNumber);
	void Cheat(const class FString& Msg);
	void ForceMatchStart();
	void KickSelf();
	void OverrideHealOtherBaseTime(const float HealOtherBaseTimeSeconds);
	void OverrideHealSelfBaseTime(const float HealSelfBaseTimeSeconds);
	void OverrideMedicTimeMultiplier(const float MedicTimeMultiplier);
	void Revive();
	void Server_OverrideHealOtherBaseTime(const float HealOtherBaseTimeSeconds);
	void Server_OverrideHealSelfBaseTime(const float HealSelfBaseTimeSeconds);
	void Server_OverrideMedicTimeMultiplier(const float MedicTimeMultiplier);
	void SetCapProtectionTime(int32 Seconds);
	void SetCaptureTime(int32 Seconds);
	void SetRconSay(const class FString& Message);
	void SetRemainingTime(int32 Seconds);
	void ShowHint(uint8 HintID);
	void ShowLoadingScreen(const class FString& MapName);
	void SpawnBot();
	void SummonVehicle(const class FString& VehName);
	void ToggleBotchedReloads();
	void ToggleInfiniteAmmo();
	void ToggleInfiniteClip();
	void ToggleInvincible();
	void ToggleJammedShots();
	void ToggleMatchTimer();

	void SetSkirmishObjectivePhase(const int32 PhaseID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterCheatManager">();
	}
	static class UShooterCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterCheatManager>();
	}
};
static_assert(alignof(UShooterCheatManager) == 0x000008, "Wrong alignment on UShooterCheatManager");
static_assert(sizeof(UShooterCheatManager) == 0x000088, "Wrong size on UShooterCheatManager");
static_assert(offsetof(UShooterCheatManager, HealSelfBaseTimeOverride) == 0x00007C, "Member 'UShooterCheatManager::HealSelfBaseTimeOverride' has a wrong offset!");
static_assert(offsetof(UShooterCheatManager, HealOtherBaseTimeOverride) == 0x000080, "Member 'UShooterCheatManager::HealOtherBaseTimeOverride' has a wrong offset!");
static_assert(offsetof(UShooterCheatManager, MedicTimeMultiplierOverride) == 0x000084, "Member 'UShooterCheatManager::MedicTimeMultiplierOverride' has a wrong offset!");

// Class HLL.HLLFallDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLFallDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLFallDamage">();
	}
	static class UHLLFallDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLFallDamage>();
	}
};
static_assert(alignof(UHLLFallDamage) == 0x000008, "Wrong alignment on UHLLFallDamage");
static_assert(sizeof(UHLLFallDamage) == 0x0001E8, "Wrong size on UHLLFallDamage");

// Class HLL.HLLDrownDamageSuicide
// 0x0000 (0x01E8 - 0x01E8)
class UHLLDrownDamageSuicide final : public UHLLDrownDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLDrownDamageSuicide">();
	}
	static class UHLLDrownDamageSuicide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLDrownDamageSuicide>();
	}
};
static_assert(alignof(UHLLDrownDamageSuicide) == 0x000008, "Wrong alignment on UHLLDrownDamageSuicide");
static_assert(sizeof(UHLLDrownDamageSuicide) == 0x0001E8, "Wrong size on UHLLDrownDamageSuicide");

// Class HLL.HLLCrosshairDamage
// 0x0000 (0x01E8 - 0x01E8)
class UHLLCrosshairDamage final : public UShooterDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLLCrosshairDamage">();
	}
	static class UHLLCrosshairDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLLCrosshairDamage>();
	}
};
static_assert(alignof(UHLLCrosshairDamage) == 0x000008, "Wrong alignment on UHLLCrosshairDamage");
static_assert(sizeof(UHLLCrosshairDamage) == 0x0001E8, "Wrong size on UHLLCrosshairDamage");

// Class HLL.ShooterGameModeActivityComponent
// 0x0008 (0x00B8 - 0x00B0)
class UShooterGameModeActivityComponent final : public UActorComponent
{
public:
	uint8                                         Pad_1596[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameModeActivityComponent">();
	}
	static class UShooterGameModeActivityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameModeActivityComponent>();
	}
};
static_assert(alignof(UShooterGameModeActivityComponent) == 0x000008, "Wrong alignment on UShooterGameModeActivityComponent");
static_assert(sizeof(UShooterGameModeActivityComponent) == 0x0000B8, "Wrong size on UShooterGameModeActivityComponent");

// Class HLL.ShooterGameViewportClient
// 0x00C0 (0x03F0 - 0x0330)
class UShooterGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_1597[0x98];                                    // 0x0330(0x0098)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          bIsGamepad;                                        // 0x03C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1598[0x1F];                                    // 0x03C9(0x001F)(Fixing Size After Last Property [ Dumper-69 ])
	class UUserWidget*                            ShouldFocusWidgetOnDialogClose;                    // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void SetLastFocusedWidget(const class UObject* WorldContextObject, class UUserWidget* MenuScreen);
	static void SetShouldFocusWidgetOnDialogBoxClose(const class UObject* WorldContextObject, class UUserWidget* WidgetToFocus);
	static void SwitchToMouseInput(const class UObject* WorldContextObject, class UUserWidget* MenuScreen);

	void ToggleDebugDashboard(int32 Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterGameViewportClient">();
	}
	static class UShooterGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterGameViewportClient>();
	}
};
static_assert(alignof(UShooterGameViewportClient) == 0x000008, "Wrong alignment on UShooterGameViewportClient");
static_assert(sizeof(UShooterGameViewportClient) == 0x0003F0, "Wrong size on UShooterGameViewportClient");
static_assert(offsetof(UShooterGameViewportClient, bIsGamepad) == 0x0003C8, "Member 'UShooterGameViewportClient::bIsGamepad' has a wrong offset!");
static_assert(offsetof(UShooterGameViewportClient, ShouldFocusWidgetOnDialogClose) == 0x0003E8, "Member 'UShooterGameViewportClient::ShouldFocusWidgetOnDialogClose' has a wrong offset!");

// Class HLL.ShooterLocalPlayer
// 0x0010 (0x0268 - 0x0258)
class UShooterLocalPlayer final : public ULocalPlayer
{
public:
	uint8                                         Pad_1599[0x10];                                    // 0x0258(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ACH_Increment(const class FString& String);
	void ACH_Reset();
	void ACH_Unlock(const class FString& String);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterLocalPlayer">();
	}
	static class UShooterLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShooterLocalPlayer>();
	}
};
static_assert(alignof(UShooterLocalPlayer) == 0x000008, "Wrong alignment on UShooterLocalPlayer");
static_assert(sizeof(UShooterLocalPlayer) == 0x000268, "Wrong size on UShooterLocalPlayer");

// Class HLL.ShooterPickup_Health
// 0x0008 (0x0268 - 0x0260)
class AShooterPickup_Health final : public AShooterPickup
{
public:
	int32                                         Health;                                            // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159A[0x4];                                     // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPickup_Health">();
	}
	static class AShooterPickup_Health* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPickup_Health>();
	}
};
static_assert(alignof(AShooterPickup_Health) == 0x000008, "Wrong alignment on AShooterPickup_Health");
static_assert(sizeof(AShooterPickup_Health) == 0x000268, "Wrong size on AShooterPickup_Health");
static_assert(offsetof(AShooterPickup_Health, Health) == 0x000260, "Member 'AShooterPickup_Health::Health' has a wrong offset!");

// Class HLL.ShooterPlayerController_Menu
// 0x00B0 (0x0670 - 0x05C0)
class AShooterPlayerController_Menu : public AShooterPlayerController_Base
{
public:
	uint8                                         Pad_159B[0x8];                                     // 0x05C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         bIsZoomedIn : 1;                                   // 0x05C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_159C[0x3];                                     // 0x05C9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ZoomOutTime;                                       // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomInTime;                                        // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EViewTargetBlendFunction                      BlendMode;                                         // 0x05D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159D[0x3];                                     // 0x05D5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         BlendPower;                                        // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159E[0x4];                                     // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHLLMainMenuBase*                       MainMenuWidget;                                    // 0x05E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLSplashScreen*                       WelcomeScreenWidget;                               // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                SocialIconClass;                                   // 0x05F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACameraActor*                           MainViewCamera;                                    // 0x05F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACameraActor*                           ZoomedViewCamera;                                  // 0x0600(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0608(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159F[0x8];                                     // 0x0610(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class USpeakingPlayersList*                   SpeakingPlayers;                                   // 0x0618(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15A0[0x50];                                    // 0x0620(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void GetAllLiveDataTest();
	void GetLiveDataTest();
	void ResetAchievements();
	void SendLiveDataTest(const int32& InData);
	void SetInitialGamepadLayout();
	void TestAchievement(const class FString& Str);
	void TravelWithParty(const class FString& InAddress);
	void ZoomIn();
	void ZoomOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterPlayerController_Menu">();
	}
	static class AShooterPlayerController_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterPlayerController_Menu>();
	}
};
static_assert(alignof(AShooterPlayerController_Menu) == 0x000008, "Wrong alignment on AShooterPlayerController_Menu");
static_assert(sizeof(AShooterPlayerController_Menu) == 0x000670, "Wrong size on AShooterPlayerController_Menu");
static_assert(offsetof(AShooterPlayerController_Menu, ZoomOutTime) == 0x0005CC, "Member 'AShooterPlayerController_Menu::ZoomOutTime' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, ZoomInTime) == 0x0005D0, "Member 'AShooterPlayerController_Menu::ZoomInTime' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, BlendMode) == 0x0005D4, "Member 'AShooterPlayerController_Menu::BlendMode' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, BlendPower) == 0x0005D8, "Member 'AShooterPlayerController_Menu::BlendPower' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, MainMenuWidget) == 0x0005E0, "Member 'AShooterPlayerController_Menu::MainMenuWidget' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, WelcomeScreenWidget) == 0x0005E8, "Member 'AShooterPlayerController_Menu::WelcomeScreenWidget' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, SocialIconClass) == 0x0005F0, "Member 'AShooterPlayerController_Menu::SocialIconClass' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, MainViewCamera) == 0x0005F8, "Member 'AShooterPlayerController_Menu::MainViewCamera' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, ZoomedViewCamera) == 0x000600, "Member 'AShooterPlayerController_Menu::ZoomedViewCamera' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, ViewportClient) == 0x000608, "Member 'AShooterPlayerController_Menu::ViewportClient' has a wrong offset!");
static_assert(offsetof(AShooterPlayerController_Menu, SpeakingPlayers) == 0x000618, "Member 'AShooterPlayerController_Menu::SpeakingPlayers' has a wrong offset!");

// Class HLL.ShooterWeaponEject
// 0x0000 (0x0230 - 0x0230)
class AShooterWeaponEject : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeaponEject">();
	}
	static class AShooterWeaponEject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeaponEject>();
	}
};
static_assert(alignof(AShooterWeaponEject) == 0x000008, "Wrong alignment on AShooterWeaponEject");
static_assert(sizeof(AShooterWeaponEject) == 0x000230, "Wrong size on AShooterWeaponEject");

// Class HLL.ShooterWeapon_Dispenser
// 0x0250 (0x0D00 - 0x0AB0)
class AShooterWeapon_Dispenser : public AShooterWeapon
{
public:
	uint8                                         Pad_15A1[0x8];                                     // 0x0AA8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateBrush                            DefaultIcon;                                       // 0x0AB0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A2[0x8];                                     // 0x0B38(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDispenserData                         DispenserData;                                     // 0x0B40(0x0190)(Edit, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         RotationRate;                                      // 0x0CD0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanDismantleItems : 1;                            // 0x0CD4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanPauseConstruction : 1;                         // 0x0CD4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EDispenserMode                                DispenserMode;                                     // 0x0CD5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowDispensingWhileOnMovable : 1;                // 0x0CD6(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_15A3[0x1];                                     // 0x0CD7(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AHLLDispenserItem_Base*>         GhostInstances;                                    // 0x0CD8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DispenseIndex;                                     // 0x0CE8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGhostRotateDirection                         CurrentRotateDirection;                            // 0x0CEC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15A4[0x13];                                    // 0x0CED(0x0013)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void DispensedItemDestroyed(class AActor* DestroyedActor);
	void Multi_NotifyItemDispensed(const uint8 ItemIndex, const struct FGhostPlacementInfo& PlacementInfo);
	void ServerDispenseItem(const uint8 ItemIndex, const struct FGhostPlacementInfo& PlacementInfo);
	void ServerStartedBuilding();

	float GetDropRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Dispenser">();
	}
	static class AShooterWeapon_Dispenser* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Dispenser>();
	}
};
static_assert(alignof(AShooterWeapon_Dispenser) == 0x000010, "Wrong alignment on AShooterWeapon_Dispenser");
static_assert(sizeof(AShooterWeapon_Dispenser) == 0x000D00, "Wrong size on AShooterWeapon_Dispenser");
static_assert(offsetof(AShooterWeapon_Dispenser, DefaultIcon) == 0x000AB0, "Member 'AShooterWeapon_Dispenser::DefaultIcon' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Dispenser, DispenserData) == 0x000B40, "Member 'AShooterWeapon_Dispenser::DispenserData' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Dispenser, RotationRate) == 0x000CD0, "Member 'AShooterWeapon_Dispenser::RotationRate' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Dispenser, DispenserMode) == 0x000CD5, "Member 'AShooterWeapon_Dispenser::DispenserMode' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Dispenser, GhostInstances) == 0x000CD8, "Member 'AShooterWeapon_Dispenser::GhostInstances' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Dispenser, DispenseIndex) == 0x000CE8, "Member 'AShooterWeapon_Dispenser::DispenseIndex' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Dispenser, CurrentRotateDirection) == 0x000CEC, "Member 'AShooterWeapon_Dispenser::CurrentRotateDirection' has a wrong offset!");

// Class HLL.ShooterWeapon_Flamethrower
// 0x0010 (0x0AC0 - 0x0AB0)
class AShooterWeapon_Flamethrower : public AShooterWeapon
{
public:
	class UFlameJetComponent*                     FlameJet;                                          // 0x0AA8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlameJetUpwardRotationTPP;                         // 0x0AB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15A7[0x4];                                     // 0x0AB4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USoundCue*                              AmmoAddedSound;                                    // 0x0AB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Server_FireWeapon(const struct FVector& ClientOrigin, const struct FVector& ClientDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_Flamethrower">();
	}
	static class AShooterWeapon_Flamethrower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_Flamethrower>();
	}
};
static_assert(alignof(AShooterWeapon_Flamethrower) == 0x000010, "Wrong alignment on AShooterWeapon_Flamethrower");
static_assert(sizeof(AShooterWeapon_Flamethrower) == 0x000AC0, "Wrong size on AShooterWeapon_Flamethrower");
static_assert(offsetof(AShooterWeapon_Flamethrower, FlameJet) == 0x000AA8, "Member 'AShooterWeapon_Flamethrower::FlameJet' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Flamethrower, FlameJetUpwardRotationTPP) == 0x000AB0, "Member 'AShooterWeapon_Flamethrower::FlameJetUpwardRotationTPP' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_Flamethrower, AmmoAddedSound) == 0x000AB8, "Member 'AShooterWeapon_Flamethrower::AmmoAddedSound' has a wrong offset!");

// Class HLL.ShooterWeapon_HealBase
// 0x0100 (0x0BB0 - 0x0AB0)
class AShooterWeapon_HealBase : public AShooterWeapon
{
public:
	struct FHealWeaponData                        HealWeaponConfig;                                  // 0x0AA8(0x00E0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AShooterCharacter>       CurrentHealTarget;                                 // 0x0B88(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15A8[0x20];                                    // 0x0B90(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClientHealFailed(const bool bWasInProgress);
	void OnFreelookStart();
	void ServerStartHealing(class AShooterCharacter* TargetCharacter);

	class AShooterCharacter* GetCurrentHealTarget() const;
	class AShooterCharacter* GetDesiredHealTarget(const EHLLFireMode ForFireMode) const;
	float GetHealRatio() const;
	float GetHealTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_HealBase">();
	}
	static class AShooterWeapon_HealBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_HealBase>();
	}
};
static_assert(alignof(AShooterWeapon_HealBase) == 0x000010, "Wrong alignment on AShooterWeapon_HealBase");
static_assert(sizeof(AShooterWeapon_HealBase) == 0x000BB0, "Wrong size on AShooterWeapon_HealBase");
static_assert(offsetof(AShooterWeapon_HealBase, HealWeaponConfig) == 0x000AA8, "Member 'AShooterWeapon_HealBase::HealWeaponConfig' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_HealBase, CurrentHealTarget) == 0x000B88, "Member 'AShooterWeapon_HealBase::CurrentHealTarget' has a wrong offset!");

// Class HLL.ShooterWeapon_ObjectiveExplosive
// 0x0010 (0x0AC0 - 0x0AB0)
class AShooterWeapon_ObjectiveExplosive final : public AShooterWeapon
{
public:
	uint8                                         Pad_15AA[0x8];                                     // 0x0AA8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class APlantedObjectiveExplosive> PlantedObjectiveExplosiveClass;                    // 0x0AB0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15AB[0x8];                                     // 0x0AB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Server_Plant();
	void Server_StartPlanting();
	void Server_StopPlanting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_ObjectiveExplosive">();
	}
	static class AShooterWeapon_ObjectiveExplosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_ObjectiveExplosive>();
	}
};
static_assert(alignof(AShooterWeapon_ObjectiveExplosive) == 0x000010, "Wrong alignment on AShooterWeapon_ObjectiveExplosive");
static_assert(sizeof(AShooterWeapon_ObjectiveExplosive) == 0x000AC0, "Wrong size on AShooterWeapon_ObjectiveExplosive");
static_assert(offsetof(AShooterWeapon_ObjectiveExplosive, PlantedObjectiveExplosiveClass) == 0x000AB0, "Member 'AShooterWeapon_ObjectiveExplosive::PlantedObjectiveExplosiveClass' has a wrong offset!");

// Class HLL.ShooterWeapon_TravelTime
// 0x0050 (0x0B00 - 0x0AB0)
class AShooterWeapon_TravelTime final : public AShooterWeapon
{
public:
	TSubclassOf<class ARifleProjectile>           ProjectileClass;                                   // 0x0AA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<uint32, class ARifleProjectile*>         TravelingProjectiles;                              // 0x0AB0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ServerFireProjectile(uint32 ProjectileID, const struct FVector& Origin, const struct FVector_NetQuantizeNormal& ShootDir);
	void ServerHandleProjectileHit(uint32 ProjectileID, const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShooterWeapon_TravelTime">();
	}
	static class AShooterWeapon_TravelTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShooterWeapon_TravelTime>();
	}
};
static_assert(alignof(AShooterWeapon_TravelTime) == 0x000010, "Wrong alignment on AShooterWeapon_TravelTime");
static_assert(sizeof(AShooterWeapon_TravelTime) == 0x000B00, "Wrong size on AShooterWeapon_TravelTime");
static_assert(offsetof(AShooterWeapon_TravelTime, ProjectileClass) == 0x000AA8, "Member 'AShooterWeapon_TravelTime::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AShooterWeapon_TravelTime, TravelingProjectiles) == 0x000AB0, "Member 'AShooterWeapon_TravelTime::TravelingProjectiles' has a wrong offset!");

// Class HLL.SkelMeshWithLinkedBoundsComponent
// 0x0000 (0x0AC0 - 0x0AC0)
class USkelMeshWithLinkedBoundsComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkelMeshWithLinkedBoundsComponent">();
	}
	static class USkelMeshWithLinkedBoundsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelMeshWithLinkedBoundsComponent>();
	}
};
static_assert(alignof(USkelMeshWithLinkedBoundsComponent) == 0x000010, "Wrong alignment on USkelMeshWithLinkedBoundsComponent");
static_assert(sizeof(USkelMeshWithLinkedBoundsComponent) == 0x000AC0, "Wrong size on USkelMeshWithLinkedBoundsComponent");

// Class HLL.SoundNodeParameterDelay
// 0x0010 (0x0058 - 0x0048)
class USoundNodeParameterDelay final : public USoundNode
{
public:
	class FName                                   ParamName;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultDelay;                                      // 0x0050(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDelay;                                          // 0x0054(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeParameterDelay">();
	}
	static class USoundNodeParameterDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeParameterDelay>();
	}
};
static_assert(alignof(USoundNodeParameterDelay) == 0x000008, "Wrong alignment on USoundNodeParameterDelay");
static_assert(sizeof(USoundNodeParameterDelay) == 0x000058, "Wrong size on USoundNodeParameterDelay");
static_assert(offsetof(USoundNodeParameterDelay, ParamName) == 0x000048, "Member 'USoundNodeParameterDelay::ParamName' has a wrong offset!");
static_assert(offsetof(USoundNodeParameterDelay, DefaultDelay) == 0x000050, "Member 'USoundNodeParameterDelay::DefaultDelay' has a wrong offset!");
static_assert(offsetof(USoundNodeParameterDelay, MaxDelay) == 0x000054, "Member 'USoundNodeParameterDelay::MaxDelay' has a wrong offset!");

// Class HLL.SoundNodeVehicleEngine
// 0x0028 (0x0070 - 0x0048)
class USoundNodeVehicleEngine final : public USoundNode
{
public:
	uint8                                         bEqualPowerCrossfade : 1;                          // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15AC[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FVehicleEngineDatum>            EngineSamples;                                     // 0x0050(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15AD[0x4];                                     // 0x0060(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CurrentRPM;                                        // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15AE[0x8];                                     // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeVehicleEngine">();
	}
	static class USoundNodeVehicleEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeVehicleEngine>();
	}
};
static_assert(alignof(USoundNodeVehicleEngine) == 0x000008, "Wrong alignment on USoundNodeVehicleEngine");
static_assert(sizeof(USoundNodeVehicleEngine) == 0x000070, "Wrong size on USoundNodeVehicleEngine");
static_assert(offsetof(USoundNodeVehicleEngine, EngineSamples) == 0x000050, "Member 'USoundNodeVehicleEngine::EngineSamples' has a wrong offset!");
static_assert(offsetof(USoundNodeVehicleEngine, CurrentRPM) == 0x000064, "Member 'USoundNodeVehicleEngine::CurrentRPM' has a wrong offset!");

// Class HLL.SpawnActorComponent
// 0x0010 (0x0200 - 0x01F0)
class USpawnActorComponent final : public USceneComponent
{
public:
	TSubclassOf<class AActor>                     ActorClassToSpawn;                                 // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnOnBeginPlay;                                 // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlySpawnOnServer;                                // 0x01F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15AF[0x6];                                     // 0x01FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnActorComponent">();
	}
	static class USpawnActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnActorComponent>();
	}
};
static_assert(alignof(USpawnActorComponent) == 0x000010, "Wrong alignment on USpawnActorComponent");
static_assert(sizeof(USpawnActorComponent) == 0x000200, "Wrong size on USpawnActorComponent");
static_assert(offsetof(USpawnActorComponent, ActorClassToSpawn) == 0x0001F0, "Member 'USpawnActorComponent::ActorClassToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnActorComponent, bSpawnOnBeginPlay) == 0x0001F8, "Member 'USpawnActorComponent::bSpawnOnBeginPlay' has a wrong offset!");
static_assert(offsetof(USpawnActorComponent, bOnlySpawnOnServer) == 0x0001F9, "Member 'USpawnActorComponent::bOnlySpawnOnServer' has a wrong offset!");

// Class HLL.SpeakingPlayersList
// 0x0040 (0x0270 - 0x0230)
class USpeakingPlayersList : public UUserWidget
{
public:
	class UImage*                                 VOIPIndicator;                                     // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           PlayersList;                                       // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15B0[0x30];                                    // 0x0240(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpeakingPlayersList">();
	}
	static class USpeakingPlayersList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpeakingPlayersList>();
	}
};
static_assert(alignof(USpeakingPlayersList) == 0x000008, "Wrong alignment on USpeakingPlayersList");
static_assert(sizeof(USpeakingPlayersList) == 0x000270, "Wrong size on USpeakingPlayersList");
static_assert(offsetof(USpeakingPlayersList, VOIPIndicator) == 0x000230, "Member 'USpeakingPlayersList::VOIPIndicator' has a wrong offset!");
static_assert(offsetof(USpeakingPlayersList, PlayersList) == 0x000238, "Member 'USpeakingPlayersList::PlayersList' has a wrong offset!");

// Class HLL.T17Button
// 0x0048 (0x0480 - 0x0438)
class UT17Button final : public UButton
{
public:
	TArray<struct FButtonTextReference>           TextBlockReferences;                               // 0x0438(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FButtonImageReference>          ImageReferences;                                   // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              HoverSound;                                        // 0x0458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PressedSound;                                      // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15B1[0x8];                                     // 0x0468(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterPlayerController_Base*          M_PlayerController;                                // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15B2[0x8];                                     // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void RevertAllImageColors();
	void RevertAllTextColors();
	void RevertImageColors(class UImage* Image);
	void RevertTextColors(class UTextBlock* TextBlock);
	void SetHoverSound(class USoundCue* Sound);
	void SetImageTint(const struct FLinearColor& Tint, EButtonState ButtonState, class UImage* Image);
	void SetPressedSound(class USoundCue* Sound);
	void SetTextColor(const struct FLinearColor& Color, EButtonState ButtonState, class UTextBlock* TextBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T17Button">();
	}
	static class UT17Button* GetDefaultObj()
	{
		return GetDefaultObjImpl<UT17Button>();
	}
};
static_assert(alignof(UT17Button) == 0x000008, "Wrong alignment on UT17Button");
static_assert(sizeof(UT17Button) == 0x000480, "Wrong size on UT17Button");
static_assert(offsetof(UT17Button, TextBlockReferences) == 0x000438, "Member 'UT17Button::TextBlockReferences' has a wrong offset!");
static_assert(offsetof(UT17Button, ImageReferences) == 0x000448, "Member 'UT17Button::ImageReferences' has a wrong offset!");
static_assert(offsetof(UT17Button, HoverSound) == 0x000458, "Member 'UT17Button::HoverSound' has a wrong offset!");
static_assert(offsetof(UT17Button, PressedSound) == 0x000460, "Member 'UT17Button::PressedSound' has a wrong offset!");
static_assert(offsetof(UT17Button, M_PlayerController) == 0x000470, "Member 'UT17Button::M_PlayerController' has a wrong offset!");

// Class HLL.T17CrossplaySubsystem
// 0x0070 (0x00A0 - 0x0030)
class UT17CrossplaySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_15B5[0x70];                                    // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T17CrossplaySubsystem">();
	}
	static class UT17CrossplaySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UT17CrossplaySubsystem>();
	}
};
static_assert(alignof(UT17CrossplaySubsystem) == 0x000008, "Wrong alignment on UT17CrossplaySubsystem");
static_assert(sizeof(UT17CrossplaySubsystem) == 0x0000A0, "Wrong size on UT17CrossplaySubsystem");

// Class HLL.T17GameActivitySubsystem
// 0x0240 (0x0270 - 0x0030)
class UT17GameActivitySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_15B6[0x240];                                   // 0x0030(0x0240)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void JACT();
	void JACTC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T17GameActivitySubsystem">();
	}
	static class UT17GameActivitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UT17GameActivitySubsystem>();
	}
};
static_assert(alignof(UT17GameActivitySubsystem) == 0x000008, "Wrong alignment on UT17GameActivitySubsystem");
static_assert(sizeof(UT17GameActivitySubsystem) == 0x000270, "Wrong size on UT17GameActivitySubsystem");

// Class HLL.T17GameInstanceOnlineSubsystem
// 0x0028 (0x0058 - 0x0030)
class UT17GameInstanceOnlineSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_15B7[0x28];                                    // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T17GameInstanceOnlineSubsystem">();
	}
	static class UT17GameInstanceOnlineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UT17GameInstanceOnlineSubsystem>();
	}
};
static_assert(alignof(UT17GameInstanceOnlineSubsystem) == 0x000008, "Wrong alignment on UT17GameInstanceOnlineSubsystem");
static_assert(sizeof(UT17GameInstanceOnlineSubsystem) == 0x000058, "Wrong size on UT17GameInstanceOnlineSubsystem");

// Class HLL.T17GlobalDelegatesSubsystem
// 0x0040 (0x0070 - 0x0030)
class UT17GlobalDelegatesSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnHostStartMatchmaking;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHostCreatedSession;                              // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchFound;                                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMuteStateChanged;                                // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T17GlobalDelegatesSubsystem">();
	}
	static class UT17GlobalDelegatesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UT17GlobalDelegatesSubsystem>();
	}
};
static_assert(alignof(UT17GlobalDelegatesSubsystem) == 0x000008, "Wrong alignment on UT17GlobalDelegatesSubsystem");
static_assert(sizeof(UT17GlobalDelegatesSubsystem) == 0x000070, "Wrong size on UT17GlobalDelegatesSubsystem");
static_assert(offsetof(UT17GlobalDelegatesSubsystem, OnHostStartMatchmaking) == 0x000030, "Member 'UT17GlobalDelegatesSubsystem::OnHostStartMatchmaking' has a wrong offset!");
static_assert(offsetof(UT17GlobalDelegatesSubsystem, OnHostCreatedSession) == 0x000040, "Member 'UT17GlobalDelegatesSubsystem::OnHostCreatedSession' has a wrong offset!");
static_assert(offsetof(UT17GlobalDelegatesSubsystem, OnMatchFound) == 0x000050, "Member 'UT17GlobalDelegatesSubsystem::OnMatchFound' has a wrong offset!");
static_assert(offsetof(UT17GlobalDelegatesSubsystem, OnMuteStateChanged) == 0x000060, "Member 'UT17GlobalDelegatesSubsystem::OnMuteStateChanged' has a wrong offset!");

// Class HLL.T17RequestSubsystem
// 0x0058 (0x0088 - 0x0030)
class UT17RequestSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_15B8[0x58];                                    // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T17RequestSubsystem">();
	}
	static class UT17RequestSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UT17RequestSubsystem>();
	}
};
static_assert(alignof(UT17RequestSubsystem) == 0x000008, "Wrong alignment on UT17RequestSubsystem");
static_assert(sizeof(UT17RequestSubsystem) == 0x000088, "Wrong size on UT17RequestSubsystem");

// Class HLL.T34
// 0x0000 (0x05F8 - 0x05F8)
class AT34 final : public ABaseTank
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T34">();
	}
	static class AT34* GetDefaultObj()
	{
		return GetDefaultObjImpl<AT34>();
	}
};
static_assert(alignof(AT34) == 0x000008, "Wrong alignment on AT34");
static_assert(sizeof(AT34) == 0x0005F8, "Wrong size on AT34");

// Class HLL.T70
// 0x0000 (0x05F8 - 0x05F8)
class AT70 final : public ABaseTank
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"T70">();
	}
	static class AT70* GetDefaultObj()
	{
		return GetDefaultObjImpl<AT70>();
	}
};
static_assert(alignof(AT70) == 0x000008, "Wrong alignment on AT70");
static_assert(sizeof(AT70) == 0x0005F8, "Wrong size on AT70");

// Class HLL.TabbedButtonContainer
// 0x0020 (0x0250 - 0x0230)
class UTabbedButtonContainer : public UUserWidget
{
public:
	class FName                                   NextTabAction;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PreviousTabAction;                                 // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShooterGameViewportClient*             ViewportClient;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15B9[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindOnInputChangedDelegate();
	bool IsUsingGamepad();
	void NextTabPressed();
	void OnInputDeviceChanged(bool NewValue);
	void OnMenuClose();
	void OnMenuOpen();
	void OnNextTab();
	void OnPreviousTab();
	void PreviousTabPressed();
	void RefreshShoulderButtons();
	void UnBindOnInputChangedDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabbedButtonContainer">();
	}
	static class UTabbedButtonContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabbedButtonContainer>();
	}
};
static_assert(alignof(UTabbedButtonContainer) == 0x000008, "Wrong alignment on UTabbedButtonContainer");
static_assert(sizeof(UTabbedButtonContainer) == 0x000250, "Wrong size on UTabbedButtonContainer");
static_assert(offsetof(UTabbedButtonContainer, NextTabAction) == 0x000230, "Member 'UTabbedButtonContainer::NextTabAction' has a wrong offset!");
static_assert(offsetof(UTabbedButtonContainer, PreviousTabAction) == 0x000238, "Member 'UTabbedButtonContainer::PreviousTabAction' has a wrong offset!");
static_assert(offsetof(UTabbedButtonContainer, ViewportClient) == 0x000240, "Member 'UTabbedButtonContainer::ViewportClient' has a wrong offset!");

// Class HLL.TankAnimInstance
// 0x0780 (0x1820 - 0x10A0)
class UTankAnimInstance final : public UTrackedVehicleAnimInstance
{
public:
	uint8                                         Pad_15BA[0x780];                                   // 0x10A0(0x0780)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankAnimInstance">();
	}
	static class UTankAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTankAnimInstance>();
	}
};
static_assert(alignof(UTankAnimInstance) == 0x000010, "Wrong alignment on UTankAnimInstance");
static_assert(sizeof(UTankAnimInstance) == 0x001820, "Wrong size on UTankAnimInstance");

// Class HLL.TankAudioComponent
// 0x0010 (0x00C0 - 0x00B0)
class UTankAudioComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            EngineDuckingCurve;                                // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15BB[0x8];                                     // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnEngineDuckingUpdated(float NewValue);
	void StartEngineDucking();

	class UAudioComponent* GetClutchAudio() const;
	class UAudioComponent* GetEngineAudio() const;
	class UAudioComponent* GetExhaustAudio() const;
	class UAudioComponent* GetInteriorAudio() const;
	class UAudioComponent* GetInteriorHitAudio() const;
	class UAudioComponent* GetTracksAudio() const;
	class UWheeledVehicleMovementComponent* GetVehicleMovement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankAudioComponent">();
	}
	static class UTankAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTankAudioComponent>();
	}
};
static_assert(alignof(UTankAudioComponent) == 0x000008, "Wrong alignment on UTankAudioComponent");
static_assert(sizeof(UTankAudioComponent) == 0x0000C0, "Wrong size on UTankAudioComponent");
static_assert(offsetof(UTankAudioComponent, EngineDuckingCurve) == 0x0000B0, "Member 'UTankAudioComponent::EngineDuckingCurve' has a wrong offset!");

// Class HLL.TankDriverSeat
// 0x0030 (0x0A00 - 0x09D0)
class ATankDriverSeat final : public ATankSeatBase
{
public:
	uint8                                         Pad_15BC[0x18];                                    // 0x09D0(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UFpsStaticMeshComponent*                InteriorMeshFPP;                                   // 0x09E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USeatCameraController*                  CameraController;                                  // 0x09F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehicleMGController*                   MGController;                                      // 0x09F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Server_UpdateHullMGRotation(const uint16 PackedPitchAndYaw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankDriverSeat">();
	}
	static class ATankDriverSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATankDriverSeat>();
	}
};
static_assert(alignof(ATankDriverSeat) == 0x000010, "Wrong alignment on ATankDriverSeat");
static_assert(sizeof(ATankDriverSeat) == 0x000A00, "Wrong size on ATankDriverSeat");
static_assert(offsetof(ATankDriverSeat, InteriorMeshFPP) == 0x0009E8, "Member 'ATankDriverSeat::InteriorMeshFPP' has a wrong offset!");
static_assert(offsetof(ATankDriverSeat, CameraController) == 0x0009F0, "Member 'ATankDriverSeat::CameraController' has a wrong offset!");
static_assert(offsetof(ATankDriverSeat, MGController) == 0x0009F8, "Member 'ATankDriverSeat::MGController' has a wrong offset!");

// Class HLL.TankMovementComponent
// 0x0000 (0x04B8 - 0x04B8)
class UTankMovementComponent final : public UTrackedVehicleMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankMovementComponent">();
	}
	static class UTankMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTankMovementComponent>();
	}
};
static_assert(alignof(UTankMovementComponent) == 0x000008, "Wrong alignment on UTankMovementComponent");
static_assert(sizeof(UTankMovementComponent) == 0x0004B8, "Wrong size on UTankMovementComponent");

// Class HLL.TargetAssaultGameMode
// 0x0018 (0x05B8 - 0x05A0)
class ATargetAssaultGameMode final : public AObjectiveGameMode
{
public:
	uint8                                         Pad_15BD[0x18];                                    // 0x05A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetAssaultGameMode">();
	}
	static class ATargetAssaultGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATargetAssaultGameMode>();
	}
};
static_assert(alignof(ATargetAssaultGameMode) == 0x000008, "Wrong alignment on ATargetAssaultGameMode");
static_assert(sizeof(ATargetAssaultGameMode) == 0x0005B8, "Wrong size on ATargetAssaultGameMode");

// Class HLL.TestingHelpers
// 0x0000 (0x0028 - 0x0028)
class UTestingHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void SetPlayerName(class APlayerState* PlayerState, const class FString& Param_Name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestingHelpers">();
	}
	static class UTestingHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestingHelpers>();
	}
};
static_assert(alignof(UTestingHelpers) == 0x000008, "Wrong alignment on UTestingHelpers");
static_assert(sizeof(UTestingHelpers) == 0x000028, "Wrong size on UTestingHelpers");

// Class HLL.TimeOfDayUiData
// 0x0040 (0x0078 - 0x0038)
class UTimeOfDayUiData final : public UServerBrowserFilterDataAsset
{
public:
	class FText                                   TimeOfDayText;                                     // 0x0038(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              TimeOfDayIcon;                                     // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	TSoftObjectPtr<class UTexture2D> GetTimeOfDayIcon() const;
	class FText GetTimeOfDayText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeOfDayUiData">();
	}
	static class UTimeOfDayUiData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeOfDayUiData>();
	}
};
static_assert(alignof(UTimeOfDayUiData) == 0x000008, "Wrong alignment on UTimeOfDayUiData");
static_assert(sizeof(UTimeOfDayUiData) == 0x000078, "Wrong size on UTimeOfDayUiData");
static_assert(offsetof(UTimeOfDayUiData, TimeOfDayText) == 0x000038, "Member 'UTimeOfDayUiData::TimeOfDayText' has a wrong offset!");
static_assert(offsetof(UTimeOfDayUiData, TimeOfDayIcon) == 0x000050, "Member 'UTimeOfDayUiData::TimeOfDayIcon' has a wrong offset!");

// Class HLL.VaultingTestCharacterController
// 0x0000 (0x0298 - 0x0298)
class AVaultingTestCharacterController final : public AController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultingTestCharacterController">();
	}
	static class AVaultingTestCharacterController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVaultingTestCharacterController>();
	}
};
static_assert(alignof(AVaultingTestCharacterController) == 0x000008, "Wrong alignment on AVaultingTestCharacterController");
static_assert(sizeof(AVaultingTestCharacterController) == 0x000298, "Wrong size on AVaultingTestCharacterController");

// Class HLL.VehicleDriverSeat
// 0x0020 (0x09F0 - 0x09D0)
class AVehicleDriverSeat final : public AVehicleSeatBase
{
public:
	uint8                                         bOnlyAllowArmourUnitsIn : 1;                       // 0x09C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_15BE[0x17];                                    // 0x09C9(0x0017)(Fixing Size After Last Property [ Dumper-69 ])
	class UStaticMeshComponent*                   InteriorMesh;                                      // 0x09E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USeatCameraController*                  CameraController;                                  // 0x09E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleDriverSeat">();
	}
	static class AVehicleDriverSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleDriverSeat>();
	}
};
static_assert(alignof(AVehicleDriverSeat) == 0x000010, "Wrong alignment on AVehicleDriverSeat");
static_assert(sizeof(AVehicleDriverSeat) == 0x0009F0, "Wrong size on AVehicleDriverSeat");
static_assert(offsetof(AVehicleDriverSeat, InteriorMesh) == 0x0009E0, "Member 'AVehicleDriverSeat::InteriorMesh' has a wrong offset!");
static_assert(offsetof(AVehicleDriverSeat, CameraController) == 0x0009E8, "Member 'AVehicleDriverSeat::CameraController' has a wrong offset!");

// Class HLL.VehicleHitComponent
// 0x0078 (0x0128 - 0x00B0)
class UVehicleHitComponent final : public UActorComponent
{
public:
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectionThreshold;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDamagingSpeedKPH;                               // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            Colliders;                                         // 0x00C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PostRemoveIgnoreTime;                              // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15BF[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<uint32, struct FTimerHandle>             CollisionIgnoreList;                               // 0x00D8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleHitComponent">();
	}
	static class UVehicleHitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleHitComponent>();
	}
};
static_assert(alignof(UVehicleHitComponent) == 0x000008, "Wrong alignment on UVehicleHitComponent");
static_assert(sizeof(UVehicleHitComponent) == 0x000128, "Wrong size on UVehicleHitComponent");
static_assert(offsetof(UVehicleHitComponent, DamageType) == 0x0000B0, "Member 'UVehicleHitComponent::DamageType' has a wrong offset!");
static_assert(offsetof(UVehicleHitComponent, DirectionThreshold) == 0x0000B8, "Member 'UVehicleHitComponent::DirectionThreshold' has a wrong offset!");
static_assert(offsetof(UVehicleHitComponent, MinDamagingSpeedKPH) == 0x0000BC, "Member 'UVehicleHitComponent::MinDamagingSpeedKPH' has a wrong offset!");
static_assert(offsetof(UVehicleHitComponent, Colliders) == 0x0000C0, "Member 'UVehicleHitComponent::Colliders' has a wrong offset!");
static_assert(offsetof(UVehicleHitComponent, PostRemoveIgnoreTime) == 0x0000D0, "Member 'UVehicleHitComponent::PostRemoveIgnoreTime' has a wrong offset!");
static_assert(offsetof(UVehicleHitComponent, CollisionIgnoreList) == 0x0000D8, "Member 'UVehicleHitComponent::CollisionIgnoreList' has a wrong offset!");

// Class HLL.VehiclePassengerAnimInstance
// 0x0070 (0x02E0 - 0x0270)
class UVehiclePassengerAnimInstance final : public UAnimInstance
{
public:
	struct FRotator                               CharacterBaseAimRotation;                          // 0x0270(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C0[0x4];                                     // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterCharacter*                      ShooterCharacter;                                  // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVehicleSeatBase*                       VehicleSeat;                                       // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C1[0x50];                                    // 0x0290(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnOccupantStanceChanged(const bool bCrouched);
	void OnSeatWeaponsInitialized(const TArray<class AHLLArmourWeapon*>& OwnedWeapons);
	void OnWeaponFireStarted(class AHLLArmourWeapon* Weapon);
	void OnWeaponFireStopped(class AHLLArmourWeapon* Weapon);
	void OnWeaponReloadStart(class AHLLArmourWeapon* Weapon, const uint8 AmmoIndex, const float ReloadTime);
	void OnWeaponReloadStop(class AHLLArmourWeapon* Weapon, const bool bWasCancelled);

	class AVehicleSeatBase* GetOwnerSeat() const;
	class ABaseVehicle* GetOwnerVehicle() const;
	struct FVector2D GetSeatViewPitchRange() const;
	struct FVector2D GetSeatViewYawRange() const;
	struct FVector GetVehicleAngularVelocity() const;
	struct FVector GetVehicleLinearVelocity() const;
	float GetVehicleSteeringAngle() const;
	struct FVector2D GetVehicleSteeringAngleRange() const;
	bool IsVehicleHornPressed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehiclePassengerAnimInstance">();
	}
	static class UVehiclePassengerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehiclePassengerAnimInstance>();
	}
};
static_assert(alignof(UVehiclePassengerAnimInstance) == 0x000010, "Wrong alignment on UVehiclePassengerAnimInstance");
static_assert(sizeof(UVehiclePassengerAnimInstance) == 0x0002E0, "Wrong size on UVehiclePassengerAnimInstance");
static_assert(offsetof(UVehiclePassengerAnimInstance, CharacterBaseAimRotation) == 0x000270, "Member 'UVehiclePassengerAnimInstance::CharacterBaseAimRotation' has a wrong offset!");
static_assert(offsetof(UVehiclePassengerAnimInstance, ShooterCharacter) == 0x000280, "Member 'UVehiclePassengerAnimInstance::ShooterCharacter' has a wrong offset!");
static_assert(offsetof(UVehiclePassengerAnimInstance, VehicleSeat) == 0x000288, "Member 'UVehiclePassengerAnimInstance::VehicleSeat' has a wrong offset!");

// Class HLL.VoipPlayerComponent
// 0x0010 (0x00C0 - 0x00B0)
class UVoipPlayerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_15C4[0x10];                                    // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClientGetJoinToken(const class FString& InToken);
	void ClientJoinInGameChannel(EVOIPChannel ChannelType, const class FString& ChannelName);
	void ServerGetJoinToken(const class FString& InAccountId, const class FString& InChannelId);
	void ServerJoinInGameChannel(EVOIPChannel ChannelType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoipPlayerComponent">();
	}
	static class UVoipPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoipPlayerComponent>();
	}
};
static_assert(alignof(UVoipPlayerComponent) == 0x000008, "Wrong alignment on UVoipPlayerComponent");
static_assert(sizeof(UVoipPlayerComponent) == 0x0000C0, "Wrong size on UVoipPlayerComponent");

// Class HLL.VotingWidget
// 0x0000 (0x0230 - 0x0230)
class UVotingWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VotingWidget">();
	}
	static class UVotingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVotingWidget>();
	}
};
static_assert(alignof(UVotingWidget) == 0x000008, "Wrong alignment on UVotingWidget");
static_assert(sizeof(UVotingWidget) == 0x000230, "Wrong size on UVotingWidget");

// Class HLL.WeaponBehindBackComponent
// 0x0070 (0x0120 - 0x00B0)
class UWeaponBehindBackComponent final : public UActorComponent
{
public:
	bool                                          bIsUsed;                                           // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C6[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   CharacterSocket;                                   // 0x00B4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C7[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimMontage*                           WeaponHidingAnimMontage;                           // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttachToHandDelay;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponSocket;                                      // 0x00CC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C8[0xC];                                     // 0x00D4(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	struct FTransform                             DefaultOffset;                                     // 0x00E0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C9[0x10];                                    // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponBehindBackComponent">();
	}
	static class UWeaponBehindBackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponBehindBackComponent>();
	}
};
static_assert(alignof(UWeaponBehindBackComponent) == 0x000010, "Wrong alignment on UWeaponBehindBackComponent");
static_assert(sizeof(UWeaponBehindBackComponent) == 0x000120, "Wrong size on UWeaponBehindBackComponent");
static_assert(offsetof(UWeaponBehindBackComponent, bIsUsed) == 0x0000B0, "Member 'UWeaponBehindBackComponent::bIsUsed' has a wrong offset!");
static_assert(offsetof(UWeaponBehindBackComponent, CharacterSocket) == 0x0000B4, "Member 'UWeaponBehindBackComponent::CharacterSocket' has a wrong offset!");
static_assert(offsetof(UWeaponBehindBackComponent, WeaponHidingAnimMontage) == 0x0000C0, "Member 'UWeaponBehindBackComponent::WeaponHidingAnimMontage' has a wrong offset!");
static_assert(offsetof(UWeaponBehindBackComponent, AttachToHandDelay) == 0x0000C8, "Member 'UWeaponBehindBackComponent::AttachToHandDelay' has a wrong offset!");
static_assert(offsetof(UWeaponBehindBackComponent, WeaponSocket) == 0x0000CC, "Member 'UWeaponBehindBackComponent::WeaponSocket' has a wrong offset!");
static_assert(offsetof(UWeaponBehindBackComponent, DefaultOffset) == 0x0000E0, "Member 'UWeaponBehindBackComponent::DefaultOffset' has a wrong offset!");

// Class HLL.WeaponBoxBase
// 0x0048 (0x0268 - 0x0220)
class AWeaponBoxBase final : public AActor
{
public:
	uint8                                         Pad_15CA[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        SceneRoot;                                         // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLMapComponent*                       MapComponent;                                      // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHLLIndicatorComponent*                 IndicatorComponent;                                // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EquipTime;                                         // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         OwningTeam;                                        // 0x024C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15CB[0x3];                                     // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class AShooterCharacter*                      InteractingPlayer;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15CC[0x10];                                    // 0x0258(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponBoxBase">();
	}
	static class AWeaponBoxBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponBoxBase>();
	}
};
static_assert(alignof(AWeaponBoxBase) == 0x000008, "Wrong alignment on AWeaponBoxBase");
static_assert(sizeof(AWeaponBoxBase) == 0x000268, "Wrong size on AWeaponBoxBase");
static_assert(offsetof(AWeaponBoxBase, SceneRoot) == 0x000228, "Member 'AWeaponBoxBase::SceneRoot' has a wrong offset!");
static_assert(offsetof(AWeaponBoxBase, Mesh) == 0x000230, "Member 'AWeaponBoxBase::Mesh' has a wrong offset!");
static_assert(offsetof(AWeaponBoxBase, MapComponent) == 0x000238, "Member 'AWeaponBoxBase::MapComponent' has a wrong offset!");
static_assert(offsetof(AWeaponBoxBase, IndicatorComponent) == 0x000240, "Member 'AWeaponBoxBase::IndicatorComponent' has a wrong offset!");
static_assert(offsetof(AWeaponBoxBase, EquipTime) == 0x000248, "Member 'AWeaponBoxBase::EquipTime' has a wrong offset!");
static_assert(offsetof(AWeaponBoxBase, OwningTeam) == 0x00024C, "Member 'AWeaponBoxBase::OwningTeam' has a wrong offset!");
static_assert(offsetof(AWeaponBoxBase, InteractingPlayer) == 0x000250, "Member 'AWeaponBoxBase::InteractingPlayer' has a wrong offset!");

// Class HLL.WeaponOverrideData
// 0x0020 (0x0050 - 0x0030)
class UWeaponOverrideData final : public UDataAsset
{
public:
	TArray<struct FBlackListedLoadoutRoleEntryData> BlacklistedWeapons;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLoadoutRoleEntryData>          AdditionalLoadoutItems;                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponOverrideData">();
	}
	static class UWeaponOverrideData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponOverrideData>();
	}
};
static_assert(alignof(UWeaponOverrideData) == 0x000008, "Wrong alignment on UWeaponOverrideData");
static_assert(sizeof(UWeaponOverrideData) == 0x000050, "Wrong size on UWeaponOverrideData");
static_assert(offsetof(UWeaponOverrideData, BlacklistedWeapons) == 0x000030, "Member 'UWeaponOverrideData::BlacklistedWeapons' has a wrong offset!");
static_assert(offsetof(UWeaponOverrideData, AdditionalLoadoutItems) == 0x000040, "Member 'UWeaponOverrideData::AdditionalLoadoutItems' has a wrong offset!");

// Class HLL.WinMatchInTimeAchievement
// 0x0008 (0x0040 - 0x0038)
class UWinMatchInTimeAchievement final : public UEndMatchAchievement
{
public:
	EHLLAchievement                               AchievementToUnlock;                               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeamSpecific;                                     // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeam                                         Team;                                              // 0x003A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15CD[0x1];                                     // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         RequiredTimeLeftInSeconds;                         // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinMatchInTimeAchievement">();
	}
	static class UWinMatchInTimeAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinMatchInTimeAchievement>();
	}
};
static_assert(alignof(UWinMatchInTimeAchievement) == 0x000008, "Wrong alignment on UWinMatchInTimeAchievement");
static_assert(sizeof(UWinMatchInTimeAchievement) == 0x000040, "Wrong size on UWinMatchInTimeAchievement");
static_assert(offsetof(UWinMatchInTimeAchievement, AchievementToUnlock) == 0x000038, "Member 'UWinMatchInTimeAchievement::AchievementToUnlock' has a wrong offset!");
static_assert(offsetof(UWinMatchInTimeAchievement, bTeamSpecific) == 0x000039, "Member 'UWinMatchInTimeAchievement::bTeamSpecific' has a wrong offset!");
static_assert(offsetof(UWinMatchInTimeAchievement, Team) == 0x00003A, "Member 'UWinMatchInTimeAchievement::Team' has a wrong offset!");
static_assert(offsetof(UWinMatchInTimeAchievement, RequiredTimeLeftInSeconds) == 0x00003C, "Member 'UWinMatchInTimeAchievement::RequiredTimeLeftInSeconds' has a wrong offset!");

}

